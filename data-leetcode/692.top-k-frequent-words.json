[
    {
        "title": "Contains Duplicate",
        "question_content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n&nbsp;\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-109 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2728722,
                "title": "all-possible-easy-solution-with-single-line-code-c",
                "content": "# Try to code by yourself by listing Approach \\uD83E\\uDD7A.\\n\\n**Brute Force** : Idea behind code\\n* Make nested loop , generate all possible pair \\n* Put a condition if both of the number generate in a pair are same\\nIn this approach only the unique pair will be formed becouse outerloop is running from 0 to n - 1, and inner loop will start from one value extra from previous loop value ( which make it to run n*(n+1)/2 ) . if we are matching each and every pair of vector , then possibly we can compare if any of them have same value then return true. else at end of nested form loop return false.\\n```\\n// Brute Force\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i =0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]) return true;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O((n*(n+1))/2)$$ \\u2248 $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n<br/>\\n\\n**Shorted Approach** : Idea behind code\\n* sort the array.\\n* linearly traverse , find if there is any of the number and its greater one are equal or not\\n\\n```\\n// Shorted Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        bool flag = false;\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]) return true;\\n        }\\n        return flag;\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(1)$$\\n<br/>\\n\\n**Set Approach** : Idea behind code\\n* Set only don\\'t contain duplicate elment .\\n* If the size of set if less than  the original vector then it contain duplicate element.\\n\\n* For your set approach, time complexity can be reduced from O(nlogn) to O(n) using an unordered_set. Regular set uses trees with O(logn) insert, but unordered_sets use hashing for O(1). :)\\n```\\n// Set Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return nums.size() > set<int>(nums.begin(),nums.end()).size();\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(n)$$\\n<br/>\\n\\n**Map** : Idea behind code\\n* traverse vector and count frequency using any data structure.\\n* Iterate through data structure to find if the frequency is beyond 1.\\n\\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(n)$$\\n\\n**Hashmap** : Idea behind code\\n* traverse vector and count frequency using any data structure.\\n* Iterate through data structure to find if the frequency is beyond 1.\\n* same as above but difference is that it will be in `O(n)`\\n\\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          unordered_map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\\n###### Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n**My Opinion**\\nIt depend on situation which Complexity is best for you.\\n\\nHappy coding, Please do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n// Brute Force\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i =0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]) return true;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```\n```\\n// Shorted Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        bool flag = false;\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]) return true;\\n        }\\n        return flag;\\n    }\\n};\\n```\n```\\n// Set Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return nums.size() > set<int>(nums.begin(),nums.end()).size();\\n    }\\n};\\n```\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          unordered_map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60858,
                "title": "possible-solutions",
                "content": "This problem seems trivial, so lets try different approaches to solve it:\\n\\nStarting from worst time complexity to the best one:\\n\\n----------\\n\\nTime complexity: O(N^2), memory: O(1)\\n\\nThe naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n            for(int i = 0; i < nums.length; i++) {\\n                for(int j = i + 1; j < nums.length; j++) {\\n                    if(nums[i] == nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\n\\nSince it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.\\n\\n----------\\n\\n        public boolean containsDuplicate(int[] nums) {\\n    \\n            Arrays.sort(nums);\\n            for(int ind = 1; ind < nums.length; ind++) {\\n                if(nums[ind] == nums[ind - 1]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N), memory: O(N)\\n\\nFinally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n        final Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n\\n----------\\n\\nThis is trivial but quite nice example of space-time tradeoff.",
                "solutionTags": [],
                "code": "This problem seems trivial, so lets try different approaches to solve it:\\n\\nStarting from worst time complexity to the best one:\\n\\n----------\\n\\nTime complexity: O(N^2), memory: O(1)\\n\\nThe naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n            for(int i = 0; i < nums.length; i++) {\\n                for(int j = i + 1; j < nums.length; j++) {\\n                    if(nums[i] == nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\n\\nSince it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.\\n\\n----------\\n\\n        public boolean containsDuplicate(int[] nums) {\\n    \\n            Arrays.sort(nums);\\n            for(int ind = 1; ind < nums.length; ind++) {\\n                if(nums[ind] == nums[ind - 1]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N), memory: O(N)\\n\\nFinally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n        final Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n\\n----------\\n\\nThis is trivial but quite nice example of space-time tradeoff.",
                "codeTag": "Unknown"
            },
            {
                "id": 2459020,
                "title": "very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set",
                "content": "# **C++ Solution (Using Set / Sort & Find Approach)**\\n```\\n/** Approach : Using Set **/\\n// Time Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create a set...\\n        unordered_set<int> hset;\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Searches set. if present, it contains duplicate...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // insert nums[i] in set...\\n            hset.insert(nums[idx]);\\n        }\\n        return false;\\n    }\\n};\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/**   Approach : Sort & Find Duplicates **/\\n// Time Complexity: O(nlogn)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Sort the nums...\\n        sort(nums.begin(), nums.end());\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size() - 1; idx++) {\\n            // Check the duplicate element...\\n            if(nums[idx] == nums[idx + 1])\\n                return true;\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n};\\n```\\n\\n# **Java Solution (Using Hashset):**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for (int idx = 0; idx < nums.length; idx ++){\\n            // Searches hashset. if present, it contains duplicate...\\n            if (hset.contains(nums[idx])){\\n                return true;\\n            }\\n            // if not present it will update hashset...\\n            hset.add(nums[idx]);\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Base case...\\n        if(nums==null || nums.length==0)\\n            return false;\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for(int idx: nums){\\n            // If it contains duplicate...\\n            if(!hset.add(idx)){\\n                return true;\\n            }\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n```\\n\\n# **Python / Python3 Solution (Creating a Set):**\\n```\\n# Time complexity: O(n)\\n# Space complexity: O(n)\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\\n                    \\n# **JavaScript Solution (Creating a Set):**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/** Approach : Using Set **/\\n// Time Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create a set...\\n        unordered_set<int> hset;\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Searches set. if present, it contains duplicate...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // insert nums[i] in set...\\n            hset.insert(nums[idx]);\\n        }\\n        return false;\\n    }\\n};\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/**   Approach : Sort & Find Duplicates **/\\n// Time Complexity: O(nlogn)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Sort the nums...\\n        sort(nums.begin(), nums.end());\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size() - 1; idx++) {\\n            // Check the duplicate element...\\n            if(nums[idx] == nums[idx + 1])\\n                return true;\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for (int idx = 0; idx < nums.length; idx ++){\\n            // Searches hashset. if present, it contains duplicate...\\n            if (hset.contains(nums[idx])){\\n                return true;\\n            }\\n            // if not present it will update hashset...\\n            hset.add(nums[idx]);\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Base case...\\n        if(nums==null || nums.length==0)\\n            return false;\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for(int idx: nums){\\n            // If it contains duplicate...\\n            if(!hset.add(idx)){\\n                return true;\\n            }\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n```\n```\\n# Time complexity: O(n)\\n# Space complexity: O(n)\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163705,
                "title": "java-best-solution-3-ways",
                "content": "# Approach\\n- First Sort the Array.\\n- Then Compare elements one by one.\\n- We Only have to return a boolean value.\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\n```\\n# Complexity using a HashMap\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                return true;\\n            }\\n            map.put(nums[i],1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Complexity using a HashSet\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n                if (set.contains(nums[i])) {\\n                    return true;\\n                }\\n                set.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                return true;\\n            }\\n            map.put(nums[i],1);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n                if (set.contains(nums[i])) {\\n                    return true;\\n                }\\n                set.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672475,
                "title": "4-method-s-c-java-python-beginner-friendly",
                "content": "# Approach 1: Brute Force\\n\\n# Intuition:\\nThe brute force approach compares each element with every other element in the array to check for duplicates. If any duplicates are found, it returns `true`. This approach is straightforward but has a time complexity of O(n^2), making it less efficient for large arrays.\\n\\n# Explanation:\\nThe brute force approach involves comparing each element in the array with every other element to check for duplicates. If any duplicates are found, return `true`, otherwise return `false`.\\n\\n# Code [TLE]:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n^2)`, where n is the length of the array.\\nso, this approach is not efficient for large arrays -> **TLE**\\n\\n# Approach 2: Sorting\\n\\n# Intuition:\\nThe sorting approach sorts the array in ascending order and then checks for adjacent elements that are the same. If any duplicates are found, it returns `true`. Sorting helps in bringing duplicates together, simplifying the check. However, sorting has a time complexity of O(n log n).\\n\\n# Explanation:\\nAnother approach is to sort the array and then check for adjacent elements that are the same. If any duplicates are found, return `true`, otherwise return `false`.\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(1, n):\\n            if nums[i] == nums[i - 1]:\\n                return True\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n log n)`, where n is the length of the array.\\n\\n# Approach 3: Hash Set\\n\\n# Intuition:\\nThe hash set approach uses a hash set data structure to store encountered elements. It iterates through the array, checking if an element is already in the set. If so, it returns `true`. Otherwise, it adds the element to the set. This approach has a time complexity of O(n) and provides an efficient way to check for duplicates.\\n\\n# Explanation:\\nA more efficient approach is to use a hash set data structure to store the encountered elements. While iterating through the array, if an element is already present in the hash set, return `true`. Otherwise, add the element to the hash set. If the loop completes without finding any duplicates, return `false`.\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.count(num) > 0)\\n                return true;\\n            seen.insert(num);\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num))\\n                return true;\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n)`, where n is the length of the array.\\n\\n# Approach 4: Hash Map \\n\\n# Intuition:\\nThe hash map approach is similar to the hash set approach but also keeps track of the count of occurrences for each element. It uses a hash map to store the elements as keys and their counts as values. If a duplicate element is encountered (count greater than or equal to 1), it returns `true`. This approach provides more information than just the presence of duplicates and has a time complexity of O(n).\\n\\n# Explanation:\\nIn this approach, we iterate through the array and store each element as a key in a hash map. The value associated with each key represents the count of occurrences of that element. If we encounter an element that already exists in the hash map with a count greater than or equal to 1, we return `true`, indicating that a duplicate has been found. Otherwise, we update the count of that element in the hash map. If we complete the iteration without finding any duplicates, we return `false`.\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> seen;\\n        for (int num : nums) {\\n            if (seen[num] >= 1)\\n                return true;\\n            seen[num]++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int num : nums) {\\n            if (seen.containsKey(num) && seen.get(num) >= 1)\\n                return true;\\n            seen.put(num, seen.getOrDefault(num, 0) + 1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for num in nums:\\n            if num in seen and seen[num] >= 1:\\n                return True\\n            seen[num] = seen.get(num, 0) + 1\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n)`, where n is the length of the array.\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/e9e2577b-5afd-4af0-8666-15afd390c2d9_1687503822.6608438.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(1, n):\\n            if nums[i] == nums[i - 1]:\\n                return True\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.count(num) > 0)\\n                return true;\\n            seen.insert(num);\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num))\\n                return true;\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> seen;\\n        for (int num : nums) {\\n            if (seen[num] >= 1)\\n                return true;\\n            seen[num]++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int num : nums) {\\n            if (seen.containsKey(num) && seen.get(num) >= 1)\\n                return true;\\n            seen.put(num, seen.getOrDefault(num, 0) + 1);\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for num in nums:\\n            if num in seen and seen[num] >= 1:\\n                return True\\n            seen[num] = seen.get(num, 0) + 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60898,
                "title": "single-line-c-solution-60ms",
                "content": "Using anonymous set<>.<br>\\nNot the most efficient as many already pointed out... but if you like one-liners ;) <br>\\nakin to the solution possible with python. \\n\\n    #include <set>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return nums.size() > set<int>(nums.begin(), nums.end()).size();        \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return nums.size() > set<int>(nums.begin(), nums.end()).size();        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 60850,
                "title": "one-line-solution-in-python",
                "content": "    class Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "    class Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))",
                "codeTag": "Java"
            },
            {
                "id": 3257522,
                "title": "one-line-code-python3",
                "content": "\\n\\n# One Line Of Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```\\n# please upvote me it would encourage me alot",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515531,
                "title": "javascript-set-vs-object",
                "content": "A lot of the posted Javascript solutions here use a one-line expression using Sets, which is certainly an elegant way of solving the problem. But I was a bit surprised that they were, according to LeetCode, faster than my solution, which uses Objects (a hash table, essentially). One immediate advantage of using Objects is that you can return early if you detect a duplicate, whereas with Sets, you have to convert the entire array to a Set before you can decide if there are duplicates.\\n\\nSo with a little bit of testing, it turns out that for small arrays, using Sets is faster. For larger arrays, even if there are no duplicates and you have to go through the entire array, using Objects becomes significantly faster. For me, the crossover point happens at arrays of about 10,000 elements. Here\\'s some test code (run on my 2016 Macbook Pro in Node, your results may vary):\\n\\n```\\nconst { performance } = require(\\'perf_hooks\\'); //Timing library\\n\\nfunction objectSolution(nums) {\\n  let testObj = {};\\n  for (var i = 0; i < nums.length; i++) {\\n    let aNum = nums[i];\\n    if (testObj[aNum]) {\\n      return true;\\n    } else {\\n      testObj[aNum] = true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction setSolution(nums) {\\n  let testSet = new Set(nums);\\n  return testSet.size !== nums.length;\\n}\\n\\nfunction runTest(testFunction, testArray) {\\n  console.log(\\'   Running test:\\', testFunction.name);\\n  let start = performance.now();\\n  let result = testFunction(testArray);\\n  let end = performance.now();\\n  console.log(\\'      Duration:\\', end - start);\\n}\\n\\nlet arr = [];\\nlet setSize = 1000;\\nfor (var i = 0; i < setSize; i++) {\\n  arr.push(i);\\n}\\nconsole.log(\\'Set size:\\', setSize);\\nrunTest(objectSolution, arr);\\nrunTest(setSolution, arr);\\n```\\n\\n**1,000 elements (Set is 7x faster):**\\n*Set: 0.15ms*\\nObject: 1.02ms\\n\\n**10,000 elements:**\\n*Set: 0.87ms*\\nObject: 0.88ms\\n\\n**100,000 elements:**\\nSet: 10.91ms\\n*Object: 7.58ms*\\n\\n**1,000,000 elements (Object is almost 3x faster):**\\nSet: 166.79ms\\n*Object: 59.55ms*\\n\\n**10,000,000 elements (Object about 5x faster):**\\nSet: 3,575.32ms (3.5 seconds!)\\n*Object: 678.08ms*",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst { performance } = require(\\'perf_hooks\\'); //Timing library\\n\\nfunction objectSolution(nums) {\\n  let testObj = {};\\n  for (var i = 0; i < nums.length; i++) {\\n    let aNum = nums[i];\\n    if (testObj[aNum]) {\\n      return true;\\n    } else {\\n      testObj[aNum] = true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction setSolution(nums) {\\n  let testSet = new Set(nums);\\n  return testSet.size !== nums.length;\\n}\\n\\nfunction runTest(testFunction, testArray) {\\n  console.log(\\'   Running test:\\', testFunction.name);\\n  let start = performance.now();\\n  let result = testFunction(testArray);\\n  let end = performance.now();\\n  console.log(\\'      Duration:\\', end - start);\\n}\\n\\nlet arr = [];\\nlet setSize = 1000;\\nfor (var i = 0; i < setSize; i++) {\\n  arr.push(i);\\n}\\nconsole.log(\\'Set size:\\', setSize);\\nrunTest(objectSolution, arr);\\nrunTest(setSolution, arr);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60861,
                "title": "5-lines-in-java",
                "content": "The Set's add method can be used for this situation,because it will return false if the element already exists .   \\n\\n    public  boolean containsDuplicate(int[] nums) {\\n    \\t\\t Set<Integer> set = new HashSet<Integer>();\\n    \\t\\t for(int i : nums)\\n    \\t\\t\\t if(!set.add(i))// if there is same\\n    \\t\\t\\t\\t return true; \\n    \\t\\t return false;\\n    \\t }",
                "solutionTags": [],
                "code": "The Set's add method can be used for this situation,because it will return false if the element already exists .   \\n\\n    public  boolean containsDuplicate(int[] nums) {\\n    \\t\\t Set<Integer> set = new HashSet<Integer>();\\n    \\t\\t for(int i : nums)\\n    \\t\\t\\t if(!set.add(i))// if there is same\\n    \\t\\t\\t\\t return true; \\n    \\t\\t return false;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 1698064,
                "title": "5-different-approaches-w-explanations",
                "content": "**Approach #1**: Brute Force - *Time Limit Exceeded*\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    n = len(nums)\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\\n\\n* **Explanation**: Use two for loops to compare pairs of integers in the array. Once we reach a comparison in which the numbers are the same, we return true. If we loop through all the integers of the array without reaching a similar pair of numbers, we return false.\\n* **Runtime**: Time Limit Exceeded\\n---\\n**Approach #2**: Sorting\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    nums.sort()\\n    for i in range(len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\\n\\n* **Explanation**: We start off by sorting the given array. Once we loop through the array from the beginning, if we see that the current number is the same as the next one in the array, there contains a duplicate in the array and therefore we return true. If we finish looping and there are no duplicates, we return false.\\n* **Runtime**: Faster than 15% (715 ms)\\n---\\n**Approach #3**: Using Counter Function\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    freq = Counter(nums)\\n    for num, freq in freq.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\\n\\n* **Explanation**: `Counter` is a subclass of `dict` designed for counting hashable objects in Python. It\\u2019s a dictionary that stores the objects as keys and the frequencies of those objects as values. In this approach, we utilize `Counter` to count the frequencies of each integer for us. For example, if the input array is `[1, 2, 3, 4, 4, 5]`, using `Counter` on that input array will give us the following dictionary: `Counter({4: 2, 1: 1, 2: 1, 3: 1, 5: 1})`. Utilizing this function, we will loop through the `freq` dictionary to see if any values (frequencies) are greater than 1, which means there exists an integer in the given array that is duplicated.\\n* **Runtime**: Faster than 7% (797 ms)\\n---\\n**Approach #4**: Using Hashmap\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    counter = {}\\n    for num in nums:\\n        if num not in counter:\\n            counter[num] = 0\\n        counter[num] += 1\\n    for num, freq in counter.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\\n\\n* **Explanation**: In this approach, we essentially mimick what the `Counter` function does in the previous approach. We first initialize a hashmap, to which we loop through the given array and plot the frequencies of each integer by incrementing the values in the hashmap. Then, we try to look for a frequency that is greater than 1 and return the result accordingly.\\n* **Runtime**: Faster than 7% (810 ms)\\n---\\n**Approach #5**: Using Set\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return False if len(set(nums)) == len(nums) else True\\n```\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```\\n\\n* **Explanation**: This approach can be done a number of ways in just one line. Essentially we are using `set()` to convert the given array to a set. In a set, the values are unique and there exists no duplicates, therefore if the set version of the input array has a different length than the regular array itself, there exists a duplicate in the original input array.\\n* **Runtime**: Faster than 5% (885 ms)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    n = len(nums)\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    nums.sort()\\n    for i in range(len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    freq = Counter(nums)\\n    for num, freq in freq.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    counter = {}\\n    for num in nums:\\n        if num not in counter:\\n            counter[num] = 0\\n        counter[num] += 1\\n    for num, freq in counter.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return False if len(set(nums)) == len(nums) else True\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3217571,
                "title": "javascript-easiest-logic-ever",
                "content": "# Intuition\\nThere are generally many ways to solve it.\\nI used this because it is easy to understand the logic and can use in any language.\\n\\n# Approach\\nJust look at the array . The array is sorted by using Sort() , if the next element is same as first it will return true.\\n\\n# Complexity\\n- Time complexity:\\nIts Linear Time Comlexity Big-O = O(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# JavaScript Solution (Using Loop):\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i <= nums.length-1; i++){\\n        if(nums[i] === nums[i+1]){\\n            return true\\n        }\\n    }\\n    return false\\n};\\n```\\n# JavaScript Solution (Creating a Set):\\n````\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); \\n    return s.size !== nums.length\\n};\\n````\\n#### I am working hard for you guys...\\n#### Please upvote if you found any help with this code...\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i <= nums.length-1; i++){\\n        if(nums[i] === nums[i+1]){\\n            return true\\n        }\\n    }\\n    return false\\n};\\n```\n````\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); \\n    return s.size !== nums.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60937,
                "title": "3ms-java-solution-with-bit-manipulation",
                "content": "if the range of element provided, we can use byte array as a marker.    \\n\\n\\n    public class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        byte[] mark = new byte[150000];\\n        for (int i : nums) {\\n            int j = i/8;\\n            int k = i%8;\\n            int check = 1<<k;\\n            if ((mark[j] & check) != 0) {\\n                return true;\\n            }\\n            mark[j]|=check;\\n        }\\n        return false;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        byte[] mark = new byte[150000];\\n        for (int i : nums) {\\n            int j = i/8;\\n            int k = i%8;\\n            int check = 1<<k;\\n            if ((mark[j] & check) != 0) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61110,
                "title": "c-solutions-sorting-maps-and-sets",
                "content": "        \\n    bool containsDuplicate1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<int(nums.size())-1; i++) {\\n            if (nums[i]==nums[i+1])\\n                return true;\\n        }\\n        return false;    \\n    }\\n    \\n    bool containsDuplicate2(vector<int>& nums) {\\n        map<int, bool> myMap;\\n        // unordered_map<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            else\\n                myMap[num] = true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate3(vector<int>& nums) {\\n        multimap<int, bool> myMap;\\n        // unordered_multimap<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            myMap.insert(make_pair(num, true));\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate4(vector<int>& nums) {\\n        set<int> mySet;\\n        // unordered_set<int> mySet;\\n        // multiset<int> mySet;\\n        // unordered_multiset<int> mySet;\\n        for (auto& num: nums) {\\n            if (mySet.find(num) != mySet.end())\\n                return true;\\n            mySet.insert(num);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "        \\n    bool containsDuplicate1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<int(nums.size())-1; i++) {\\n            if (nums[i]==nums[i+1])\\n                return true;\\n        }\\n        return false;    \\n    }\\n    \\n    bool containsDuplicate2(vector<int>& nums) {\\n        map<int, bool> myMap;\\n        // unordered_map<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            else\\n                myMap[num] = true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate3(vector<int>& nums) {\\n        multimap<int, bool> myMap;\\n        // unordered_multimap<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            myMap.insert(make_pair(num, true));\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate4(vector<int>& nums) {\\n        set<int> mySet;\\n        // unordered_set<int> mySet;\\n        // multiset<int> mySet;\\n        // unordered_multiset<int> mySet;\\n        for (auto& num: nums) {\\n            if (mySet.find(num) != mySet.end())\\n                return true;\\n            mySet.insert(num);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60872,
                "title": "1-line-javascript-solutions",
                "content": "Using `Set`:\\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size < nums.length;\\n};\\n```\\nWe can also use `sort` which is slower O(n log n) time but improved O(1) space (although we mutate the input):\\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.sort().some((a, i) => a === nums[i - 1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size < nums.length;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.sort().some((a, i) => a === nums[i - 1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60852,
                "title": "three-python-solution-for-contain-duplicates",
                "content": "        # Method 1 -- Apply hashtable O(n)\\n        # hashNum = {}\\n        # for i in nums:\\n        #     if i not in hashNum:\\n        #         hashNum[i] = 1\\n        #     else:\\n        #         return True\\n        # return False\\n        \\n        # Method 2 -- Sorting\\n        # l =  len(nums)\\n        # if l < 2:\\n        #     return False\\n        # nums.sort()\\n        # for i in range(l-1):\\n        #     if nums[i] == nums[i+1]:\\n        #         return True\\n        # return False\\n        \\n        # Method 3 -- Set solution for python\\n        numsSet =  set(nums)\\n        if len(nums) == len(numsSet):\\n            return False\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "        # Method 1 -- Apply hashtable O(n)\\n        # hashNum = {}\\n        # for i in nums:\\n        #     if i not in hashNum:\\n        #         hashNum[i] = 1\\n        #     else:\\n        #         return True\\n        # return False\\n        \\n        # Method 2 -- Sorting\\n        # l =  len(nums)\\n        # if l < 2:\\n        #     return False\\n        # nums.sort()\\n        # for i in range(l-1):\\n        #     if nums[i] == nums[i+1]:\\n        #         return True\\n        # return False\\n        \\n        # Method 3 -- Set solution for python\\n        numsSet =  set(nums)\\n        if len(nums) == len(numsSet):\\n            return False\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 2677785,
                "title": "python-1-liner",
                "content": "```\\ndef containsDuplicate(nums):\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsDuplicate(nums):\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61076,
                "title": "in-python-this-problem-is-a-joke",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def containsDuplicate(self, nums):\\n            return not (len(nums) == len(set(nums)))",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 60909,
                "title": "c-solution-simply-one-line",
                "content": "    class Solution {\\n      public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return set<int>(nums.begin(), nums.end()).size() < nums.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n      public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return set<int>(nums.begin(), nums.end()).size() < nums.size();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3216138,
                "title": "best-c-3-solution-hash-table-two-pointers-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Using Array(Two Nested Loop). Brute Force Approach.\\n2. Using Array + Sorting. Brute Better Approach.\\n3. Using Array + Hash Table. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array(nums). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] == nums[j]){\\n                    return ture;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(N), Hash Table(unordered map) space.\\n\\n    Using Array + Hash Table. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<long,long> map;   \\n        for(int i=0; i<nums.size(); i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] > 1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array(nums). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] == nums[j]){\\n                    return ture;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(N), Hash Table(unordered map) space.\\n\\n    Using Array + Hash Table. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<long,long> map;   \\n        for(int i=0; i<nums.size(); i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] > 1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500880,
                "title": "java-tc-o-n-sc-o-n-clean-concise-solution-using-hashset",
                "content": "```java\\n/**\\n * Using HashSet\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution1 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (!found.add(n)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Sort the array\\n *\\n * Time Complexity: O(N log N)\\n *\\n * Space Complexity: O(Space used by sorting algorithm)\\n */\\nclass Solution2 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return false;\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Contains Duplicate question on LeetCode:\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```java\\n/**\\n * Using HashSet\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution1 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (!found.add(n)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Sort the array\\n *\\n * Time Complexity: O(N log N)\\n *\\n * Space Complexity: O(Space used by sorting algorithm)\\n */\\nclass Solution2 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return false;\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61054,
                "title": "javascript-very-fast-solution",
                "content": "    var containsDuplicate = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            \\n            if(obj[nums[i]] > 1) return true;\\n        }\\n        \\n        return false;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var containsDuplicate = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            \\n            if(obj[nums[i]] > 1) return true;\\n        }\\n        \\n        return false;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3419018,
                "title": "3-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Set\\n\\n## Approach\\nThis approach to solving the problem uses the property of sets in Swift that they cannot contain duplicates. Therefore, if we convert the given integer array `nums` to a set using `Set(nums)`, it will automatically remove any duplicate elements from `nums`. \\n\\nIf there are no duplicates in `nums`, the `count` of the set will be equal to the `count` of the original array, so `nums.count == Set(nums).count` will be `true`, and the function will return `false`. \\n\\nHowever, if there are duplicates in `nums`, the count of the set will be less than the count of the original array, so `nums.count != Set(nums).count` will be `true`, and the function will return `true`.\\n\\n## Complexity\\nThe time complexity of this approach is $$O(n)$$, where $$n$$ is the number of elements in the input array `nums`.\\n\\nThe space complexity of this approach is also $$O(n)$$, as the size of the set `Set(nums)` will be at most $$n$$ if there are no duplicates.\\n\\nTherefore, this approach has *linear time* and *space complexity*, which is efficient for an array of a moderate size.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        nums.count != Set(nums).count\\n    }\\n}\\n```\\n\\n---\\n\\n# Second solution using Dictionary\\n\\n## Approach\\nThis approach uses a dictionary to keep track of the frequency of each element in the input array.\\n\\nThe function initializes an empty dictionary dict to keep track of the frequency of each element. It then loops through each element in the input array `nums`. For each element, it checks if the element is already in the dictionary or not. If the element is already in the dictionary, it means that it appears more than once in the array, so the function returns `true`. Otherwise, it adds the element to the dictionary with a value of `1`.\\n\\nIf the function has looped through all the elements in the array without finding any duplicates, it means that every element is distinct, so the function returns `false`.\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n)$$ because it loops through each element in the array exactly once, and a space complexity of $$O(n)$$ because it creates a dictionary with at most $$n$$ key-value pairs, where $$n$$ is the length of the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        var dict = [Int: Int]()\\n\\n        for num in nums {\\n            if dict[num] != nil {\\n                return true\\n            } else {\\n                dict[num] = 1\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\\n\\n---\\n\\n# Third solution using Sorting\\n\\n## Approach\\nThe solution approach first sorts the given array `nums` using the `sorted()` method which arranges the elements in *ascending* order. Sorting the array makes it easier to identify duplicates as they will be placed next to each other after sorting.\\n\\nThen, the function iterates over the sorted array using a for-loop from the first element until the second last element. Within the loop, it compares the current element with the next element in the array. If they are equal, it means that there is a duplicate in the array and the function returns `true`.\\n\\nIf the for-loop completes its iteration without finding any duplicates, the function returns `false`, indicating that there are no duplicate elements in the array.\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n \\\\cdot \\\\log n)$$ due to the sorting operation, where $$n$$ is the size of the input array.\\n\\nThe space complexity of the function is $$O(n)$$ due to the creation of a sorted version of the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0 ..< sortedNums.count - 1 {\\n            if sortedNums[i] == sortedNums[i + 1] {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\\n\\n# Upvote ^_^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/3fc71cb4-8ae5-4d42-8631-ca17c423afa8_1681550043.7428308.png)\\n\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        nums.count != Set(nums).count\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        var dict = [Int: Int]()\\n\\n        for num in nums {\\n            if dict[num] != nil {\\n                return true\\n            } else {\\n                dict[num] = 1\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0 ..< sortedNums.count - 1 {\\n            if sortedNums[i] == sortedNums[i + 1] {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521790,
                "title": "4-solutions-in-python",
                "content": "1. Brute force \\nTime Complexity: O(n^2)  [It gets Time Limit Exceeded when n \\u226510^5] \\nSpace Complexity: O(1) \\n```\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\\n\\n2. use sort()\\nTime Complexity: O(n Log n)   \\nSpace Complexity: O(1) \\n```\\n        nums.sort()\\n        for i in range(1,len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return True\\n        return False\\n```\\n\\n\\n3. use set()\\nTime Complexity: O(n)   \\nSpace Complexity: O(n) \\n```\\n            new_List = set()\\n            for i in range(len(nums)):\\n                if nums[i] in new_List:\\n                    return True\\n                new_List.add(nums[i])\\n            return False\\n```\\n\\n4. use hash Table\\nTime Complexity: O(n)   \\nSpace Complexity: O(n) \\n\\n```\\n# easy to understand\\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                hashTable[nums[i]] += 1\\n        \\n        for i in range(len(nums)):\\n            if hashTable[nums[i]] >= 2:\\n                return True\\n        return False\\n```\\n\\n```\\n# more straightforward, similar to set(): \\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                return True\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\n```\\n        nums.sort()\\n        for i in range(1,len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return True\\n        return False\\n```\n```\\n            new_List = set()\\n            for i in range(len(nums)):\\n                if nums[i] in new_List:\\n                    return True\\n                new_List.add(nums[i])\\n            return False\\n```\n```\\n# easy to understand\\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                hashTable[nums[i]] += 1\\n        \\n        for i in range(len(nums)):\\n            if hashTable[nums[i]] >= 2:\\n                return True\\n        return False\\n```\n```\\n# more straightforward, similar to set(): \\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60851,
                "title": "basic-48ms-c-solution-with-unordered-map",
                "content": "    class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if (nums.empty()) { return false; }\\n            unordered_map<int,int> mp;\\n            for (int i : nums) {\\n                if (++mp[i] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if (nums.empty()) { return false; }",
                "codeTag": "Java"
            },
            {
                "id": 60866,
                "title": "12ms-c-language-solution-with-in-house-hashset",
                "content": "    struct Node\\n    {\\n        int val;\\n        struct Node *next;\\n    };\\n    \\n    struct Set\\n    {\\n        int bucketSize;\\n        struct Node **table;\\n    };\\n    \\n    void initSet(struct Set *set, int bucketSize)\\n    {\\n        set->bucketSize = bucketSize;\\n        set->table = malloc(sizeof(struct Node*) * bucketSize);\\n        memset(set->table, 0, sizeof(struct Node*) * bucketSize);\\n    }\\n    \\n    bool addValue(struct Set *s, int val)\\n    {\\n        int idx = val > 0 ? val : -val;\\n        idx %= s->bucketSize;\\n        struct Node *ptr = s->table[idx];\\n        while(ptr != NULL)\\n        {\\n            if(ptr->val == val)\\n            {\\n                return false;\\n            }\\n        \\n            ptr = ptr->next;\\n        }\\n        ptr = malloc(sizeof(struct Node));\\n        ptr->val = val;\\n        ptr->next = s->table[idx];\\n        s->table[idx] = ptr;\\n        return true;\\n    }\\n    void releaseSet(struct Set *s)\\n    {\\n        struct Node *ptr, *tmp;\\n        for(int i = 0; i < s->bucketSize; ++i)\\n        {\\n            ptr = s->table[i];\\n            while(ptr != NULL)\\n            {\\n                tmp = ptr;\\n                ptr = ptr->next;\\n                free(tmp);\\n            }\\n        }\\n        free(s->table);\\n        s->table = NULL;\\n        s->bucketSize = 0;\\n    }\\n    bool containsDuplicate(int* nums, int numsSize) {\\n        if(numsSize < 2)\\n        {\\n            return false;\\n        }\\n        struct Set set;\\n        initSet(&set, numsSize / 2);\\n        for(int i = 0; i < numsSize; ++i)\\n        {\\n            if(!addValue(&set, nums[i]))\\n            {\\n                releaseSet(&set);\\n                return true;\\n            }\\n        }\\n        releaseSet(&set);\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    struct Node\\n    {\\n        int val;\\n        struct Node *next;\\n    };\\n    \\n    struct Set\\n    {\\n        int bucketSize;\\n        struct Node **table;\\n    };\\n    \\n    void initSet(struct Set *set, int bucketSize)\\n    {\\n        set->bucketSize = bucketSize;\\n        set->table = malloc(sizeof(struct Node*) * bucketSize);\\n        memset(set->table, 0, sizeof(struct Node*) * bucketSize);\\n    }\\n    \\n    bool addValue(struct Set *s, int val)\\n    {\\n        int idx = val > 0 ? val : -val;\\n        idx %= s->bucketSize;\\n        struct Node *ptr = s->table[idx];\\n        while(ptr != NULL)\\n        {\\n            if(ptr->val == val)\\n            {\\n                return false;\\n            }\\n        \\n            ptr = ptr->next;\\n        }\\n        ptr = malloc(sizeof(struct Node));\\n        ptr->val = val;\\n        ptr->next = s->table[idx];\\n        s->table[idx] = ptr;\\n        return true;\\n    }\\n    void releaseSet(struct Set *s)\\n    {\\n        struct Node *ptr, *tmp;\\n        for(int i = 0; i < s->bucketSize; ++i)\\n        {\\n            ptr = s->table[i];\\n            while(ptr != NULL)\\n            {\\n                tmp = ptr;\\n                ptr = ptr->next;\\n                free(tmp);\\n            }\\n        }\\n        free(s->table);\\n        s->table = NULL;\\n        s->bucketSize = 0;\\n    }\\n    bool containsDuplicate(int* nums, int numsSize) {\\n        if(numsSize < 2)\\n        {\\n            return false;\\n        }\\n        struct Set set;\\n        initSet(&set, numsSize / 2);\\n        for(int i = 0; i < numsSize; ++i)\\n        {\\n            if(!addValue(&set, nums[i]))\\n            {\\n                releaseSet(&set);\\n                return true;\\n            }\\n        }\\n        releaseSet(&set);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 861276,
                "title": "python3-one-line-solution",
                "content": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 856678,
                "title": "swift-one-liner",
                "content": "Swift one liner\\n```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        Set(nums).count != nums.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        Set(nums).count != nums.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725096,
                "title": "c-solution-multiple-approaches-o-n",
                "content": "There are multiple approaches to solve this question. \\n\\n**APPROACH 1 : USING MAPS**\\nWe have to find out whether there is an element with a frequency >=2. \\nIf yes , we **return TRUE** .\\nElse , we **return FALSE**.\\n\\nSo , we create a map and store the frequency of each element in the map. \\nThen we can traverse the map to check if any key has a value >=2 . \\nIf yes , *return true* else , *return false*. \\n\\nAnother way is to compare the size of the map with the size of the array. \\nIf all the elements are unique , then , \\n\\t\\t**NUMS SIZE == SIZE OF THE MAP**  --> *RETURN FALSE*\\n\\telse *RETURN TRUE*\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int> a;\\n        for(auto &x:nums)\\n        {\\n            a[x]++;\\n        }\\n        \\n        for(auto &z:a)\\n        {\\n            if(z.second>=2)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**APPROACH 2 : FIND ALL THE UNIQUE ELEMENTS**\\nCreate a set and store all the unique elements of the array. \\nIf the set size == array size , this means all the elements are distinct and hence , occur only once.\\nSo , \\n\\t if(**set size == array size**)\\n\\t return false;\\n\\t else\\n\\t return true;\\n\\t \\n ```\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tset<int> a;\\n\\t\\t\\tfor(auto &x:nums)\\n\\t\\t\\ta.insert(x);\\n\\t\\t\\treturn (a.size()!=nums.size());\\n    }\\n};\\n```\\n\\n**APPROACH 3 : SORT THE ARRAY .**\\nAfter sorting the array , if any 2 adjacent elements are equal , this means that 1 value has a \\nfrequency>=2. \\nSo , \\n1. Sort the array.\\n2. If any 2 adjacent elements are equal , **return true**.\\n3. Else **return false**.\\n\\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t\\tif(nums[i]==nums[i-1])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n    }\\n};\\n```\\n**THANKS FOR READING . HAVE A NICE DAY AND KEEP CODING !!**",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int> a;\\n        for(auto &x:nums)\\n        {\\n            a[x]++;\\n        }\\n        \\n        for(auto &z:a)\\n        {\\n            if(z.second>=2)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\n```\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tset<int> a;\\n\\t\\t\\tfor(auto &x:nums)\\n\\t\\t\\ta.insert(x);\\n\\t\\t\\treturn (a.size()!=nums.size());\\n    }\\n};\\n```\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t\\tif(nums[i]==nums[i-1])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552285,
                "title": "go-multiple-solutions-in-go-golang",
                "content": "Hello gophers!\\n\\n# Problem: 217. Contains Duplicate (Easy)\\n\\n## Solutions\\n\\nFrom worst to best solutions!\\n\\n| Solution #       | Solution Name                                 | Time Complexity | Space Complexity |\\n|------------------|------------------------------------------------|-----------------|------------------|\\n| Solution 1 (Worst)       | Brute Force                                    | `O(n^2)`        | `O(1)`           |\\n| Solution 2       | Sorting                                        | `O(nlogn)`      | `O(logn)`           |\\n| Solution 3       | Using a `multiset`                             | `O(n)`          | `O(n)`           |\\n| Solution 4       | Another `multiset` solution                    | `O(n)`          | `O(n)`           |\\n| Solution 5 (Clean)       | Using a `set` with custom data structure       | `O(n)`          | `O(n)`           |\\n| Solution 6 (Interview)       | Using a `set` for interviews (No custom struct)| `O(n)`          | `O(n)`           |\\n\\n\\n### Solution1: Brute Force\\n\\nWe check every possible pairs! \\uD83D\\uDC80\\n\\nTime: `O(n^2)`\\nSpace: `O(1)`\\n\\n```go\\n// Time: O(n*n) = O(n^2)\\n// Space: O(1)\\nfunc containsDuplicate(nums []int) bool {\\n    // Time: O(n-1) = O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        // Time: O(n-1) = O(n)\\n        for j := i+1; j < len(nums); j++ {\\n            if nums[i] == nums[j] {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 2: Sorting\\n\\nWe sort all nums and we check the pairs that are beside each others!\\n\\nTime: `O(nlogn)`\\nSpace: `O(logn)` (see `sort` pkg doc)\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(logn)\\nfunc containsDuplicate(nums []int) bool {\\n    if len(nums) <= 1 {\\n        return false\\n    }\\n    \\n    // Time: O(nlogn)\\n    // Space: O(logn)\\n    sort.Ints(nums)\\n    \\n    // Time: O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        if nums[i] == nums[i+1] {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```\\n\\n### Solution 3: Using a `multiset`\\n\\nWe create a `multiset` (`map[num]occurence` where both `num` and `occurence` are `int`s).  \\nWhen the `multiset` is created, we checked if one of the `num` has more than one `occurence`.\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.HasDuplicate(num) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) OccurenceOf(num int) int {\\n    // Time: O(1)\\n    occ, ok := s.items[num]\\n    if !ok {\\n        return 0\\n    }\\n    return occ\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate(num int) bool {\\n    // Time: O(n)\\n    occ := s.OccurenceOf(num)\\n    return occ > 1\\n}\\n```\\n\\nWe could have also create\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc BuildMultiSet(nums []int) *MultiSet {\\n    s := NewMultiSet()\\n    // Time: O(n)\\n    // Space: O(n)\\n    s.Add(nums)\\n    return s\\n}\\n```\\n\\n### Solution 4: Another `multiset` solution\\n\\nor we could iterate over the map instead of the slice (same algorithm):\\n\\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    return set.HasDuplicate()\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate() bool {\\n    // Time: O(n)\\n    for _, val := range s.items {\\n        // Time: O(1)\\n        if val > 1 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 5: Using a `set` with custom data structure\\n\\nWe don\\'t need to keep in memory the occurence.  \\nAs soon as we have a second occurence, we return true.  \\nThis mean we can use a `set` instead of a `multiset`!  \\nIn go, we usually implement a set with a `map[int]bool` or `map[int]struct{}`.\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewSet()\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.Has(num) {\\n            return true\\n        }\\n        // Time: O(1)\\n        set.Add(num)\\n    }\\n\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[int]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[int]struct{}),\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Add(val int) {\\n    // Time: O(1)\\n    s.items[val] = struct{}{}\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Has(val int) bool {\\n    // Time: O(1)\\n    _, ok := s.items[val]\\n    return ok\\n}\\n```\\n\\n### Solution 6 : Using a `set` for interviews\\n\\nSolution `6`, but without a custom data structure and comments to save time! **This is the solution I would do if I was short on time**.  \\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, num := range nums {\\n        if _, hasNum := set[num]; hasNum {\\n            return true\\n        }\\n        set[num] = struct{}{}\\n    }\\n    return false\\n}\\n```\\n\\n## `set` vs `multiset`\\n\\nSet:\\n- **Description**: Collection of distinct elements\\n- **Operations**: Insertion (if not present), Deletion, Membership testing\\n- **Go Implementation**: `set := make(map[ElementType]struct{})`\\n- **Examples**: Students in a class, Countries in the world\\n\\nMultiset (Bag)\\n- **Description**: Collection where elements can appear multiple times\\n- **Operations**: Insertion (anytime), Deletion (specific occurrence), Counting occurrences\\n- **Go Implementation**: `multiset := make(map[ElementType]int)` where `int` is the **occurence**\\n- **Examples**: Word frequency in a document, Fruit counts in a basket\\n\\n## Next problems\\n\\n- [219. Contains Duplicate II (Easy)](https://leetcode.com/problems/contains-duplicate-ii/) (see my solution [here](https://leetcode.com/problems/contains-duplicate-ii/discuss/1737679/Go-Sliding-Window-Clean-code-(100)))\\n- [220. Contains Duplicate III (Hard)](https://leetcode.com/problems/contains-duplicate-iii/) (my solution = WIP)\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go",
                    "Ordered Set"
                ],
                "code": "```go\\n// Time: O(n*n) = O(n^2)\\n// Space: O(1)\\nfunc containsDuplicate(nums []int) bool {\\n    // Time: O(n-1) = O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        // Time: O(n-1) = O(n)\\n        for j := i+1; j < len(nums); j++ {\\n            if nums[i] == nums[j] {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(logn)\\nfunc containsDuplicate(nums []int) bool {\\n    if len(nums) <= 1 {\\n        return false\\n    }\\n    \\n    // Time: O(nlogn)\\n    // Space: O(logn)\\n    sort.Ints(nums)\\n    \\n    // Time: O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        if nums[i] == nums[i+1] {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.HasDuplicate(num) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) OccurenceOf(num int) int {\\n    // Time: O(1)\\n    occ, ok := s.items[num]\\n    if !ok {\\n        return 0\\n    }\\n    return occ\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate(num int) bool {\\n    // Time: O(n)\\n    occ := s.OccurenceOf(num)\\n    return occ > 1\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc BuildMultiSet(nums []int) *MultiSet {\\n    s := NewMultiSet()\\n    // Time: O(n)\\n    // Space: O(n)\\n    s.Add(nums)\\n    return s\\n}\\n```\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    return set.HasDuplicate()\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate() bool {\\n    // Time: O(n)\\n    for _, val := range s.items {\\n        // Time: O(1)\\n        if val > 1 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewSet()\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.Has(num) {\\n            return true\\n        }\\n        // Time: O(1)\\n        set.Add(num)\\n    }\\n\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[int]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[int]struct{}),\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Add(val int) {\\n    // Time: O(1)\\n    s.items[val] = struct{}{}\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Has(val int) bool {\\n    // Time: O(1)\\n    _, ok := s.items[val]\\n    return ok\\n}\\n```\n```go\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, num := range nums {\\n        if _, hasNum := set[num]; hasNum {\\n            return true\\n        }\\n        set[num] = struct{}{}\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790062,
                "title": "c",
                "content": "A hashset is the most efficient way to check if a collection has duplicates in C#. Always remember this when you see descriptions asking to check for dupes, distinct things, pairs of socks, etc.  Sorting, on the other hand, is a very inneficient procedure and should be avoided if possible. HashSet.Add and .Remove methods will return false if element already exists, or not found, which can be used in a wide range of situations, replacing methods like List.Exists() or Array.IndexOf when checking collections.\\n```\\n    var hash=new HashSet<int>();\\n    foreach (var item in nums)\\n        if (!hash.Add(item)) return true;\\n    return false;\\n```",
                "solutionTags": [],
                "code": "```\\n    var hash=new HashSet<int>();\\n    foreach (var item in nums)\\n        if (!hash.Add(item)) return true;\\n    return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782699,
                "title": "three-javascript-solutions-with-explanation",
                "content": "The first solution is based on sorting. We sort array elements, so that all of elements with the same value become adjacent. Then we iterate through the array and check if the adjacent elements are equal. If so, we found a duplicate.\\n\\nSorting takes up O(NLog(N)) time, iterating through the arrray takes O(N) time.\\nWe sort the array in-place, we do not create a new array, so it doesn\\'t take up any extra space.\\n\\n**Time complexity:** *O(NLog(N)) + O(N) = O(NLog(N))*\\n**Space complexity:** *O(1)*\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   nums.sort();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1]) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\\n\\nThe next two solutions are based on [Set](https://tutorialedge.net/compsci/data-structures/sets-for-beginners/#:~:text=A%20set%20is%20a%20data,repeated%2C%20unique%20values%20within%20them.&text=We%20can%20then%20view%20these,the%20contents%20of%20our%20set.) data structure, which is akin to set in mathematics. Set can only contain unique elements and if the element appears more than once, it will be included only once.\\n\\nThe first solution iterartes through array and adds elements which we already saw, and if that element appears again we return true.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    const set = new Set();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n    }\\n    \\n    return false;\\n};\\n```\\n\\nIn the worst case we need to traverse the whole array and also insert every element from the array in our set. Each set insertion is O(1), so inserting N elemnts will cost us O(N).\\nNew set can contain up to N elements in case there are no duplicates.\\n\\n**Time complexity:** *O(N) + O(N) = O(N)*\\n**Space complexity:** *O(N)*\\n\\nThe second solution creates a new set from an array of numbers and check that the length of this set is the same as the length of the array it was constructed from. If that\\'s not the case it means there is 1 or more duplicates and we return true.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums)).size !== nums.length;\\n};\\n```\\n\\nIn this case we just need to create a set from numbers that we are given.\\nConstructing a set has O(N) time complexity.\\nStorign each element from the numbers array in set has O(N) time complexity.\\n\\n**Time complexity:** *O(N)*\\n**Space complexity:** *O(N)*\\n\\nIf you found this useful, please upvote! If you have some comments or remarks, please leave them! Thank you.",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   nums.sort();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1]) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    const set = new Set();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n    }\\n    \\n    return false;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums)).size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836662,
                "title": "faster-than-97-easy-to-read-one-liner",
                "content": "```\\npublic class Solution\\n{\\n    public bool ContainsDuplicate(int[] nums)\\n    {\\n        return new HashSet<int>(nums).Count < nums.Length;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool ContainsDuplicate(int[] nums)\\n    {\\n        return new HashSet<int>(nums).Count < nums.Length;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383485,
                "title": "javascript",
                "content": "```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381975,
                "title": "python-easily-understood-dp-faster-than-88-simple",
                "content": "Since transforming the nums from list to set can remove those duplicates, the length will be different if the list contains dupicates.\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61055,
                "title": "5-lines-simple-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        HashSet<Integer> flag = new HashSet<Integer>();\\n        \\n        for(int i : nums) {\\n            if(!flag.add(i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        HashSet<Integer> flag = new HashSet<Integer>();\\n        \\n        for(int i : nums) {\\n            if(!flag.add(i)) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490824,
                "title": "c-python",
                "content": "In this problem we\\'ve to find out an element whose frequency is **greater** than 1. We can do this problem by using two approaches:-\\n\\n\\n* 1:-\\nIn this approach, first we\\'ll sort the array, then we\\'ll check whether the two adjacent elements are equal or not. If we find out there are two adjacent elements that are equal, then we\\'ll return **true**, and if there are no such adjacent elements, then we\\'ll return **false**.\\n\\n   <iframe src=\"https://leetcode.com/playground/AQ5jq99H/shared\" frameBorder=\"0\" width=\"450\" height=\"255\"></iframe>\\n\\n  **Time Complexity:-** `O(nlogn)`\\n  **Space Complexity :-** `O(1)`\\n\\n* 2:-\\nIn this approach, we\\'ll store all the elements of array *nums* in a set. This set will store the unique elements of nums. Then we\\'ll compare the size of the set with size of array *nums*. \\n\\ti. If the size of set is **equal** to size of nums, then we\\'ll return **false**, because this means all the elements are unique in the array *nums*.\\n\\tii. If the size of set is **not equal** to size of nums, then we\\'ll return **true**.\\n\\t\\n\\n\\t<iframe src=\"https://leetcode.com/playground/RaixEqtk/shared\" frameBorder=\"0\" width=\"570\" height=\"160\"></iframe>\\n\\t\\n\\t**Time Complexity:-** `O(n)`\\n\\t**Space Complexity :-** `O(n)`\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "In this problem we\\'ve to find out an element whose frequency is **greater** than 1. We can do this problem by using two approaches:-\\n\\n\\n* 1:-\\nIn this approach, first we\\'ll sort the array, then we\\'ll check whether the two adjacent elements are equal or not. If we find out there are two adjacent elements that are equal, then we\\'ll return **true**, and if there are no such adjacent elements, then we\\'ll return **false**.\\n\\n   <iframe src=\"https://leetcode.com/playground/AQ5jq99H/shared\" frameBorder=\"0\" width=\"450\" height=\"255\"></iframe>\\n\\n  **Time Complexity:-** `O(nlogn)`\\n  **Space Complexity :-** `O(1)`\\n\\n* 2:-\\nIn this approach, we\\'ll store all the elements of array *nums* in a set. This set will store the unique elements of nums. Then we\\'ll compare the size of the set with size of array *nums*. \\n\\ti. If the size of set is **equal** to size of nums, then we\\'ll return **false**, because this means all the elements are unique in the array *nums*.\\n\\tii. If the size of set is **not equal** to size of nums, then we\\'ll return **true**.\\n\\t\\n\\n\\t<iframe src=\"https://leetcode.com/playground/RaixEqtk/shared\" frameBorder=\"0\" width=\"570\" height=\"160\"></iframe>\\n\\t\\n\\t**Time Complexity:-** `O(n)`\\n\\t**Space Complexity :-** `O(n)`\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "codeTag": "Unknown"
            },
            {
                "id": 174189,
                "title": "javascript-1-line",
                "content": "`Set` can only store unique values. So if `Set.size` is less than `nums.length` - there have been duplicates.\\n```\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums).size !== nums.length);    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums).size !== nums.length);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374283,
                "title": "easy-c-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Just `sorted` the array.\\n- then used `two pointers` to check if they are equal at any point.\\n- if the are equal then return `true` other wise return `false`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## `Upvote! If you it helps :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<nums.size()-1 && j<nums.size()){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/98c22f7e-e3a6-4ed7-b0ee-dcfd6d8a8e8a_1680519332.2082071.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<nums.size()-1 && j<nums.size()){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010587,
                "title": "c-two-line-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public bool ContainsDuplicate(int[] nums) \\n    {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        return nums.Length != set.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool ContainsDuplicate(int[] nums) \\n    {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        return nums.Length != set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084097,
                "title": "2-line-solution-with-rust-hashset",
                "content": "Simple solution with Rust using only 2 lines within the function.\\n\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut exists = HashSet::new();\\n        !nums.into_iter().all(|n| exists.insert(n))\\n    }\\n}\\n```\\n\\n### Explanation\\n- `HashSet.insert` will return `true` if the inserted value does not yet exist in the set, otherwise false.\\n- Using this behaviour in an `Iter.all()` on the number list, it will return `true` if all the numbers are different and `false` if there is a duplicate number.\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut exists = HashSet::new();\\n        !nums.into_iter().all(|n| exists.insert(n))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1818765,
                "title": "short-only-2-lines-sweet-typescript-solution-top-1-speed",
                "content": "## Solution\\n**Link to submission \\u2192  ([click here](https://leetcode.com/submissions/detail/653157243/))**\\n```typescript \\nfunction containsDuplicate(nums: number[]): boolean {\\n    const set = new Set<number>(nums);\\n    return (set.size < nums.length);\\n};\\n```\\n\\n### LeetCode output:\\n* Runtime: **76 ms**, faster than **99.50%** of TypeScript online submissions for Contains Duplicate.\\n* Memory Usage: **51.7 MB**, less than **22.17%** of TypeScript online submissions for Contains Duplicate.\\n\\n\\n\\n ### \\u261D\\uFE0F Considerations:\\n>  Although this solution is acceptable given the constraints, it is worth noting that as the input\\n>   *```nums```* grows larger in size, constructing a new Set object with an input array (*```nums```*, in this case) becomes increasingly less efficient.\\n>\\n> For larger input array sizes, it may be more performant to add to the set iteratively (see below)...\\n> \\n\\n## Solution (alt.)\\n**Link to submission \\u2192  ([click here](https://leetcode.com/submissions/detail/653717028/))**\\n```javascript\\n// javascript\\nvar containsDuplicate = function(nums) {\\n    let set = new Set();\\n    for (let x of nums) {\\n\\t\\t// short circuits the loop at the first instance of a duplicate\\n        if (set.has(x)) return true;\\n        set.add(x);\\n    }\\n    return false;\\n};\\n```\\n\\n### LeetCode output:\\n* Runtime: **76 ms**, faster than **98.71%** of JavaScript online submissions for Contains Duplicate.\\n* Memory Usage: **51.4 MB**, less than **22.30%** of JavaScript online submissions for Contains Duplicate.\\n\\n---\\n\\n## Explanation:\\nSource: [mdn web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#specifications)\\n### \\u301D\\n>  [In JavaScript] the ```Set``` object lets you **store unique values** of any type, whether primitive >values or object references.\\n>\\n> ### ...\\n>\\n>### Relationship with arrays:\\n>```javascript\\n>let myArray = [\\'value1\\', \\'value2\\', \\'value3\\']\\n> \\n> // Use the regular Set constructor to transform an Array into a Set\\n> let mySet = new Set(myArray)\\n>\\n> mySet.has(\\'value1\\')     // returns true\\n> \\n> // Use the spread operator to transform a set into an Array.\\n> console.log([...mySet]) // Will show you exactly the same Array as myArray\\n>\\n>```\\n>\\n###  \\u301E",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript \\nfunction containsDuplicate(nums: number[]): boolean {\\n    const set = new Set<number>(nums);\\n    return (set.size < nums.length);\\n};\\n```\n```nums```\n```nums```\n```javascript\\n// javascript\\nvar containsDuplicate = function(nums) {\\n    let set = new Set();\\n    for (let x of nums) {\\n\\t\\t// short circuits the loop at the first instance of a duplicate\\n        if (set.has(x)) return true;\\n        set.add(x);\\n    }\\n    return false;\\n};\\n```\n```Set```\n```javascript\\n>let myArray = [\\'value1\\', \\'value2\\', \\'value3\\']\\n> \\n> // Use the regular Set constructor to transform an Array into a Set\\n> let mySet = new Set(myArray)\\n>\\n> mySet.has(\\'value1\\')     // returns true\\n> \\n> // Use the spread operator to transform a set into an Array.\\n> console.log([...mySet]) // Will show you exactly the same Array as myArray\\n>\\n>```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632329,
                "title": "brute-force-and-optimal-approach-well-explained",
                "content": "* Brute-Sorting Approach\\n```\\nclass Solution {\\n    public  boolean containsDuplicate(int[] nums) { \\n        Arrays.sort(nums); // Sorting the array\\n        // Run a loop till end;\\n        for (int i =0 ; i<nums.length-1; i++){\\n            if(nums[i] == nums[i+1]) return true;\\n            // if the value of current index is equals to next index, then return true\\n        }\\n        return false; // otherwise return false  \\n\\t }\\n}\\n```\\n* Time Complexity = BigO(NlogN) as we are sorting\\n\\n* Space Complexity= BigO(1) as no memory used\\n\\n\\n \\n* HashSet Approach\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Created HashSet to store all different Integers\\n        Set<Integer> set = new HashSet<>();\\n        for (int i: nums){ // run loop till end\\n                if(!set.add(i))return true;// if we found the similar value which is already present in set, then no need to add simply return true;\\n            // as it mean\\'s the one of the same value is already over there\\n        }\\n        return false;// otherwise, return false\\n    }\\n}\\n```\\n* Time Complexity = BigO(N) where N is no of integers to traverse\\n\\n* Space Complexity = BigO(N) as for worse case it can add N no of nodes",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  boolean containsDuplicate(int[] nums) { \\n        Arrays.sort(nums); // Sorting the array\\n        // Run a loop till end;\\n        for (int i =0 ; i<nums.length-1; i++){\\n            if(nums[i] == nums[i+1]) return true;\\n            // if the value of current index is equals to next index, then return true\\n        }\\n        return false; // otherwise return false  \\n\\t }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Created HashSet to store all different Integers\\n        Set<Integer> set = new HashSet<>();\\n        for (int i: nums){ // run loop till end\\n                if(!set.add(i))return true;// if we found the similar value which is already present in set, then no need to add simply return true;\\n            // as it mean\\'s the one of the same value is already over there\\n        }\\n        return false;// otherwise, return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249813,
                "title": "100-faster-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums){\\n            if(!set.add(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums){\\n            if(!set.add(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894268,
                "title": "c-90-sort-solution-o-n-log-n-n",
                "content": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025835,
                "title": "kotlin-1-line",
                "content": "```\\nfun containsDuplicate(nums: IntArray) = nums.size > nums.toSet().size\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun containsDuplicate(nums: IntArray) = nums.size > nums.toSet().size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61156,
                "title": "1-line-in-python",
                "content": "    return len(set(nums)) < len(nums)\\n\\nIt's not optimal solution (64 ms), however it simple and clear.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return len(set(nums)) < len(nums)\\n\\nIt's not optimal solution (64 ms), however it simple and clear.",
                "codeTag": "Unknown"
            },
            {
                "id": 3097839,
                "title": "contains-duplicate-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num2=set(nums)\\n        l1=len(nums)\\n        l2=len(num2)\\n        if(l1!=l2):\\n            return True\\n        else:\\n            return False\\n```\\nIf you find it helful, please give your valuable vote!!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num2=set(nums)\\n        l1=len(nums)\\n        l2=len(num2)\\n        if(l1!=l2):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215124,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Compare the length of array with the length of set of (array)\\n\\t\\t# Converting into set will automatically remove all the duplicates.\\n\\t\\t# That means if the length doesn\\'t match each other, it implies there is duplicate.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        return len(set(nums)) != len(nums)\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary then check if there are more than \"two\" in values of dictionary.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            if num in d:\\n                d[num] += 1\\n            else:\\n                d[num] = 1\\n        \\n        for k, v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary by using Python library\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Bitwise operation gives 0 if there is duplicates. \\n        # For example, 1 ^ 1 will give you 0.\\n\\t\\t# 2 ^ 2 = 0\\n\\t\\t# 3 ^ 3 = 0\\n\\t\\t# 1 XOR 1 equals 0\\n\\t\\t# 1 XOR 0 equals 1\\n        # T: O(n log n)\\n        # S: O(1)\\n        \\n        if len(nums) == 0:\\n            return False\\n        \\n        # In-place sort.\\n        # Ex) [1,2,3,1] to [1,1,2,3]\\n        nums.sort()\\n        \\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i]^curr == 0:\\n                return True\\n            curr = nums[i]\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Compare the length of array with the length of set of (array)\\n\\t\\t# Converting into set will automatically remove all the duplicates.\\n\\t\\t# That means if the length doesn\\'t match each other, it implies there is duplicate.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        return len(set(nums)) != len(nums)\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary then check if there are more than \"two\" in values of dictionary.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            if num in d:\\n                d[num] += 1\\n            else:\\n                d[num] = 1\\n        \\n        for k, v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary by using Python library\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Bitwise operation gives 0 if there is duplicates. \\n        # For example, 1 ^ 1 will give you 0.\\n\\t\\t# 2 ^ 2 = 0\\n\\t\\t# 3 ^ 3 = 0\\n\\t\\t# 1 XOR 1 equals 0\\n\\t\\t# 1 XOR 0 equals 1\\n        # T: O(n log n)\\n        # S: O(1)\\n        \\n        if len(nums) == 0:\\n            return False\\n        \\n        # In-place sort.\\n        # Ex) [1,2,3,1] to [1,1,2,3]\\n        nums.sort()\\n        \\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i]^curr == 0:\\n                return True\\n            curr = nums[i]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222337,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Linear Search Approach - Brute-Force Algorithm**\\n\\n**Time complexity** : O(N<sup>2</sup>). In the worst case, there are `n * (n + 1) / 2` pairs of integers to check. Therefore, the time complexity is O(N<sup>2</sup>).\\n**Space complexity** : `O(1)`. We only used constant extra space.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 2: Sorting Approach**\\n\\n**Explanation**:\\n- If there are any duplicate integers, they will be consecutive after sorting.\\n- The implementation here modifies the original array by sorting it. In general, it is not a good practice to modify the input. We can also make a copy of input array and operate on the copy instead.\\n\\n**Algorithm**:\\n- This approach employs sorting algorithm. Since comparison sorting algorithm like `HeapSort` is known to provide `O(N log N)` worst-case performance, sorting is often a good PreProcessing step.\\n- After sorting, we can traverse the sorted array to find if there are any two consecutive duplicate elements.\\n\\n**Time complexity** : `O(N log N)`. Sorting is `O(N log N)` and the traversing is `O(N)`. The entire algorithm is dominated by the sorting step, which is `O(N log N)`.\\n**Space complexity** : `O(1)`. Space depends on the sorting implementation which, usually, costs `O(1)` auxiliary space if `HeapSort` is used.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 3: Hash Table Approach Using Set**\\n\\n**Explanation**:\\n- Utilize a dynamic data structure that supports fast search and insert operations.\\n- For certain test cases with not very large `N`, the runtime of this method can be slower than Sorting Approach. The reason is hash table has some overhead in maintaining its property. \\n- We should keep in mind that real world performance can be different from what the Big-O notation says. The Big-O notation only tells us that for sufficiently large input, one will be faster than the other. Therefore, when `N` is not sufficiently large, an `O(N)` algorithm can be slower than an `O(N log N)` algorithm.\\n\\n**Algorithm**:\\n- Utilizing a data structure with faster search time will speed up the entire algorithm.\\n- There are many data structures commonly used as dynamic sets such as `Binary Search Tree` and `Hash Table`. \\n- The operations we need to support here are `search()` and `insert()`. \\n- For a self-balancing `Binary Search Tree` (`TreeSet` or `TreeMap` in Java), `search()` and `insert()` are both `O(log N)` time. For a `Hash Table` (`HashSet` or `HashMap` in Java), `search()` and `insert()` are both `O(1)` on average. Therefore, by using `Hash Table`, we can achieve linear time complexity for finding the duplicate in an unsorted array.\\n\\n**Time complexity** : `O(N)`. We do `search()` and `insert()` for `N` times and each operation takes a constant time.\\n**Space complexity** : `O(N)`. The space used by a hash table is linear with the number of elements in it.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return true;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return true;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60991,
                "title": "java-9ms-solution-using-hashset-very-very-easy-version",
                "content": "    public boolean containsDuplicate(int[] nums) {\\n    \\tHashSet<Integer> set = new HashSet<Integer>();\\n    \\tfor(int i=0;i<nums.length;i++){\\n    \\t\\tif(!set.add(nums[i])) return true;\\n    \\t}\\n\\t\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean containsDuplicate(int[] nums) {\\n    \\tHashSet<Integer> set = new HashSet<Integer>();\\n    \\tfor(int i=0;i<nums.length;i++){\\n    \\t\\tif(!set.add(nums[i])) return true;\\n    \\t}\\n\\t\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2697900,
                "title": "c-java-python3-javascript-solutions-faster-than-93",
                "content": "C#,Java,Python3,JavaScript different solution with explanation\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/)\\u2B50**\\n\\n**Example : C# Solution1 - HashSet ( \\u2B06To see other languages \\u2B06)**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Example : C# Solution2 - sort the array first**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nIf you got any problem or want other programming language solution, please feel free to let me know.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509447,
                "title": "c-python-one-line-solution",
                "content": "**C++ :**\\n\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n\\treturn nums.size() != set(nums.begin(), nums.end()).size();\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn not len(nums) == len(set(nums))\\n```\\n        \\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nbool containsDuplicate(vector<int>& nums) {\\n\\treturn nums.size() != set(nums.begin(), nums.end()).size();\\n}\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn not len(nums) == len(set(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61094,
                "title": "very-simple-c-solution",
                "content": "Sort and search\\n\\n    int comp (const void * a, const void * b) {\\n       return ( *(int*)a - *(int*)b );\\n    }\\n    \\n    \\n    bool containsDuplicate(int* nums, int numsSize) {\\n        // Sort\\n        qsort(nums, numsSize, sizeof(int), comp);\\n        \\n        // Loop\\n        for (int i = 0; i < numsSize - 1; i++) {\\n            if (nums[i] == nums[i+1]) return true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Sort and search\\n\\n    int comp (const void * a, const void * b) {\\n       return ( *(int*)a - *(int*)b );\\n    }\\n    \\n    \\n    bool containsDuplicate(int* nums, int numsSize) {\\n        // Sort\\n        qsort(nums, numsSize, sizeof(int), comp);\\n        \\n        // Loop\\n        for (int i = 0; i < numsSize - 1; i++) {\\n            if (nums[i] == nums[i+1]) return true;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1904169,
                "title": "java-solutions-100-efficiency-3-different-approaches",
                "content": "Java solutions, 100% efficiency, 3 different approaches\\n##### Please Upvote, If you like the solution.\\n\\n\\n\\n    class Solution {\\n\\tpublic boolean containsDuplicate(int[] nums) {\\n    \\n\\tHashSet<Integer> set = new HashSet<Integer>();\\t\\n\\tfor(int i:nums){\\n          \\n\\t\\t  if(set.contains(i)){ return true; }\\n\\t\\t  \\n            set.add(i);   \\n        }\\n        return false;\\n\\t\\t}\\n\\t}\\n\\n\\nRuntime: 6 ms\\nMemory Usage: 54.8 MB\\n\\n\\n\\n\\n\\tclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\nRuntime: 31 ms\\nMemory Usage: 71.9 MB\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(!map.containsKey(nums[i])){\\n\\t\\t\\t\\t\\tmap.put(nums[i],1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(Map.Entry<Integer, Integer> entry: map.entrySet()){\\n\\t\\t\\t\\tif(entry.getValue()>1){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\nRuntime: 46 ms\\nMemory Usage: 76.5 MB",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic boolean containsDuplicate(int[] nums) {\\n    \\n\\tHashSet<Integer> set = new HashSet<Integer>();\\t\\n\\tfor(int i:nums){\\n          \\n\\t\\t  if(set.contains(i)){ return true; }",
                "codeTag": "Java"
            },
            {
                "id": 1346854,
                "title": "javascript",
                "content": "we can create object in javascript and in JS object key will always be unique in nature so we can story array element as key in object and check if key exists already means element is duplicated.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    \\n    for(let i=0;i<nums.length;i++){\\n        if(hashMap[nums[i]]){\\n            return true;\\n        }else{\\n            hashMap[nums[i]]=true\\n        }\\n    }\\n    return false\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    \\n    for(let i=0;i<nums.length;i++){\\n        if(hashMap[nums[i]]){\\n            return true;\\n        }else{\\n            hashMap[nums[i]]=true\\n        }\\n    }\\n    return false\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794517,
                "title": "c-simplest-one-liner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return (std::set<int>(nums.begin(), nums.end())).size() != nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return (std::set<int>(nums.begin(), nums.end())).size() != nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980397,
                "title": "java-solved-using-multiple-6-approaches-brute-force-to-optimal-explained",
                "content": "\\tpublic class ContainsDuplicates {\\n\\n \\n\\n    /*approach 1: sort and see if two adjacent elements are equal\\n    * TC: O(nlogn) SC: O(1)\\n    * */\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){// run loop till nums.length-1 otherwise\\n                                        // you will get Indexoutofbound while doing nums[i]==nums[i+1] for last index\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 2: add elements to the set. if set already contains element then duplicate exists\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach2(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 3: add elements to the map. if map frequency is greater then 1 return true\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach3(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                return true;\\n            } else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 4: using XOR property A^A=0 and 0^A=A\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateApproach4(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]^nums[j])==0){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 5: brute force\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateBruteForce(int[] nums) {\\n        for (int i = 0; i + 1 < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\t/* using java stream api */\\n\\tpublic boolean containsDuplicateStreamApi(int[] nums) {\\n        return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "\\tpublic class ContainsDuplicates {\\n\\n \\n\\n    /*approach 1: sort and see if two adjacent elements are equal\\n    * TC: O(nlogn) SC: O(1)\\n    * */\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){// run loop till nums.length-1 otherwise\\n                                        // you will get Indexoutofbound while doing nums[i]==nums[i+1] for last index\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 2: add elements to the set. if set already contains element then duplicate exists\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach2(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 3: add elements to the map. if map frequency is greater then 1 return true\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach3(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                return true;\\n            } else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 4: using XOR property A^A=0 and 0^A=A\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateApproach4(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]^nums[j])==0){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 5: brute force\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateBruteForce(int[] nums) {\\n        for (int i = 0; i + 1 < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\t/* using java stream api */\\n\\tpublic boolean containsDuplicateStreamApi(int[] nums) {\\n        return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 61106,
                "title": "32-lines-in-c-by-hashtable-only-12ms",
                "content": "    typedef struct hashlist {\\n         int val;\\n         struct hashlist *next;\\n    }list;\\n    \\n    int containsDuplicate(int* nums, int numsSize) {\\n    \\tint i;\\n    \\tint mask = numsSize - 1;\\n    \\tlist *tmp[numsSize];\\n    \\tmemset(tmp, 0, sizeof(list*)*numsSize);\\n    \\tif(numsSize == 0 || numsSize == 1) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tfor(i=0; i < numsSize; i++) {\\n    \\t\\tint idx;\\n    \\t\\tlist *p;\\n    \\t\\tlist *node = malloc(sizeof(list));\\n    \\t\\tnode->val = *nums;\\n    \\t\\tidx = abs(*nums) % mask;\\t\\n    \\t\\tp = tmp[idx];\\n    \\t\\tnode->next = p;\\n    \\t\\ttmp[idx] = node;\\n    \\t\\twhile(p) {\\n    \\t\\t\\tif (p->val == node->val) {\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t\\tp = p->next;\\n    \\t\\t}\\n    \\t\\tnums++;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [],
                "code": "    typedef struct hashlist {\\n         int val;\\n         struct hashlist *next;\\n    }list;\\n    \\n    int containsDuplicate(int* nums, int numsSize) {\\n    \\tint i;\\n    \\tint mask = numsSize - 1;\\n    \\tlist *tmp[numsSize];\\n    \\tmemset(tmp, 0, sizeof(list*)*numsSize);\\n    \\tif(numsSize == 0 || numsSize == 1) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tfor(i=0; i < numsSize; i++) {\\n    \\t\\tint idx;\\n    \\t\\tlist *p;\\n    \\t\\tlist *node = malloc(sizeof(list));\\n    \\t\\tnode->val = *nums;\\n    \\t\\tidx = abs(*nums) % mask;\\t\\n    \\t\\tp = tmp[idx];\\n    \\t\\tnode->next = p;\\n    \\t\\ttmp[idx] = node;\\n    \\t\\twhile(p) {\\n    \\t\\t\\tif (p->val == node->val) {\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t\\tp = p->next;\\n    \\t\\t}\\n    \\t\\tnums++;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2546139,
                "title": "3-different-python-solutions",
                "content": "\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        res = {}\\n        for i in nums:\\n            if i not in res:\\n                res[i] = 1\\n            else:\\n                return True\\n        return False\\n```\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return set(collections.Counter(nums).values()) != set([1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        res = {}\\n        for i in nums:\\n            if i not in res:\\n                res[i] = 1\\n            else:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return set(collections.Counter(nums).values()) != set([1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188618,
                "title": "3-lines-of-code-with-explanation-simple-and-easy",
                "content": "# Easy and Simple code in just 3 line\\n**217. Contains Duplicate Solution:**\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        LinkedHashSet<Integer> set = new LinkedHashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) set.add(nums[i]);\\n        return set.size() != nums.length;\\n    }\\n}\\n```\\n**Explanation:**\\nUse LinkedHashSet to remove the duplicates \\nthen compare hashset size with array size.\\nreturn result...\\n\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        LinkedHashSet<Integer> set = new LinkedHashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) set.add(nums[i]);\\n        return set.size() != nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934190,
                "title": "python-3-approachs-easy-explanation-faster-than-97",
                "content": "# Please upvote if it helps\\n**1st approach**\\n- As we know, set in python store only unique value and removes duplicate\\n- So just return not( len(nums)==len(set(nums))\\n\\t- not ( length of nums == length of unique value)\\n\\t- not ( False )\\n\\t- will return True\\n\\t- else not (True)\\n\\t- will return False\\n\\tCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return not(len(nums)==len(set(nums)))\\n```\\n\\n**2nd Approach:**\\n- Declair a HashMap/Dictionary\\n- Check all the elements if it\\'s exist in hashmap or not.\\n\\t- If it exisits return True\\n\\t- If it doesn\\'t then, just set dic[element]= 1/any_value\\nNote: It\\'s the most efficient way.\\nCode: \\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        dic = {}\\n        \\n        for n in nums:\\n            if n in dic:\\n                return True\\n            else:\\n                dic[n]=1\\n```\\n**3rd Approach**\\n- Similiar to second approach just use set instead of dictionary\\nCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        stack = set()\\n        for n in nums:\\n            if n in stack:\\n                return True\\n            else:\\n                stack.add(n)\\n            \\n        return False\\n```\\n\\n**4th approach**\\n- Sort the nums list\\n- Loop through the list return True if the nums[i]==nums[i+1] else False\\n\\nCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n\\n        for i in range(len(nums) - 1):\\n            if nums[i] - nums[i+1] == 0:\\n                return True\\n        \\n        return False\\n```\\n\\n## Leave a comment if you have any question.\\n\\n![image](https://assets.leetcode.com/users/images/f0b1e99d-9004-4d92-95d8-18dd55d86627_1649619264.0194342.png)\\n",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return not(len(nums)==len(set(nums)))\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        dic = {}\\n        \\n        for n in nums:\\n            if n in dic:\\n                return True\\n            else:\\n                dic[n]=1\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        stack = set()\\n        for n in nums:\\n            if n in stack:\\n                return True\\n            else:\\n                stack.add(n)\\n            \\n        return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n\\n        for i in range(len(nums) - 1):\\n            if nums[i] - nums[i+1] == 0:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 315147,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        return Set(nums).count != nums.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        return Set(nums).count != nums.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257460,
                "title": "easiest-maths-problem-ever-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        x=set(nums)\\n        return not len(nums)==len(x)\\n        #please do upvote if found helpful.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        x=set(nums)\\n        return not len(nums)==len(x)\\n        #please do upvote if found helpful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007472,
                "title": "c-easy-approach-with-explanation-2-line-code",
                "content": "# Approach:\\n*  Creating a set\\n*  Insert all the values of the nums vector to set\\n*  Why using set? Because - >Set contains only unique values\\n*  If any value appears at least twice in the array then it will not store the value twice\\n*  Compare both the sizes of array and set\\n*  If both sizes are equal that means every element occurs once so return true\\n*  Otherwise return false.\\n\\n```\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n\\t{\\n        set<int> s;\\n\\t\\t\\n        s.insert(nums.begin(),nums.end()); \\n\\t\\t\\n        bool ans = nums.size()!=s.size();  \\n\\t\\t\\n        return ans;\\n        \\n    }\\n};\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n\\t{\\n        set<int> s;\\n\\t\\t\\n        s.insert(nums.begin(),nums.end()); \\n\\t\\t\\n        bool ans = nums.size()!=s.size();  \\n\\t\\t\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1678724,
                "title": "python-one-line-code",
                "content": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1496268,
                "title": "python-98-speed-faster",
                "content": "```python\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975497,
                "title": "xor-based-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nps: I know it can be solved with hashset in better time complexity but here I wanted to solve it with a different, xor approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nas we know when two equal numbers are xor\\'ed the output is zero,hence we will first sort array, if a duplicate element exist they would be adjacent,hence xor them and if output comes out as 0 return true. note that without sorting this won\\'t work as you would think of doing xor of all elements and checking for zero value along the way, but keep in mind that a similar number can be generated by xor which is already present in array giving us pseudo ans.\\n\\nfor ex-[1,2,3,4]\\nx=1^2=3\\nx=3^3=0\\nbut there is no duplicate that\\'s why it won\\'t work\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if((nums[i]^nums[i+1])==0){\\n                return true;\\n            }\\n        }\\n      return false;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if((nums[i]^nums[i+1])==0){\\n                return true;\\n            }\\n        }\\n      return false;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593840,
                "title": "simple-python3-solution-one-liner-easiest-using-set",
                "content": "***UPVOTE*** if it is helpful\\n``` \\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums)==len(list(set(nums))) else True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums)==len(list(set(nums))) else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196197,
                "title": "python-one-liner",
                "content": "**Using dictionary**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] = seen.get(nums[i], 0) + 1\\n        \\n        for k, v in seen.items():\\n            if v > 1:\\n                return True\\n        return False\\n```\\n\\n**One-liner**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return not len(nums) == len(set(nums))\\n```\\n\\n**Efficient** [Updated] \\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        temp = set()\\n        count = 0\\n        for num in nums:\\n            temp.add(num)\\n            count += 1\\n            if len(temp) != count:\\n                return True\\n        return False\\n```\\nPlease upvote if you find it helpful. Thank You",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] = seen.get(nums[i], 0) + 1\\n        \\n        for k, v in seen.items():\\n            if v > 1:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return not len(nums) == len(set(nums))\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        temp = set()\\n        count = 0\\n        for num in nums:\\n            temp.add(num)\\n            count += 1\\n            if len(temp) != count:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159583,
                "title": "c-solution-all-possible-approaches-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n       // Brute Force Method   -> O(n^2)\\n        int n =nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n            for(int j=i+1;j<n;j++)\\n            {\\n               if(nums[i]==nums[j])return true\\n            }\\n        }\\n        return false;\\n        \\n        //Using Sort Function    -> O(nlogn)\\n       \\n      sort(nums.begin() , nums.end())\\n      for(int i=0;i<n;i++)\\n       if(nums[i]==nums[i+1])return true;\\n         return false;\\n        \\n        //Using Map      -> O(n)\\n     unordered_map<int,int> m;\\n     for(auto a: nums) m[a]++;\\n        for(auto a: m)\\n            if(a.second>1)return 1;\\n        return 0;\\n        \\n        //Using Sets     -> O(n)\\n        unordered_set<int> s;\\n        for(auto a:nums)s.insert(a);\\n        if(nums.size()==s.size())return false;\\n        return true;\\n       \\n        \\n        \\n    }\\n};\\n```\\nIf you really like this or it is helpfulto you, please UpVote",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n       // Brute Force Method   -> O(n^2)\\n        int n =nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n            for(int j=i+1;j<n;j++)\\n            {\\n               if(nums[i]==nums[j])return true\\n            }\\n        }\\n        return false;\\n        \\n        //Using Sort Function    -> O(nlogn)\\n       \\n      sort(nums.begin() , nums.end())\\n      for(int i=0;i<n;i++)\\n       if(nums[i]==nums[i+1])return true;\\n         return false;\\n        \\n        //Using Map      -> O(n)\\n     unordered_map<int,int> m;\\n     for(auto a: nums) m[a]++;\\n        for(auto a: m)\\n            if(a.second>1)return 1;\\n        return 0;\\n        \\n        //Using Sets     -> O(n)\\n        unordered_set<int> s;\\n        for(auto a:nums)s.insert(a);\\n        if(nums.size()==s.size())return false;\\n        return true;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779939,
                "title": "simple-2-lines-of-c-hash-set-comments-for-beginners",
                "content": "```\\n bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n     // property of set is only unique elements are allowed\\n\\t // it will add only unique elements\\n\\t // so, its size will always be less, if duplicates are there\\n\\t // and equal size means no duplicates\\n        return (s.size() != nums.size());\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n     // property of set is only unique elements are allowed\\n\\t // it will add only unique elements\\n\\t // so, its size will always be less, if duplicates are there\\n\\t // and equal size means no duplicates\\n        return (s.size() != nums.size());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1538157,
                "title": "c-3-solutions-easy-to-understand",
                "content": "Contains Duplicate - \\n\\n**1) One Line -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n     {\\n        return nums.size()!=set(nums.begin(),nums.end()).size();\\n     }  \\n};\\n```\\n\\n**2) Five Lines -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n      sort(nums.begin(),nums.end());\\n      for(int i=1;i<nums.size();i++)\\n        {\\n          if(nums[i-1]==nums[i])\\n          return true;\\n        }\\n     return false;   \\n    } \\n};\\n```\\n\\n**3) Using Counter -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n       int n=nums.size();\\n       sort(nums.begin(),nums.end());\\n       int cnt=1;\\n       for(int i=0;i<n-1;i++)\\n        {\\n          if(nums[i]==nums[i+1])\\n            {\\n              cnt++;\\n            }\\n        }\\n         if(cnt>1)\\n           {\\n             return true;\\n           }\\n        else\\n          {\\n            return false;  \\n          }\\n    } \\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n     {\\n        return nums.size()!=set(nums.begin(),nums.end()).size();\\n     }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n      sort(nums.begin(),nums.end());\\n      for(int i=1;i<nums.size();i++)\\n        {\\n          if(nums[i-1]==nums[i])\\n          return true;\\n        }\\n     return false;   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n       int n=nums.size();\\n       sort(nums.begin(),nums.end());\\n       int cnt=1;\\n       for(int i=0;i<n-1;i++)\\n        {\\n          if(nums[i]==nums[i+1])\\n            {\\n              cnt++;\\n            }\\n        }\\n         if(cnt>1)\\n           {\\n             return true;\\n           }\\n        else\\n          {\\n            return false;  \\n          }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726562,
                "title": "rust-solutions",
                "content": "### 1. Set-len\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() > nums.iter().collect::<HashSet<_>>().len()\\n    }\\n}\\n```\\n\\n### 2. Linear Scan\\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let len = nums.len();\\n        for i in 0..len {\\n            for j in (i + 1)..len {\\n                if nums[i] == nums[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n### 3. Set-contains\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut set = HashSet::new();\\n        for n in nums {\\n            if set.contains(&n) {\\n                return true;\\n            } else {\\n                set.insert(n);\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n### 4. Sort\\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if nums[i - 1] == nums[i] {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() > nums.iter().collect::<HashSet<_>>().len()\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let len = nums.len();\\n        for i in 0..len {\\n            for j in (i + 1)..len {\\n                if nums[i] == nums[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut set = HashSet::new();\\n        for n in nums {\\n            if set.contains(&n) {\\n                return true;\\n            } else {\\n                set.insert(n);\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if nums[i - 1] == nums[i] {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258771,
                "title": "python-beats-100-o-n",
                "content": "Using the set function of python.\\n```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        numSet = list(set(nums))\\n        return not (len(numSet) == len(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        numSet = list(set(nums))\\n        return not (len(numSet) == len(nums))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 200829,
                "title": "simple-java-solution",
                "content": "set.add(val) in java returns true if the val is not already present in the set and it returns false otherwise.\\n```class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) {\\n            if(!set.add(val))\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) {\\n            if(!set.add(val))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61142,
                "title": "one-line-52ms-python-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def containsDuplicate(self, nums):\\n            return len(set(nums)) != len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3500516,
                "title": "solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225442,
                "title": "217-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem using a hash set. We can iterate over the array and add each element to the hash set. If we encounter an element that is already in the hash set, we can return True, since it means that we have found a duplicate. If we finish iterating over the entire array and have not found a duplicate, we can return False.\\n\\nAlgorithm:\\n\\n1. Create an empty hash set.\\n2. Iterate over the array.\\n3. If an element is already in the hash set, return True.\\n4. Otherwise, add the element to the hash set.\\n5. If we finish iterating over the array and have not found a duplicate, return False.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - We iterate over the array once.\\n\\n- Space complexity:\\n O(n) - We use a hash set to store the elements.\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        # Create an empty hash set\\n        seen = set()\\n        # Iterate over the array\\n        for num in nums:\\n            # If an element is already in the hash set, return True\\n            if num in seen:\\n                return True\\n            # Otherwise, add the element to the hash set\\n            seen.add(num)\\n        # If we finish iterating over the array and have not found a duplicate, return False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        # Create an empty hash set\\n        seen = set()\\n        # Iterate over the array\\n        for num in nums:\\n            # If an element is already in the hash set, return True\\n            if num in seen:\\n                return True\\n            # Otherwise, add the element to the hash set\\n            seen.add(num)\\n        # If we finish iterating over the array and have not found a duplicate, return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109031,
                "title": "without-using-hashing-in-java-onlycode",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632114,
                "title": "python-set-no-loop-solution",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        unique = set(nums)\\n        if len(unique) < len(nums):\\n            return True\\n        return False\\n```\\n\\t\\t\\nAbove solution converts the input array into a set inorder to remove the duplicates. Then, the length of set is compared to length of input array. If the array contained duplicates, then the length of set will be less than input array(return true).",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        unique = set(nums)\\n        if len(unique) < len(nums):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583026,
                "title": "c-easiest-solution-100-best-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==nums[i-1]){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\t\\n**Upvote if you liked the solution\\uD83D\\uDE42**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==nums[i-1]){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2403618,
                "title": "rust-one-liner",
                "content": "```rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() != HashSet::<i32>::from_iter(nums).len()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() != HashSet::<i32>::from_iter(nums).len()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141805,
                "title": "c-java-c-c-javascript-python-possible-solutions-easy-to-understand",
                "content": "To solve this problem, we can use a HashSet in C#. This data structure allows us to efficiently identify whether an element has been previously encountered in the array by using the Add or Contains methods. By adding each element to the HashSet as we iterate through the array, we can quickly determine if a duplicate element is encountered. This approach is simple and effective, making it a useful solution for this problem.\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n         return nums.size() > set<int>(nums.begin(), nums.end()).size(); \\n    }\\n};\\n```\\n```Java []\\n// 1. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> Secondary = new HashSet<Integer>();\\n\\t\\t for(int i : nums)\\n\\t\\t\\t if(!Secondary.add(i))\\n\\t\\t\\t\\t return true; \\n\\t\\t return false;\\n    }\\n}\\n// 2. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n```\\n```csharp []\\n// 1. \\n//Count all the unique elements in the array and checks its equality with the size of the array. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t if (secondary.Add(nums[i]))\\n\\t\\t\\t\\tcounter++;                                       \\n        }\\n        if(counter == nums.Length)\\n\\t\\t\\treturn false;\\n        return true;\\n    }\\n}\\n// 2. \\n// A more optimized solution is to end the loop as soon as the element is repeated. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> distinct = new HashSet<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (distinct.Contains(nums[i]))\\n                return true;\\n            distinct.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n// 3. \\n// Another solution approach can by using sorted array. Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n\\t\\tArray.Sort(nums);\\n        HashSet<int> secondary = new HashSet<int>();\\n            for (int i = 0; i < nums.Length; i++)\\n                if (!secondary.Add(nums[i]))                  \\n                    return true;            \\n        return false;  \\n    }\\n}\\n```\\n-------\\n```C []\\nstatic int _cmp(const int *l, const int *r) { \\n    return (*l - *r); \\n}\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    return false;\\n}\\n```\\n```javascript []\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    for(let i=0;i<nums.length;i++) {\\n        if(hashMap[nums[i]])\\n            return true;\\n        else\\n            hashMap[nums[i]]=true;\\n    }\\n    return false\\n};\\n```\\n```Python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        return len(nums) > len(set(nums))\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n         return nums.size() > set<int>(nums.begin(), nums.end()).size(); \\n    }\\n};\\n```\n```Java []\\n// 1. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> Secondary = new HashSet<Integer>();\\n\\t\\t for(int i : nums)\\n\\t\\t\\t if(!Secondary.add(i))\\n\\t\\t\\t\\t return true; \\n\\t\\t return false;\\n    }\\n}\\n// 2. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n```\n```csharp []\\n// 1. \\n//Count all the unique elements in the array and checks its equality with the size of the array. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t if (secondary.Add(nums[i]))\\n\\t\\t\\t\\tcounter++;                                       \\n        }\\n        if(counter == nums.Length)\\n\\t\\t\\treturn false;\\n        return true;\\n    }\\n}\\n// 2. \\n// A more optimized solution is to end the loop as soon as the element is repeated. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> distinct = new HashSet<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (distinct.Contains(nums[i]))\\n                return true;\\n            distinct.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n// 3. \\n// Another solution approach can by using sorted array. Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n\\t\\tArray.Sort(nums);\\n        HashSet<int> secondary = new HashSet<int>();\\n            for (int i = 0; i < nums.Length; i++)\\n                if (!secondary.Add(nums[i]))                  \\n                    return true;            \\n        return false;  \\n    }\\n}\\n```\n```C []\\nstatic int _cmp(const int *l, const int *r) { \\n    return (*l - *r); \\n}\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    return false;\\n}\\n```\n```javascript []\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    for(let i=0;i<nums.length;i++) {\\n        if(hashMap[nums[i]])\\n            return true;\\n        else\\n            hashMap[nums[i]]=true;\\n    }\\n    return false\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        return len(nums) > len(set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628394,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         return(len(set(nums))!=len(nums))\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         return(len(set(nums))!=len(nums))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457561,
                "title": "python-one-line-solution-easy",
                "content": "```\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\nIt utilizes sets and if the length of set of array and length of original array is not equal, we can say that our array contains duplicate.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343102,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n    \\treturn len(set(nums)) != len(nums)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n    \\treturn len(set(nums)) != len(nums)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 61111,
                "title": "python-set-36ms-o-n",
                "content": "    class Solution(object):\\n        def containsDuplicate(self, nums):\\n            s = set()\\n            for num in nums:\\n                if num in s: return True\\n                else: s.add(num)\\n            return False",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "    class Solution(object):\\n        def containsDuplicate(self, nums):\\n            s = set()\\n            for num in nums:\\n                if num in s: return True\\n                else: s.add(num)\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3380086,
                "title": "4-line-solution-javascript-easy-explanation-99-71-beats",
                "content": "# What is **Set()** in Javascript\\nIn JavaScript, Set is a built-in object that allows you to store unique values of any type. A Set can be created by using the new keyword with the Set() constructor, and it can be initialized with an iterable object such as an array. When elements are added to a Set, it automatically removes any duplicates. Set objects have methods to add, remove, check for the existence of, and iterate over their elements.\\n\\n\\n# Explanation \\nThe containsDuplicate function takes an array of numbers called nums as its input.\\n\\nIt creates a new Set object called set that contains the same elements as the nums array.\\n\\nThe Set object automatically removes any duplicate values that are added to it. So, if the size of the set is equal to the length of the nums array, it means that all of the elements in the nums array are unique.\\n\\nIf the size of the set is not equal to the length of the nums array, it means that there is at least one duplicate element in the nums array.\\n\\nThe containsDuplicate function returns true if there are duplicates in the nums array, and false otherwise.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array\\n\\n- Space complexity:\\nO(n), where n is the length of the input array, due to the creation of a Set object to store the unique elements\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n  const set = new Set(nums)\\n  if(set.size == nums.length){\\n      return false\\n  }  \\n  return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n  const set = new Set(nums)\\n  if(set.size == nums.length){\\n      return false\\n  }  \\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347093,
                "title": "contains-duplicate-made-simple",
                "content": "# Intuition\\nThe input we have will contain a set of numbers , possibly dublicates of existing numbers or perhabs all unique numbers , if we get the unique numbers and store them somewhere , we can then easily check if the number of unique elements we have is smaller than the actual length of the array.\\nSo , how do we get only a single occurance for each element ?\\n\\n# Approach\\nWe can use a hashset , which will store the distinct elements from the nums array in it , after doing so , we can check the number of elements we have inside our hashset , if it\\'s smaller than the length of the array , then that implies the set left out some duplicates out there , and that results in the array containing duplicate values.\\n\\nIf the count of elements in the set is equal to the array length then the array doesn\\'t contain any duplicates, which solves our problem !\\n\\n# Complexity\\n- Time complexity: O(n) \\nWhere n is the length of the input array nums , becuase the hashset constructor takes takes O(n) time to add the elements from the input array to the hashset.\\nThe Count property and the comparisions performed take constant time O(1) , so that doesn\\'t affect the overall time complexity.\\n\\n\\n\\n- Space complexity: O(n)\\nWhere n is the length of the input array nums , that\\'s because a hashset of size n is created to accomodate the unique elements from the received array.\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        \\n        var uniqueNums = new HashSet<int>(nums);\\n\\n        if(uniqueNums.Count < nums.Length)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        \\n        var uniqueNums = new HashSet<int>(nums);\\n\\n        if(uniqueNums.Count < nums.Length)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965652,
                "title": "there-is-no-shorter-1-line-of-code-and-simpler-for-beginners-solution-like-this-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size !== nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727168,
                "title": "o-n-c-solution-easy-to-understand-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (++umap[nums[i]] == 2) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (++umap[nums[i]] == 2) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478270,
                "title": "easy-javascript-solution-faster-than-99-88",
                "content": "var containsDuplicate = function(nums){\\n    if(nums.length == 1)\\n        return false\\n    let set = new Set(nums)\\n    if(nums.length > set.size)\\n        return true\\n    return false    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var containsDuplicate = function(nums){\\n    if(nums.length == 1)\\n        return false\\n    let set = new Set(nums)\\n    if(nums.length > set.size)\\n        return true\\n    return false    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2376162,
                "title": "c-92-faster",
                "content": "```\\npublic bool ContainsDuplicate(int[] nums) {\\n\\tif (nums.Distinct().Count() == nums.Length)\\n\\t\\treturn false;\\n\\treturn true; \\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic bool ContainsDuplicate(int[] nums) {\\n\\tif (nums.Distinct().Count() == nums.Length)\\n\\t\\treturn false;\\n\\treturn true; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019031,
                "title": "two-line-c-solution-most-optimal-two-approaches",
                "content": "**Approach 1:**  Using sorting. Time: O(nlogn)    Space: O(1)\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n**Approach 2:** Using hash set . This takes less time than the above code but takes more memory. \\n**Idea:** If we make a set form array then the size will not be same if the array contains atleast one repeating element.\\nTime: O(n)    Space : O(n)\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> hsh(nums.begin(), nums.end());\\n        return !(nums.size() == hsh.size());\\n    }\\n```\\n\\n*Please upvote if you liked the solutions*",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nbool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> hsh(nums.begin(), nums.end());\\n        return !(nums.size() == hsh.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703567,
                "title": "2-line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        return !(s.size()==nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        return !(s.size()==nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591505,
                "title": "simple-one-line-solution-using-linq-c",
                "content": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.GroupBy(x=>x).Any(x=>x.Count() > 1);\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.GroupBy(x=>x).Any(x=>x.Count() > 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1541530,
                "title": "3-different-c-solutions-using-stl-with-time-and-space-complexities",
                "content": "* Approach 1 : First sort the vector and then check if any two adjacent elements are equal.\\nTime Complexity :- O(nlogn)\\nSpace Complexity :- O(1)\\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); i++)\\n            if (nums[i] == nums[i - 1]) return true;\\n        return false;\\n```\\n* STL version\\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        return adjacent_find(nums.begin(), nums.end()) != nums.end();\\n```\\n* Approach 2 : Convert the vector into hashset and check if the size is reduced.\\nTime Complexity :- O(n) for all cases\\nSpace Complexity :- O(n) for all cases\\n```\\n\\t\\tunordered_set<int> st(nums.begin(), nums.end());\\n        return nums.size() > st.size();\\n```\\n* One-liner\\n```\\n\\t\\treturn nums.size() > unordered_set(nums.begin(), nums.end()).size();\\n```\\n* Approach 3 : While inserting, check if we have encountered this number before\\nTime Complexity :- O(n) worst case [ ignoring unordered_set worst case i.e. assuming constant time insertions ]\\nSpace Complexity :- O(n) worst case\\n```\\n\\t\\tunordered_set<int> st;\\n        for (const int& i : nums) {\\n            if (st.count(i)) return true;\\n            st.insert(i);\\n        }\\n        return false;\\n```\\n* STL version\\n```\\n\\t\\tunordered_set<int> st;\\n        return any_of(nums.begin(), nums.end(), [&](const auto& num) { return !st.insert(num).second; });\\n```\\n\\nIf you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\tsort(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); i++)\\n            if (nums[i] == nums[i - 1]) return true;\\n        return false;\\n```\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        return adjacent_find(nums.begin(), nums.end()) != nums.end();\\n```\n```\\n\\t\\tunordered_set<int> st(nums.begin(), nums.end());\\n        return nums.size() > st.size();\\n```\n```\\n\\t\\treturn nums.size() > unordered_set(nums.begin(), nums.end()).size();\\n```\n```\\n\\t\\tunordered_set<int> st;\\n        for (const int& i : nums) {\\n            if (st.count(i)) return true;\\n            st.insert(i);\\n        }\\n        return false;\\n```\n```\\n\\t\\tunordered_set<int> st;\\n        return any_of(nums.begin(), nums.end(), [&](const auto& num) { return !st.insert(num).second; });\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128103,
                "title": "simple-python-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806966,
                "title": "easy-python-set-algorithm",
                "content": "**Easy Python | Set Algorithm**\\n\\nEasy Python solution iterating through every element in the input array \"A\"; checking in O(1) time if we had already seen each value \"x\" before. We return \"True\" the first time we detect a duplicate. If the loop ends without finding duplicates, we return \"False\".\\n\\nTime/Space Complexity: O(N)\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, A):\\n        D = set()\\n        for x in A:\\n            if x in D:\\n                return True\\n            D.add(x)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, A):\\n        D = set()\\n        for x in A:\\n            if x in D:\\n                return True\\n            D.add(x)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538862,
                "title": "go",
                "content": "```\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, v := range nums {\\n        if _, ok := set[v]; ok {\\n            return true\\n        } else {\\n            set[v] = struct{}{}\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, v := range nums {\\n        if _, ok := set[v]; ok {\\n            return true\\n        } else {\\n            set[v] = struct{}{}\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60901,
                "title": "12ms-c-solution-with-hashtable",
                "content": "```\\n#define PRIME 941\\nstruct Data{\\n\\tint val;\\n\\tint empty;\\n\\tstruct Data *link;\\n}Hashtable[PRIME];\\n\\n\\nint containsDuplicate(int* nums, int numsSize) {\\n    int i;\\n    for(i=0;i<PRIME;i++)           //initialize hashtable\\n    {\\n    \\tHashtable[i].empty = 1;\\n    \\tHashtable[i].link = NULL;\\n    }\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(Hashtable[hash(nums[i])].empty == 1)\\n        {\\n\\t\\tHashtable[hash(nums[i])].val = nums[i];\\n\\t\\tHashtable[hash(nums[i])].empty = 0;\\n        }\\n        else if(Hashtable[hash(nums[i])].empty == 0)\\n        {\\n\\t\\tif(Hashtable[hash(nums[i])].val == nums[i])\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tstruct Data *prev = &Hashtable[hash(nums[i])],*current;\\n\\t\\twhile(prev->link != NULL)\\n\\t\\t{\\n\\t\\t\\tprev = prev->link;\\n\\t\\t\\tif(prev->val == nums[i])\\n\\t\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tcurrent = (struct Data*)malloc(sizeof(struct Data));\\n\\t\\tcurrent->link = NULL;\\n\\t\\tcurrent->val = nums[i];\\n\\t\\tprev->link = current;\\n        }\\n    }\\n    return 0;\\n}\\n\\nint hash(int number)    //get hash value\\n{\\n\\treturn abs(number%PRIME);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define PRIME 941\\nstruct Data{\\n\\tint val;\\n\\tint empty;\\n\\tstruct Data *link;\\n}Hashtable[PRIME];\\n\\n\\nint containsDuplicate(int* nums, int numsSize) {\\n    int i;\\n    for(i=0;i<PRIME;i++)           //initialize hashtable\\n    {\\n    \\tHashtable[i].empty = 1;\\n    \\tHashtable[i].link = NULL;\\n    }\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(Hashtable[hash(nums[i])].empty == 1)\\n        {\\n\\t\\tHashtable[hash(nums[i])].val = nums[i];\\n\\t\\tHashtable[hash(nums[i])].empty = 0;\\n        }\\n        else if(Hashtable[hash(nums[i])].empty == 0)\\n        {\\n\\t\\tif(Hashtable[hash(nums[i])].val == nums[i])\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tstruct Data *prev = &Hashtable[hash(nums[i])],*current;\\n\\t\\twhile(prev->link != NULL)\\n\\t\\t{\\n\\t\\t\\tprev = prev->link;\\n\\t\\t\\tif(prev->val == nums[i])\\n\\t\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tcurrent = (struct Data*)malloc(sizeof(struct Data));\\n\\t\\tcurrent->link = NULL;\\n\\t\\tcurrent->val = nums[i];\\n\\t\\tprev->link = current;\\n        }\\n    }\\n    return 0;\\n}\\n\\nint hash(int number)    //get hash value\\n{\\n\\treturn abs(number%PRIME);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61003,
                "title": "c-one-liner",
                "content": "    public bool ContainsDuplicate(int[] nums) {\\n        return new HashSet<int>(nums).Count != nums.Length;\\n    }",
                "solutionTags": [],
                "code": "    public bool ContainsDuplicate(int[] nums) {\\n        return new HashSet<int>(nums).Count != nums.Length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61013,
                "title": "20ms-c-use-bitmap",
                "content": "    #define BITSPERWORD 32  \\n    #define SHIFT 5  \\n    #define MASK 0x1F  \\n    #define N 10000000  \\n    int a[1 + N/BITSPERWORD]; \\n    void set_(int i) {        a[i>>SHIFT] |=  (1<<(i & MASK)); }  \\n    void clr(int i) {        a[i>>SHIFT] &= ~(1<<(i & MASK)); }  \\n    int  test(int i){ return a[i>>SHIFT] &   (1<<(i & MASK)); }  \\n      \\n     \\n    class Solution {\\n        \\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if(nums.size()==0)return false;\\n            int i;  \\n        for (i = 0; i < nums.size(); i++)  \\n            clr(nums[i]);    \\n        for (i = 0; i < nums.size(); i++)  \\n        {\\n            if(test(nums[i]))return true;\\n            else set_(nums[i]);  \\n        }\\n       return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if(nums.size()==0)return false;\\n            int i;  \\n        for (i = 0; i < nums.size(); i++)  \\n            clr(nums[i]);    \\n        for (i = 0; i < nums.size(); i++)  \\n        {\\n            if(test(nums[i]))return true;\\n            else set_(nums[i]);  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3038832,
                "title": "easy-4-line-approach-please-upvote-if-you-like-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        set<int> s;\\n        for(auto i:nums)\\n            s.insert(i);\\n\\n        if(s.size()!=nums.size()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        set<int> s;\\n        for(auto i:nums)\\n            s.insert(i);\\n\\n        if(s.size()!=nums.size()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802251,
                "title": "simple-solution-using-set",
                "content": "# Intuition\\nUsing set and it contains only unique elements \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       set <int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()<nums.size())\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       set <int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()<nums.size())\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702984,
                "title": "two-line-solution-clean-code",
                "content": "```\\nvar containsDuplicate = function(nums) {\\n    var unique = new Set(nums);\\n    return unique.size !== nums.length\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    var unique = new Set(nums);\\n    return unique.size !== nums.length\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2688614,
                "title": "python3-java-2-approach-easy-to-understand-well-explained",
                "content": "# Contains Duplicate\\n\\n#### Intusion: If all the elements are unique the length of set of element will be equal to the the length of the array. If they are not equal it means it contains duplicate.\\n\\n**Python3**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n        \\n```\\n**Java**\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        // set.addAll(nums);\\n        return !(set.size() == nums.length);\\n    }\\n}\\n```\\n**S.C of O(N) for the set**\\n**T.C of O(1) for the length comparision + O(N) for set Creation, which is equal to O(N)**\\n****\\n\\n### Another way to solve this proble could be to sort the array and see if the adjacent elements are equal\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n-1):\\n            if (nums[i]==nums[i+1]):\\n                return True\\n        return False\\n```\\n\\n**S.C of O(1)**\\n**T.C of O(nlogn + n) for sort and linear traversal respectively. So overall time complexcity will be O(nlogn)**\\n",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n        \\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        // set.addAll(nums);\\n        return !(set.size() == nums.length);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n-1):\\n            if (nums[i]==nums[i+1]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674094,
                "title": "fast-solution-using-hashmap-with-logic-operation-with-explanation",
                "content": "\\t* class Solution {\\n\\t\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t\\t\\tHashMap size = new HashMap(); \\n\\t\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\t\\tsize.put(n,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn size.size() != nums.length;\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t\\t\\tHashMap size = new HashMap(); \\n\\t\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\t\\tsize.put(n,null);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2555381,
                "title": "why-you-should-not-use-set-when-searching-for-duplicates-in-an-array",
                "content": "# The Problem\\n**Contains Duplicate**: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\\n\\n## Solution using `set`\\n\\nYou might have seen the solution with `set ` touted as a one liner:\\n\\nIn Javascript:\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n  return nums.length > (new Set(nums)).size;\\n};\\n```\\n\\n### Issues with using `set` for finding duplicates\\n\\n**The best case and the worst case are the same**:\\n\\nConsider an array with one billion elements that goes as `[1, 1, 2, 3, ...]`. As soon as you see the second element you know the answer:  duplicaters exist in the array. But if you use the above solution with `set` all the one billion elements will be processed. So what could be `O(2)` ends up being `O(n)`. \\n But you might say `O(2)` is `O(n)`; constant factors are ignored. Yes, but within reasonable limits. \\n\\n> A few words of caution about asymptotic notation are in order at this point. First, note that the use of the big-Oh and related notations can be somewhat misleading should the constant factors they \\u201Chide\\u201D be very large. For example, while it is true that the function 10^100 n is O(n), if this is the running time of an algorithm being compared to one whose running time is 10n log n, we prefer the O(n log n) time algorithm, even though the linear-time algorithm is asymptotically faster. This preference is because the constant factor, 10^100 , which is called \\u201Cone googol,\\u201D is believed by many astronomers to be an upper bound on the number of atoms in the observable universe. So we are unlikely to ever have a real-world problem that has this number as its input size. Thus, even when using the big-Oh notation, we should at least be somewhat mindful of the constant factors and lower order terms we are \\u201Chiding.\\u201D\\n> > Data Structures and Algorithms in C++,  Goodrich, Tamassia, Mount \\n\\n**It does not engage with the intentions of the question:**\\n\\nThe question is asked to test your problem solving ability not your knowledge of the standard library or built in functions of a programming language. While it is okay to use libraries or built in functions for some steps in the algorithm not directly related to the question you can\\'t skip the problem entirely by using a library or built in function.\\n\\n> The primary reason for using C is that I want to teach you data structures and algorithms from the ground up. When we want a hash table, we\\u2019ll build it ourselves. There will be no reliance on dictionaries or hashmaps or similar data structures of other languages. When we don\\u2019t know the maximum length of a string, we\\u2019ll build an extensible array: we won\\u2019t let the language handle memory allocation for us. **I want you to know exactly what\\u2019s going on, with no tricks up my sleeve**. Using C helps me toward this goal.\\n>> Algorithmic Thinking: A Problem-Based Introduction, Daniel Zingaro\\n\\nWhile you don\\'t have to use C or build everything by yourself, I hope you appreciate the intentions of the author.\\n\\n**Less code is not better:**\\n\\nWe are here to build effecient algorithms not play [code golf](https://en.wikipedia.org/wiki/Code_golf). While code golf can be a great [recreational activity](https://codegolf.stackexchange.com/) in itself it does not figure in learning algorithms. Code  that is easy to read and understand is better than shorter code.\\n\\nYou can read more about [code readability on wikipedia](https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code).\\n\\n## Conclusion\\n\\nIt is easier to forget the interviewer when we grind on leetcode. Leetcode will gladly accept the solution with `set` but the interview might raise objects if their intention is to test you on hash tables or sorting. It\\'s not just about passing the test but engaging with the interviewer and understanding the intentions behind their questions. \\n\\nAlternate solution using a `map` in Javascript:\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n  const seen = new Map();\\n  \\n  for(const num of nums) {\\n  /*\\n\\t  best case scenario:\\n\\t  does not process the whole array,\\n\\t  exits as soons as a duplicate is found\\n  */\\n    if(seen.get(num) === true) {\\n      return true;\\n    } else {\\n      seen.set(num, true);\\n    }\\n  }\\n  \\n  return false;\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```javascript\\nvar containsDuplicate = function(nums) {\\n  return nums.length > (new Set(nums)).size;\\n};\\n```\n```javascript\\nvar containsDuplicate = function(nums) {\\n  const seen = new Map();\\n  \\n  for(const num of nums) {\\n  /*\\n\\t  best case scenario:\\n\\t  does not process the whole array,\\n\\t  exits as soons as a duplicate is found\\n  */\\n    if(seen.get(num) === true) {\\n      return true;\\n    } else {\\n      seen.set(num, true);\\n    }\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536972,
                "title": "python-3-sol-one-line",
                "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))<len(nums)",
                "solutionTags": [],
                "code": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))<len(nums)",
                "codeTag": "Java"
            },
            {
                "id": 2227993,
                "title": "python-easy",
                "content": "I remember Python has a set data structure)\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2031977,
                "title": "python-3-easy-solution",
                "content": "\\n\\n        if len(nums) == len(set(nums)):\\n            #example nums= [2,3,5,3]\\n            #len of nums is 4 and when you use set, set will take only once of the each element in array.\\n            #so with set(nums) will be [2,3,5] after that we will check if the length of the set and len(nums) are equal.\\n            return False\\n        else:\\n            return True",
                "solutionTags": [],
                "code": "\\n\\n        if len(nums) == len(set(nums)):\\n            #example nums= [2,3,5,3]\\n            #len of nums is 4 and when you use set, set will take only once of the each element in array.\\n            #so with set(nums) will be [2,3,5] after that we will check if the length of the set and len(nums) are equal.\\n            return False\\n        else:\\n            return True",
                "codeTag": "Unknown"
            },
            {
                "id": 1893521,
                "title": "3-methods-java-solution",
                "content": "Method 1: BRUTE FORCE \\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nMethod 2: SORTING\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n      Arrays.sort(nums);\\n\\t  for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nMethod 3: HASHSET\\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\\nDO UPVOTE!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n      Arrays.sort(nums);\\n\\t  for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657752,
                "title": "easiest-python3-solution",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(a)!=len(nums):\\n            return True\\n        else: \\n            return False\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(a)!=len(nums):\\n            return True\\n        else: \\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452827,
                "title": "python-contains-duplicate",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums) == len(set(nums)) else True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums) == len(set(nums)) else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059554,
                "title": "python-one-line-beats-98-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return  len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return  len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904845,
                "title": "kotlin-solution",
                "content": "Use a hashSet object, if the num already exists we already found a duplicated:\\n```\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n    val hashSet = HashSet<Int>()\\n    \\n    nums.forEach {\\n        if(!hashSet.add(it))\\n            return true\\n    }\\n    \\n    return false\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n    val hashSet = HashSet<Int>()\\n    \\n    nums.forEach {\\n        if(!hashSet.add(it))\\n            return true\\n    }\\n    \\n    return false\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619056,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(), nums.end());\\n        \\n        return (s.size() != nums.size());\\n        \\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(), nums.end());\\n        \\n        return (s.size() != nums.size());\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60912,
                "title": "golang-concise-solution-using-map",
                "content": "```\\nfunc containsDuplicate(nums []int) bool {\\n\\tappearance := make(map[int]bool)\\n\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := appearance[num]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tappearance[num] = true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc containsDuplicate(nums []int) bool {\\n\\tappearance := make(map[int]bool)\\n\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := appearance[num]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tappearance[num] = true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60984,
                "title": "simple-5-lines-7ms-java",
                "content": "Simple 5-liner using sort. You could implement your own sort and break when you find a duplicate making it faster.\\n\\n    public boolean containsDuplicate(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t    if (nums[i] == nums[i - 1])\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Simple 5-liner using sort. You could implement your own sort and break when you find a duplicate making it faster.\\n\\n    public boolean containsDuplicate(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t    if (nums[i] == nums[i - 1])\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61120,
                "title": "simple-java-solution-using-hashset-o-n",
                "content": "    public class Solution {\\n        public boolean containsDuplicate(int[] nums) {\\n            Set<Integer> set = new HashSet<>();\\n            for(int i : nums){ set.add(i); }\\n            return nums.length!=0 && set.size()!=nums.length;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean containsDuplicate(int[] nums) {\\n            Set<Integer> set = new HashSet<>();\\n            for(int i : nums){ set.add(i); }",
                "codeTag": "Java"
            },
            {
                "id": 4062087,
                "title": "video-clear-visualization-of-o-n-solution",
                "content": "https://www.youtube.com/watch?v=JTIq3m8F4hw\\n\\nThe brute force approach would be to simply check each element with every other element in the array, and return `True` if a duplicate is found or `False` otherwise.  Unfortunately, this runs in O(n<sup>2</sup>).\\n\\nWe can reduce this to O(n) by using a hash set, or simply a `set()` in Python. For each element in the array, we\\'ll check to see if it is already in the set.  If it isn\\'t, we\\'ll add it to the set and move on, and if it is, then that means it is a duplicate and we\\'ll return `True`.  If we get through the whole array without finding a duplicate, we\\'ll return `False`\\n\\nThis runs in O(n) time because hash set lookup runs in O(1) time.  Similar to a hash table, when you need to check for a key in the set, you don\\'t have to iterate over all elements in the set.  Instead, the corresponding hash is calculated, and you can jump straight to it.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736588,
                "title": "easy-and-elegant-solution-using-hashset",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\n\\nThe solution uses a HashSet data structure to check for duplicate elements in the given array.\\n\\n# Approach\\n1. Create an empty HashSet called \\'st\\' to store the unique elements.\\n1. Iterate through each element in the array.\\n1. For each element, check if it already exists in the HashSet.\\n1. If it does, return true to indicate the presence of a duplicate.\\n1. If it doesn\\'t exist, add the element to the HashSet.\\n1. After checking all elements, return false to indicate that no duplicates were found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is $$O(n)$$, where n is the length of the input array. This is because we iterate through each element in the array once.\\n\\n\\n- Space complexity:\\nThe space complexity is also $$O(n)$$ in the worst case, where all elements in the array are unique. This is because the HashSet will store all n elements.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a HashSet to store unique elements\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Iterate through the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Check if the element is already in the HashSet\\n            if (set.contains(nums[i])) {\\n                return true; // Found a duplicate\\n            } else {\\n                set.add(nums[i]); // Add the element to the HashSet\\n            }\\n        }\\n        return false; // No duplicates found\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Create an empty set to store unique elements\\n        st = set()\\n\\n        # Iterate through each element in the array\\n        for num in nums:\\n            # Check if the element already exists in the set\\n            if num in st:\\n                return True  # Duplicate found, return True\\n            else:\\n                st.add(num)  # Add the element to the set\\n\\n        return False  # No duplicates found, return False\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create an empty set to store unique elements\\n        unordered_set<int> st;\\n\\n        // Iterate through each element in the array\\n        for (int num : nums) {\\n            // Check if the element already exists in the set\\n            if (st.find(num) != st.end()) {\\n                return true;  // Duplicate found, return true\\n            } else {\\n                st.insert(num);  // Add the element to the set\\n            }\\n        }\\n\\n        return false;  // No duplicates found, return false\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/661ff5b1-ca20-4a6c-b4bd-9c763646f18e_1688822668.3935153.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a HashSet to store unique elements\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Iterate through the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Check if the element is already in the HashSet\\n            if (set.contains(nums[i])) {\\n                return true; // Found a duplicate\\n            } else {\\n                set.add(nums[i]); // Add the element to the HashSet\\n            }\\n        }\\n        return false; // No duplicates found\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Create an empty set to store unique elements\\n        st = set()\\n\\n        # Iterate through each element in the array\\n        for num in nums:\\n            # Check if the element already exists in the set\\n            if num in st:\\n                return True  # Duplicate found, return True\\n            else:\\n                st.add(num)  # Add the element to the set\\n\\n        return False  # No duplicates found, return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create an empty set to store unique elements\\n        unordered_set<int> st;\\n\\n        // Iterate through each element in the array\\n        for (int num : nums) {\\n            // Check if the element already exists in the set\\n            if (st.find(num) != st.end()) {\\n                return true;  // Duplicate found, return true\\n            } else {\\n                st.insert(num);  // Add the element to the set\\n            }\\n        }\\n\\n        return false;  // No duplicates found, return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715609,
                "title": "2-best-methods-to-solve-c-sorting-maps",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!------- By Sorting ------>\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int i=0;\\n        while(i<n-1){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n<!-------- Using Unordered Map -------->\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]++;\\n        }\\n\\n        for(auto p : m){\\n            if(p.second>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n![4i5ri4f9.png](https://assets.leetcode.com/users/images/280cc0bf-e1b5-417b-a72d-4ba7e737f34f_1688448157.4485767.png)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n<!------- By Sorting ------>\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int i=0;\\n        while(i<n-1){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n<!-------- Using Unordered Map -------->\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]++;\\n        }\\n\\n        for(auto p : m){\\n            if(p.second>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498681,
                "title": "one-liner-c",
                "content": "Use the Linq Distinct to remove duplicates and compare the collection lengths\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.Distinct().Count() != nums.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.Distinct().Count() != nums.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112564,
                "title": "one-line-solution-using-set-c-python3-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the `nums` into an unordered set and compare its size to that of `nums`. If the size of the unordered set is smaller, it indicates the presence of duplicate item(s) in `nums`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return unordered_set(nums.begin(), nums.end()).size() != nums.size();\\n    }\\n};\\n```\\nPython 3\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\nJavascript\\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size != nums.length;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return unordered_set(nums.begin(), nums.end()).size() != nums.size();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size != nums.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841814,
                "title": "no-for-or-count-needed-python",
                "content": "```\\ndef containsDuplicate(self, nums):\\n        if len(set(nums)) < len(nums):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums):\\n        if len(set(nums)) < len(nums):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2808487,
                "title": "php-beats-99-79",
                "content": "# Intuition\\n```\\nSpeed: isset($arr[$i]) is much faster than in_array()\\n```\\n```\\nSpeed: $arr[$i] is much faster than array_push()\\n```\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Boolean\\n     */\\n    function containsDuplicate($nums) {\\n        \\n        $tempArr = [];\\n\\n        foreach($nums as $num) {\\n            if(isset($tempArr[$num])) return true;\\n            $tempArr[$num] = 1;\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nSpeed: isset($arr[$i]) is much faster than in_array()\\n```\n```\\nSpeed: $arr[$i] is much faster than array_push()\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Boolean\\n     */\\n    function containsDuplicate($nums) {\\n        \\n        $tempArr = [];\\n\\n        foreach($nums as $num) {\\n            if(isset($tempArr[$num])) return true;\\n            $tempArr[$num] = 1;\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632214,
                "title": "java-solution-using-hashset",
                "content": "```\\npublic boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs = new HashSet<>();  //taken a HashSet \\n        for(int x: nums) { hs.add(x);} //added all the array elements in HashSet and HashSet will remove the Duplicacy \\n        return hs.size()!=nums.length; // if HashSet Size is not equal to array Length it means there were duplicate elements and if HashSet size and Array length is same then no Duplicates present\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs = new HashSet<>();  //taken a HashSet \\n        for(int x: nums) { hs.add(x);} //added all the array elements in HashSet and HashSet will remove the Duplicacy \\n        return hs.size()!=nums.length; // if HashSet Size is not equal to array Length it means there were duplicate elements and if HashSet size and Array length is same then no Duplicates present\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2603321,
                "title": "c-java-python3-javascript-solutions-faster-than-93",
                "content": "C#,Java,Python3,JavaScript different solution with explanation\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/)\\u2B50**\\n\\n**Example : C# Solution1 - HashSet ( \\u2B06To see other languages \\u2B06)**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Example : C# Solution2 - sort the array first**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nIf you got any problem or want other programming language solution, please feel free to let me know.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514407,
                "title": "javascript-o-n-comments-appreciated",
                "content": "const map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i]);\\n\\t}\\n\\n\\treturn false;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "const map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i]);\\n\\t}\\n\\n\\treturn false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2480584,
                "title": "c-fastest-easiest-solution",
                "content": "**UP VOTE**\\n\\t\\n\\t//1 solution - passed\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tstd::sort(nums.begin(), nums.end()); \\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t//2\\'th solution - Time Limit Exceeded\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(nums[i] == nums[j] && i != j) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tstd::sort(nums.begin(), nums.end()); \\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2345319,
                "title": "easy-c-solution-2-approaches",
                "content": "\\tbool containsDuplicate(vector<int>& nums){\\n        unordered_map<int,int> m;\\n        for(auto i : nums){\\n            if(++m[i]>1)\\n                return 1;\\n            }\\n        return 0;\\n    }\\n\\t\\nAnother approach would be:\\n\\n\\tbool containsDuplicate(vector& nums){\\n\\t\\treturn set(nums.begin(),nums.end()).size() < nums.size(); // set contain only unique elements\\n\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tbool containsDuplicate(vector<int>& nums){\\n        unordered_map<int,int> m;\\n        for(auto i : nums){\\n            if(++m[i]>1)\\n                return 1;\\n            }\\n        return 0;\\n    }\\n\\t\\nAnother approach would be:\\n\\n\\tbool containsDuplicate(vector& nums){\\n\\t\\treturn set(nums.begin(),nums.end()).size() < nums.size(); // set contain only unique elements\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2340241,
                "title": "fast-short-simple-python-code",
                "content": "Runtime: 441 ms, faster than 99.46% of Python3 online submissions for Contains Duplicate.\\nMemory Usage: 26.1 MB, less than 30.56% of Python3 online submissions for Contains Duplicate.\\n**Python3** code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        ls=len(set(nums))\\n        l=len(nums)\\n        return l>ls\\n```\\nIf you find it helpful, do not forget to **upvote**.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        ls=len(set(nums))\\n        l=len(nums)\\n        return l>ls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212692,
                "title": "python-solution-one-liner",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) < len(nums)\\n```\\nMore LeetCode solutions of mine at https://github.com/aurimas13/SolutionsToProblems\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) < len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026269,
                "title": "python-one-line-of-code-d",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(set(nums))!=len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956970,
                "title": "simple-python-one-liner",
                "content": "Make a set from the list to ensure that every element is present only once and compare the lenght of the nums agains the length of the set. \\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715275,
                "title": "python-solutions-brute-force-sorting-python-sets-hashmap",
                "content": "### **1. Brute Force Solution**\\n\\n```\\n# Time Complexity: O(n^2)\\ndef contains_duplicate(nums):\\n    for i in range(0, len(nums)):\\n        for j in range(i+1, len(nums)):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\\n\\n### **2. Using Sorting**\\n\\n```\\n# Total Time Complexity : O(nlogn)\\ndef contains_duplicate(nums):\\n    nums.sort() # O(log N)\\n\\n    # O(N)\\n    for i in range(0, len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\\n\\n### **2. Using Python Sets**\\n\\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    new_nums = set(nums)\\n    if len(new_nums) == len(nums): return False\\n    return True\\n```\\n\\n### **2. Using Python Dictionary or HashMap**\\n\\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    occurence = dict()\\n    for item in nums:\\n        if item not in occurence:\\n            occurence[item] = 1\\n        else:\\n            occurence[item] = occurence.get(item) + 1\\n\\n    for k,v in occurence.items():\\n        if v > 1: return True\\n        return False\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Time Complexity: O(n^2)\\ndef contains_duplicate(nums):\\n    for i in range(0, len(nums)):\\n        for j in range(i+1, len(nums)):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\n```\\n# Total Time Complexity : O(nlogn)\\ndef contains_duplicate(nums):\\n    nums.sort() # O(log N)\\n\\n    # O(N)\\n    for i in range(0, len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    new_nums = set(nums)\\n    if len(new_nums) == len(nums): return False\\n    return True\\n```\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    occurence = dict()\\n    for item in nums:\\n        if item not in occurence:\\n            occurence[item] = 1\\n        else:\\n            occurence[item] = occurence.get(item) + 1\\n\\n    for k,v in occurence.items():\\n        if v > 1: return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1652670,
                "title": "js-solutions",
                "content": "**1. O(n)**\\n\\nRuntime: 92 ms, faster than 51.72% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 49.5 MB, less than 5.13% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    let obj = {};\\n    for (let num of nums) {\\n        if (obj[num]) {\\n            return true;\\n        } else {\\n            obj[num] = true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n**2. O(n)**\\n\\nRuntime: 96 ms, faster than 43.95% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 47.6 MB, less than 21.20% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```\\n\\n**3. O(n log n)**\\n\\nRuntime: 168 ms, faster than 19.65% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 48.2 MB, less than 12.69% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    nums.sort();\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n**4. O(n^2)**\\n\\nRuntime: 2924 ms, faster than 5.01% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 46.2 MB, less than 46.41% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    return !nums.every((item, index, array) => index === array.lastIndexOf(item))\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    let obj = {};\\n    for (let num of nums) {\\n        if (obj[num]) {\\n            return true;\\n        } else {\\n            obj[num] = true;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    nums.sort();\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return !nums.every((item, index, array) => index === array.lastIndexOf(item))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498681,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                flag = true;\\n                //hm.put(nums[i],hm.get(nums[i])+1);\\n            }else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                flag = true;\\n                //hm.put(nums[i],hm.get(nums[i])+1);\\n            }else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445483,
                "title": "two-liner-simple-solution-in-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tunordered_set<int> s(nums.begin(),nums.end());\\n\\t\\t\\treturn s.size()==nums.size()? false:true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tunordered_set<int> s(nums.begin(),nums.end());\\n\\t\\t\\treturn s.size()==nums.size()? false:true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1192632,
                "title": "javascript-solution",
                "content": "Runtime: 84 ms, faster than 84.29% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 45.1 MB, less than 57.85% of JavaScript online submissions for Contains Duplicate.\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   // use the Set to store array element \\n    let found = new Set(nums);\\n\\t// check if the size of the set is the same as the original array\\n\\t// if array has duplicate they won\\'t be the same\\n    return found.size !== nums.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   // use the Set to store array element \\n    let found = new Set(nums);\\n\\t// check if the size of the set is the same as the original array\\n\\t// if array has duplicate they won\\'t be the same\\n    return found.size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 966313,
                "title": "scala-single-line-solution",
                "content": "```\\ndef containsDuplicate(nums: Array[Int]): Boolean = {\\n\\tnums.size != nums.toSet.size\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef containsDuplicate(nums: Array[Int]): Boolean = {\\n\\tnums.size != nums.toSet.size\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 814651,
                "title": "0-ms-2-7mb-simple-2-line-solution-using-hashset",
                "content": "\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n      pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n            //add vector to hashset.\\n            //sets don\\'t add dupes\\n            let set_of_nums: HashSet<i32> = HashSet::from_iter(nums.clone());\\n            //returns a bool\\n            !(&nums.len() == &set_of_nums.len())\\n      }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n      pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n            //add vector to hashset.\\n            //sets don\\'t add dupes\\n            let set_of_nums: HashSet<i32> = HashSet::from_iter(nums.clone());\\n            //returns a bool\\n            !(&nums.len() == &set_of_nums.len())\\n      }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691212,
                "title": "java-sorting-solution",
                "content": "```\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=1; i < nums.length; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\t\\n\\t// Runtime: 3 ms, faster than 99.65% of Java online submissions\\n\\t// Memory Usage: 42.9 MB, less than 99.23% of Java online submissions.\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=1; i < nums.length; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\t\\n\\t// Runtime: 3 ms, faster than 99.65% of Java online submissions\\n\\t// Memory Usage: 42.9 MB, less than 99.23% of Java online submissions.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563897,
                "title": "c-hash-solution-o-n-time-o-n-space",
                "content": "Having used c++ stl library to show [various solutions](https://leetcode.com/problems/contains-duplicate/discuss/191396/c%2B%2B-fast-simple-short-solutions.-1-line-without-modifying-input.-2-lines-with-modifying.), I thought I would put up a c hash solution using uhash.h.\\n\\n```cpp\\nstruct number_set {\\n  int value;\\n  UT_hash_handle hh;\\n};\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n  struct number_set* set = NULL;\\n  struct number_set* element;\\n  bool result = false;\\n  \\n  for (int i = 0; i < numsSize; ++i) {\\n    HASH_FIND_INT(set, &nums[i], element);\\n    if (element) {\\n      result = true;\\n      break;\\n    }\\n    \\n    element = (struct number_set *) malloc(sizeof(*element));\\n    element->value = nums[i];\\n    HASH_ADD_INT(set, value, element);\\n  }\\n \\n  /* Destroy the hashset */\\n  struct number_set* curr;\\n  struct number_set* tmp;\\n  HASH_ITER(hh, set, curr, tmp) {\\n    HASH_DEL(set, curr);\\n    free(curr);\\n  }\\n  \\n  return result;\\n}\\n```\\n\\nPretty simple concempt of checking for existance in hashset, returning true if it does and adding it to the hashset if it doesn\\'t. Rinse and repeat.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstruct number_set {\\n  int value;\\n  UT_hash_handle hh;\\n};\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n  struct number_set* set = NULL;\\n  struct number_set* element;\\n  bool result = false;\\n  \\n  for (int i = 0; i < numsSize; ++i) {\\n    HASH_FIND_INT(set, &nums[i], element);\\n    if (element) {\\n      result = true;\\n      break;\\n    }\\n    \\n    element = (struct number_set *) malloc(sizeof(*element));\\n    element->value = nums[i];\\n    HASH_ADD_INT(set, value, element);\\n  }\\n \\n  /* Destroy the hashset */\\n  struct number_set* curr;\\n  struct number_set* tmp;\\n  HASH_ITER(hh, set, curr, tmp) {\\n    HASH_DEL(set, curr);\\n    free(curr);\\n  }\\n  \\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440357,
                "title": "easy-to-understand-python-python3-code-using-dictionary",
                "content": "The time complexity is O(n), because search in dicitonary is O(1). This is achieved at the expense of extra O(n) space.\\n\\n        dic = {}\\n        for n in nums:\\n            if n in dic: return True\\n            else: dic[n] = 1\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The time complexity is O(n), because search in dicitonary is O(1). This is achieved at the expense of extra O(n) space.\\n\\n        dic = {}\\n        for n in nums:\\n            if n in dic: return True\\n            else: dic[n] = 1\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 216923,
                "title": "c-qsort-8ms",
                "content": "```\\nstatic int _cmp(const int *l, const int *r)  \\n{ \\n    return (*l - *r); \\n}\\n\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    \\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int _cmp(const int *l, const int *r)  \\n{ \\n    return (*l - *r); \\n}\\n\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    \\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140954,
                "title": "python-one-liner",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1805121,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1570451,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568303,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567688,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1571445,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1566700,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1572616,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576158,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568546,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567227,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1805121,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1570451,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568303,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567688,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1571445,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1566700,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1572616,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576158,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568546,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567227,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576843,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1576599,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1795206,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1692282,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1793517,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1693438,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1576803,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1575747,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1575560,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1572842,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1570225,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1897000,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1848272,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1793428,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1752790,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576859,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576754,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576623,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576536,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576443,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1575393,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1575335,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1573687,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572540,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572525,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572382,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572099,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572010,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569337,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569026,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569027,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1567713,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1576087,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1575857,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2077164,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2074194,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2072329,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2069878,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2067451,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2065535,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2056924,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2055491,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2050884,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2046557,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2046256,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2045749,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042772,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042549,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042378,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2041651,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2035560,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2034083,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2031457,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2031005,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2028988,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2028097,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2023354,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2013910,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2012350,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2008476,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2006846,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 2003383,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 2001839,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1999397,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1999016,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1997693,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1993692,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1984022,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1978657,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1974154,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1968183,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1961690,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1955105,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1953905,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1946601,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1945092,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1944593,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1942211,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1940850,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1940004,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1937679,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1933655,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1926404,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1925769,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1925532,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1918769,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1918292,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1917941,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1912288,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1911680,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1910566,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1905232,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1904443,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1903952,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1900176,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1893655,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1863664,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1859156,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1858804,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1856703,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1852910,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1851903,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1851466,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1846466,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1841500,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1840787,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1835313,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1829086,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1814239,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1813289,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1813225,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1813018,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1811593,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1811582,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1809215,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1804947,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1801700,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1794813,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1794253,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1792003,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1791203,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1785816,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1784365,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1782972,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1782750,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1781814,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1781147,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1780282,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1779402,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1775886,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1774078,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1773827,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1773144,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1771589,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1770933,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1769765,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1768092,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1766996,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1766939,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1765472,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1764895,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1762059,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1761261,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1758248,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1757525,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1754272,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1753016,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1752079,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1751828,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1751514,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1750482,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1746120,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1743208,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1740140,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1737751,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1736590,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1736521,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1735769,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1734433,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1733902,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1732934,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1731938,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1730969,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1729464,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1728621,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1725342,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1723106,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1719841,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1719115,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1717207,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1717194,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1717072,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1716234,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1715253,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1708256,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1707971,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1706593,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1706197,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1704076,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1701634,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1698970,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1695735,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1695314,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1694932,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1693981,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1693157,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1692523,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1690781,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1687527,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1675905,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            }
        ]
    },
    {
        "title": "Top K Frequent Words",
        "question_content": "<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>\n\n<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2\n<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]\n<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.\nNote that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4\n<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]\n<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>\n",
        "solutions": [
            {
                "id": 431008,
                "title": "summary-of-all-the-methods-you-can-imagine-of-this-problem",
                "content": "To help you guys have a better understanding of this problem, I tried to summary the methods I saw from others in this post. This is my first time to write a summary post, so correct me if there is any problem. Thanks!\\n\\nTo analyze Time Complexity and Space Complexity: n is the total number of words, m is the average length of each word\\n\\n# Just Sorting\\nThe easiest way to think of this problem and easy to implement.\\n*Time complexity*: O(nlogn), naive sort is o(nlogn)\\n*Space complexity*: O(n), for map and list\\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>();\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            l.add(e);\\n        }\\n        Collections.sort(l, new MyComparator());//just use our Comparator to sort\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(l.get(i).getKey());\\n        }\\n        return ans;\\n    }\\n}\\n/*\\nImplement our own comparator for this problem, I will also use this Comparator in other methods(A little different in minHeap method).\\nWe can also use anonymous Comparaotr or Lambda function.\\n*/\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```\\n\\n------------------------\\n\\n# Max Heap\\nMaintain a max heap and add all the words in it. Pop top K words to get the results.\\n*Time Complexity*: O(nlogn + Klogn) = O(nlogn)\\n*Space Complexity*: O(n), for heap\\n```JAVA\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(new MyComparator());\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            pq.offer(e);\\n        }\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(pq.poll().getKey());\\n        }\\n        return ans;\\n    }\\n}\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```\\n\\n------------------------\\n\\n# Min Heap\\nInstead of using a max heap, we only store Top K Freqency word we have met so far in our min heap.\\n*Time Complexity*: O(nlogK), logK time for each word\\n*Space Complexity*: O(K), since the largest number of words in our minheap is K\\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        MyComparator comparator = new MyComparator();\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(comparator);\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            // If minHeap\\'s size is smaller than K, we just add the entry\\n            if(pq.size()<k){\\n                pq.offer(e);\\n            }\\n            // Else, we compare the current entry with \"min\" entry in priority queue\\n            else {\\n                if(comparator.compare(e, pq.peek())>0){\\n                    pq.poll();\\n                    pq.offer(e);\\n                }\\n            }\\n        }\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(0, pq.poll().getKey());//the \"smaller\" entry poll out ealier \\n        }\\n        return ans;\\n    }    \\n}\\n\\n// The comparaotr is reversed as maxHeap\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq1-freq2;\\n        }\\n        else {\\n            return word2.compareTo(word1);\\n        }\\n    }\\n}\\n```\\n\\n------------------------\\n\\n# Bucket sort + Trie\\nThis method is derived from 347. Top K Frequent Elements. At 347, we use bucket sort(LinkedList in each bucket) to find top K frequency integers and we can choose any integer if there is a tie of frequency . But in this question, the problem is that when there is a tie of frequency, we need to compare the lexicographic order. Thus using bucket sort(LinkedList in each bucket) is not good.\\nThe way to solve the tie problem is to use either trie or BST.\\n*Time Complexity*: O(n*m) = O(n), m time to construct trie for each word and m is a constant\\n*Space Complexity*: O(n*m) = O(n), m space for each bucket and m is a constant\\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        \\n        Trie[] buckets = new Trie[words.length];\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            //for each word, add it into trie at its bucket\\n            String word = e.getKey();\\n            int freq = e.getValue();\\n            if(buckets[freq]==null){\\n                buckets[freq] = new Trie();\\n            }\\n            buckets[freq].addWord(word);\\n        }\\n        \\n        List<String> ans = new LinkedList<>();\\n\\n        for(int i = buckets.length-1;i>=0;i--){\\n        //for trie in each bucket, get all the words with same frequency in lexicographic order. Compare with k and get the result\\n            if(buckets[i]!=null){\\n                List<String> l = new LinkedList<>();                               \\n                buckets[i].getWords(buckets[i].root, l);\\n                if(l.size()<k){\\n                    ans.addAll(l);\\n                    k = k - l.size(); \\n                }\\n                else {\\n                   for(int j = 0;j<=k-1;j++){\\n                       ans.add(l.get(j));\\n                   } \\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String word = null;\\n}\\n\\nclass Trie {\\n    TrieNode root = new TrieNode();\\n    public void addWord(String word){\\n        TrieNode cur = root;\\n        for(char c:word.toCharArray()){\\n            if(cur.children[c-\\'a\\']==null){\\n                cur.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    public void getWords(TrieNode node, List<String> ans){\\n        //use DFS to get lexicograpic order of all the words with same frequency\\n        if(node==null){\\n            return;\\n        }\\n        if(node.word!=null){\\n            ans.add(node.word);\\n        }\\n        for(int i = 0;i<=25;i++){\\n            if(node.children[i]!=null){\\n                getWords(node.children[i], ans);\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\n------------------------\\n\\n\\n# Bucket sort + BST\\nThe reason we use Trie is to break the tie of same word frequency. Thus we can easily use BST to replace Trie(In Java, we can use TreeMap or TreeSet)\\n*Time Complexity*: O(n), not sure\\n*Space Complexity*: O(n), not sure\\n```JAVA\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        TreeMap<String, Integer>[] buckets = new TreeMap[words.length];\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            String word = e.getKey();\\n            int freq = e.getValue();\\n            if(buckets[freq]==null){\\n                buckets[freq] = new TreeMap<>((a, b)->{\\n                    return a.compareTo(b);\\n                });\\n            }\\n            buckets[freq].put(word, freq);\\n        }\\n        \\n        List<String> ans = new LinkedList<>();\\n        for(int i = buckets.length-1;i>=0;i--){\\n            if(buckets[i]!=null){\\n                TreeMap<String, Integer> temp = buckets[i];\\n                if(temp.size()<k){\\n                    k = k - temp.size();\\n                    while(temp.size()>0){\\n                        ans.add(temp.pollFirstEntry().getKey());\\n                    }  \\n                }\\n                else {\\n                    while(k>0){\\n                        ans.add(temp.pollFirstEntry().getKey());\\n                        k--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }     \\n        return ans;\\n    }\\n}\\n```\\n\\n------------------------\\n\\n# Quick select\\nIf the question is to find Kth frequency word, quick select is a good solution and only cost O(n), for this question, after getting Top K frequency words by using quick select, we also need to do a sort to make sure they are in the right order.\\n*Time Complexity*: O(n+KlogK), n time for quick select and KlogK time for sort\\n*Space Complexity*: O(n)\\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        \\n        Map.Entry<String, Integer>[] entrys = new Map.Entry[map.size()];\\n        int index = 0;\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            entrys[index] = e;\\n            index++;\\n        }\\n        //do quick select\\n        int start = 0;\\n        int end = entrys.length-1;\\n        int mid = 0;\\n        while(start<=end){\\n            mid = partition(entrys, start, end);\\n            if(mid == k-1){\\n                break;\\n            }\\n            else if(mid<k-1){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        List<String> ans = new LinkedList<>();\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>();\\n        for(int i = 0;i<=mid;i++){\\n            l.add(entrys[i]);\\n        }\\n        //still need to sort these K words, because we only know they are in result, but not in right order\\n        Collections.sort(l, new MyComparator());\\n        for(Map.Entry<String, Integer> e:l){\\n            ans.add(e.getKey());\\n        }\\n        return ans;\\n    }\\n    \\n    private int partition(Map.Entry<String, Integer>[] entrys, int start, int end){\\n        int pivot = start;\\n        int left = start + 1;\\n        int right = end;\\n        MyComparator myComparator = new MyComparator();\\n        while(true){\\n            while(left<=end){\\n                if(myComparator.compare(entrys[left], entrys[pivot])<=0){\\n                    left++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            while(right>=start+1){\\n                if(myComparator.compare(entrys[right], entrys[pivot])>0){\\n                    right--;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            if(left>right){\\n                break;\\n            }\\n            swap(entrys, left, right);\\n        }\\n        swap(entrys, pivot, right);\\n        return right;\\n    }\\n\\n    private void swap(Map.Entry<String, Integer>[] entrys, int i, int j){\\n        Map.Entry<String, Integer> a = entrys[i];\\n        entrys[i] = entrys[j];\\n        entrys[j] = a;\\n    }\\n}\\n\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Trie",
                    "Binary Search Tree",
                    "Heap (Priority Queue)",
                    "Bucket Sort",
                    "Quickselect"
                ],
                "code": "```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>();\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            l.add(e);\\n        }\\n        Collections.sort(l, new MyComparator());//just use our Comparator to sort\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(l.get(i).getKey());\\n        }\\n        return ans;\\n    }\\n}\\n/*\\nImplement our own comparator for this problem, I will also use this Comparator in other methods(A little different in minHeap method).\\nWe can also use anonymous Comparaotr or Lambda function.\\n*/\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```\n```JAVA\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(new MyComparator());\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            pq.offer(e);\\n        }\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(pq.poll().getKey());\\n        }\\n        return ans;\\n    }\\n}\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        MyComparator comparator = new MyComparator();\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(comparator);\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            // If minHeap\\'s size is smaller than K, we just add the entry\\n            if(pq.size()<k){\\n                pq.offer(e);\\n            }\\n            // Else, we compare the current entry with \"min\" entry in priority queue\\n            else {\\n                if(comparator.compare(e, pq.peek())>0){\\n                    pq.poll();\\n                    pq.offer(e);\\n                }\\n            }\\n        }\\n        List<String> ans = new LinkedList<>();\\n        for(int i = 0;i<=k-1;i++){\\n            ans.add(0, pq.poll().getKey());//the \"smaller\" entry poll out ealier \\n        }\\n        return ans;\\n    }    \\n}\\n\\n// The comparaotr is reversed as maxHeap\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq1-freq2;\\n        }\\n        else {\\n            return word2.compareTo(word1);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        \\n        Trie[] buckets = new Trie[words.length];\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            //for each word, add it into trie at its bucket\\n            String word = e.getKey();\\n            int freq = e.getValue();\\n            if(buckets[freq]==null){\\n                buckets[freq] = new Trie();\\n            }\\n            buckets[freq].addWord(word);\\n        }\\n        \\n        List<String> ans = new LinkedList<>();\\n\\n        for(int i = buckets.length-1;i>=0;i--){\\n        //for trie in each bucket, get all the words with same frequency in lexicographic order. Compare with k and get the result\\n            if(buckets[i]!=null){\\n                List<String> l = new LinkedList<>();                               \\n                buckets[i].getWords(buckets[i].root, l);\\n                if(l.size()<k){\\n                    ans.addAll(l);\\n                    k = k - l.size(); \\n                }\\n                else {\\n                   for(int j = 0;j<=k-1;j++){\\n                       ans.add(l.get(j));\\n                   } \\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    String word = null;\\n}\\n\\nclass Trie {\\n    TrieNode root = new TrieNode();\\n    public void addWord(String word){\\n        TrieNode cur = root;\\n        for(char c:word.toCharArray()){\\n            if(cur.children[c-\\'a\\']==null){\\n                cur.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            cur = cur.children[c-\\'a\\'];\\n        }\\n        cur.word = word;\\n    }\\n    \\n    public void getWords(TrieNode node, List<String> ans){\\n        //use DFS to get lexicograpic order of all the words with same frequency\\n        if(node==null){\\n            return;\\n        }\\n        if(node.word!=null){\\n            ans.add(node.word);\\n        }\\n        for(int i = 0;i<=25;i++){\\n            if(node.children[i]!=null){\\n                getWords(node.children[i], ans);\\n            }\\n        }\\n        \\n    }\\n}\\n```\n```JAVA\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        TreeMap<String, Integer>[] buckets = new TreeMap[words.length];\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            String word = e.getKey();\\n            int freq = e.getValue();\\n            if(buckets[freq]==null){\\n                buckets[freq] = new TreeMap<>((a, b)->{\\n                    return a.compareTo(b);\\n                });\\n            }\\n            buckets[freq].put(word, freq);\\n        }\\n        \\n        List<String> ans = new LinkedList<>();\\n        for(int i = buckets.length-1;i>=0;i--){\\n            if(buckets[i]!=null){\\n                TreeMap<String, Integer> temp = buckets[i];\\n                if(temp.size()<k){\\n                    k = k - temp.size();\\n                    while(temp.size()>0){\\n                        ans.add(temp.pollFirstEntry().getKey());\\n                    }  \\n                }\\n                else {\\n                    while(k>0){\\n                        ans.add(temp.pollFirstEntry().getKey());\\n                        k--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }     \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word:words){\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        \\n        Map.Entry<String, Integer>[] entrys = new Map.Entry[map.size()];\\n        int index = 0;\\n        for(Map.Entry<String, Integer> e:map.entrySet()){\\n            entrys[index] = e;\\n            index++;\\n        }\\n        //do quick select\\n        int start = 0;\\n        int end = entrys.length-1;\\n        int mid = 0;\\n        while(start<=end){\\n            mid = partition(entrys, start, end);\\n            if(mid == k-1){\\n                break;\\n            }\\n            else if(mid<k-1){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        List<String> ans = new LinkedList<>();\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>();\\n        for(int i = 0;i<=mid;i++){\\n            l.add(entrys[i]);\\n        }\\n        //still need to sort these K words, because we only know they are in result, but not in right order\\n        Collections.sort(l, new MyComparator());\\n        for(Map.Entry<String, Integer> e:l){\\n            ans.add(e.getKey());\\n        }\\n        return ans;\\n    }\\n    \\n    private int partition(Map.Entry<String, Integer>[] entrys, int start, int end){\\n        int pivot = start;\\n        int left = start + 1;\\n        int right = end;\\n        MyComparator myComparator = new MyComparator();\\n        while(true){\\n            while(left<=end){\\n                if(myComparator.compare(entrys[left], entrys[pivot])<=0){\\n                    left++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            \\n            while(right>=start+1){\\n                if(myComparator.compare(entrys[right], entrys[pivot])>0){\\n                    right--;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            if(left>right){\\n                break;\\n            }\\n            swap(entrys, left, right);\\n        }\\n        swap(entrys, pivot, right);\\n        return right;\\n    }\\n\\n    private void swap(Map.Entry<String, Integer>[] entrys, int i, int j){\\n        Map.Entry<String, Integer> a = entrys[i];\\n        entrys[i] = entrys[j];\\n        entrys[j] = a;\\n    }\\n}\\n\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n\\n    public int compare(Map.Entry<String, Integer> e1, Map.Entry<String, Integer> e2){\\n        String word1 = e1.getKey();\\n        int freq1 = e1.getValue();\\n        String word2 = e2.getKey();\\n        int freq2 = e2.getValue();\\n        if(freq1!=freq2){\\n            return freq2-freq1;\\n        }\\n        else {\\n            return word1.compareTo(word2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108346,
                "title": "my-simple-java-solution-using-hashmap-priorityqueue-o-nlogk-time-o-n-space",
                "content": "The idea is to keep a count of each word in a HashMap and then insert in a Priority Queue.\\nWhile inserting in pq, if the count of two words is same then insert based on string compare of the keys.\\n```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n        List<String> result = new LinkedList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(map.containsKey(words[i]))\\n                map.put(words[i], map.get(words[i])+1);\\n            else\\n                map.put(words[i], 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n                 (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()\\n        );\\n        \\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            pq.offer(entry);\\n            if(pq.size()>k)\\n                pq.poll();\\n        }\\n\\n        while(!pq.isEmpty())\\n            result.add(0, pq.poll().getKey());\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n        List<String> result = new LinkedList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(map.containsKey(words[i]))\\n                map.put(words[i], map.get(words[i])+1);\\n            else\\n                map.put(words[i], 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n                 (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()\\n        );\\n        \\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            pq.offer(entry);\\n            if(pq.size()>k)\\n                pq.poll();\\n        }\\n\\n        while(!pq.isEmpty())\\n            result.add(0, pq.poll().getKey());\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274279,
                "title": "cpp-c-priority-queue-custom-comparator-and-solution-explain-o-nlogk-solution",
                "content": "```\\n/*\\n  Given a set of strings we have to print top k frequent strings.\\n  We have to return the array such that the string with highest frequency comes first and lower later.\\n  If two strings have the same frequency then they should be ordered in lexiographical order\\n  LeetCode Question: 692 - https://leetcode.com/problems/top-k-frequent-words/\\n*/\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n/*\\n  This question is almost same as top k frequent numbers in the set. The only here is we have to maintain certain order with the strings too.\\n*/\\n\\n#define psi pair<int, string>\\n\\n\\n/* \\n  If you are not familier with how to declare a custom comparator function then you can have a read over this stackoverflow thread.\\n  https://stackoverflow.com/questions/16111337/declaring-a-priority-queue-in-c-with-a-custom-comparator/48587737\\n\\n  Basically, you can do it in many ways out of which i feel the doing it with the class is the simpler. We can also do it with \\n  lamdha function but for that we would have to make some more arrangements which declaring our pioirity queue.\\n\\n  Type 1:\\n  auto myComparator = [](const psi &p1 const psi &p2){\\n    if(p1.first == p2.first) return p1.second < p2.second;\\n\\n    return p1.first > p2.first;\\n  } \\n\\n  While declaring the priority queue\\n  priority_queue<psi, vector<psi>, decltype(myComparator)> anyName(myComparator)\\n\\n  Type 2: If you want to declare a normal function and use it in the priority queue then it can be done in the following way\\n  bool myComparator(const psi &p2 const psi *p2) {\\n    if(p1.first == p2.first) return p1.second < p2.second;\\n\\n    return p1.first > p2.first;\\n  }\\n\\n  While declaring the priority queue you just have to give the pointer to the function\\n  priority_queue<psi, vector<psi>, decltype(&myComparator)> anyName(myComparator)\\n */\\nclass myComparator {\\n  public:\\n    bool operator() (const psi &p1, const psi &p2) {\\n      if(p1.first == p2.first) return p1.second < p2.second;\\n      \\n      return p1.first > p2.first;\\n    }\\n\\n    /* Here the point to note is how we are writing the compare function. \\n      We will return true for what type of order we want to maintain. The order will be seen from bottom to top.\\n      Actually there are many ways to understand but after seeing lot of ways i found the below one more understandable and easier.\\n      \\n      We will see the ordering from bottom to top. So, if i say that the order is ascending then it means that the smaller elements \\n      will be at the bottom and the higher elements will be at the top. (I\\'m taking tree representation of the heap, \\n\\t  if you consider array representation then the higher values will be at right and lower at the left)\\n\\n      Here if you are getting the doubt that - here the higher values are coming at the top and lower values are coming at the \\n      bottom then it is max heap not min heap. Then please note that the priority queue that we have declared in the getTopKFreqStrings \\n      is neither min heap nor max heap. \\n      The working or the order in which the elements are stored in priority queue depends on the comparator function.\\n\\n      General syntax to declare the priority queue is priority_queue<data_type, container, comparator>\\n      the default values for container is vector<data_type> and for comparator is less<data_type>. \\n      It automatically take the datatype what to give.\\n\\n      In case of max heap, we declare it as => priority_queue<int> maxHeap;\\n      Its basically a shorthand of this => priority_queue<int, vector<int>, less<int>> maxHeap; \\n      we don\\'t write the defualt values\\n\\n      and in case of min heap we declare it as => priority_queue<int, vector<int> greater<int>> minHeap;\\n\\n      note the comparator in both, its because of them the priority queue becomes min heap or max heap otherwise \\n      from the name itself we can see (priority) so - to which elements we should give priority depends on the comparator function. \\n      So, now lets come back to question\\n\\n      So, as per the question we want the decreasing order for the frequency of the strings\\n      and increasing order in the lexiographical way\\n      so that the strings with the least frequency and cannot be fitted inside k can be poped.\\n\\n      So, p1.first > p2.first will return true only when the frequency of first string is more than the second\\n      similary, p1.second < p2.second will return true when the string s1 in p1 is lexiographically smaller then string s2 in p2.\\n     */\\n};  \\n\\nvector<string> getTopKFreqStrings(vector<string> &words, int k) {\\n  int n = words.size();\\n\\n  /* First we will find the frequency of all the strings then we will keep track of the top k frequent strings with the help of priority queue */\\n\\n  unordered_map<string, int> freq;\\n\\n  for(string word : words) {\\n    freq[word]++;\\n  }\\n\\n  priority_queue<psi, vector<psi>, myComparator> pq;\\n  /* Since here we want to order the elements in a different way we will write our own custom comparator function */\\n  /* For defining our own comparator function we would have to declare it in the class as done above */\\n\\n  for(auto it : freq) {\\n    pq.push({it.second, it.first});\\n\\n    if(pq.size() > k) {\\n      pq.pop();\\n    }\\n  }\\n\\n  /* Now at this point the priority queue will contain the top k frequent elements or strings of the set */\\n\\n  /* Since, we know that we want to find the top k frequent strings hence we can directly declare the size of the answer vector \\n  and while psing we will get the strings in ascending order of the frequency hence we will put the strings from back side \\n  so that we don\\'t have to do an extra work to reverse the vector before returning  */\\n  vector<string> ans(k);\\n  int m = k-1;\\n\\n  while(pq.size() > 0) {\\n    ans[m--] = pq.top().second;\\n    pq.pop();\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int n, k;\\n  cin >> n >> k;\\n\\n  vector<string> arr(n);\\n  for(int i=0; i<n; i++) {\\n    string s; cin >> s;\\n    arr[i] = s;\\n  }\\n\\n  vector<string> topKFreq(getTopKFreqStrings(arr, k));\\n\\n  for(string s : topKFreq) {\\n    cout << s << \" \";\\n  }\\n\\n  return 0;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\n  Given a set of strings we have to print top k frequent strings.\\n  We have to return the array such that the string with highest frequency comes first and lower later.\\n  If two strings have the same frequency then they should be ordered in lexiographical order\\n  LeetCode Question: 692 - https://leetcode.com/problems/top-k-frequent-words/\\n*/\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n/*\\n  This question is almost same as top k frequent numbers in the set. The only here is we have to maintain certain order with the strings too.\\n*/\\n\\n#define psi pair<int, string>\\n\\n\\n/* \\n  If you are not familier with how to declare a custom comparator function then you can have a read over this stackoverflow thread.\\n  https://stackoverflow.com/questions/16111337/declaring-a-priority-queue-in-c-with-a-custom-comparator/48587737\\n\\n  Basically, you can do it in many ways out of which i feel the doing it with the class is the simpler. We can also do it with \\n  lamdha function but for that we would have to make some more arrangements which declaring our pioirity queue.\\n\\n  Type 1:\\n  auto myComparator = [](const psi &p1 const psi &p2){\\n    if(p1.first == p2.first) return p1.second < p2.second;\\n\\n    return p1.first > p2.first;\\n  } \\n\\n  While declaring the priority queue\\n  priority_queue<psi, vector<psi>, decltype(myComparator)> anyName(myComparator)\\n\\n  Type 2: If you want to declare a normal function and use it in the priority queue then it can be done in the following way\\n  bool myComparator(const psi &p2 const psi *p2) {\\n    if(p1.first == p2.first) return p1.second < p2.second;\\n\\n    return p1.first > p2.first;\\n  }\\n\\n  While declaring the priority queue you just have to give the pointer to the function\\n  priority_queue<psi, vector<psi>, decltype(&myComparator)> anyName(myComparator)\\n */\\nclass myComparator {\\n  public:\\n    bool operator() (const psi &p1, const psi &p2) {\\n      if(p1.first == p2.first) return p1.second < p2.second;\\n      \\n      return p1.first > p2.first;\\n    }\\n\\n    /* Here the point to note is how we are writing the compare function. \\n      We will return true for what type of order we want to maintain. The order will be seen from bottom to top.\\n      Actually there are many ways to understand but after seeing lot of ways i found the below one more understandable and easier.\\n      \\n      We will see the ordering from bottom to top. So, if i say that the order is ascending then it means that the smaller elements \\n      will be at the bottom and the higher elements will be at the top. (I\\'m taking tree representation of the heap, \\n\\t  if you consider array representation then the higher values will be at right and lower at the left)\\n\\n      Here if you are getting the doubt that - here the higher values are coming at the top and lower values are coming at the \\n      bottom then it is max heap not min heap. Then please note that the priority queue that we have declared in the getTopKFreqStrings \\n      is neither min heap nor max heap. \\n      The working or the order in which the elements are stored in priority queue depends on the comparator function.\\n\\n      General syntax to declare the priority queue is priority_queue<data_type, container, comparator>\\n      the default values for container is vector<data_type> and for comparator is less<data_type>. \\n      It automatically take the datatype what to give.\\n\\n      In case of max heap, we declare it as => priority_queue<int> maxHeap;\\n      Its basically a shorthand of this => priority_queue<int, vector<int>, less<int>> maxHeap; \\n      we don\\'t write the defualt values\\n\\n      and in case of min heap we declare it as => priority_queue<int, vector<int> greater<int>> minHeap;\\n\\n      note the comparator in both, its because of them the priority queue becomes min heap or max heap otherwise \\n      from the name itself we can see (priority) so - to which elements we should give priority depends on the comparator function. \\n      So, now lets come back to question\\n\\n      So, as per the question we want the decreasing order for the frequency of the strings\\n      and increasing order in the lexiographical way\\n      so that the strings with the least frequency and cannot be fitted inside k can be poped.\\n\\n      So, p1.first > p2.first will return true only when the frequency of first string is more than the second\\n      similary, p1.second < p2.second will return true when the string s1 in p1 is lexiographically smaller then string s2 in p2.\\n     */\\n};  \\n\\nvector<string> getTopKFreqStrings(vector<string> &words, int k) {\\n  int n = words.size();\\n\\n  /* First we will find the frequency of all the strings then we will keep track of the top k frequent strings with the help of priority queue */\\n\\n  unordered_map<string, int> freq;\\n\\n  for(string word : words) {\\n    freq[word]++;\\n  }\\n\\n  priority_queue<psi, vector<psi>, myComparator> pq;\\n  /* Since here we want to order the elements in a different way we will write our own custom comparator function */\\n  /* For defining our own comparator function we would have to declare it in the class as done above */\\n\\n  for(auto it : freq) {\\n    pq.push({it.second, it.first});\\n\\n    if(pq.size() > k) {\\n      pq.pop();\\n    }\\n  }\\n\\n  /* Now at this point the priority queue will contain the top k frequent elements or strings of the set */\\n\\n  /* Since, we know that we want to find the top k frequent strings hence we can directly declare the size of the answer vector \\n  and while psing we will get the strings in ascending order of the frequency hence we will put the strings from back side \\n  so that we don\\'t have to do an extra work to reverse the vector before returning  */\\n  vector<string> ans(k);\\n  int m = k-1;\\n\\n  while(pq.size() > 0) {\\n    ans[m--] = pq.top().second;\\n    pq.pop();\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int n, k;\\n  cin >> n >> k;\\n\\n  vector<string> arr(n);\\n  for(int i=0; i<n; i++) {\\n    string s; cin >> s;\\n    arr[i] = s;\\n  }\\n\\n  vector<string> topKFreq(getTopKFreqStrings(arr, k));\\n\\n  for(string s : topKFreq) {\\n    cout << s << \" \";\\n  }\\n\\n  return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 108348,
                "title": "python-3-solution-with-o-nlogk-and-o-n",
                "content": "```\\nimport collections\\nimport heapq\\nimport functools\\n\\n@functools.total_ordering\\nclass Element:\\n    def __init__(self, count, word):\\n        self.count = count\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        if self.count == other.count:\\n            return self.word > other.word\\n        return self.count < other.count\\n    \\n    def __eq__(self, other):\\n        return self.count == other.count and self.word == other.word\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        counts = collections.Counter(words)   \\n        \\n        freqs = []\\n        heapq.heapify(freqs)\\n        for word, count in counts.items():\\n            heapq.heappush(freqs, (Element(count, word), word))\\n            if len(freqs) > k:\\n                heapq.heappop(freqs)\\n        \\n        res = []\\n        for _ in range(k):\\n            res.append(heapq.heappop(freqs)[1])\\n        return res[::-1]\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport heapq\\nimport functools\\n\\n@functools.total_ordering\\nclass Element:\\n    def __init__(self, count, word):\\n        self.count = count\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        if self.count == other.count:\\n            return self.word > other.word\\n        return self.count < other.count\\n    \\n    def __eq__(self, other):\\n        return self.count == other.count and self.word == other.word\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        counts = collections.Counter(words)   \\n        \\n        freqs = []\\n        heapq.heapify(freqs)\\n        for word, count in counts.items():\\n            heapq.heappush(freqs, (Element(count, word), word))\\n            if len(freqs) > k:\\n                heapq.heappop(freqs)\\n        \\n        res = []\\n        for _ in range(k):\\n            res.append(heapq.heappop(freqs)[1])\\n        return res[::-1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 108366,
                "title": "o-nlog-k-priority-queue-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> freq;\\n        for(auto w : words){\\n            freq[w]++;\\n        }\\n        \\n        auto comp = [&](const pair<string,int>& a, const pair<string,int>& b) {\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        };\\n        typedef priority_queue< pair<string,int>, vector<pair<string,int>>, decltype(comp) > my_priority_queue_t;\\n        my_priority_queue_t  pq(comp);\\n        \\n        for(auto w : freq ){\\n            pq.emplace(w.first, w.second);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        \\n        vector<string> output;\\n        while(!pq.empty()){\\n            output.insert(output.begin(), pq.top().first);\\n            pq.pop();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> freq;\\n        for(auto w : words){\\n            freq[w]++;\\n        }\\n        \\n        auto comp = [&](const pair<string,int>& a, const pair<string,int>& b) {\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        };\\n        typedef priority_queue< pair<string,int>, vector<pair<string,int>>, decltype(comp) > my_priority_queue_t;\\n        my_priority_queue_t  pq(comp);\\n        \\n        for(auto w : freq ){\\n            pq.emplace(w.first, w.second);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        \\n        vector<string> output;\\n        while(!pq.empty()){\\n            output.insert(output.begin(), pq.top().first);\\n            pq.pop();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108399,
                "title": "java-o-n-solution-using-hashmap-bucketsort-and-trie-22ms-beat-81",
                "content": "This problem is quite similar to the problem [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/). You can refer to [this post](https://discuss.leetcode.com/topic/44237/java-o-n-solution-bucket-sort) for the solution of the problem.\\n\\nWe can solve this problem with the similar idea:\\nFirstly, we need to calculate the frequency of each word and store the result in a hashmap.\\n\\nSecondly, we will use bucket sort to store words. Why? Because the minimum frequency is greater than or equal to 1 and the maximum frequency is less than or equal to the length of the input string array. \\n\\nThirdly, we can define a trie within each bucket to store all the words with the same frequency. With Trie, it ensures that the lower alphabetical word will be met first, saving the trouble to sort the words within the bucket. \\n\\nFrom the above analysis, we can see the time complexity is O(n).\\nHere is my code:\\n```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        // calculate frequency of each word\\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word : words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1);\\n        }\\n        // build the buckets\\n        TrieNode[] count = new TrieNode[words.length + 1];\\n        for(String word : freqMap.keySet()) {\\n            int freq = freqMap.get(word);\\n            if(count[freq] == null) {\\n                count[freq] = new TrieNode();\\n            }\\n            addWord(count[freq], word);\\n        }\\n        // get k frequent words\\n        List<String> list = new LinkedList<>();\\n        for(int f = count.length - 1; f >= 1 && list.size() < k; f--) {\\n            if(count[f] == null) continue;\\n            getWords(count[f], list, k);\\n        }\\n        return list;\\n    }\\n    \\n    private void getWords(TrieNode node, List<String> list, int k) {\\n        if(node == null) return;\\n        if(node.word != null) {\\n            list.add(node.word);\\n        }\\n        if(list.size() == k) return;\\n        for(int i = 0; i < 26; i++) {\\n            if(node.next[i] != null) {\\n                getWords(node.next[i], list, k);\\n            }\\n        }\\n    }\\n    \\n    private boolean addWord(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            if(curr.next[c - 'a'] == null) {\\n                curr.next[c - 'a'] = new TrieNode();\\n            }\\n            curr = curr.next[c - 'a'];\\n        }\\n        curr.word = word;\\n        return true;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        TrieNode() {\\n            this.next = new TrieNode[26];\\n            this.word = null;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        // calculate frequency of each word\\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word : words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1);\\n        }\\n        // build the buckets\\n        TrieNode[] count = new TrieNode[words.length + 1];\\n        for(String word : freqMap.keySet()) {\\n            int freq = freqMap.get(word);\\n            if(count[freq] == null) {\\n                count[freq] = new TrieNode();\\n            }\\n            addWord(count[freq], word);\\n        }\\n        // get k frequent words\\n        List<String> list = new LinkedList<>();\\n        for(int f = count.length - 1; f >= 1 && list.size() < k; f--) {\\n            if(count[f] == null) continue;\\n            getWords(count[f], list, k);\\n        }\\n        return list;\\n    }\\n    \\n    private void getWords(TrieNode node, List<String> list, int k) {\\n        if(node == null) return;\\n        if(node.word != null) {\\n            list.add(node.word);\\n        }\\n        if(list.size() == k) return;\\n        for(int i = 0; i < 26; i++) {\\n            if(node.next[i] != null) {\\n                getWords(node.next[i], list, k);\\n            }\\n        }\\n    }\\n    \\n    private boolean addWord(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            if(curr.next[c - 'a'] == null) {\\n                curr.next[c - 'a'] = new TrieNode();\\n            }\\n            curr = curr.next[c - 'a'];\\n        }\\n        curr.word = word;\\n        return true;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next;\\n        String word;\\n        TrieNode() {\\n            this.next = new TrieNode[26];\\n            this.word = null;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719962,
                "title": "c-solutio-using-structure-fast-and-easy-solution",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam 95](https://github.com/Yaduttam95)\\n\\n## PLEASE UPVOTE IF YOU LIKE IT\\n\\n```\\nstruct Compare {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# If u reached till here and solution worked for you please upvote it",
                "solutionTags": [],
                "code": "```\\nstruct Compare {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244692,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String,Integer> freq=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            freq.put(words[i],freq.getOrDefault(words[i],0)+1);\\n        }\\n        List<String> res = new ArrayList(freq.keySet());\\n        //sorting\\n        //if two words have the same frequency, then the word with the lower alphabetical order comes first.\\n        //else most frequent words will come first\\n        Collections.sort(res, (w1, w2) -> freq.get(w1).equals(freq.get(w2)) ?\\n                w1.compareTo(w2) : freq.get(w2) - freq.get(w1));\\n\\n        return res.subList(0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String,Integer> freq=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            freq.put(words[i],freq.getOrDefault(words[i],0)+1);\\n        }\\n        List<String> res = new ArrayList(freq.keySet());\\n        //sorting\\n        //if two words have the same frequency, then the word with the lower alphabetical order comes first.\\n        //else most frequent words will come first\\n        Collections.sort(res, (w1, w2) -> freq.get(w1).equals(freq.get(w2)) ?\\n                w1.compareTo(w2) : freq.get(w2) - freq.get(w1));\\n\\n        return res.subList(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449970,
                "title": "python-use-dictionary-and-lambda-beat-94",
                "content": "Use lambda to sort the dictionary in desc order based on words frequency and if frequency are equal then sort dictionary in asc order based on the word alphabet. \\n\\n```\\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dict = {}\\n        for x in words:\\n            if x in dict:\\n                dict[x] += 1\\n            else:\\n                dict[x] = 1\\n        res = sorted(dict, key=lambda x: (-dict[x], x))\\n        return res[:k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dict = {}\\n        for x in words:\\n            if x in dict:\\n                dict[x] += 1\\n            else:\\n                dict[x] = 1\\n        res = sorted(dict, key=lambda x: (-dict[x], x))\\n        return res[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 369128,
                "title": "c-o-nlogk-s-k-solution-using-hashmap-and-priority-queue-clear-analysis",
                "content": "```\\n/*\\nO(N) for hashmap, O(NlogK) for pq --- O(logK) each time\\nS(K) for hashmap, S(K) for pq\\ntrick : whenever we have a new pair, push it to the pq first\\nlet the pq decide the order, and then pop the top if pq.size() > k\\nMin-heap: return int a > int b (keep larger one)\\nlow-alphabetical order : string a < string b (keep lower one)\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> hashmap;\\n        for(string& word : words) {\\n            hashmap[word] += 1;\\n        }\\n        priority_queue<pair<int, string>, vector<pair<int, string>>, MyComp> pq;\\n        for(auto it = hashmap.begin(); it != hashmap.end(); ++it) {\\n            pq.push(make_pair(it->second, it->first));\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<string> res;\\n        while(!pq.empty()) {\\n            res.insert(res.begin(), pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\nprivate:\\n    struct MyComp {\\n        bool operator() (const pair<int, string>& a, const pair<int, string>& b) {\\n            if(a.first != b.first) {\\n                return a.first > b.first;\\n            }\\n            else {\\n                return a.second < b.second;\\n            }\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\nO(N) for hashmap, O(NlogK) for pq --- O(logK) each time\\nS(K) for hashmap, S(K) for pq\\ntrick : whenever we have a new pair, push it to the pq first\\nlet the pq decide the order, and then pop the top if pq.size() > k\\nMin-heap: return int a > int b (keep larger one)\\nlow-alphabetical order : string a < string b (keep lower one)\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> hashmap;\\n        for(string& word : words) {\\n            hashmap[word] += 1;\\n        }\\n        priority_queue<pair<int, string>, vector<pair<int, string>>, MyComp> pq;\\n        for(auto it = hashmap.begin(); it != hashmap.end(); ++it) {\\n            pq.push(make_pair(it->second, it->first));\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<string> res;\\n        while(!pq.empty()) {\\n            res.insert(res.begin(), pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\nprivate:\\n    struct MyComp {\\n        bool operator() (const pair<int, string>& a, const pair<int, string>& b) {\\n            if(a.first != b.first) {\\n                return a.first > b.first;\\n            }\\n            else {\\n                return a.second < b.second;\\n            }\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108355,
                "title": "simplest-python-solution",
                "content": "```\\n    def topKFrequent(self, words, k):\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0) + 1\\n        \\n        ret = sorted(d, key=lambda word: (-d[word], word))\\n        \\n        return ret[:k]\\n```",
                "solutionTags": [],
                "code": "```\\n    def topKFrequent(self, words, k):\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0) + 1\\n        \\n        ret = sorted(d, key=lambda word: (-d[word], word))\\n        \\n        return ret[:k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444221,
                "title": "javascript-solution",
                "content": "#### The idea\\n1. Build a hash and count the frequency\\n2. Sort the hash using frequency or compare strings\\n3. Return the top k results\\n``` javascript\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n    let hash = {};\\n    for (let word of words) {\\n        hash[word] = hash[word]+1||1;\\n    }\\n    let result = Object.keys(hash).sort((a,b)=>{\\n            let countCompare = hash[b] - hash[a];\\n            if (countCompare == 0) return a.localeCompare(b);\\n            else return countCompare;\\n        }   \\n    );\\n    return result.slice(0, k);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n    let hash = {};\\n    for (let word of words) {\\n        hash[word] = hash[word]+1||1;\\n    }\\n    let result = Object.keys(hash).sort((a,b)=>{\\n            let countCompare = hash[b] - hash[a];\\n            if (countCompare == 0) return a.localeCompare(b);\\n            else return countCompare;\\n        }   \\n    );\\n    return result.slice(0, k);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176865,
                "title": "o-nlogk-time-to-o-n-time",
                "content": "### O(nlogk) time\\nIt is a must-have to map a word to its frequency. Since we aim to get k words with largest frequency, we have to map frequency to words and sort frequency decreasingly.\\n**Heap** or **TreeMap** achieve that with `O(n log k)` time complexity.\\n```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> wordToFreq = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreq.put(word, wordToFreq.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        PriorityQueue<String> minHeap = new PriorityQueue<>(\\n            (a, b) -> (\\n                wordToFreq.get(a) == wordToFreq.get(b) \\n                ? b.compareTo(a)\\n                : wordToFreq.get(a) - wordToFreq.get(b)\\n            )\\n        );\\n        \\n        for (String word: wordToFreq.keySet()) {\\n            minHeap.offer(word);\\n            if (minHeap.size() > k)\\n                minHeap.poll();\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        while (!minHeap.isEmpty()) {\\n            res.add(0, minHeap.poll());\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n### O(n + k) time\\n\\nHowever, we could do better using **Bucket Sort** that takes `O(n + k)` time complexity for n is number of elements and k is number of buckets. \\n\\nSince we have to output words lexicographically, we take advantage of **Trie** for it has no sorting costs.\\n\\nThat is, we build a trie consists of all words within the same bucket. And we apply **DFS** to traverse the trie and add words we met to the result list one by one.\\nFinally, we go through buckets from tail to head until we get top K frequent words.\\n****\\n```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n        int n = words.length;\\n        ArrayList<String> bucketResult, result = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>(); // Key: word, value: frequency.\\n        ArrayList<String>[] buckets = new ArrayList[n + 1]; // For bucket sort.\\n        \\n        for (String word : words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n      \\n        for (String word : map.keySet()) {\\n            int freq = map.get(word);\\n            if (buckets[freq] == null)\\n                buckets[freq] = new ArrayList<>();\\n            buckets[freq].add(word);\\n        }\\n        \\n        for (int i = n; i > 0; i--) {\\n            ArrayList<String> list = buckets[i]; \\n            if (list != null) {\\n                bucketResult = new ArrayList<>();\\n                getWords(buildTrie(list), bucketResult);\\n                if (bucketResult.size() > k){\\n                    for (int j = 0; j < k; j++)\\n                        result.add(bucketResult.get(j));\\n                    break;\\n                }\\n                k -= bucketResult.size();\\n                result.addAll(bucketResult);\\n                if (k == 0)\\n                    break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    private void getWords(Node parentPtr, ArrayList<String> result) {\\n        \\n        if (parentPtr.content != null) {\\n            result.add(parentPtr.content);\\n        }\\n        \\n        for (Node child : parentPtr.children) {\\n            if (child != null) {\\n                getWords(child, result);\\n            }\\n        }\\n        \\n    }\\n    \\n    private Node buildTrie(ArrayList<String> list) {\\n        \\n        Node root = new Node();\\n\\n        Node ptr;\\n        for (String word : list) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null) \\n                    ptr.children[order] = new Node();\\n                ptr = ptr.children[order];\\n            }\\n            ptr.content = word;\\n        }\\n        \\n        return root;        \\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        String content;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            content = null;\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> wordToFreq = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreq.put(word, wordToFreq.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        PriorityQueue<String> minHeap = new PriorityQueue<>(\\n            (a, b) -> (\\n                wordToFreq.get(a) == wordToFreq.get(b) \\n                ? b.compareTo(a)\\n                : wordToFreq.get(a) - wordToFreq.get(b)\\n            )\\n        );\\n        \\n        for (String word: wordToFreq.keySet()) {\\n            minHeap.offer(word);\\n            if (minHeap.size() > k)\\n                minHeap.poll();\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        while (!minHeap.isEmpty()) {\\n            res.add(0, minHeap.poll());\\n        }\\n        return res;\\n    }\\n```\n```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n        int n = words.length;\\n        ArrayList<String> bucketResult, result = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>(); // Key: word, value: frequency.\\n        ArrayList<String>[] buckets = new ArrayList[n + 1]; // For bucket sort.\\n        \\n        for (String word : words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n      \\n        for (String word : map.keySet()) {\\n            int freq = map.get(word);\\n            if (buckets[freq] == null)\\n                buckets[freq] = new ArrayList<>();\\n            buckets[freq].add(word);\\n        }\\n        \\n        for (int i = n; i > 0; i--) {\\n            ArrayList<String> list = buckets[i]; \\n            if (list != null) {\\n                bucketResult = new ArrayList<>();\\n                getWords(buildTrie(list), bucketResult);\\n                if (bucketResult.size() > k){\\n                    for (int j = 0; j < k; j++)\\n                        result.add(bucketResult.get(j));\\n                    break;\\n                }\\n                k -= bucketResult.size();\\n                result.addAll(bucketResult);\\n                if (k == 0)\\n                    break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    private void getWords(Node parentPtr, ArrayList<String> result) {\\n        \\n        if (parentPtr.content != null) {\\n            result.add(parentPtr.content);\\n        }\\n        \\n        for (Node child : parentPtr.children) {\\n            if (child != null) {\\n                getWords(child, result);\\n            }\\n        }\\n        \\n    }\\n    \\n    private Node buildTrie(ArrayList<String> list) {\\n        \\n        Node root = new Node();\\n\\n        Node ptr;\\n        for (String word : list) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null) \\n                    ptr.children[order] = new Node();\\n                ptr = ptr.children[order];\\n            }\\n            ptr.content = word;\\n        }\\n        \\n        return root;        \\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        String content;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            content = null;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657648,
                "title": "simple-4-lines-using-heap-with-explanation",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        #Have a dict of word and its freq\\n        counts = collections.Counter(words)\\n        \\n        #get a array wchich will have a tuple of word and count\\n        heap = [(-count, word) for word, count in counts.items()]\\n        \\n        #as default heap structure in python min heap and we want max heap\\n        # to get top frequent word, we will do a make the counter negative\\n        #so that the topmost element will come up (i.e -8 < -2 so in min heap -8 will come up wich is actually 8)\\n        \\n        heapq.heapify(heap) #creating heap in place\\n        #by deualt it will sort by fre then word\\n        \\n        return [heapq.heappop(heap)[1] for _ in range(k)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        #Have a dict of word and its freq\\n        counts = collections.Counter(words)\\n        \\n        #get a array wchich will have a tuple of word and count\\n        heap = [(-count, word) for word, count in counts.items()]\\n        \\n        #as default heap structure in python min heap and we want max heap\\n        # to get top frequent word, we will do a make the counter negative\\n        #so that the topmost element will come up (i.e -8 < -2 so in min heap -8 will come up wich is actually 8)\\n        \\n        heapq.heapify(heap) #creating heap in place\\n        #by deualt it will sort by fre then word\\n        \\n        return [heapq.heappop(heap)[1] for _ in range(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112651,
                "title": "simple-c-solutions",
                "content": "1. using map & bucket sort, O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> cnt;\\n        for (auto& w : words)\\n            ++cnt[w];\\n        \\n        vector<vector<string>> bucket(words.size());\\n        for (auto it : cnt)\\n            bucket[it.second].push_back(it.first);\\n        \\n        vector<string> res;\\n        for (int i = (int)bucket.size() - 1; k > 0 && i >= 0; i--) {\\n            if (bucket[i].empty())\\n                continue;\\n            int n = min(k, (int)bucket[i].size());\\n            res.insert(res.end(), bucket[i].begin(), bucket[i].begin() + n);\\n            k -= n;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n2. using hash map & priority queue, O((n + k)logn)\\n```\\nclass Solution {\\npublic:\\n    struct Comp {\\n        bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) const {\\n            if (lhs.first != rhs.first)\\n                return lhs.first < rhs.first;\\n            return lhs.second > rhs.second;\\n        }\\n    };\\n\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> cnt;\\n        for (auto& w : words)\\n            ++cnt[w];\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Comp> Q;\\n        for (auto it : cnt)\\n            Q.emplace(it.second, it.first);\\n        \\n        vector<string> res;\\n        while (k-- > 0 && !Q.empty()) {\\n            res.push_back(Q.top().second);\\n            Q.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> cnt;\\n        for (auto& w : words)\\n            ++cnt[w];\\n        \\n        vector<vector<string>> bucket(words.size());\\n        for (auto it : cnt)\\n            bucket[it.second].push_back(it.first);\\n        \\n        vector<string> res;\\n        for (int i = (int)bucket.size() - 1; k > 0 && i >= 0; i--) {\\n            if (bucket[i].empty())\\n                continue;\\n            int n = min(k, (int)bucket[i].size());\\n            res.insert(res.end(), bucket[i].begin(), bucket[i].begin() + n);\\n            k -= n;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct Comp {\\n        bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) const {\\n            if (lhs.first != rhs.first)\\n                return lhs.first < rhs.first;\\n            return lhs.second > rhs.second;\\n        }\\n    };\\n\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> cnt;\\n        for (auto& w : words)\\n            ++cnt[w];\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Comp> Q;\\n        for (auto it : cnt)\\n            Q.emplace(it.second, it.first);\\n        \\n        vector<string> res;\\n        while (k-- > 0 && !Q.empty()) {\\n            res.push_back(Q.top().second);\\n            Q.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720232,
                "title": "java-easy-solution-with-explanation-hashmap",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n  public List<String> topKFrequent(String[] words, int k) {\\n        \\n        // map hold the word: counts\\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        // sort the map by frequency high->low order, sort words lexi order\\n        PriorityQueue<Map.Entry<String, Integer>> heap = new PriorityQueue<>(\\n            (a,b)->{\\n                if(a.getValue() != b.getValue())\\n                    return a.getValue().compareTo(b.getValue());\\n                return -a.getKey().compareTo(b.getKey());\\n            }\\n        );\\n        \\n        // fill the map\\n        for(String word: words){\\n            map.merge(word, 1, Integer::sum);\\n        }\\n        \\n        // put into heap\\n        for(Map.Entry<String, Integer> entry: map.entrySet()){\\n            heap.offer(entry);\\n            if(heap.size() > k)\\n                heap.poll();\\n        }\\n        \\n        // pop out the answer\\n        List<String> ans = new ArrayList();\\n        while(heap.size() > 0)\\n            ans.add(heap.poll().getKey());\\n        \\n        // check the order\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<String> topKFrequent(String[] words, int k) {\\n        \\n        // map hold the word: counts\\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        // sort the map by frequency high->low order, sort words lexi order\\n        PriorityQueue<Map.Entry<String, Integer>> heap = new PriorityQueue<>(\\n            (a,b)->{\\n                if(a.getValue() != b.getValue())\\n                    return a.getValue().compareTo(b.getValue());\\n                return -a.getKey().compareTo(b.getKey());\\n            }\\n        );\\n        \\n        // fill the map\\n        for(String word: words){\\n            map.merge(word, 1, Integer::sum);\\n        }\\n        \\n        // put into heap\\n        for(Map.Entry<String, Integer> entry: map.entrySet()){\\n            heap.offer(entry);\\n            if(heap.size() > k)\\n                heap.poll();\\n        }\\n        \\n        // pop out the answer\\n        List<String> ans = new ArrayList();\\n        while(heap.size() > 0)\\n            ans.add(heap.poll().getKey());\\n        \\n        // check the order\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720142,
                "title": "fastest-python-solution-tc-o-nlogk-sc-o-n",
                "content": "```\\nfrom collections import defaultdict\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        cnt=defaultdict(lambda :[0,\"\"])\\n        for i in words:\\n            cnt[i]=[cnt[i][0]-1,i]\\n        lst=list(cnt.values())\\n        heapq.heapify(lst)\\n        lst=heapq.nsmallest(k,lst)\\n        ans=[]\\n        for i in lst:\\n            ans.append(i[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        cnt=defaultdict(lambda :[0,\"\"])\\n        for i in words:\\n            cnt[i]=[cnt[i][0]-1,i]\\n        lst=list(cnt.values())\\n        heapq.heapify(lst)\\n        lst=heapq.nsmallest(k,lst)\\n        ans=[]\\n        for i in lst:\\n            ans.append(i[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143211,
                "title": "python-o-nlogk-solution",
                "content": "```\\nclass FreqWord(object):\\n    def __init__(self, freq, word):\\n        self.freq = freq\\n        self.word = word\\n\\n    def __cmp__(self, other):\\n        if self.freq != other.freq:\\n            return cmp(self.freq, other.freq)\\n        else:\\n            return cmp(other.word, self.word)\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        count = collections.Counter(words)\\n        heap = []\\n        for word, freq in count.items():\\n            heapq.heappush(heap, FreqWord(freq, word))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n\\n        return [heapq.heappop(heap).word for _ in xrange(k)][::-1]    \\n```",
                "solutionTags": [],
                "code": "```\\nclass FreqWord(object):\\n    def __init__(self, freq, word):\\n        self.freq = freq\\n        self.word = word\\n\\n    def __cmp__(self, other):\\n        if self.freq != other.freq:\\n            return cmp(self.freq, other.freq)\\n        else:\\n            return cmp(other.word, self.word)\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        count = collections.Counter(words)\\n        heap = []\\n        for word, freq in count.items():\\n            heapq.heappush(heap, FreqWord(freq, word))\\n            if len(heap) > k:\\n                heapq.heappop(heap)\\n\\n        return [heapq.heappop(heap).word for _ in xrange(k)][::-1]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 108356,
                "title": "c-linq-one-liner-sorry-java-folks",
                "content": "I have no idea what Linq does under the hood, but I would expect O(n*logn) time (due to OrderBy/sort)  and  O(n) space (due to projections etc.)\\n\\n582ms (beats 33%), which is only 20% worse than the best C# submission at 485ms\\n\\nat least, this is readable: \\n```\\n    public IList<string> TopKFrequent(string[] words, int k) \\n    {\\n        return words.GroupBy(x => x)\\n                .Select(x => new { word = x.Key, count = x.Count() })\\n                .OrderByDescending(x => x.count)\\n                .ThenBy(x => x.word)\\n                .Select(x => x.word)\\n                .Take(k)\\n                .ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> TopKFrequent(string[] words, int k) \\n    {\\n        return words.GroupBy(x => x)\\n                .Select(x => new { word = x.Key, count = x.Count() })\\n                .OrderByDescending(x => x.count)\\n                .ThenBy(x => x.word)\\n                .Select(x => x.word)\\n                .Take(k)\\n                .ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774414,
                "title": "easy-understandable-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(pair<string,int> p1, pair<string,int> p2)\\n    {\\n        if(p1.second>p2.second || (p1.second==p2.second && p1.first<p2.first))\\n            return true;\\n        return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> m1;\\n        \\n        for(int i=0; i<words.size(); i++)\\n            m1[words[i]]++;\\n        \\n        vector<pair<string,int>> v1;\\n        for(auto it=m1.begin(); it!=m1.end(); it++)\\n            v1.push_back({it->first,it->second});\\n        \\n        sort(v1.begin(),v1.end(),comparator);\\n        \\n        vector<string> ans;\\n        for(int i=0; i<k; i++)\\n        {\\n            ans.push_back(v1[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(pair<string,int> p1, pair<string,int> p2)\\n    {\\n        if(p1.second>p2.second || (p1.second==p2.second && p1.first<p2.first))\\n            return true;\\n        return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> m1;\\n        \\n        for(int i=0; i<words.size(); i++)\\n            m1[words[i]]++;\\n        \\n        vector<pair<string,int>> v1;\\n        for(auto it=m1.begin(); it!=m1.end(); it++)\\n            v1.push_back({it->first,it->second});\\n        \\n        sort(v1.begin(),v1.end(),comparator);\\n        \\n        vector<string> ans;\\n        for(int i=0; i<k; i++)\\n        {\\n            ans.push_back(v1[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538903,
                "title": "python-o-n-log-k-code-using-heap-to-sort-by-multiple-attributes",
                "content": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Node:\\n    def __init__(self, word, freq):\\n        self.word = word\\n        self.freq = freq\\n    \\n    def __lt__(self, other):\\n        if self.freq == other.freq:\\n            return self.word > other.word\\n        return self.freq < other.freq\\n    \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        mapper = defaultdict(int)\\n        for word in words:\\n            mapper[word] += 1\\n        \\n        h = list()\\n        for word, freq in mapper.items():\\n            node = Node(word, freq)\\n            if len(h) == k:\\n                heappushpop(h, node)\\n            else:\\n                heappush(h, node)\\n                \\n        result = list()\\n        while h:\\n            result.append(heappop(h).word)\\n        return result[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heappushpop\\n\\nclass Node:\\n    def __init__(self, word, freq):\\n        self.word = word\\n        self.freq = freq\\n    \\n    def __lt__(self, other):\\n        if self.freq == other.freq:\\n            return self.word > other.word\\n        return self.freq < other.freq\\n    \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        mapper = defaultdict(int)\\n        for word in words:\\n            mapper[word] += 1\\n        \\n        h = list()\\n        for word, freq in mapper.items():\\n            node = Node(word, freq)\\n            if len(h) == k:\\n                heappushpop(h, node)\\n            else:\\n                heappush(h, node)\\n                \\n        result = list()\\n        while h:\\n            result.append(heappop(h).word)\\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428419,
                "title": "c-unordered-map-priority-queue",
                "content": "```\\nclass cmp{\\n    public:\\n    bool operator()(pair<int,string> a, pair<int,string> b) const{\\n        if(a.first < b.first) return true;\\n        else if(a.first == b.first && a.second>b.second) return true;\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> ump;\\n        for(auto &w : words) ump[w]++;\\n        \\n        priority_queue<pair<int,string>,vector<pair<int,string>>,cmp> pq;\\n        for(auto &m : ump) pq.push({m.second,m.first});\\n        \\n        vector<string> vec;\\n        while(k--){\\n            vec.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass cmp{\\n    public:\\n    bool operator()(pair<int,string> a, pair<int,string> b) const{\\n        if(a.first < b.first) return true;\\n        else if(a.first == b.first && a.second>b.second) return true;\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> ump;\\n        for(auto &w : words) ump[w]++;\\n        \\n        priority_queue<pair<int,string>,vector<pair<int,string>>,cmp> pq;\\n        for(auto &m : ump) pq.push({m.second,m.first});\\n        \\n        vector<string> vec;\\n        while(k--){\\n            vec.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651714,
                "title": "javascript-structured-min-heap-simulated-for-interview",
                "content": "* Whenever I have an interview and the problem requires a heap, I always use this mockup. I let the interviewer know that there is no native priority queue in javascript so I use that simulation. Then I can focus on the algorithm iteself, which is what matters. \\n* What do you usually do in javascript algo interviews where a p.queue is required ?\\n\\n```javascript\\nconst topKFrequent = (words, k) => {\\n    if(!words || words.length === 0) return [];\\n    \\n    const freq = getFrequencies(words);\\n    const minHeap = new Heap(compareFunc);\\n    \\n    for(const word of freq.keys()) {\\n        const tuple = [word, freq.get(word)];\\n        minHeap.insert(tuple);\\n        if(minHeap.size > k) minHeap.extract();\\n    }\\n    \\n    const ans = new Array();\\n    while(minHeap.size > 0) ans.unshift(minHeap.extract()[0]);\\n          \\n    return ans;\\n};\\n\\nconst compareFunc = (a, b) => {\\n    if(a[1] === b[1]) {\\n        if(a[0] === b[0]) return 0;\\n        if(a[0] < b[0]) return 1;\\n        return -1;\\n    }\\n    \\n    return a[1] - b[1];\\n};\\n\\nconst getFrequencies = (words) => {\\n    const freq = new Map();\\n    words.forEach(word => {\\n        if(!freq.has(word)) freq.set(word, 0);\\n        freq.set(word, freq.get(word) + 1);\\n    });\\n    \\n    return freq;\\n};\\n\\nclass Heap {\\n    constructor(compareFunc) {\\n        this.compareFunc = compareFunc;\\n        this.heap = new Array();\\n    }\\n    \\n    insert(val) {\\n        this.heap.push(val);\\n        this.heap.sort(this.compareFunc);\\n    }\\n    \\n    extract() {\\n        return this.heap.shift();\\n    }\\n    \\n    peek() {\\n        return this.heap[0];\\n    }\\n    \\n    get size() {\\n        return this.heap.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\nconst topKFrequent = (words, k) => {\\n    if(!words || words.length === 0) return [];\\n    \\n    const freq = getFrequencies(words);\\n    const minHeap = new Heap(compareFunc);\\n    \\n    for(const word of freq.keys()) {\\n        const tuple = [word, freq.get(word)];\\n        minHeap.insert(tuple);\\n        if(minHeap.size > k) minHeap.extract();\\n    }\\n    \\n    const ans = new Array();\\n    while(minHeap.size > 0) ans.unshift(minHeap.extract()[0]);\\n          \\n    return ans;\\n};\\n\\nconst compareFunc = (a, b) => {\\n    if(a[1] === b[1]) {\\n        if(a[0] === b[0]) return 0;\\n        if(a[0] < b[0]) return 1;\\n        return -1;\\n    }\\n    \\n    return a[1] - b[1];\\n};\\n\\nconst getFrequencies = (words) => {\\n    const freq = new Map();\\n    words.forEach(word => {\\n        if(!freq.has(word)) freq.set(word, 0);\\n        freq.set(word, freq.get(word) + 1);\\n    });\\n    \\n    return freq;\\n};\\n\\nclass Heap {\\n    constructor(compareFunc) {\\n        this.compareFunc = compareFunc;\\n        this.heap = new Array();\\n    }\\n    \\n    insert(val) {\\n        this.heap.push(val);\\n        this.heap.sort(this.compareFunc);\\n    }\\n    \\n    extract() {\\n        return this.heap.shift();\\n    }\\n    \\n    peek() {\\n        return this.heap[0];\\n    }\\n    \\n    get size() {\\n        return this.heap.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108359,
                "title": "java-hashmap-maxheap-o-nlogn",
                "content": "Below solution is MaxHeap with O(nlogn) time.  For O(nlogk), please refer to [min heap solution](https://discuss.leetcode.com/topic/107751/my-simple-java-solution-using-hashmap-priorityqueue-o-nlogk-time-o-n-space)\\n\\n```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer > map = new HashMap<>();\\n        for (String s : words)  map.put(s, map.getOrDefault(s,0) + 1);  // Frequent hashmap\\n        \\n        PriorityQueue<Map.Entry<String,Integer>> maxHeap = new PriorityQueue<>(k, (a,b) -> \\n            a.getValue()==b.getValue() ? a.getKey().compareTo(b.getKey()) : b.getValue()-a.getValue()); \\n        // if same frequency, then sort alphabetical .  \\n        \\n        for (Map.Entry<String,Integer> entry : map.entrySet() ) maxHeap.add(entry);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (res.size() < k) res.add(maxHeap.poll().getKey());  //add top k\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer > map = new HashMap<>();\\n        for (String s : words)  map.put(s, map.getOrDefault(s,0) + 1);  // Frequent hashmap\\n        \\n        PriorityQueue<Map.Entry<String,Integer>> maxHeap = new PriorityQueue<>(k, (a,b) -> \\n            a.getValue()==b.getValue() ? a.getKey().compareTo(b.getKey()) : b.getValue()-a.getValue()); \\n        // if same frequency, then sort alphabetical .  \\n        \\n        for (Map.Entry<String,Integer> entry : map.entrySet() ) maxHeap.add(entry);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (res.size() < k) res.add(maxHeap.poll().getKey());  //add top k\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720208,
                "title": "10-line-easy-solution-using-defaultdict-in-o-nlog-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in words:\\n            dc[a]+=1\\n        arr=[]\\n        for a in dc:\\n            arr.append([dc[a],a])\\n        arr.sort(key=lambda x:(1/x[0],x[1]))\\n        ans=[]\\n        for i in range(k):\\n            ans.append(arr[i][1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in words:\\n            dc[a]+=1\\n        arr=[]\\n        for a in dc:\\n            arr.append([dc[a],a])\\n        arr.sort(key=lambda x:(1/x[0],x[1]))\\n        ans=[]\\n        for i in range(k):\\n            ans.append(arr[i][1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720074,
                "title": "python-3-3-lines-w-example-t-m-98-54",
                "content": "Yes, I know this code could be one line, but it\\'s easier to see how it works with at least three lines.\\n```\\nclass Solution:\\n    def topKFrequent(self, words: list[str], k: int) -> list[str]:\\n\\t\\n                                                    # Ex: words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        c = Counter(words)                          #         c = {\\'i\\': 2, \\'love\\': 2, \\'leetcode\\': 1, \\'coding\\': 1}\\n        \\n        ans = sorted(c, key = lambda x: (-c[x],x))  #       ans = [\\'i\\', \\'love\\', \\'coding\\', \\'leetcode\\']\\n                                                    #             sort keys are [(-2,\\'i\\'), (-2,\\'love\\'), (-1,\\'coding\\'), (-1,\\'leetcode\\')]\\n\\n        return ans[:k]                              #   ans[:2] = [\\'i\\', \\'love\\']\\n\\n```\\n[https://leetcode.com/submissions/detail/825570963/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: list[str], k: int) -> list[str]:\\n\\t\\n                                                    # Ex: words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        c = Counter(words)                          #         c = {\\'i\\': 2, \\'love\\': 2, \\'leetcode\\': 1, \\'coding\\': 1}\\n        \\n        ans = sorted(c, key = lambda x: (-c[x],x))  #       ans = [\\'i\\', \\'love\\', \\'coding\\', \\'leetcode\\']\\n                                                    #             sort keys are [(-2,\\'i\\'), (-2,\\'love\\'), (-1,\\'coding\\'), (-1,\\'leetcode\\')]\\n\\n        return ans[:k]                              #   ans[:2] = [\\'i\\', \\'love\\']\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070499,
                "title": "min-heap-o-n-logk-time-python-easy-to-understand",
                "content": "```\\n\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop, heapify\\n\\n# HELPER CLASS\\nclass Item(object):\\n    def __init__(self, word, freq):\\n        self.word = word\\n        self.freq = freq\\n    \\n    # override the comparison operator - heapq internally uses this for comparison\\n    def __lt__(self, other):\\n        if self.freq == other.freq:\\n            # this step is important!\\n            # since we need word with lower aplha order first in FINAL RESULT\\n            # and this Final result will be achieved by reversing the temp result array\\n            # SO HERE, we return self.word>other.word instead of self.word<other.word \\n            # Think :)\\n            return self.word > other.word \\n        \\n        return self.freq < other.freq\\n            \\n# MAIN CLASS \\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \\n        # edge cases\\n        if not words or not k:\\n            return []\\n        elif len(words) == 1:\\n            return [words[0]]\\n        \\n        # create map\\n        dic = defaultdict(lambda:0)\\n        for word in words:\\n            dic[word]+=1\\n        \\n        # min heap\\n        min_heap = []\\n        heapify(min_heap)\\n        for word,freq in dic.items():\\n            item = Item(word, freq)\\n            \\n            if(len(min_heap) < k): # if we still have capacity\\n                heappush(min_heap, item) # normal push\\n                \\n\\t\\t\\t# else\\n            elif(item > min_heap[0]): # if item is greater than the min item in heap\\n                heappop(min_heap) # remove it\\n                heappush(min_heap, item) # push the new item\\n        result = []\\n\\n        while(min_heap): # pop all elements from our heap and push in \\'result\\' array\\n            result.append(heappop(min_heap).word)\\n\\n\\t\\t# return reversed result as our FINAL RESULT since we need most frequent first\\n        return result[::-1] \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop, heapify\\n\\n# HELPER CLASS\\nclass Item(object):\\n    def __init__(self, word, freq):\\n        self.word = word\\n        self.freq = freq\\n    \\n    # override the comparison operator - heapq internally uses this for comparison\\n    def __lt__(self, other):\\n        if self.freq == other.freq:\\n            # this step is important!\\n            # since we need word with lower aplha order first in FINAL RESULT\\n            # and this Final result will be achieved by reversing the temp result array\\n            # SO HERE, we return self.word>other.word instead of self.word<other.word \\n            # Think :)\\n            return self.word > other.word \\n        \\n        return self.freq < other.freq\\n            \\n# MAIN CLASS \\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \\n        # edge cases\\n        if not words or not k:\\n            return []\\n        elif len(words) == 1:\\n            return [words[0]]\\n        \\n        # create map\\n        dic = defaultdict(lambda:0)\\n        for word in words:\\n            dic[word]+=1\\n        \\n        # min heap\\n        min_heap = []\\n        heapify(min_heap)\\n        for word,freq in dic.items():\\n            item = Item(word, freq)\\n            \\n            if(len(min_heap) < k): # if we still have capacity\\n                heappush(min_heap, item) # normal push\\n                \\n\\t\\t\\t# else\\n            elif(item > min_heap[0]): # if item is greater than the min item in heap\\n                heappop(min_heap) # remove it\\n                heappush(min_heap, item) # push the new item\\n        result = []\\n\\n        while(min_heap): # pop all elements from our heap and push in \\'result\\' array\\n            result.append(heappop(min_heap).word)\\n\\n\\t\\t# return reversed result as our FINAL RESULT since we need most frequent first\\n        return result[::-1] \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721452,
                "title": "java-stream-api-memory-usage-less-than-83-39",
                "content": "\\n```java\\npublic List<String> topKFrequent(String[] words, int k) {\\n        TreeMap<String, Integer> map = new TreeMap<>(String::compareTo);\\n        Arrays.stream(words).forEach(x -> map.put(x, map.getOrDefault(x, 0) + 1));\\n        return map.entrySet().stream()\\n            .sorted((o1, o2) -> Integer.compare(o2.getValue(), o1.getValue()))\\n            .map(Map.Entry::getKey)\\n            .limit(k)\\n            .collect(Collectors.toList());\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\npublic List<String> topKFrequent(String[] words, int k) {\\n        TreeMap<String, Integer> map = new TreeMap<>(String::compareTo);\\n        Arrays.stream(words).forEach(x -> map.put(x, map.getOrDefault(x, 0) + 1));\\n        return map.entrySet().stream()\\n            .sorted((o1, o2) -> Integer.compare(o2.getValue(), o1.getValue()))\\n            .map(Map.Entry::getKey)\\n            .limit(k)\\n            .collect(Collectors.toList());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573662,
                "title": "python-2-lines-heap",
                "content": "The idea is to leverage the heap data structure, comparing elements by frequency (in decreasing order) and then by lexicographical order (increasing).\\nPython has all the necessary tools included in the standard library, no need to reinvent the wheel here.\\n```\\nfrom heapq import nsmallest\\nfrom collections import Counter\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq = Counter(words)\\n        return nsmallest(k, freq.keys(), key=lambda x: (-freq[x], x))\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import nsmallest\\nfrom collections import Counter\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq = Counter(words)\\n        return nsmallest(k, freq.keys(), key=lambda x: (-freq[x], x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137674,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n    func topKFrequent(_ words: [String], _ k: Int) -> [String] {\\n        var frequency = [String: Int]()\\n        \\n        for word in words {\\n            frequency[word] = (frequency[word] ?? 0) + 1\\n        }\\n        return Array(frequency.keys.sorted{\\n            let freq1 = frequency[$0] ?? 0\\n            let freq2 = frequency[$1] ?? 0\\n            if freq1 == freq2 {\\n                return $0 < $1\\n            } else {\\n                return freq1 > freq2\\n            }\\n        }.prefix(k))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func topKFrequent(_ words: [String], _ k: Int) -> [String] {\\n        var frequency = [String: Int]()\\n        \\n        for word in words {\\n            frequency[word] = (frequency[word] ?? 0) + 1\\n        }\\n        return Array(frequency.keys.sorted{\\n            let freq1 = frequency[$0] ?? 0\\n            let freq2 = frequency[$1] ?? 0\\n            if freq1 == freq2 {\\n                return $0 < $1\\n            } else {\\n                return freq1 > freq2\\n            }\\n        }.prefix(k))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720272,
                "title": "c-hashmap-pq-easy-to-understand",
                "content": "* ***Using Hashmap && Priority Queue***\\n\\n* ***Time complexity :- O(NlogK)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // comparator\\n    \\n    struct comparator\\n    {\\n        bool operator() (pair<int, string>& a, pair<int, string>& b)\\n        {\\n            if(a.first == b.first)           // if frequency are equal put lexicographically greater element on top\\n            {\\n                return a.second < b.second;\\n            }\\n            else                            // if frequency are not equal put the elements on top which has less frequency\\n            {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        \\n        int n = words.size();\\n        \\n        // declare a map which store the frequency of words\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(auto word : words)\\n        {\\n            mp[word]++;\\n        }\\n        \\n        // declare a priority queue\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, comparator> pq;\\n        \\n        for(auto x : mp)\\n        {\\n            if(pq.size() < k)             // firstly push k elements into pq\\n            {\\n                pq.push({x.second, x.first});\\n            }\\n            else\\n            {\\n                if(pq.top().first < x.second || (pq.top().first == x.second && pq.top().second > x.first))\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({x.second, x.first});\\n                }\\n            }\\n        }\\n        \\n        // push all the elements from pq to res\\n        \\n        vector<string> res;\\n        \\n        while(!pq.empty())\\n        {\\n            res.push_back(pq.top().second);\\n            \\n            pq.pop();\\n        }\\n        \\n        // reverse the res\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // comparator\\n    \\n    struct comparator\\n    {\\n        bool operator() (pair<int, string>& a, pair<int, string>& b)\\n        {\\n            if(a.first == b.first)           // if frequency are equal put lexicographically greater element on top\\n            {\\n                return a.second < b.second;\\n            }\\n            else                            // if frequency are not equal put the elements on top which has less frequency\\n            {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        \\n        int n = words.size();\\n        \\n        // declare a map which store the frequency of words\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(auto word : words)\\n        {\\n            mp[word]++;\\n        }\\n        \\n        // declare a priority queue\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, comparator> pq;\\n        \\n        for(auto x : mp)\\n        {\\n            if(pq.size() < k)             // firstly push k elements into pq\\n            {\\n                pq.push({x.second, x.first});\\n            }\\n            else\\n            {\\n                if(pq.top().first < x.second || (pq.top().first == x.second && pq.top().second > x.first))\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({x.second, x.first});\\n                }\\n            }\\n        }\\n        \\n        // push all the elements from pq to res\\n        \\n        vector<string> res;\\n        \\n        while(!pq.empty())\\n        {\\n            res.push_back(pq.top().second);\\n            \\n            pq.pop();\\n        }\\n        \\n        // reverse the res\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589570,
                "title": "python-3-solutions-on-sorting-heap-and-trie",
                "content": "Solution 1: **Sorting**\\n**Complexity**: Time O(NlogN), N is the length of `words`. Space O(N)\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counts = collections.Counter(words)\\n        res = []\\n        for w in sorted(counts, key=lambda w: (-counts[w], w)):\\n            res.append(w)\\n            if len(res) == k: break\\n        return res\\n```\\n\\nSolution 2: **Heap**\\n**Complexity**: Time O(N + klogN), N is the length of `words`, `heapq.heapify` is O(N), and for each k, `heapq.heappop` is O(logN). Space O(N)\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        pq = [(-t, w)for w, t in collections.Counter(words).items()]\\n        heapq.heapify(pq)\\n        return [heapq.heappop(pq)[1] for _ in range(k)]\\n```\\n\\nSolution 3: **Trie + BFS**\\n**Complexity**: Time O(N + klogN), N is the length of `words`, k is `k`. Space O(N)\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.word = \\'\\'\\n        self.freq = 0\\n        \\n    def __lt__(self, other):\\n        return self.freq > other.freq if self.freq != other.freq else self.word < other.word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word: str) -> None:\\n        root = self.root\\n        for c in word:\\n            if c not in root.children:\\n                root.children[c] = TrieNode()\\n            root = root.children[c] \\n        root.is_word = True\\n        root.word = word\\n        root.freq += 1\\n    \\n    def topK(self, k):\\n        q, pq = collections.deque([self.root]), []\\n        while q:\\n            node = q.popleft()\\n            if node.is_word: heapq.heappush(pq, node)\\n            for _, nxt in node.children.items():\\n                q.append(nxt)\\n        return heapq.nsmallest(k, pq)\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n        return [node.word for node in trie.topK(k)]\\n```",
                "solutionTags": [
                    "Trie",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counts = collections.Counter(words)\\n        res = []\\n        for w in sorted(counts, key=lambda w: (-counts[w], w)):\\n            res.append(w)\\n            if len(res) == k: break\\n        return res\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        pq = [(-t, w)for w, t in collections.Counter(words).items()]\\n        heapq.heapify(pq)\\n        return [heapq.heappop(pq)[1] for _ in range(k)]\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.word = \\'\\'\\n        self.freq = 0\\n        \\n    def __lt__(self, other):\\n        return self.freq > other.freq if self.freq != other.freq else self.word < other.word\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word: str) -> None:\\n        root = self.root\\n        for c in word:\\n            if c not in root.children:\\n                root.children[c] = TrieNode()\\n            root = root.children[c] \\n        root.is_word = True\\n        root.word = word\\n        root.freq += 1\\n    \\n    def topK(self, k):\\n        q, pq = collections.deque([self.root]), []\\n        while q:\\n            node = q.popleft()\\n            if node.is_word: heapq.heappush(pq, node)\\n            for _, nxt in node.children.items():\\n                q.append(nxt)\\n        return heapq.nsmallest(k, pq)\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        trie = Trie()\\n        for w in words:\\n            trie.insert(w)\\n        return [node.word for node in trie.topK(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512357,
                "title": "simple-java-brute-force-method-clean-code-w-comments",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        // Hande null data and edge cases\\n        if (words == null | words.length == 0) return new ArrayList<>();\\n        \\n        // Use a map to keep track of counts\\n        Map<String, Integer> map = new HashMap<>();\\n        // Use a list to keep track of words, to then sort them\\n        List<String> list = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            // Count the # of times a words appears\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n            // Load only unique words to list\\n            if (!list.contains(word)) list.add(word);\\n        }\\n        \\n        Collections.sort(list, (String a, String b) -> {\\n                int aCount = map.get(a);\\n                int bCount = map.get(b);\\n            \\n                // If the counts are equal, then use String.compareTo to lexigraphically compare the strings\\n                if (aCount == bCount) {\\n                    return a.compareTo(b);\\n                } else {  // Else sort by greatest count\\n                    return bCount - aCount;\\n                }\\n            });\\n        \\n        // Return a list with only up to k elements\\n        return list.subList(0, k);\\n    }\\n}\\n```\\nTime Complexity: O(n log n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        // Hande null data and edge cases\\n        if (words == null | words.length == 0) return new ArrayList<>();\\n        \\n        // Use a map to keep track of counts\\n        Map<String, Integer> map = new HashMap<>();\\n        // Use a list to keep track of words, to then sort them\\n        List<String> list = new ArrayList<>();\\n        \\n        for (String word : words) {\\n            // Count the # of times a words appears\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n            // Load only unique words to list\\n            if (!list.contains(word)) list.add(word);\\n        }\\n        \\n        Collections.sort(list, (String a, String b) -> {\\n                int aCount = map.get(a);\\n                int bCount = map.get(b);\\n            \\n                // If the counts are equal, then use String.compareTo to lexigraphically compare the strings\\n                if (aCount == bCount) {\\n                    return a.compareTo(b);\\n                } else {  // Else sort by greatest count\\n                    return bCount - aCount;\\n                }\\n            });\\n        \\n        // Return a list with only up to k elements\\n        return list.subList(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001099,
                "title": "c-three-approaches-min-heap-max-heap-quick-select-time-o-n-log-k-to-o-n-space-o-n",
                "content": "**Mocking a Min Heap behaviour (unordered_map and Priority Queue)**\\nIf you don\\'t want to make a custom comparator, use a Min Heap. More info by [@codedayday](https://leetcode.com/codedayday) available [here](https://leetcode.com/problems/top-k-frequent-words/discuss/362389/template-possible-shortest-and-easy-solution-with-joke)\\nTime Complexity: O (N (log K))\\n Space Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        priority_queue <pair<int, string>> pq;\\n        for (auto it: umap) {\\n            pq.push({-it.second, it.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector <string> res;\\n        while (k--) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse (res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Max Heap (unordered_map and Priority Queue)**\\nIf you want to make a custom comparator, use Max Heap.\\nTime Complexity: O ((N+K) (log K))\\n Space Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    struct Comp {\\n        bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) const {\\n            if (lhs.first != rhs.first)\\n                return lhs.first < rhs.first;\\n            return lhs.second > rhs.second;\\n        } //for more info refer Resource#3 mentioned below\\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        priority_queue <pair<int, string>, vector<pair<int, string>>, Comp> pq;\\n        for (auto it: umap) {\\n            pq.push({it.second, it.first});\\n        }\\n        vector <string> res;\\n        while (k--) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\nOther Resources: \\n1. [More on Priority Queue](https://en.cppreference.com/w/cpp/container/priority_queue)\\n2. [More on Comparator Function and how it uses a weak compare](https://en.cppreference.com/w/cpp/named_req/Compare)\\n3. [A Comment from the Discuss that talks about the Compare function](https://leetcode.com/problems/top-k-frequent-words/discuss/154012/Javascript-and-C++-solutions/528912)\\n\\n**Quick Select**\\nTime Complexity: Well, Quick Select is supposed to be O (N) in average case and O (N^2) but, I am sorting the tempRes function in the end which adds a time complexity of O (unique elements in array * (log of unique elements in array). I am sure someone could improvise on this.\\nSpace Complexity: O (N)\\n\\n```\\nclass Solution {\\n    int partition(vector<pair<int, string>>& tempRes, int start, int end) {\\n        int pivot = tempRes[start].first, s = start + 1, e = end;\\n        while (s <= e) {\\n            if (tempRes[s].first < pivot && tempRes[e].first > pivot) \\n                swap(tempRes[s++], tempRes[e--]);\\n            if (tempRes[s].first >= pivot) s++;\\n            if (tempRes[e].first <= pivot) e--;\\n        }\\n        swap(tempRes[start], tempRes[e]);\\n        return e;\\n    }\\n   int quickSelect(vector<pair<int, string>>& tempRes, int k) {\\n    int start = 0, end = tempRes.size() - 1;\\n        while (true) {\\n            int index = partition(tempRes, start, end);\\n            if (index == k - 1) \\n                return index;\\n            if (index < k - 1) start = index + 1;\\n            else end = index - 1;\\n        }\\n    }\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        vector <pair<int, string>> tempRes;\\n        for (auto it: umap) {\\n            tempRes.push_back({it.second, it.first});\\n        }\\n        int index=quickSelect (tempRes, k);\\n        sort (tempRes.begin(), tempRes.end(), [](pair <int, string> s1, pair <int, string>s2) {\\n            if (s1.first!=s2.first) return s1.first>s2.first;\\n            return s1.second<s2.second;\\n        });\\n        vector <string> res;\\n        for (int i=0; i<k; i++){\\n            res.push_back(tempRes[i].second);\\n        }\\n        return res;\\n    }  \\n};\\n```\\n\\nA similar problem: [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) and [my solution article](https://leetcode.com/problems/top-k-frequent-elements/discuss/1001062/C%2B%2B-or-Two-Approaches%3A-Hashmap-%2B-Priority-Queue-and-Quick-Select-or-Time%3A-O-(nlogk)-O(n)-Space%3A-O-(n)).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        priority_queue <pair<int, string>> pq;\\n        for (auto it: umap) {\\n            pq.push({-it.second, it.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector <string> res;\\n        while (k--) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse (res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct Comp {\\n        bool operator()(const pair<int, string>& lhs, const pair<int, string>& rhs) const {\\n            if (lhs.first != rhs.first)\\n                return lhs.first < rhs.first;\\n            return lhs.second > rhs.second;\\n        } //for more info refer Resource#3 mentioned below\\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        priority_queue <pair<int, string>, vector<pair<int, string>>, Comp> pq;\\n        for (auto it: umap) {\\n            pq.push({it.second, it.first});\\n        }\\n        vector <string> res;\\n        while (k--) {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int partition(vector<pair<int, string>>& tempRes, int start, int end) {\\n        int pivot = tempRes[start].first, s = start + 1, e = end;\\n        while (s <= e) {\\n            if (tempRes[s].first < pivot && tempRes[e].first > pivot) \\n                swap(tempRes[s++], tempRes[e--]);\\n            if (tempRes[s].first >= pivot) s++;\\n            if (tempRes[e].first <= pivot) e--;\\n        }\\n        swap(tempRes[start], tempRes[e]);\\n        return e;\\n    }\\n   int quickSelect(vector<pair<int, string>>& tempRes, int k) {\\n    int start = 0, end = tempRes.size() - 1;\\n        while (true) {\\n            int index = partition(tempRes, start, end);\\n            if (index == k - 1) \\n                return index;\\n            if (index < k - 1) start = index + 1;\\n            else end = index - 1;\\n        }\\n    }\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map <string, int> umap;\\n        for (string s: words) umap[s]++;\\n        vector <pair<int, string>> tempRes;\\n        for (auto it: umap) {\\n            tempRes.push_back({it.second, it.first});\\n        }\\n        int index=quickSelect (tempRes, k);\\n        sort (tempRes.begin(), tempRes.end(), [](pair <int, string> s1, pair <int, string>s2) {\\n            if (s1.first!=s2.first) return s1.first>s2.first;\\n            return s1.second<s2.second;\\n        });\\n        vector <string> res;\\n        for (int i=0; i<k; i++){\\n            res.push_back(tempRes[i].second);\\n        }\\n        return res;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362389,
                "title": "template-possible-shortest-easy-solution-with-joke",
                "content": "challenge me for any bugs or complexity issues: (This is probably the best solution which I feel proud of myself, wish to conribute more)\\n```\\n// here is the template: solve 692. Top K Frequent Words & 347. Top K Frequent Elements\\n// yes, it is a template, you need to change nothing:\\n\\n\\nclass Solution {//idea: negative + pair + priority_queue \\npublic:\\n    template<class T>\\n    vector<T> topKFrequent(vector<T>& words, int k) {        \\n        unordered_map<T, int> m;\\n        for(const auto& i: words) ++m[i];\\n        priority_queue<pair<int, T>> pq; //trick1: built-in structure pair is well-supported, no need define comparator, \\n        //joke: in Chinese, we call pair, Qing Er Zi(\\u4EB2\\u513F\\u5B50), or nature son, to C++ system, so spoiled, and user need to do nothing extra\\n \\n        for(const auto& i: m){\\n            pq.emplace(-i.second, i.first); //trick2: use -1 to turn default max heap into min heap\\n            //pq.push({-i.second, i.first});// ok, but less efficient than emplace\\n            if(pq.size() > k) pq.pop();  //trick3:\\n        }\\n        \\n        vector<T> ans(pq.size());\\n        for(int i = pq.size() -1; i >=0; i--){\\n            ans[i] = pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you are not familiar with template, here is the non-template one to solve 692. Top K Frequent Words:\\n```\\nclass Solution {//idea: negative + pair + priority_queue \\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {        \\n        unordered_map<string, int> m;\\n        for(const auto& i: words) ++m[i];\\n        priority_queue<pair<int, string>> pq; //trick1: built-in structure pair is well-supported, no need compare\\n        //joke: in Chinese, we call pair, Qing Er Zi(\\u4EB2\\u513F\\u5B50), or nature son, to C++ system, so spoiled, and user need to do nothing extra\\n \\n        for(const auto& i: m){\\n            pq.emplace(-i.second, i.first); //trick2: use -1 to turn default max heap into min heap\\n            //pq.push({-i.second, i.first});// ok, but less efficient than emplace\\n            if(pq.size() > k) pq.pop();\\n        }\\n        \\n        vector<string> ans(pq.size());\\n        for(int i = pq.size() -1; i >=0; i--){\\n            ans[i] = pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nSpecial notes:\\nThe most difficult ones are maybe with trick1 & trick2:  \\npriority_queue<pair<int, T>> pq;  // this actually defines a max heap, but later with negative flipping operation, it behaves like a min-heap.\\n\\ntrick3:\\n1 million dollar line of the code is:\\n```\\nif(pq.size()>k) pq.pop();\\n```\\nNote, the pq defined in the post is min heap, so whenever pop happens, the \\'smallest\\' entry is always popped off. By \"smallest\", it means \\'either word with least frequency or same frequency but later/bigger dictionary order\\'.",
                "solutionTags": [],
                "code": "```\\n// here is the template: solve 692. Top K Frequent Words & 347. Top K Frequent Elements\\n// yes, it is a template, you need to change nothing:\\n\\n\\nclass Solution {//idea: negative + pair + priority_queue \\npublic:\\n    template<class T>\\n    vector<T> topKFrequent(vector<T>& words, int k) {        \\n        unordered_map<T, int> m;\\n        for(const auto& i: words) ++m[i];\\n        priority_queue<pair<int, T>> pq; //trick1: built-in structure pair is well-supported, no need define comparator, \\n        //joke: in Chinese, we call pair, Qing Er Zi(\\u4EB2\\u513F\\u5B50), or nature son, to C++ system, so spoiled, and user need to do nothing extra\\n \\n        for(const auto& i: m){\\n            pq.emplace(-i.second, i.first); //trick2: use -1 to turn default max heap into min heap\\n            //pq.push({-i.second, i.first});// ok, but less efficient than emplace\\n            if(pq.size() > k) pq.pop();  //trick3:\\n        }\\n        \\n        vector<T> ans(pq.size());\\n        for(int i = pq.size() -1; i >=0; i--){\\n            ans[i] = pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {//idea: negative + pair + priority_queue \\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {        \\n        unordered_map<string, int> m;\\n        for(const auto& i: words) ++m[i];\\n        priority_queue<pair<int, string>> pq; //trick1: built-in structure pair is well-supported, no need compare\\n        //joke: in Chinese, we call pair, Qing Er Zi(\\u4EB2\\u513F\\u5B50), or nature son, to C++ system, so spoiled, and user need to do nothing extra\\n \\n        for(const auto& i: m){\\n            pq.emplace(-i.second, i.first); //trick2: use -1 to turn default max heap into min heap\\n            //pq.push({-i.second, i.first});// ok, but less efficient than emplace\\n            if(pq.size() > k) pq.pop();\\n        }\\n        \\n        vector<string> ans(pq.size());\\n        for(int i = pq.size() -1; i >=0; i--){\\n            ans[i] = pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nif(pq.size()>k) pq.pop();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254354,
                "title": "explanation-using-a-custom-comparator-for-priorityqueue-in-java",
                "content": "Hi! I made a PriorityQueue (heap) in Java that uses a custom comparator and a Word object. Yeah, I probably could have gotten away with a few less data structures but this solution I did was one that made sense to me. I would rather make it clearer in an interview rather than fewer lines and harder to understand. \\n\\nI heavily commented the parts using the compare() and compareTo() methods because those are sometimes difficult to grasp. It\\'s probably not the best code, that\\'s not really what I aimed for lol. Just hope it helps someone who is having trouble understanding custom Comparators!\\n\\n```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Word> map = new HashMap<>();\\n        List<String> list = new ArrayList<>();\\n        PriorityQueue<Word> pq = new PriorityQueue<>(new Comparator<Word>() {\\n            // the compare method returns a positive or negative integer based on\\n            // these 2 elements, w1 and w2. return 1 means the current order is bad, swap. return -1\\n            // mean the current order is good, dont swap. if its equal to each other, usually\\n            // return 0 but in our case we will then sort by lex order using String.compareTo().\\n            @Override\\n            public int compare(Word w1, Word w2) {\\n                // ** w1 freq greater than w2 freq, keep the order. **\\n                // given some order of element 1, and element 2,\\n                // if the value of element 1 is greater than element 2, return a -1\\n                // which is a negative integer less than 0, don\\'t swap! because this\\n                // is what we want, w1 (higher freq) to be in front of the w2 (lower freq).\\n                if(w1.freq > w2.freq) {\\n                    return -1;\\n                }\\n                // ** w1 freq lesser than w2 freq, swap the order. **\\n                // given some order of element 1, and element 2,\\n                // if the value of element 1 is lesser than element 2, return a 1\\n                // which is a positive integer greater than 0, swap them. since\\n\\t\\t\\t\\t// the element\\'s freq is lesser we want to put w2 (higher freq)\\n\\t\\t\\t\\t// in front of w1 (lower freq).\\n                else if(w1.freq < w2.freq) {\\n                    return 1;\\n                }\\n                // ** Strings are equal freq, return lexicographic order. **\\n                else {\\n                    int w1ComapredToW2 = w1.name.compareTo(w2.name);\\n                    // works the same way as above\\n\\t\\t\\t\\t\\t// if the lex is smaller, keep order, return -1.\\n                    if(w1ComapredToW2 <= 0) {\\n                        return -1;\\n                    }\\n\\t\\t\\t\\t\\t// if the lex returns a positive number, swap, so return 1.\\n                    else {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        });\\n        \\n        // cache in map.\\n        for(String w : words) {\\n            if(map.containsKey(w)) {\\n                Word word = map.get(w);\\n                word.freq++;\\n                map.put(w, word);\\n            }\\n            else {\\n                map.put(w, new Word(w));\\n            }\\n        }\\n        \\n        // load into pq.\\n        map.forEach((name, word) -> {\\n           pq.offer(word); \\n        });\\n        \\n        // empty for k elements.\\n        int i = 0;\\n        while(i < k) {\\n            Word word = pq.poll();\\n            list.add(word.name);\\n            i++;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    \\n}\\n\\nclass Word {\\n    public String name;\\n    public int freq;\\n    \\n    Word(String n) {\\n        this.name = n;\\n        this.freq = 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Word> map = new HashMap<>();\\n        List<String> list = new ArrayList<>();\\n        PriorityQueue<Word> pq = new PriorityQueue<>(new Comparator<Word>() {\\n            // the compare method returns a positive or negative integer based on\\n            // these 2 elements, w1 and w2. return 1 means the current order is bad, swap. return -1\\n            // mean the current order is good, dont swap. if its equal to each other, usually\\n            // return 0 but in our case we will then sort by lex order using String.compareTo().\\n            @Override\\n            public int compare(Word w1, Word w2) {\\n                // ** w1 freq greater than w2 freq, keep the order. **\\n                // given some order of element 1, and element 2,\\n                // if the value of element 1 is greater than element 2, return a -1\\n                // which is a negative integer less than 0, don\\'t swap! because this\\n                // is what we want, w1 (higher freq) to be in front of the w2 (lower freq).\\n                if(w1.freq > w2.freq) {\\n                    return -1;\\n                }\\n                // ** w1 freq lesser than w2 freq, swap the order. **\\n                // given some order of element 1, and element 2,\\n                // if the value of element 1 is lesser than element 2, return a 1\\n                // which is a positive integer greater than 0, swap them. since\\n\\t\\t\\t\\t// the element\\'s freq is lesser we want to put w2 (higher freq)\\n\\t\\t\\t\\t// in front of w1 (lower freq).\\n                else if(w1.freq < w2.freq) {\\n                    return 1;\\n                }\\n                // ** Strings are equal freq, return lexicographic order. **\\n                else {\\n                    int w1ComapredToW2 = w1.name.compareTo(w2.name);\\n                    // works the same way as above\\n\\t\\t\\t\\t\\t// if the lex is smaller, keep order, return -1.\\n                    if(w1ComapredToW2 <= 0) {\\n                        return -1;\\n                    }\\n\\t\\t\\t\\t\\t// if the lex returns a positive number, swap, so return 1.\\n                    else {\\n                        return 1;\\n                    }\\n                }\\n            }\\n        });\\n        \\n        // cache in map.\\n        for(String w : words) {\\n            if(map.containsKey(w)) {\\n                Word word = map.get(w);\\n                word.freq++;\\n                map.put(w, word);\\n            }\\n            else {\\n                map.put(w, new Word(w));\\n            }\\n        }\\n        \\n        // load into pq.\\n        map.forEach((name, word) -> {\\n           pq.offer(word); \\n        });\\n        \\n        // empty for k elements.\\n        int i = 0;\\n        while(i < k) {\\n            Word word = pq.poll();\\n            list.add(word.name);\\n            i++;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    \\n}\\n\\nclass Word {\\n    public String name;\\n    public int freq;\\n    \\n    Word(String n) {\\n        this.name = n;\\n        this.freq = 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603190,
                "title": "java-min-heap-fast-explaines-o-n-log-k-simple",
                "content": "The trick to solving this problem is to be very comfortable with **heaps (priority queues)**. Anytime a question asks \"Top K frequent\" or anything similar, it is a dead giveaway that you should try to use a heap. This is because the heap structure can guarantee the collection stays sorted upon addition and deletion in **O(log m)** time (where **m is the number of elements in the heap**).\\n\\nJust to re-iterate, if a question ever asks for some number of elements that can be sorted, always try to think if a heap can be applied.\\n\\nI will not go into how heaps actually work, but if you have never used them, then I would recommend reading up on them more and getting very familiar. This data structure is very useful and very powerful.\\n\\nThe idea with this solution is to first count up all occurances of each word, and then add each word to a **PriorityQueue (heap)** that sorts the entries based on the number of occurances counted. The only special case is if the number of occurances are equal, this is because we want to sort lexicographically in this case.\\n\\nIt is very important to note too that I am using a **MinHeap** here, not a **MaxHeap**. This means that the **heap** will in essence be **sorted from smallest to largest**. This is so that as items are added into the **MinHeap**, the lowest occurance items (or the highest rated lexiographical item) is always at the top of the heap ready to be polled out. This allows the optimal runtime because the size of the heap never goes over (k + 1).\\n\\nUsing **MaxHeap** to solve this problem would also work, but would instead result in the solution being **O(N log N) which is worse than O(N log k)** in most cases and equivalent in the extreme case where N = k.\\n\\n\\n```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer> wordCounts = new HashMap<>();\\n        for(String word : words) wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n        \\n        PriorityQueue<String> minHeap = new PriorityQueue<>((s1, s2) -> {\\n            int s1Count = wordCounts.get(s1);\\n            int s2Count = wordCounts.get(s2);\\n            \\n            if(s1Count == s2Count) return s2.compareTo(s1);\\n            return s1Count - s2Count;\\n        });\\n        \\n        for(String word : wordCounts.keySet()) {\\n            minHeap.offer(word);\\n            \\n            if(minHeap.size() > k) minHeap.poll(); \\n        }\\n        \\n        LinkedList<String> toReturn = new LinkedList<>();\\n        while(!minHeap.isEmpty()) toReturn.addFirst(minHeap.poll());\\n        \\n        return toReturn;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer> wordCounts = new HashMap<>();\\n        for(String word : words) wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n        \\n        PriorityQueue<String> minHeap = new PriorityQueue<>((s1, s2) -> {\\n            int s1Count = wordCounts.get(s1);\\n            int s2Count = wordCounts.get(s2);\\n            \\n            if(s1Count == s2Count) return s2.compareTo(s1);\\n            return s1Count - s2Count;\\n        });\\n        \\n        for(String word : wordCounts.keySet()) {\\n            minHeap.offer(word);\\n            \\n            if(minHeap.size() > k) minHeap.poll(); \\n        }\\n        \\n        LinkedList<String> toReturn = new LinkedList<>();\\n        while(!minHeap.isEmpty()) toReturn.addFirst(minHeap.poll());\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932255,
                "title": "easy-algorithm-with-best-time-complexity-yet-o-klogn-n-time-o-n-space",
                "content": "def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n\\n\\t\\t#create a hashmap containing the count for each distinct word. This costs O(n).\\n        word_count = collections.Counter(words)\\n\\t\\t\\n\\t\\t#create a list using the hashmap. We negate the counter so the word with highest count is at the top of the heap. \\n\\t\\t#This costs O(n).\\n        word_count = [(-counter, word) for word, counter in word_count.items()]\\n\\t\\t\\n\\t\\t#This next operation costs O(n) NOT O(nlgn) since we are running heapify on the entire list and not inserting elements\\n\\t\\t#one by one into the heap.\\n        heapq.heapify(word_count)\\n        \\n\\t\\t#pop k elements from the heap. Each pop costs O(lgn) if we want to maintain the heap invariant after popping. \\n        return [heappop(word_count)[1] for _ in range(k)]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n\\n\\t\\t#create a hashmap containing the count for each distinct word. This costs O(n).\\n        word_count = collections.Counter(words)\\n\\t\\t\\n\\t\\t#create a list using the hashmap. We negate the counter so the word with highest count is at the top of the heap. \\n\\t\\t#This costs O(n).\\n        word_count = [(-counter, word) for word, counter in word_count.items()]\\n\\t\\t\\n\\t\\t#This next operation costs O(n) NOT O(nlgn) since we are running heapify on the entire list and not inserting elements\\n\\t\\t#one by one into the heap.\\n        heapq.heapify(word_count)\\n        \\n\\t\\t#pop k elements from the heap. Each pop costs O(lgn) if we want to maintain the heap invariant after popping. \\n        return [heappop(word_count)[1] for _ in range(k)]",
                "codeTag": "Python3"
            },
            {
                "id": 2720516,
                "title": "straightforward-approach-in-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int> freq;\\n        priority_queue<pair<int,string>> pq;\\n        \\n        // count frequency of each word\\n        for(auto w:words){\\n            freq[w]++;\\n        }\\n        \\n        // insert each unique word into max-heap based on there frequecy\\n        for(auto it:freq) pq.push({it.second,it.first});\\n        vector<string> res;\\n        \\n        // insert all words inorder highest to lowest into the priority queue insack of lexicographically order sorting of same frequency words\\n        for(int i=0;i<freq.size();i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        // sort same frequecy words\\n        for(int i=0;i<res.size();i++){\\n            for(int j=0;j<res.size()-1;j++){\\n                if(res[j] > res[j+1] && freq[res[j]] == freq[res[j+1]]) swap(res[j],res[j+1]);\\n            }\\n        }\\n        \\n        vector<string> res2;\\n        \\n        // insert top k frequency words into your answer vector\\n        for(int j=0;j<k;j++){\\n            res2.push_back(res[j]);\\n        }\\n        \\n        return res2;\\n    }\\n};\\n```\\n\\n****\\n\\n**Do share feedbacks and do upvote if found it helpful.\\nThanks.**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int> freq;\\n        priority_queue<pair<int,string>> pq;\\n        \\n        // count frequency of each word\\n        for(auto w:words){\\n            freq[w]++;\\n        }\\n        \\n        // insert each unique word into max-heap based on there frequecy\\n        for(auto it:freq) pq.push({it.second,it.first});\\n        vector<string> res;\\n        \\n        // insert all words inorder highest to lowest into the priority queue insack of lexicographically order sorting of same frequency words\\n        for(int i=0;i<freq.size();i++){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        // sort same frequecy words\\n        for(int i=0;i<res.size();i++){\\n            for(int j=0;j<res.size()-1;j++){\\n                if(res[j] > res[j+1] && freq[res[j]] == freq[res[j+1]]) swap(res[j],res[j+1]);\\n            }\\n        }\\n        \\n        vector<string> res2;\\n        \\n        // insert top k frequency words into your answer vector\\n        for(int j=0;j<k;j++){\\n            res2.push_back(res[j]);\\n        }\\n        \\n        return res2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500479,
                "title": "c-simple-solution",
                "content": "```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n       // Count of Frequency of each word \\n       Dictionary<string, int> dict = new Dictionary<string, int>();\\n       for(int i = 0 ; i < words.Length; i++){\\n           if(!dict.ContainsKey(words[i]))\\n                dict.Add(words[i], 1);\\n           else\\n               dict[words[i]]++;\\n           \\n       }\\n       // dictionary in C# has inbuilt method for sorting both key and value \\n\\t   // Sort first by frequency and then by key in case of tie like same frequency \\n       List<KeyValuePair<string, int>> test = \\n          dict.OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).ToList();      \\n       \\n       //  return top k keys from dict  \\n       return test.Select(x => x.Key).ToList();\\n              \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n       // Count of Frequency of each word \\n       Dictionary<string, int> dict = new Dictionary<string, int>();\\n       for(int i = 0 ; i < words.Length; i++){\\n           if(!dict.ContainsKey(words[i]))\\n                dict.Add(words[i], 1);\\n           else\\n               dict[words[i]]++;\\n           \\n       }\\n       // dictionary in C# has inbuilt method for sorting both key and value \\n\\t   // Sort first by frequency and then by key in case of tie like same frequency \\n       List<KeyValuePair<string, int>> test = \\n          dict.OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).ToList();      \\n       \\n       //  return top k keys from dict  \\n       return test.Select(x => x.Key).ToList();\\n              \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720956,
                "title": "c-2-methods-learn-writing-custom-comparator-of-priority-queue",
                "content": "General syntax to declare the priority queue is **priority_queue<data_type, container, comparator>**\\nThe default values for container is *vector<data_type>* and for comparator is *less<data_type>*. \\n\\nIn case of max heap, we declare it as,  **priority_queue < int > maxHeap;**\\nIt is basically a shorthand of this,  **priority_queue<int, vector< int>, less< int>> maxHeap**; \\n\\nAnd in case of min heap we declare it as,  **priority_queue<int, vector< int>, greater< int>> minHeap**;\\n\\n\\n```\\nclass comp {\\n  public:\\n    bool operator() (const pair<int, string>&p1, const pair<int, string>&p2) {\\n        if(p1.first > p2.first) return false;\\n        else if(p1.first == p2.first) return p1.second > p2.second;\\n        else return true;\\n    }\\n};    \\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto it : words)\\n\\t\\t\\tmp[it]++;\\n        \\n        priority_queue< pair<int, string>, vector<pair<int, string>>, comp > pq;\\n        for(auto it : mp)\\n\\t\\t\\tpq.push({it.second, it.first});\\n        \\n        vector<string> ans;\\n        for(int i = 1; i <= k; i++)\\n            ans.push_back(pq.top().second), pq.pop();\\n\\t\\t\\t\\n        return ans;    \\n    }\\n};\\n```\\n\\n*OR*\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int, string>&p1, const pair<int, string>&p2) {\\n        if(p1.first < p2.first) return true;\\n        else if(p1.first == p2.first) return p1.second > p2.second;\\n        else return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto it : words) mp[it]++;\\n        \\n        std::priority_queue< pair<int, string>, std::vector<pair<int, string>>, std::function<bool(pair<int, string>, pair<int, string>)> > pq(comp);\\n        for(auto it : mp) pq.push({it.second, it.first});\\n        \\n        vector<string> ans;\\n        for(int i = 1; i <= k; i++)\\n            ans.push_back(pq.top().second), pq.pop();\\n        return ans;    \\n    }\\n};\\n```\\n\\nSource :\\n[https://leetcode.com/problems/top-k-frequent-words/discuss/1274279/CPP-or-C%2B%2B-or-priority-queue-or-Custom-Comparator-and-Solution-Explain-oror-O(nLogk)-Solution](http://)\\n[https://stackoverflow.com/questions/16111337/declaring-a-priority-queue-in-c-with-a-custom-comparator/48587737](http://)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass comp {\\n  public:\\n    bool operator() (const pair<int, string>&p1, const pair<int, string>&p2) {\\n        if(p1.first > p2.first) return false;\\n        else if(p1.first == p2.first) return p1.second > p2.second;\\n        else return true;\\n    }\\n};    \\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto it : words)\\n\\t\\t\\tmp[it]++;\\n        \\n        priority_queue< pair<int, string>, vector<pair<int, string>>, comp > pq;\\n        for(auto it : mp)\\n\\t\\t\\tpq.push({it.second, it.first});\\n        \\n        vector<string> ans;\\n        for(int i = 1; i <= k; i++)\\n            ans.push_back(pq.top().second), pq.pop();\\n\\t\\t\\t\\n        return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int, string>&p1, const pair<int, string>&p2) {\\n        if(p1.first < p2.first) return true;\\n        else if(p1.first == p2.first) return p1.second > p2.second;\\n        else return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto it : words) mp[it]++;\\n        \\n        std::priority_queue< pair<int, string>, std::vector<pair<int, string>>, std::function<bool(pair<int, string>, pair<int, string>)> > pq(comp);\\n        for(auto it : mp) pq.push({it.second, it.first});\\n        \\n        vector<string> ans;\\n        for(int i = 1; i <= k; i++)\\n            ans.push_back(pq.top().second), pq.pop();\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720033,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,string> &a,pair<int,string> &b)\\n    {\\n        if(a.first!=b.first) return a.first>b.first;\\n        else return a.second<b.second;\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        vector<pair<int,string>> pq;\\n        for(auto &it:mp)\\n        {\\n            pq.push_back({it.second,it.first});\\n        }\\n        sort(pq.begin(),pq.end(),comp);\\n        vector<string> ans;\\n        for(int i=0;i<pq.size();i++)\\n        {\\n            if(k)\\n            {\\n                ans.push_back(pq[i].second);\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,string> &a,pair<int,string> &b)\\n    {\\n        if(a.first!=b.first) return a.first>b.first;\\n        else return a.second<b.second;\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        vector<pair<int,string>> pq;\\n        for(auto &it:mp)\\n        {\\n            pq.push_back({it.second,it.first});\\n        }\\n        sort(pq.begin(),pq.end(),comp);\\n        vector<string> ans;\\n        for(int i=0;i<pq.size();i++)\\n        {\\n            if(k)\\n            {\\n                ans.push_back(pq[i].second);\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478681,
                "title": "hash-map-priority-queue-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        String word;\\n        int freq;\\n        Pair(String word, int freq){\\n            this.word=word;\\n            this.freq=freq;\\n        }\\n    }\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer>map=new HashMap<>();\\n        for(String w:words){\\n            map.put(w,map.getOrDefault(w,0)+1);\\n        }\\n        PriorityQueue<Pair> maxheap=new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.freq==b.freq)\\n                    return a.word.compareTo(b.word);\\n                else \\n                    return b.freq-a.freq;\\n            }\\n        });\\n      \\n\\n        for(Map.Entry<String, Integer>entry:map.entrySet()){\\n            maxheap.add(new Pair(entry.getKey(),entry.getValue()));\\n        }\\n            List<String> res = new ArrayList<>();\\n            for(int i=0;i<k;i++){\\n                Pair rem=maxheap.poll();\\n                res.add(rem.word);\\n            }\\n        return res;\\n        }\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        String word;\\n        int freq;\\n        Pair(String word, int freq){\\n            this.word=word;\\n            this.freq=freq;\\n        }\\n    }\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String, Integer>map=new HashMap<>();\\n        for(String w:words){\\n            map.put(w,map.getOrDefault(w,0)+1);\\n        }\\n        PriorityQueue<Pair> maxheap=new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.freq==b.freq)\\n                    return a.word.compareTo(b.word);\\n                else \\n                    return b.freq-a.freq;\\n            }\\n        });\\n      \\n\\n        for(Map.Entry<String, Integer>entry:map.entrySet()){\\n            maxheap.add(new Pair(entry.getKey(),entry.getValue()));\\n        }\\n            List<String> res = new ArrayList<>();\\n            for(int i=0;i<k;i++){\\n                Pair rem=maxheap.poll();\\n                res.add(rem.word);\\n            }\\n        return res;\\n        }\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760457,
                "title": "python-min-heap-efficient-solution",
                "content": "Using a max heap here would directly give you the result but it\\'s not efficient.\\nUsing a min heap would be more efficient as you only have k elements in the heap.\\nBut there is a corner case where the order of words having the same count has to be handled. For that added a custom class with a comparator.\\n```\\nclass HeapElement:\\n    def __init__(self, count, word):\\n        self.count = count\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        if self.count == other.count:\\n            return self.word > other.word\\n        return self.count < other.count\\n        \\n    def __eq__(self, other):\\n        return self.count == other.count and self.word == other.word\\n\\n    \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        c = Counter(words)\\n        kFrequent = []\\n        for word, count in c.items():\\n            if k > 0:\\n                heapq.heappush(kFrequent, (HeapElement(count, word), word))\\n                k -= 1\\n            else:\\n                heapq.heappushpop(kFrequent, (HeapElement(count, word), word))\\n        res = []\\n        for _ in range(len(kFrequent)):\\n            res.append(heapq.heappop(kFrequent)[1])\\n        return res[::-1]\\n```\\nRuntime: 52 ms, faster than 94.74% of Python3 online submissions for Top K Frequent Words.\\nMemory Usage: 13.9 MB, less than 48.35% of Python3 online submissions for Top K Frequent Words.",
                "solutionTags": [],
                "code": "```\\nclass HeapElement:\\n    def __init__(self, count, word):\\n        self.count = count\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        if self.count == other.count:\\n            return self.word > other.word\\n        return self.count < other.count\\n        \\n    def __eq__(self, other):\\n        return self.count == other.count and self.word == other.word\\n\\n    \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        c = Counter(words)\\n        kFrequent = []\\n        for word, count in c.items():\\n            if k > 0:\\n                heapq.heappush(kFrequent, (HeapElement(count, word), word))\\n                k -= 1\\n            else:\\n                heapq.heappushpop(kFrequent, (HeapElement(count, word), word))\\n        res = []\\n        for _ in range(len(kFrequent)):\\n            res.append(heapq.heappop(kFrequent)[1])\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154012,
                "title": "a-few-solutions",
                "content": "Sort the input array `A` by descending frequency, then by lexicographical order, and return the top `K`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun topKFrequent(A: Array<String>, K: Int): List<String> {\\n        var ans = mutableListOf<String>()\\n        var m = A.groupingBy{ it }.eachCount()\\n        for (cnt in m.values.toSet().sorted().reversed())\\n            for (cand in A.filter{ m[it]!! == cnt }.toSet().sorted())\\n                if (ans.size < K)\\n                    ans.add(cand)\\n        return ans.toList()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet topKFrequent = (A, K) => Object.entries(_.countBy(A)).sort((a, b) => a[1] == b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1]).map(pair => pair[0]).slice(0, K);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    topKFrequent = lambda self, A, K: [pair[0] for pair in Counter(sorted(A)).most_common()][:K]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, int>;\\n    using Pair = pair<string, int>;\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.second != b.second ? a.second < b.second : a.first > b.first;\\n        }\\n    };\\n    using Queue = priority_queue<Pair, vector<Pair>, Comp>;\\n    VS topKFrequent(VS& A, int K, Map m = {}, VS ans={}) {\\n        for (auto& word: A)\\n            ++m[word];\\n        Queue q{ m.begin(),m.end() };\\n        while (K--)\\n            ans.push_back(q.top().first), q.pop();\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun topKFrequent(A: Array<String>, K: Int): List<String> {\\n        var ans = mutableListOf<String>()\\n        var m = A.groupingBy{ it }.eachCount()\\n        for (cnt in m.values.toSet().sorted().reversed())\\n            for (cand in A.filter{ m[it]!! == cnt }.toSet().sorted())\\n                if (ans.size < K)\\n                    ans.add(cand)\\n        return ans.toList()\\n    }\\n}\\n```\n```\\nlet topKFrequent = (A, K) => Object.entries(_.countBy(A)).sort((a, b) => a[1] == b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1]).map(pair => pair[0]).slice(0, K);\\n```\n```\\nclass Solution:\\n    topKFrequent = lambda self, A, K: [pair[0] for pair in Counter(sorted(A)).most_common()][:K]\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, int>;\\n    using Pair = pair<string, int>;\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.second != b.second ? a.second < b.second : a.first > b.first;\\n        }\\n    };\\n    using Queue = priority_queue<Pair, vector<Pair>, Comp>;\\n    VS topKFrequent(VS& A, int K, Map m = {}, VS ans={}) {\\n        for (auto& word: A)\\n            ++m[word];\\n        Queue q{ m.begin(),m.end() };\\n        while (K--)\\n            ans.push_back(q.top().first), q.pop();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721990,
                "title": "java-easy-solution-tree-map",
                "content": "IF YOU LIKE THE SOLUTION \\nMAKE SURE TO UPVOTE IT !\\n\\nWELCOME YOU ALL IN COMMENTS .\\n\\n```\\nclass Solution {\\n    \\n    //According to me this is my time complextity, not sure about TC.\\n    //Time Complextiy -> O(n) for first Iteration + O(n) for one more iteration + O(k) approx for last one\\n    // Space Complextity --> O(N)+ O(N) overall O(N).\\n    \\n    public List<String> topKFrequent(String[] words, int k) {\\n        // make the list to store the output res.\\n        List<String> res = new ArrayList<>();\\n        \\n        // Make a treemap , so that it store strings in sorted order\\n        // it will help in when there repetitions is same.\\n        TreeMap<String,Integer> tmap = new TreeMap<>();\\n        // fill our tmap .\\n        for(String s : words)\\n            tmap.put(s,tmap.getOrDefault(s,0) + 1);\\n        \\n        // Make another Treemap to store values according to their repetition \\n        // and store them according to Integer values in reverse order !\\n        TreeMap<Integer,String> treemap = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for(Map.Entry m : tmap.entrySet()){\\n            // If key value is not present put it normally.\\n            if(treemap.get(m.getValue()) == null)\\n                treemap.put((Integer)m.getValue(),(String)m.getKey());\\n            else{\\n                // if it is present already then we just concatnate it with previously\\n                // present string which is already in sorted order.\\n                String val = treemap.get(m.getValue());\\n                treemap.put((Integer)m.getValue(),val + \" \" + (String)m.getKey());\\n            }\\n        }\\n        \\n        \\n        for(Map.Entry m : treemap.entrySet()){\\n            if(k>0){\\n                // Iterate through the map \\n                // Take the values and split it against backspace\\n                String str = (String)m.getValue();\\n                String[] arr = str.split(\" \");\\n                // Just put it in our res and reduce value of k until it becomes zero.\\n                for(int i = 0; i<arr.length; i++){\\n                    if(k>0){\\n                         res.add(arr[i]);\\n                         k--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n\\n/** INPUT\\n    [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"]\\n    2\\n    \\n    First tmap --> \\n    Key     Value\\n    coding   1\\n    i        2\\n    leetcode 1\\n    love     2\\n    \\n    second treeMap -- >\\n    key Value\\n    2   i love\\n    1   coding leetcode\\n\\n    FINAL OUTPUT\\n    [\"i\",\"love\"]\\n**/\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //According to me this is my time complextity, not sure about TC.\\n    //Time Complextiy -> O(n) for first Iteration + O(n) for one more iteration + O(k) approx for last one\\n    // Space Complextity --> O(N)+ O(N) overall O(N).\\n    \\n    public List<String> topKFrequent(String[] words, int k) {\\n        // make the list to store the output res.\\n        List<String> res = new ArrayList<>();\\n        \\n        // Make a treemap , so that it store strings in sorted order\\n        // it will help in when there repetitions is same.\\n        TreeMap<String,Integer> tmap = new TreeMap<>();\\n        // fill our tmap .\\n        for(String s : words)\\n            tmap.put(s,tmap.getOrDefault(s,0) + 1);\\n        \\n        // Make another Treemap to store values according to their repetition \\n        // and store them according to Integer values in reverse order !\\n        TreeMap<Integer,String> treemap = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for(Map.Entry m : tmap.entrySet()){\\n            // If key value is not present put it normally.\\n            if(treemap.get(m.getValue()) == null)\\n                treemap.put((Integer)m.getValue(),(String)m.getKey());\\n            else{\\n                // if it is present already then we just concatnate it with previously\\n                // present string which is already in sorted order.\\n                String val = treemap.get(m.getValue());\\n                treemap.put((Integer)m.getValue(),val + \" \" + (String)m.getKey());\\n            }\\n        }\\n        \\n        \\n        for(Map.Entry m : treemap.entrySet()){\\n            if(k>0){\\n                // Iterate through the map \\n                // Take the values and split it against backspace\\n                String str = (String)m.getValue();\\n                String[] arr = str.split(\" \");\\n                // Just put it in our res and reduce value of k until it becomes zero.\\n                for(int i = 0; i<arr.length; i++){\\n                    if(k>0){\\n                         res.add(arr[i]);\\n                         k--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n\\n/** INPUT\\n    [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"]\\n    2\\n    \\n    First tmap --> \\n    Key     Value\\n    coding   1\\n    i        2\\n    leetcode 1\\n    love     2\\n    \\n    second treeMap -- >\\n    key Value\\n    2   i love\\n    1   coding leetcode\\n\\n    FINAL OUTPUT\\n    [\"i\",\"love\"]\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966395,
                "title": "c-priority-queue-easy-to-understand-with-comment-and-figure",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> topKFrequent(vector<string>& words, int k) {\\n\\t\\t\\t\\tunordered_map <string, int> umap;\\n\\t\\t\\t\\tfor (string s: words) umap[s]++;\\n\\t\\t\\t\\tpriority_queue <pair<int, string>> pq;\\n\\t\\t\\t\\tfor (auto it: umap) {\\n\\t\\t\\t\\t\\t// minus sign used to build min heap \\n\\t\\t\\t\\t\\tpq.push({-it.second, it.first});\\n\\t\\t\\t\\t\\tif(pq.size() > k) pq.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector <string> res;\\n\\t\\t\\t\\twhile (k--) {\\n\\t\\t\\t\\t\\tres.push_back(pq.top().second);\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treverse (res.begin(), res.end());\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> topKFrequent(vector<string>& words, int k) {\\n\\t\\t\\t\\tunordered_map <string, int> umap;\\n\\t\\t\\t\\tfor (string s: words) umap[s]++;\\n\\t\\t\\t\\tpriority_queue <pair<int, string>> pq;\\n\\t\\t\\t\\tfor (auto it: umap) {\\n\\t\\t\\t\\t\\t// minus sign used to build min heap \\n\\t\\t\\t\\t\\tpq.push({-it.second, it.first}",
                "codeTag": "Java"
            },
            {
                "id": 1943478,
                "title": "c-o-n-solution-using-hashmap-bucketsort-and-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        TrieNode* child[26];\\n        string word;\\n        \\n        TrieNode(){\\n            string word = \"\";\\n            for(int i=0;i<26;i++){\\n                child[i] = nullptr;\\n            }\\n        }\\n    };\\n    \\n    void addWord(TrieNode* root, string word){\\n        TrieNode* cur = root;\\n        for(auto c: word){\\n            int x = c - \\'a\\';\\n            if(cur->child[x] == nullptr){\\n                cur->child[x] = new TrieNode();\\n            }\\n            cur = cur->child[x]; \\n        }\\n        cur->word = word;\\n    }\\n    \\n    void getWord(TrieNode* node, vector<string> &res, int k){\\n        if(node == nullptr) return;\\n        if(node->word != \"\") {\\n            res.push_back(node->word);\\n        }\\n        if(res.size() == k) return;\\n        for(int i=0;i<26;i++){\\n            if(node->child[i] == nullptr) continue;\\n            getWord(node->child[i], res, k);\\n        }\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto word: words){\\n            mp[word] ++;\\n        }\\n        \\n        int n = words.size();\\n        vector<TrieNode *> freqs;\\n        for(int i=0;i<=n;i++){\\n            TrieNode * newNode = new TrieNode();\\n            freqs.push_back(newNode);\\n        }\\n        \\n        for(auto x: mp){\\n            addWord(freqs[x.second], x.first);\\n        }\\n        vector<string> res;\\n        for(int i=n;i>=1;i--){\\n            getWord(freqs[i], res, k);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Trie",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        TrieNode* child[26];\\n        string word;\\n        \\n        TrieNode(){\\n            string word = \"\";\\n            for(int i=0;i<26;i++){\\n                child[i] = nullptr;\\n            }\\n        }\\n    };\\n    \\n    void addWord(TrieNode* root, string word){\\n        TrieNode* cur = root;\\n        for(auto c: word){\\n            int x = c - \\'a\\';\\n            if(cur->child[x] == nullptr){\\n                cur->child[x] = new TrieNode();\\n            }\\n            cur = cur->child[x]; \\n        }\\n        cur->word = word;\\n    }\\n    \\n    void getWord(TrieNode* node, vector<string> &res, int k){\\n        if(node == nullptr) return;\\n        if(node->word != \"\") {\\n            res.push_back(node->word);\\n        }\\n        if(res.size() == k) return;\\n        for(int i=0;i<26;i++){\\n            if(node->child[i] == nullptr) continue;\\n            getWord(node->child[i], res, k);\\n        }\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(auto word: words){\\n            mp[word] ++;\\n        }\\n        \\n        int n = words.size();\\n        vector<TrieNode *> freqs;\\n        for(int i=0;i<=n;i++){\\n            TrieNode * newNode = new TrieNode();\\n            freqs.push_back(newNode);\\n        }\\n        \\n        for(auto x: mp){\\n            addWord(freqs[x.second], x.first);\\n        }\\n        vector<string> res;\\n        for(int i=n;i>=1;i--){\\n            getWord(freqs[i], res, k);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883869,
                "title": "asked-in-amazon-interview",
                "content": "i got this question in Amazon interview.I had given three approaches:-\\n1)count frequency and sort w.r.t frequency and pick top k elements. \\n     Time Complexity:O(nlog(n)).\\n2) count frequency and put in priority queue of size k..                      \\n     Time Complexity:O(n log(k)).\\n3) quickselect approach,where i had to select kth element and all the larger frequency words will be on right side\\n     Average case time complexity: n+klogk           \\n\\t worst case time complexity O(n^2)\\nAfter giving all three approaches,interviewer kept on insisting to optimize the space,and i was left with no clue that how to proceed.\\nLater on,i googled the question and came to know that,this question can be solved usign TRIE also.\\nMay be the interviewer wanted to get the TRIE solution.\\n**NOTE**:- sadly,I got rejected,because i didn\\'t speak about trie at that moment.\\n                   So readers,please keep in mind about the trie solution",
                "solutionTags": [],
                "code": "i got this question in Amazon interview.I had given three approaches:-\\n1)count frequency and sort w.r.t frequency and pick top k elements. \\n     Time Complexity:O(nlog(n)).\\n2) count frequency and put in priority queue of size k..                      \\n     Time Complexity:O(n log(k)).\\n3) quickselect approach,where i had to select kth element and all the larger frequency words will be on right side\\n     Average case time complexity: n+klogk           \\n\\t worst case time complexity O(n^2)\\nAfter giving all three approaches,interviewer kept on insisting to optimize the space,and i was left with no clue that how to proceed.\\nLater on,i googled the question and came to know that,this question can be solved usign TRIE also.\\nMay be the interviewer wanted to get the TRIE solution.\\n**NOTE**:- sadly,I got rejected,because i didn\\'t speak about trie at that moment.\\n                   So readers,please keep in mind about the trie solution",
                "codeTag": "Unknown"
            },
            {
                "id": 533190,
                "title": "python-3-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic = {}\\n        for word in words:\\n            dic[word] = dic.get(word, 0) + 1\\n        p = []\\n        for key,val in dic.items():\\n            heapq.heappush(p, (-val,key))\\n        res = []\\n        for _ in range(k):\\n            res.append(heapq.heappop(p)[1])\\n        return res\\n```\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic = {}\\n        for word in words:\\n            dic[word] = dic.get(word, 0) + 1\\n        p = []\\n        for key,val in dic.items():\\n            heapq.heappush(p, (-val,key))\\n        res = []\\n        for _ in range(k):\\n            res.append(heapq.heappop(p)[1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496992,
                "title": "python3-follow-up-solution-with-time-o-nlogk",
                "content": "Attention: Design `WrapString` class for max_heap construction (based on freq and word alphabetical order).\\n\\n``` python\\nfrom collections import Counter\\nimport heapq\\n\\nclass WrapString:\\n    def __init__(self, string):\\n        self.val = string\\n\\n    def __eq__(self, other):\\n        return self.val == other.val\\n        \\n    def __lt__(self, other):\\n        return self.val > other.val\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        word_count = Counter(words)\\n        min_heap = []\\n        for w in word_count:\\n            heapq.heappush(min_heap, ((word_count[w], WrapString(w)), w))\\n            if len(min_heap) > k:\\n                heapq.heappop(min_heap)\\n        return [heapq.heappop(min_heap)[1] for _ in range(len(min_heap))][::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "``` python\\nfrom collections import Counter\\nimport heapq\\n\\nclass WrapString:\\n    def __init__(self, string):\\n        self.val = string\\n\\n    def __eq__(self, other):\\n        return self.val == other.val\\n        \\n    def __lt__(self, other):\\n        return self.val > other.val\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        word_count = Counter(words)\\n        min_heap = []\\n        for w in word_count:\\n            heapq.heappush(min_heap, ((word_count[w], WrapString(w)), w))\\n            if len(min_heap) > k:\\n                heapq.heappop(min_heap)\\n        return [heapq.heappop(min_heap)[1] for _ in range(len(min_heap))][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108383,
                "title": "12-lines-c-min-heap-o-nlogk-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string>res;\\n        unordered_map<string, int>m;\\n        auto comp = [](pair<int, string>& a, pair<int, string>& b){ return a.first == b.first ? a.second < b.second : a.first > b.first; };\\n        priority_queue<pair<int, string>, vector<pair<int, string> >, decltype(comp)>pq(comp);\\n        for(auto x: words) m[x]++;\\n        for(auto x: m){\\n            pq.push({x.second, x.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        while(!pq.empty()) res.push_back(pq.top().second), pq.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string>res;\\n        unordered_map<string, int>m;\\n        auto comp = [](pair<int, string>& a, pair<int, string>& b){ return a.first == b.first ? a.second < b.second : a.first > b.first; };\\n        priority_queue<pair<int, string>, vector<pair<int, string> >, decltype(comp)>pq(comp);\\n        for(auto x: words) m[x]++;\\n        for(auto x: m){\\n            pq.push({x.second, x.first});\\n            if(pq.size() > k) pq.pop();\\n        }\\n        while(!pq.empty()) res.push_back(pq.top().second), pq.pop();\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 108384,
                "title": "python-with-explanation",
                "content": "We know that the maximum frequency of words cannot exceed N because there is only a maximum of N words.\\n\\nInput: `[\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]`\\n\\nFrequency: `{\"i\": 2, \"love\": 2, \"leetcode\": 1, \"coding\": 1}`\\n\\nGroup by frequency: `{ 1: [\"leetcode\", \"coding\"], 2: [\"i\", \"love\"] }`\\n\\nHence we can count the frequency of the words and group them by frequency. Iterate through the group starting from a frequency of N and collect until you have at least k words. We then sort the final list and that takes approximately O(klgk), worst case O(nlgn) if every word only appears once.\\n\\n```\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # Time: O(n + klgk)\\n        # Space: O(n)\\n        from collections import Counter\\n        counter = Counter(words)\\n        freqs = {}\\n        for word, count in counter.items():\\n            if count not in freqs:\\n                freqs[count] = []\\n            freqs[count].append(word)\\n        res = []\\n        for i in range(len(words), 0, -1):\\n            if i in freqs:\\n                for word in freqs[i]:\\n                    res.append((word, i))\\n            if len(res) >= k:\\n                break\\n        res.sort(cmp=lambda a, b: (b[1] - a[1]) if a[1] != b[1] else (-1 if a[0] < b[0] else 1))\\n        return [el[0] for el in res[:k]]\\n```\\n\\n*- Yangshun*",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # Time: O(n + klgk)\\n        # Space: O(n)\\n        from collections import Counter\\n        counter = Counter(words)\\n        freqs = {}\\n        for word, count in counter.items():\\n            if count not in freqs:\\n                freqs[count] = []\\n            freqs[count].append(word)\\n        res = []\\n        for i in range(len(words), 0, -1):\\n            if i in freqs:\\n                for word in freqs[i]:\\n                    res.append((word, i))\\n            if len(res) >= k:\\n                break\\n        res.sort(cmp=lambda a, b: (b[1] - a[1]) if a[1] != b[1] else (-1 if a[0] < b[0] else 1))\\n        return [el[0] for el in res[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400030,
                "title": "simple-javascript-solution-76ms",
                "content": "Runtime: 76 ms, faster than 46.76% of JavaScript online submissions for Top K Frequent Words.\\nMemory Usage: 37.2 MB, less than 100.00% of JavaScript online submissions for Top K Frequent Words.\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n    const mappings = {}\\n    for (let i = 0; i < words.length; i++) {\\n        mappings[words[i]] = mappings[words[i]] + 1 || 1\\n    }\\n    const sorted = Object.keys(mappings).sort((a, b) => { \\n        if (mappings[b] === mappings[a]) { \\n            return a > b ? 1 : -1 \\n        }\\n        return mappings[b] - mappings[a]\\n    })\\n    return sorted.slice(0, k)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n    const mappings = {}\\n    for (let i = 0; i < words.length; i++) {\\n        mappings[words[i]] = mappings[words[i]] + 1 || 1\\n    }\\n    const sorted = Object.keys(mappings).sort((a, b) => { \\n        if (mappings[b] === mappings[a]) { \\n            return a > b ? 1 : -1 \\n        }\\n        return mappings[b] - mappings[a]\\n    })\\n    return sorted.slice(0, k)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203980,
                "title": "simple-java-solution-using-map-and-bucketsort-beats-95",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        if(words.length == 0) return new ArrayList<>();\\n        \\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for(String word : words)\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) +1);\\n        \\n        List<String>[] count = new List[words.length+1];\\n        \\n        for(Map.Entry<String, Integer> entry : wordMap.entrySet()) {\\n            if(count[entry.getValue()] == null)\\n                count[entry.getValue()] = new ArrayList<>();\\n            count[entry.getValue()].add(entry.getKey());\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for(int i=count.length-1; i >=0 && k > 0; i--) {\\n            if(count[i] == null) continue;\\n            Collections.sort(count[i]);\\n            List<String> temp = count[i].subList(0, Math.min(count[i].size(), k));\\n            result.addAll(temp);\\n            k = k - temp.size();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        if(words.length == 0) return new ArrayList<>();\\n        \\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for(String word : words)\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) +1);\\n        \\n        List<String>[] count = new List[words.length+1];\\n        \\n        for(Map.Entry<String, Integer> entry : wordMap.entrySet()) {\\n            if(count[entry.getValue()] == null)\\n                count[entry.getValue()] = new ArrayList<>();\\n            count[entry.getValue()].add(entry.getKey());\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for(int i=count.length-1; i >=0 && k > 0; i--) {\\n            if(count[i] == null) continue;\\n            Collections.sort(count[i]);\\n            List<String> temp = count[i].subList(0, Math.min(count[i].size(), k));\\n            result.addAll(temp);\\n            k = k - temp.size();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721398,
                "title": "python-rust-c-concise-using-map-heap-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/825677154/) employs *Counter* to obtain sorted word frequencies. It demonstrated **54 ms runtime (97.95%)** and used **13.9 MB memory (94.22%)**. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        \\n        # [1] Starting from Python 3.7, dictionary order is guaranteed \\n        #     to be insertion order, thus, we can use \\'sorted\\' first\\n        return [w for w,_ in Counter(sorted(words)).most_common(k)]\\n        \\n        # [2] Other one-liners are also possible, e.g.,\\n        #     return list(zip(*Counter(sorted(words)).most_common(k)))[0]\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/825788554/) employs *HashMap* and *BinaryHeap* to compute sorted frequencies. It demonstrated **0 ms runtime (100.00%)** and used **2.2 MB memory (37.84%)**. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n```\\nuse std::collections::{HashMap, BinaryHeap};\\nuse std::cmp::Reverse;\\n\\nimpl Solution \\n{\\n    pub fn top_k_frequent(words: Vec<String>, k: i32) -> Vec<String> \\n    {\\n        // [1] obtain word frequencies\\n        let mut freq = words\\n            .into_iter()\\n            .fold(HashMap::new(), |mut f,w| { *f.entry(w).or_default() += 1; f });\\n        \\n        // [2] heapify to sort:\\n        //     - first, by count in decreasing order\\n        //     - next, by word in alphabetic (reverse) order\\n        let mut heap = freq\\n            .into_iter()\\n            .map(|(w, c)| (c, Reverse(w)))\\n            .collect::<BinaryHeap<(i32,Reverse<String>)>>();\\n\\n        // [3] extract first k elements from the heap\\n        (0..k)\\n            .map(|_| heap.pop().unwrap().1.0)\\n            .collect()\\n\\n        // in nightly Rust, there is another solution:\\n        // heap.into_iter_sorted()\\n        //    .take(k as usize)\\n        //    .map(|(c,Reverse(s))| s)\\n        //    .collect::<Vec<String>>()\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/825832080/) employs *unordered_map* and *priority_queue* to obtain sorted frequencies. It demonstrated **4 ms runtime (99.62%)** and used **12.7 MB memory (39.56%)**. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**.\\n```\\nclass Solution \\n{\\n    using strint = pair<string, int>;\\n    \\n    // define a custom comparator for the frequency string/int pairs \\n    struct cmp \\n    {\\n        bool operator()(const strint& left, const strint& right) const \\n        {\\n            return left.second != right.second ? \\n                   left.second < right.second : left.first > right.first;\\n        }\\n    };\\n    \\npublic:\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) \\n    {\\n        // [1] obtain word frequencies\\n        unordered_map<string, int> freq;\\n        for (auto& word : words) ++freq[word];\\n        \\n        // [2] heapify to sort\\n        priority_queue<strint, vector<strint>, cmp> heap { freq.begin(), freq.end() };\\n        \\n        // [3] extract first k elements from the heap\\n        vector<string> res;\\n        while (!heap.empty() && k--) { res.push_back(heap.top().first); heap.pop(); }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        \\n        # [1] Starting from Python 3.7, dictionary order is guaranteed \\n        #     to be insertion order, thus, we can use \\'sorted\\' first\\n        return [w for w,_ in Counter(sorted(words)).most_common(k)]\\n        \\n        # [2] Other one-liners are also possible, e.g.,\\n        #     return list(zip(*Counter(sorted(words)).most_common(k)))[0]\\n```\n```\\nuse std::collections::{HashMap, BinaryHeap};\\nuse std::cmp::Reverse;\\n\\nimpl Solution \\n{\\n    pub fn top_k_frequent(words: Vec<String>, k: i32) -> Vec<String> \\n    {\\n        // [1] obtain word frequencies\\n        let mut freq = words\\n            .into_iter()\\n            .fold(HashMap::new(), |mut f,w| { *f.entry(w).or_default() += 1; f });\\n        \\n        // [2] heapify to sort:\\n        //     - first, by count in decreasing order\\n        //     - next, by word in alphabetic (reverse) order\\n        let mut heap = freq\\n            .into_iter()\\n            .map(|(w, c)| (c, Reverse(w)))\\n            .collect::<BinaryHeap<(i32,Reverse<String>)>>();\\n\\n        // [3] extract first k elements from the heap\\n        (0..k)\\n            .map(|_| heap.pop().unwrap().1.0)\\n            .collect()\\n\\n        // in nightly Rust, there is another solution:\\n        // heap.into_iter_sorted()\\n        //    .take(k as usize)\\n        //    .map(|(c,Reverse(s))| s)\\n        //    .collect::<Vec<String>>()\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    using strint = pair<string, int>;\\n    \\n    // define a custom comparator for the frequency string/int pairs \\n    struct cmp \\n    {\\n        bool operator()(const strint& left, const strint& right) const \\n        {\\n            return left.second != right.second ? \\n                   left.second < right.second : left.first > right.first;\\n        }\\n    };\\n    \\npublic:\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) \\n    {\\n        // [1] obtain word frequencies\\n        unordered_map<string, int> freq;\\n        for (auto& word : words) ++freq[word];\\n        \\n        // [2] heapify to sort\\n        priority_queue<strint, vector<strint>, cmp> heap { freq.begin(), freq.end() };\\n        \\n        // [3] extract first k elements from the heap\\n        vector<string> res;\\n        while (!heap.empty() && k--) { res.push_back(heap.top().first); heap.pop(); }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549599,
                "title": "javascript-max-priority-queue-solution-explained",
                "content": "we could use a max priority queue\\n1. iterate the array, build a hash map of all seen element and count\\n2. build a max PQ with all elements in order of count & alphabet\\n3. pop k times and save each to result\\n4. return the result\\n\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n\\tif(words.length === 0 || k === 0) {\\n\\t\\treturn [];\\n\\t}\\n\\t\\n\\t// build a hash map to count words\\n\\tconst hashMap = {};\\n\\n\\t// count words\\n\\twords.forEach((w) => hashMap[w]  // O(n)\\n\\t\\t? hashMap[w] = hashMap[w] + 1\\n\\t\\t: hashMap[w] = 1\\n\\t);\\n\\t\\n\\t// create a max priority queue, with custom compare function\\n\\tconst maxPQ = new MaxPriorityQueue({ \\n\\t\\n\\t\\t// custom compare function, swap if return 1, don\\'t swap if return -1\\n\\t\\tcompare: (w1, w2) => {\\n\\t\\t\\t// compare count first\\n\\t\\t\\tif (w1.count > w2.count) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif (w1.count < w2.count) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if count is the same, compare string(length and alphabetic order )\\n\\t\\t\\treturn w1.word > w2.word\\n\\t\\t\\t\\t? 1\\n\\t\\t\\t\\t: -1;\\n\\t\\t}\\n\\t});\\n\\n\\t// iterate word count hash map and put all element into max priority queue\\n\\tObject.keys(hashMap).forEach((w) => maxPQ.enqueue({ // O(n log n)\\n\\t\\tword: w, \\n\\t\\tcount: hashMap[w]\\n\\t}));\\n\\t\\n\\t// var to store result\\n\\tconst result = [];\\n\\t\\n\\t// pop k times from max priority queue for top k words\\n\\twhile(result.length < k) { // O(k log n)\\n\\t\\tconst top = maxPQ.dequeue();\\n\\t\\tresult.push(top.word);\\n\\t}\\n\\t\\n\\treturn result;\\n};\\n```\\n\\nTime O(n + n log n + k log n) ~ O(n log n)",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {number} k\\n * @return {string[]}\\n */\\nvar topKFrequent = function(words, k) {\\n\\tif(words.length === 0 || k === 0) {\\n\\t\\treturn [];\\n\\t}\\n\\t\\n\\t// build a hash map to count words\\n\\tconst hashMap = {};\\n\\n\\t// count words\\n\\twords.forEach((w) => hashMap[w]  // O(n)\\n\\t\\t? hashMap[w] = hashMap[w] + 1\\n\\t\\t: hashMap[w] = 1\\n\\t);\\n\\t\\n\\t// create a max priority queue, with custom compare function\\n\\tconst maxPQ = new MaxPriorityQueue({ \\n\\t\\n\\t\\t// custom compare function, swap if return 1, don\\'t swap if return -1\\n\\t\\tcompare: (w1, w2) => {\\n\\t\\t\\t// compare count first\\n\\t\\t\\tif (w1.count > w2.count) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif (w1.count < w2.count) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if count is the same, compare string(length and alphabetic order )\\n\\t\\t\\treturn w1.word > w2.word\\n\\t\\t\\t\\t? 1\\n\\t\\t\\t\\t: -1;\\n\\t\\t}\\n\\t});\\n\\n\\t// iterate word count hash map and put all element into max priority queue\\n\\tObject.keys(hashMap).forEach((w) => maxPQ.enqueue({ // O(n log n)\\n\\t\\tword: w, \\n\\t\\tcount: hashMap[w]\\n\\t}));\\n\\t\\n\\t// var to store result\\n\\tconst result = [];\\n\\t\\n\\t// pop k times from max priority queue for top k words\\n\\twhile(result.length < k) { // O(k log n)\\n\\t\\tconst top = maxPQ.dequeue();\\n\\t\\tresult.push(top.word);\\n\\t}\\n\\t\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220302,
                "title": "python-o-nlogk-99-runtime-86-memory",
                "content": "The key to solving this question is really two parts. \\n1. You have to use a heap to only store `k` values.\\n2. You need to implement a custom comparitor that takes care of the weird logic for comparing words.\\n\\nNote: At the end I call `sorted(heap, reverse=True)` This is because Python\\'s `sorted` function uses Timsort, which would be quicker than using `heapq.heappop` to build the list to return. Both are `O(nlogn)` time (Timsort actually has `O(n)` best-case performance), but Timsort generally gives slightly better performance.\\n\\n```\\nclass HeapWord:\\n    def __init__(self, word, count):\\n        self.word = word\\n        self.count = count\\n            \\n    def __gt__(self, other):\\n        if self.count > other.count:\\n            return True\\n        \\n        elif self.count < other.count:\\n            return False\\n        \\n        for s, o in zip_longest(self.word, other.word, fillvalue=\\'#\\'):\\n            # if a letter is \\'#\\', that means it is smaller that the other word,\\n            # and therefore is GREATER\\n            if s < o or s == \\'#\\':\\n                return True \\n            elif s > o or o == \"#\":\\n                return False      \\n\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counter = Counter(words)\\n        heap = []\\n        \\n        for w, count in counter.items():\\n            word = HeapWord(w, count)\\n            \\n            if len(heap) < k:\\n                heapq.heappush(heap, word)\\n                \\n            elif word > heap[0]:\\n                heapq.heapreplace(heap, word)\\n                    \\n        return [w.word for w in sorted(heap, reverse=True)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass HeapWord:\\n    def __init__(self, word, count):\\n        self.word = word\\n        self.count = count\\n            \\n    def __gt__(self, other):\\n        if self.count > other.count:\\n            return True\\n        \\n        elif self.count < other.count:\\n            return False\\n        \\n        for s, o in zip_longest(self.word, other.word, fillvalue=\\'#\\'):\\n            # if a letter is \\'#\\', that means it is smaller that the other word,\\n            # and therefore is GREATER\\n            if s < o or s == \\'#\\':\\n                return True \\n            elif s > o or o == \"#\":\\n                return False      \\n\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counter = Counter(words)\\n        heap = []\\n        \\n        for w, count in counter.items():\\n            word = HeapWord(w, count)\\n            \\n            if len(heap) < k:\\n                heapq.heappush(heap, word)\\n                \\n            elif word > heap[0]:\\n                heapq.heapreplace(heap, word)\\n                    \\n        return [w.word for w in sorted(heap, reverse=True)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524151,
                "title": "16ms-beats-84-10-6mb-beats-100-using-priority-queue-and-hashing-c",
                "content": "# Explaination: \\nThis solution uses priority_queue to get top K highest frequency elements. To get the frequencies of each string, I have used ***unordered_map<string, int>*** and then grabbed pairs from them and put them into priority_queue.\\n\\nThe ***priority_queue < pair<string, int>>, vector<pair<string, int>>, cmp >*** makes priority queue of strings with their frequencies. Here, I have made the cmp structure to override the sorting in priority queue. This cmp structure has the boolean function which checks whether the strings are having the same frequencies, if so it compares the strings and makes lexicographically smaller string come first; but if the frequencies are not equal, then the string with higher frequency is given priority over the other.\\n\\n# Solution: \\nHere is the short and crisp code in ***C***++...\\n\\n```\\ntypedef pair<string, int> PAIR;\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> dict;\\n        for(string s : words) {\\n            dict[s]++;\\n        }\\n        struct cmp {\\n            bool operator()(const PAIR &a, const PAIR &b) {\\n                return (a.second == b.second) ? \\n                    (a.first > b.first) : \\n                    (a.second < b.second);\\n            };\\n        };\\n        priority_queue<PAIR, vector<PAIR>, cmp> pq(dict.begin(), dict.end());\\n        vector<string> res;\\n        while (!pq.empty() && res.size() < k) {\\n            PAIR top = pq.top();\\n            res.push_back(top.first);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<string, int> PAIR;\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> dict;\\n        for(string s : words) {\\n            dict[s]++;\\n        }\\n        struct cmp {\\n            bool operator()(const PAIR &a, const PAIR &b) {\\n                return (a.second == b.second) ? \\n                    (a.first > b.first) : \\n                    (a.second < b.second);\\n            };\\n        };\\n        priority_queue<PAIR, vector<PAIR>, cmp> pq(dict.begin(), dict.end());\\n        vector<string> res;\\n        while (!pq.empty() && res.size() < k) {\\n            PAIR top = pq.top();\\n            res.push_back(top.first);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316935,
                "title": "different-python-solutions-counter-trie-heapq",
                "content": "Solution 1: Counter + heapq (Beat 82.61%)\\n```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        count = Counter(words)\\n        heap = [(-count[w], w) for w in count]\\n        heapq.heapify(heap)\\n        res = []\\n        while heap and k > 0:\\n            res.append(heapq.heappop(heap)[1])\\n            k -= 1\\n        return res\\n```\\n\\nSolution 2: Trie + heapq (Beat 7.96%)\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.freq = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.freq += 1\\n    \\n    def counter(self):\\n        def find_words(node, s):\\n            if node.freq > 0:\\n                lst.append((-node.freq, s))\\n            for char in node.children:\\n                find_words(node.children[char], s + char)\\n                \\n        lst = []\\n        find_words(self.root, \\'\\')\\n        return lst\\n        \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        heap = trie.counter()\\n        heapq.heapify(heap)\\n        res = []\\n        while heap and k > 0:\\n            res.append(heapq.heappop(heap)[1])\\n            k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        count = Counter(words)\\n        heap = [(-count[w], w) for w in count]\\n        heapq.heapify(heap)\\n        res = []\\n        while heap and k > 0:\\n            res.append(heapq.heappop(heap)[1])\\n            k -= 1\\n        return res\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.freq = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.freq += 1\\n    \\n    def counter(self):\\n        def find_words(node, s):\\n            if node.freq > 0:\\n                lst.append((-node.freq, s))\\n            for char in node.children:\\n                find_words(node.children[char], s + char)\\n                \\n        lst = []\\n        find_words(self.root, \\'\\')\\n        return lst\\n        \\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        heap = trie.counter()\\n        heapq.heapify(heap)\\n        res = []\\n        while heap and k > 0:\\n            res.append(heapq.heappop(heap)[1])\\n            k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307883,
                "title": "simple-javascript-solution",
                "content": "```\\nvar topKFrequent = function(words, k) {    \\n    if(words.length === 0)\\n        return null;\\n    \\n    const map = new Map();\\n    \\n    for(let i = 0; i < words.length; i++){\\n        map.set(words[i], (map.get(words[i]) || 0) + 1);\\n    }\\n    \\n    const result = [];\\n    \\n    for(let key of map.keys()){\\n        result.push([key, map.get(key)]);\\n    }\\n    \\n    result.sort((a, b) => {\\n        if(a[1] === b[1]){\\n            return a[0] > b[0] ? 1 : -1;\\n        }\\n        \\n        return b[1] - a[1];\\n    });    \\n   \\n    let i = 1;\\n    \\n    while(i < k){\\n        i++;\\n    }\\n    \\n    return result.slice(0, i).map(v => v[0]);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar topKFrequent = function(words, k) {    \\n    if(words.length === 0)\\n        return null;\\n    \\n    const map = new Map();\\n    \\n    for(let i = 0; i < words.length; i++){\\n        map.set(words[i], (map.get(words[i]) || 0) + 1);\\n    }\\n    \\n    const result = [];\\n    \\n    for(let key of map.keys()){\\n        result.push([key, map.get(key)]);\\n    }\\n    \\n    result.sort((a, b) => {\\n        if(a[1] === b[1]){\\n            return a[0] > b[0] ? 1 : -1;\\n        }\\n        \\n        return b[1] - a[1];\\n    });    \\n   \\n    let i = 1;\\n    \\n    while(i < k){\\n        i++;\\n    }\\n    \\n    return result.slice(0, i).map(v => v[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828789,
                "title": "java-memory-usage-less-than-99-21-treemap-stream-api",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new TreeMap<>();\\n        for (String s : words) {\\n            map.merge(s, 1, Integer::sum);\\n        }\\n        return map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .limit(k)\\n                .map(Map.Entry::getKey)\\n                .toList();\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5bda1a0b-adb0-4e87-895f-0a2cc185f2dd_1668822852.97628.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new TreeMap<>();\\n        for (String s : words) {\\n            map.merge(s, 1, Integer::sum);\\n        }\\n        return map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .limit(k)\\n                .map(Map.Entry::getKey)\\n                .toList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722719,
                "title": "aditya-verma-s-approach-c-easy-min-heap-solution-tc-o-n-log-k-sc-o-n",
                "content": "**Upvote If It Helps**\\n\\nIf you use mean heap you don\\'t need to make a custom comparator\\n\\n*Ask me in comments if you have any doubts \\uD83D\\uDE03*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string>ans;\\n        unordered_map<string,int>mp;\\n        for(auto i:words) mp[i]++;\\n        priority_queue<pair<int,string>>pq;\\n        for (auto it:mp){\\n            pq.push({-it.second,it.first});\\n            if(pq.size()>k) pq.pop();\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string>ans;\\n        unordered_map<string,int>mp;\\n        for(auto i:words) mp[i]++;\\n        priority_queue<pair<int,string>>pq;\\n        for (auto it:mp){\\n            pq.push({-it.second,it.first});\\n            if(pq.size()>k) pq.pop();\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721365,
                "title": "python-solution-sorted-dictionary-detailed-explanations",
                "content": "**Using a heap** \\u274C\\n\\nSince we\\'re trying to find the \"k most common\" something, we\\'re immediately tempted to use a heap. In reality, this approach proves very laborious - but let\\'s try to understand why by seeing where it takes us.\\n\\nThe idea goes as follows:\\n\\n- We create a hashmap of frequencies, i.e. a dictionary in which the keys are the words and the values are the number of times they appear in the array `words`;\\n\\n- We create a min-heap by iterating over the words in the dictionary, where each node in the heap is a tuple `(frequency, word)`. We make sure the heap\\'s length doesn\\'t exceed `k`,  by popping the root if it does at any point;\\n\\n- Eventually, we iterate by popping the heap\\'s root and appending it to a response array `res`, until the heap is empty. Since nodes are going to be popped by increasing frequencies, and we want the response array to be sorted in decreasing order, we need to return `res[::-1]` (`res` reversed).\\n\\nHere is the code to this solution:\\n\\n```\\n class Solution:\\n    def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        heap = []\\n        for key, val in dico.items():\\n            heapq.heappush(heap, (val, key))\\n            if len(heap)>k: heapq.heappop(heap)\\n        \\n        res = []\\n        while heap:\\n            res.append([heapq.heappop(heap)[1]])\\n        return res[::-1]\\n```\\n\\nThis solution **almost works - but doesn\\'t quite**. What\\'s missing is the fact that words in the response array should be sorted in lexicographical order when their frequencies are the same, which isn\\'t the case here (they\\'re simply sorted in the same order as in the original array `words`).\\n\\nIt turns out there is no easy way to make this work. What we would need is a way of changing the function that rules the way in which elements are added to a heap (instead of just comparing the first values of tuples), which would need us to define a new class. This can be done, but is for sure a bit tedious. Check out [this SO thread](https://stackoverflow.com/questions/8875706/heapq-with-custom-compare-predicate) for more details.\\n\\n***\\n\\n**Using a sorted dictionary** \\u2705\\n\\nIn reality, there is a much easier way around this problem. We can\\'t customize easily how elements are added to a heap, but we can sort a dictionary in a customized way thanks to a lambda function. So once we\\'ve created our dictionary, we can turn it into a list correctly sorted - i.e. by decreasing frequencies, and then by lexicographical order -  and then return this list (sliced at index `k` to make sure we return only the `k` most frequent words).\\n\\nThis is actually quite straightforward to code. Little trick used here: when comparing tuples, the first element is used, and then the second one - so `lambda x: (-dico[x], x)` will first compare frequencies (with a minus sign to make sure the list is sorted in decreasing order in terms of frequencies) and then strings (which results in a lexicographical comparison).\\n\\nFinal code:\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        res = sorted(dico, key = lambda x: (-dico[x], x))\\n        return res[:k]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n class Solution:\\n    def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        heap = []\\n        for key, val in dico.items():\\n            heapq.heappush(heap, (val, key))\\n            if len(heap)>k: heapq.heappop(heap)\\n        \\n        res = []\\n        while heap:\\n            res.append([heapq.heappop(heap)[1]])\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        res = sorted(dico, key = lambda x: (-dico[x], x))\\n        return res[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648996,
                "title": "python-3-4-liner-hashmap",
                "content": "**4lines** if you don\\'t think of the spaces:\\n```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        dicktionary = defaultdict(int)\\n        for i in words: dicktionary[i] += 1\\n        \\n        sorted_dick = sorted(dicktionary.items(), key=lambda x: (-x[1], x[0]))\\n        \\n        return [i[0] for i in sorted_dick][:k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        dicktionary = defaultdict(int)\\n        for i in words: dicktionary[i] += 1\\n        \\n        sorted_dick = sorted(dicktionary.items(), key=lambda x: (-x[1], x[0]))\\n        \\n        return [i[0] for i in sorted_dick][:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560939,
                "title": "simple-java-solution-using-map-and-sorting",
                "content": "class Solution {\\n\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String , Integer> freq = new HashMap<>();\\n        \\n        for(String word : words)\\n            freq.put(word,freq.getOrDefault(word , 0) + 1);\\n        \\n        ArrayList<String> res = new ArrayList<>(freq.keySet());\\n        \\n        Collections.sort(res , (a,b) -> freq.get(b) != freq.get(a) ? freq.get(b) - freq.get(a) : a.compareTo(b));\\n        \\n        return res.subList(0,k);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String , Integer> freq = new HashMap<>();\\n        \\n        for(String word : words)\\n            freq.put(word,freq.getOrDefault(word , 0) + 1);\\n        \\n        ArrayList<String> res = new ArrayList<>(freq.keySet());\\n        \\n        Collections.sort(res , (a,b) -> freq.get(b) != freq.get(a) ? freq.get(b) - freq.get(a) : a.compareTo(b));\\n        \\n        return res.subList(0,k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1440463,
                "title": "python-solution-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 44ms   -   99.04%\\n#   Memory: 14.2MB  -   96.94%\\n\\n######################################################\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        # Word as key and its frequency in words as value\\n        dictionary = {}\\n        # Finding the word count and storing in dictionary\\n        for word in words:\\n            if word in dictionary: dictionary[word] += 1\\n            else: dictionary[word] = 1\\n        # Converting the dictionary into list of tuples using dictionary.items()\\n        # Using Lambda function to sort that tuple, first using Word count using \\n        # -word[1]. Why -word[1] but not word[1] is we want to sort in descending \\n        # order according to word count. For words having count same we have to sort\\n        # them lexographically so we next add word[0]. That is the use of\\n        # (-word[1], word[0]). \\n        dictionary = sorted(dictionary.items(), key = lambda word: (-word[1], word[0]))\\n        # Using List Comprehension and creating a list with words from dictionary till\\n        # k length\\n        return [word[0] for word in dictionary[:k]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 44ms   -   99.04%\\n#   Memory: 14.2MB  -   96.94%\\n\\n######################################################\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        # Word as key and its frequency in words as value\\n        dictionary = {}\\n        # Finding the word count and storing in dictionary\\n        for word in words:\\n            if word in dictionary: dictionary[word] += 1\\n            else: dictionary[word] = 1\\n        # Converting the dictionary into list of tuples using dictionary.items()\\n        # Using Lambda function to sort that tuple, first using Word count using \\n        # -word[1]. Why -word[1] but not word[1] is we want to sort in descending \\n        # order according to word count. For words having count same we have to sort\\n        # them lexographically so we next add word[0]. That is the use of\\n        # (-word[1], word[0]). \\n        dictionary = sorted(dictionary.items(), key = lambda word: (-word[1], word[0]))\\n        # Using List Comprehension and creating a list with words from dictionary till\\n        # k length\\n        return [word[0] for word in dictionary[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000542,
                "title": "java-easy-priority-queue-approach",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s: words)\\n            map.put(s, map.getOrDefault(s, 0)+ 1);\\n        \\n\\t\\t//custom comparator for comparing the words\\n        Queue<String> q = new PriorityQueue<>((w1, w2) -> map.get(w1).equals(map.get(w2)) ?\\n                w2.compareTo(w1) : map.get(w1) - map.get(w2));\\n        \\n\\t\\t//add to the heap\\n        for (String word: map.keySet()){\\n            q.add(word);\\n            if (q.size() > k) q.poll();\\n        }\\n                                       \\n        //add to the result\\n        List<String> result = new ArrayList<>();\\n        while (!q.isEmpty())\\n            result.add(q.poll());\\n        Collections.reverse(result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s: words)\\n            map.put(s, map.getOrDefault(s, 0)+ 1);\\n        \\n\\t\\t//custom comparator for comparing the words\\n        Queue<String> q = new PriorityQueue<>((w1, w2) -> map.get(w1).equals(map.get(w2)) ?\\n                w2.compareTo(w1) : map.get(w1) - map.get(w2));\\n        \\n\\t\\t//add to the heap\\n        for (String word: map.keySet()){\\n            q.add(word);\\n            if (q.size() > k) q.poll();\\n        }\\n                                       \\n        //add to the result\\n        List<String> result = new ArrayList<>();\\n        while (!q.isEmpty())\\n            result.add(q.poll());\\n        Collections.reverse(result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933479,
                "title": "python3-trie-bucket-sort",
                "content": "To save the trouble of sorting words (including simply sorting the results and using heap), we can use bucket sort and Trie instead.Bucket[i] = a TrieNode of words with frequency i. So we add words to the Trie according to its frequency. And since words are alphabetically added, we do not need to sort them, but simply add until we have k words in the list.\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None for _ in range(26)]\\n        self.word = None\\n        \\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        count = collections.Counter(words)\\n        buckets = [TrieNode() for _ in range(len(words) + 1)]\\n        for word in count:\\n            root = buckets[count[word]]\\n            self.add(word, root)\\n        \\n        res = []\\n        for i in range(len(buckets) - 1, -1, -1):\\n            if not buckets[i].children:\\n                continue\\n            self.getWord(res, buckets[i], k)\\n            if len(res) >= k:\\n                return res\\n        return res\\n    \\n    def add(self, word, root):\\n        for c in word:\\n            if root.children[ord(c) - ord(\"a\")] == None:\\n                root.children[ord(c) - ord(\"a\")] = TrieNode()\\n            root = root.children[ord(c) - ord(\"a\")]\\n        root.word = word\\n        \\n        \\n    def getWord(self, res, root, k):\\n        if not root:\\n            return \\n        if len(res) >= k:\\n            return \\n        if root.word:\\n            res.append(root.word)\\n        \\n        for i in range(26):\\n            self.getWord(res, root.children[i], k)\\n        return \\n```\\n\\nPlease upvote if you find it helpful!",
                "solutionTags": [
                    "Python3",
                    "Trie",
                    "Bucket Sort"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None for _ in range(26)]\\n        self.word = None\\n        \\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        count = collections.Counter(words)\\n        buckets = [TrieNode() for _ in range(len(words) + 1)]\\n        for word in count:\\n            root = buckets[count[word]]\\n            self.add(word, root)\\n        \\n        res = []\\n        for i in range(len(buckets) - 1, -1, -1):\\n            if not buckets[i].children:\\n                continue\\n            self.getWord(res, buckets[i], k)\\n            if len(res) >= k:\\n                return res\\n        return res\\n    \\n    def add(self, word, root):\\n        for c in word:\\n            if root.children[ord(c) - ord(\"a\")] == None:\\n                root.children[ord(c) - ord(\"a\")] = TrieNode()\\n            root = root.children[ord(c) - ord(\"a\")]\\n        root.word = word\\n        \\n        \\n    def getWord(self, res, root, k):\\n        if not root:\\n            return \\n        if len(res) >= k:\\n            return \\n        if root.word:\\n            res.append(root.word)\\n        \\n        for i in range(26):\\n            self.getWord(res, root.children[i], k)\\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 923385,
                "title": "one-more-solution-in-python-easy",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        if len(words)==0:\\n            return None\\n        d= {}\\n        for word in words:\\n            if word not in d:\\n                d[word] = 1\\n            else:\\n                d[word] += 1\\n        print(d)\\n        nd = sorted(d.items(),key=lambda num:(-num[1],num[0]))\\n        ans = []\\n        for i in range(k):\\n            ans.append(nd[i][0])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        if len(words)==0:\\n            return None\\n        d= {}\\n        for word in words:\\n            if word not in d:\\n                d[word] = 1\\n            else:\\n                d[word] += 1\\n        print(d)\\n        nd = sorted(d.items(),key=lambda num:(-num[1],num[0]))\\n        ans = []\\n        for i in range(k):\\n            ans.append(nd[i][0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905372,
                "title": "simplest-python-solutions-o-nlogn-time-and-o-n-space-beats-98-time",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        myC=collections.Counter(words)\\n        \\n        return [w for w,v in sorted(myC.items(), key=lambda x:(-x[1],x[0]))][:k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        myC=collections.Counter(words)\\n        \\n        return [w for w,v in sorted(myC.items(), key=lambda x:(-x[1],x[0]))][:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864478,
                "title": "easy-js-solution",
                "content": "```\\nvar topKFrequent = function(words, k) {\\n    let m = new Map();\\n    words.forEach(word => m.set(word, m.get(word)+1 || 1));\\n    let arr = Array.from(m.entries()).sort((a,b) => {\\n\\t\\t\\t\\t\\treturn a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1]-a[1];\\n\\t\\t\\t\\t\\t}).slice(0,k).map(pair => pair[0]);\\n    return arr;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar topKFrequent = function(words, k) {\\n    let m = new Map();\\n    words.forEach(word => m.set(word, m.get(word)+1 || 1));\\n    let arr = Array.from(m.entries()).sort((a,b) => {\\n\\t\\t\\t\\t\\treturn a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1]-a[1];\\n\\t\\t\\t\\t\\t}).slice(0,k).map(pair => pair[0]);\\n    return arr;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 728179,
                "title": "classic-c-style-with-lambda-comparator-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        auto compare = [](pair<string,int> &x,pair<string,int> &y){\\n            if(x.second==y.second){\\n                return x.first.compare(y.first)<0;\\n            }\\n            else{\\n                return x.second>y.second;\\n            }\\n        };\\n        \\n        map<string,int>mp;\\n        priority_queue<pair<string,int>,vector<pair<string,int>>,decltype(compare)>pq(compare);\\n        vector<string>res(k);\\n        \\n        for(auto word: words){\\n           mp[word]++; \\n        }\\n        for(auto &word_freq:mp){\\n            if(pq.size()<k){\\n                pq.push({word_freq.first,word_freq.second});\\n            }\\n            else{\\n                if(pq.top().second < word_freq.second){\\n                    pq.pop();\\n                    pq.push({word_freq.first,word_freq.second});\\n                }\\n            }\\n        }\\n        int index = k-1;\\n        while(!pq.empty()){\\n            res[index--] = pq.top().first;\\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        auto compare = [](pair<string,int> &x,pair<string,int> &y){\\n            if(x.second==y.second){\\n                return x.first.compare(y.first)<0;\\n            }\\n            else{\\n                return x.second>y.second;\\n            }\\n        };\\n        \\n        map<string,int>mp;\\n        priority_queue<pair<string,int>,vector<pair<string,int>>,decltype(compare)>pq(compare);\\n        vector<string>res(k);\\n        \\n        for(auto word: words){\\n           mp[word]++; \\n        }\\n        for(auto &word_freq:mp){\\n            if(pq.size()<k){\\n                pq.push({word_freq.first,word_freq.second});\\n            }\\n            else{\\n                if(pq.top().second < word_freq.second){\\n                    pq.pop();\\n                    pq.push({word_freq.first,word_freq.second});\\n                }\\n            }\\n        }\\n        int index = k-1;\\n        while(!pq.empty()){\\n            res[index--] = pq.top().first;\\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529058,
                "title": "c-apply-two-data-structures-sorteddictionary-and-sortedset",
                "content": "March 4, 2020\\nIt is my first practice, so I like to solve the problem first, and then I will work on optimzing the time complexity. \\n\\nHere are highlights:\\n\\n1. First step, save all word and count into hashmap; C# Dictionary<string, int> is used to store data; \\n2. Next step, SortedDictionary<int, SortedSet<string>> is used to store key as count of a word, and value as a list of string sorted by lexicographic order. \\n3. In order to apply ascending order of SortedDictionary, -1 * word of count is used, so that bigger count will be listed first. \\n4. Time complexity can be improved since all words are sorted by number of count, but only top K are needed to be sorted. \\n\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _692_top_sorted_k_elements\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = TopKFrequent(new string[] { \"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\" }, 2);\\n        }\\n\\n        public static IList<string> TopKFrequent(string[] words, int k)\\n        {\\n            if (words == null)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var map = new Dictionary<string, int>();\\n            foreach (var item in words)\\n            {\\n                if(!map.ContainsKey(item))\\n                {\\n                    map.Add(item, 0);\\n                }\\n\\n                map[item]++; \\n            }\\n\\n            var sorted = new SortedDictionary<int, SortedSet<string>>(); \\n            foreach(var pair in map)\\n            {\\n                var key = pair.Key;\\n                var value = -1 * pair.Value;\\n                \\n\\n                if (!sorted.ContainsKey(value))\\n                {\\n                    sorted.Add(value, new SortedSet<string>());\\n                }\\n\\n                sorted[value].Add(key); \\n            }\\n\\n            int count = 0;\\n            var topK = new List<string>();\\n            var foundK = false;\\n\\n            foreach (var key in sorted.Keys)\\n            {\\n                var sortedWords = sorted[key];\\n                foreach (var item in sortedWords)\\n                {\\n                    if (count < k)\\n                    {\\n                        topK.Add(item);\\n                        count++;\\n                    }\\n                    if (count >= k)\\n                    {\\n                        foundK = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (foundK)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return topK; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _692_top_sorted_k_elements\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = TopKFrequent(new string[] { \"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\" }, 2);\\n        }\\n\\n        public static IList<string> TopKFrequent(string[] words, int k)\\n        {\\n            if (words == null)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var map = new Dictionary<string, int>();\\n            foreach (var item in words)\\n            {\\n                if(!map.ContainsKey(item))\\n                {\\n                    map.Add(item, 0);\\n                }\\n\\n                map[item]++; \\n            }\\n\\n            var sorted = new SortedDictionary<int, SortedSet<string>>(); \\n            foreach(var pair in map)\\n            {\\n                var key = pair.Key;\\n                var value = -1 * pair.Value;\\n                \\n\\n                if (!sorted.ContainsKey(value))\\n                {\\n                    sorted.Add(value, new SortedSet<string>());\\n                }\\n\\n                sorted[value].Add(key); \\n            }\\n\\n            int count = 0;\\n            var topK = new List<string>();\\n            var foundK = false;\\n\\n            foreach (var key in sorted.Keys)\\n            {\\n                var sortedWords = sorted[key];\\n                foreach (var item in sortedWords)\\n                {\\n                    if (count < k)\\n                    {\\n                        topK.Add(item);\\n                        count++;\\n                    }\\n                    if (count >= k)\\n                    {\\n                        foundK = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (foundK)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return topK; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481745,
                "title": "java-priorityqueue-and-hashmap",
                "content": "Priority Queue comparator:\\nsort from freq heigh to low\\nif freq same, sort from alphabetical order.\\n```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> m = new HashMap<>();\\n        for (String w : words) {\\n            m.put(w, m.getOrDefault(w, 0) + 1);\\n        }\\n        \\n        Queue<String> pq = new PriorityQueue<>\\n            (k + 1, (a, b) -> m.get(a) == m.get(b) ? b.compareTo(a) : m.get(a) - m.get(b));\\n        for (String w : m.keySet()) {\\n            pq.offer(w);\\n            if(pq.size() > k){\\n                pq.poll();\\n            }\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        while(!pq.isEmpty()){\\n            res.add(0, pq.poll());\\n        }\\n        \\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> m = new HashMap<>();\\n        for (String w : words) {\\n            m.put(w, m.getOrDefault(w, 0) + 1);\\n        }\\n        \\n        Queue<String> pq = new PriorityQueue<>\\n            (k + 1, (a, b) -> m.get(a) == m.get(b) ? b.compareTo(a) : m.get(a) - m.get(b));\\n        for (String w : m.keySet()) {\\n            pq.offer(w);\\n            if(pq.size() > k){\\n                pq.poll();\\n            }\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        while(!pq.isEmpty()){\\n            res.add(0, pq.poll());\\n        }\\n        \\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 238167,
                "title": "java-solutions",
                "content": "**Solution 1: Using HashMap and minHeap - Accepted in 48 ms**\\n\\nTime complexity: `O(n log k)` - where `k` is the size of `minHeap`. Insertion and removal of each element from `minHeap` will take `2 * log k` time.\\nSpace Complexity: `O(n + k)` - space required for `HashMap` and `minHeap`.\\n\\n```\\nclass Solution\\n{\\n    public List<String> topKFrequent(String[] words, int k)\\n\\t{\\n        PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>((a,b) -> a.getValue() == b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue() - b.getValue());\\n\\t\\tMap<String, Integer> map = new HashMap<>();\\n\\t\\tList<String> list = new LinkedList<>();\\n\\n\\t\\tfor(String word : words)\\n\\t\\t\\tmap.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            minHeap.offer(entry);\\n\\n            if(minHeap.size() > k)\\n                minHeap.poll();\\n        }\\n\\n        while(!minHeap.isEmpty())\\n            list.add(0, minHeap.poll().getKey());\\n\\n        return list;\\n    }\\n}\\n```\\n\\n**Solution 2: Using minHeap and Helper class - Accepted in 9 ms**\\n\\nTime complexity: `O(n log k)` - where `k` is the size of `minHeap`. Insertion and removal of each element from `minHeap` will take `2 * log k` time.\\nSpace Complexity: `O(n + k)` - space required for `HashMap` and `minHeap`.\\n\\n```\\nclass Solution\\n{\\n    public List<String> topKFrequent(String[] words, int k)\\n\\t{\\n        PriorityQueue<Element> minHeap = new PriorityQueue<>();\\n\\t\\tMap<String, Element> wordCountMap = new HashMap<>();\\n\\t\\tList<String> list = new LinkedList<>();\\n\\n\\t\\tfor(String word : words)\\n\\t\\t{\\n\\t\\t\\tif(wordCountMap.containsKey(word))\\n\\t\\t\\t\\twordCountMap.get(word).count += 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\twordCountMap.put(word, new Element(word, 1));\\n\\t\\t}\\n\\n        for(Element e : wordCountMap.values())\\n\\t\\t{\\n\\t\\t\\tminHeap.add(e);\\n\\t\\t\\t\\n\\t\\t\\tif(minHeap.size() > k)\\n\\t\\t\\t\\tminHeap.poll();\\n        }\\n\\n\\t\\twhile(!minHeap.isEmpty())\\n            list.add(0, minHeap.poll().word);\\n\\n        return list;\\n    }\\n\\n\\tprivate static class Element implements Comparable<Element>\\n\\t{\\n\\t\\tString word;\\n\\t\\tint count;\\n\\n\\t\\tpublic Element (String word, int count)\\n\\t\\t{\\n\\t\\t\\tthis.word = word;\\n\\t\\t\\tthis.count = count;\\n\\t\\t}\\n\\n\\t\\tpublic int compareTo(Element e)\\n\\t\\t{\\n\\t\\t\\tif(this.count == e.count)\\n\\t\\t\\t\\treturn e.word.compareTo(this.word);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn Integer.compare(this.count, e.count);\\n\\t\\t}\\n\\t}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public List<String> topKFrequent(String[] words, int k)\\n\\t{\\n        PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>((a,b) -> a.getValue() == b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue() - b.getValue());\\n\\t\\tMap<String, Integer> map = new HashMap<>();\\n\\t\\tList<String> list = new LinkedList<>();\\n\\n\\t\\tfor(String word : words)\\n\\t\\t\\tmap.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            minHeap.offer(entry);\\n\\n            if(minHeap.size() > k)\\n                minHeap.poll();\\n        }\\n\\n        while(!minHeap.isEmpty())\\n            list.add(0, minHeap.poll().getKey());\\n\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<String> topKFrequent(String[] words, int k)\\n\\t{\\n        PriorityQueue<Element> minHeap = new PriorityQueue<>();\\n\\t\\tMap<String, Element> wordCountMap = new HashMap<>();\\n\\t\\tList<String> list = new LinkedList<>();\\n\\n\\t\\tfor(String word : words)\\n\\t\\t{\\n\\t\\t\\tif(wordCountMap.containsKey(word))\\n\\t\\t\\t\\twordCountMap.get(word).count += 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\twordCountMap.put(word, new Element(word, 1));\\n\\t\\t}\\n\\n        for(Element e : wordCountMap.values())\\n\\t\\t{\\n\\t\\t\\tminHeap.add(e);\\n\\t\\t\\t\\n\\t\\t\\tif(minHeap.size() > k)\\n\\t\\t\\t\\tminHeap.poll();\\n        }\\n\\n\\t\\twhile(!minHeap.isEmpty())\\n            list.add(0, minHeap.poll().word);\\n\\n        return list;\\n    }\\n\\n\\tprivate static class Element implements Comparable<Element>\\n\\t{\\n\\t\\tString word;\\n\\t\\tint count;\\n\\n\\t\\tpublic Element (String word, int count)\\n\\t\\t{\\n\\t\\t\\tthis.word = word;\\n\\t\\t\\tthis.count = count;\\n\\t\\t}\\n\\n\\t\\tpublic int compareTo(Element e)\\n\\t\\t{\\n\\t\\t\\tif(this.count == e.count)\\n\\t\\t\\t\\treturn e.word.compareTo(this.word);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn Integer.compare(this.count, e.count);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190691,
                "title": "python-o-nlogk-time-o-n-space",
                "content": "```\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass WordFreq:\n    def __init__(self, freq, word):\n        self.freq = freq\n        self.word = word\n    def __lt__(self, other):\n        if self.freq != other.freq:\n            return self.freq.__lt__(other.freq)\n        else:\n            return self.word.__gt__(other.word)\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # word frequency\n        word_frequency = defaultdict(int)\n        for word in words:\n            word_frequency[word] += 1\n        \n        # current k most frequent elements\n        k_most_frequent = []\n        for word, freq in word_frequency.items():\n            heappush(k_most_frequent, WordFreq(freq, word))\n            if len(k_most_frequent) == k + 1:\n                heappop(k_most_frequent)\n        \n        res = []\n        while len(k_most_frequent) != 0:\n            res.insert(0, heappop(k_most_frequent).word)\n        \n        return res\n```",
                "solutionTags": [],
                "code": "```\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass WordFreq:\n    def __init__(self, freq, word):\n        self.freq = freq\n        self.word = word\n    def __lt__(self, other):\n        if self.freq != other.freq:\n            return self.freq.__lt__(other.freq)\n        else:\n            return self.word.__gt__(other.word)\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # word frequency\n        word_frequency = defaultdict(int)\n        for word in words:\n            word_frequency[word] += 1\n        \n        # current k most frequent elements\n        k_most_frequent = []\n        for word, freq in word_frequency.items():\n            heappush(k_most_frequent, WordFreq(freq, word))\n            if len(k_most_frequent) == k + 1:\n                heappop(k_most_frequent)\n        \n        res = []\n        while len(k_most_frequent) != 0:\n            res.insert(0, heappop(k_most_frequent).word)\n        \n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 125767,
                "title": "javascript-solution-beating-98-of-solutions",
                "content": "```\\nvar topKFrequent = function(words, k) {\\n  const wordCounts = words.reduce((a, b) => {\\n    a[b] ? a[b]++ : a[b] = 1;\\n    return a;\\n  }, {});\\n  return Object.keys(wordCounts).sort((a, b) => {\\n    if (wordCounts[a] > wordCounts[b]) return -1;\\n    if (wordCounts[b] > wordCounts[a]) return 1;\\n    else {\\n      return a.localeCompare(b);\\n    }\\n  }).slice(0, k);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar topKFrequent = function(words, k) {\\n  const wordCounts = words.reduce((a, b) => {\\n    a[b] ? a[b]++ : a[b] = 1;\\n    return a;\\n  }, {});\\n  return Object.keys(wordCounts).sort((a, b) => {\\n    if (wordCounts[a] > wordCounts[b]) return -1;\\n    if (wordCounts[b] > wordCounts[a]) return 1;\\n    else {\\n      return a.localeCompare(b);\\n    }\\n  }).slice(0, k);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3077571,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(string s:words)\\n            mp[s]++;\\n        priority_queue<pair<int,string>> pq;\\n\\n        for(auto it:mp)\\n        {\\n            pq.push({-it.second, it.first});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        \\n        vector<string> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> mp;\\n        for(string s:words)\\n            mp[s]++;\\n        priority_queue<pair<int,string>> pq;\\n\\n        for(auto it:mp)\\n        {\\n            pq.push({-it.second, it.first});\\n            if(pq.size()>k)\\n                pq.pop();\\n        }\\n        \\n        vector<string> ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721289,
                "title": "c-one-line-solution",
                "content": "\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<string> TopKFrequent(string[] words, int k)\\n    {\\n        return words.GroupBy(word => word).OrderByDescending(freq => freq.Count()).ThenBy(freq => freq.Key).Take(k).Select(freq => freq.Key).ToList();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> TopKFrequent(string[] words, int k)\\n    {\\n        return words.GroupBy(word => word).OrderByDescending(freq => freq.Count()).ThenBy(freq => freq.Key).Take(k).Select(freq => freq.Key).ToList();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720881,
                "title": "golang-simple-solution-using-map",
                "content": "```go\\nfunc topKFrequent(words []string, k int) []string {\\n        freq := make(map[string]int)\\n        var uniq []string\\n        for _, w := range words {\\n                if _, ok := freq[w]; !ok {\\n                        uniq = append(uniq, w)\\n                }\\n                freq[w]++\\n        }\\n\\n        sort.SliceStable(uniq, func(i, j int) bool {\\n                if freq[uniq[i]] == freq[uniq[j]] {\\n                        return uniq[i] < uniq[j]\\n                }\\n                return freq[uniq[i]] > freq[uniq[j]]\\n        })\\n\\n        return uniq[:k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc topKFrequent(words []string, k int) []string {\\n        freq := make(map[string]int)\\n        var uniq []string\\n        for _, w := range words {\\n                if _, ok := freq[w]; !ok {\\n                        uniq = append(uniq, w)\\n                }\\n                freq[w]++\\n        }\\n\\n        sort.SliceStable(uniq, func(i, j int) bool {\\n                if freq[uniq[i]] == freq[uniq[j]] {\\n                        return uniq[i] < uniq[j]\\n                }\\n                return freq[uniq[i]] > freq[uniq[j]]\\n        })\\n\\n        return uniq[:k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719947,
                "title": "daily-leetcoding-challenge-october-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Max Heap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/top-k-frequent-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2488258,
                "title": "c-priority-queue-comparator",
                "content": "```\\nclass Vaibhav\\n{\\n      public:\\n      string word;\\n      int freq;\\n      Vaibhav(string word,int freq)\\n      {\\n          this->word=word;\\n          this->freq=freq;\\n      }\\n};\\nclass Mycompare\\n{\\n    public:\\n    bool operator ()(Vaibhav item1,Vaibhav item2)\\n    {\\n        if(item1.freq!=item2.freq)\\n        {\\n            return item1.freq<item2.freq;\\n        }\\n        else\\n        {\\n            return item1.word>item2.word;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    public:\\n    vector<string> topKFrequent(vector<string>& words, int k) \\n    {\\n        map<string,int>mymap;\\n        for(auto word:words)\\n            mymap[word]++;\\n        priority_queue<Vaibhav,vector<Vaibhav>,Mycompare>highF;\\n        for(auto each:mymap)\\n        {\\n            string word=each.first;\\n            int freq=each.second;\\n            Vaibhav mypair(word,freq);\\n            highF.push(mypair);\\n        }\\n        vector<string>ans;\\n        while(k--)\\n        {\\n            Vaibhav topMost=highF.top();\\n            highF.pop();\\n            ans.push_back(topMost.word);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Vaibhav\\n{\\n      public:\\n      string word;\\n      int freq;\\n      Vaibhav(string word,int freq)\\n      {\\n          this->word=word;\\n          this->freq=freq;\\n      }\\n};\\nclass Mycompare\\n{\\n    public:\\n    bool operator ()(Vaibhav item1,Vaibhav item2)\\n    {\\n        if(item1.freq!=item2.freq)\\n        {\\n            return item1.freq<item2.freq;\\n        }\\n        else\\n        {\\n            return item1.word>item2.word;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    public:\\n    vector<string> topKFrequent(vector<string>& words, int k) \\n    {\\n        map<string,int>mymap;\\n        for(auto word:words)\\n            mymap[word]++;\\n        priority_queue<Vaibhav,vector<Vaibhav>,Mycompare>highF;\\n        for(auto each:mymap)\\n        {\\n            string word=each.first;\\n            int freq=each.second;\\n            Vaibhav mypair(word,freq);\\n            highF.push(mypair);\\n        }\\n        vector<string>ans;\\n        while(k--)\\n        {\\n            Vaibhav topMost=highF.top();\\n            highF.pop();\\n            ans.push_back(topMost.word);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233441,
                "title": "dictionary-priorityqueue-o-nlogk-time-o-n-space",
                "content": "```\\npublic class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string, int> frequencyMap = new Dictionary<string, int>();\\n        \\n        foreach(string word in words) {\\n            if(!frequencyMap.ContainsKey(word)) {\\n                frequencyMap[word] = 0;\\n            }\\n            \\n            frequencyMap[word]++;\\n        }\\n        \\n        PriorityQueue<string, KeyValuePair<string, int>> maxHeap = new(new NameComparer());\\n        \\n        foreach(KeyValuePair<string, int> entry in frequencyMap)\\n        {\\n           maxHeap.Enqueue(entry.Key, entry);\\n        }\\n\\n        List<string> result = new List<string>();\\n        \\n        while(k > 0 && maxHeap.Count > 0) {\\n            string word = maxHeap.Dequeue();\\n            result.Add(word);\\n            k--;        \\n        }   \\n        \\n        return result;\\n    }\\n    \\n    public class NameComparer: IComparer<KeyValuePair<string, int>>\\n\\t{\\n\\t\\tpublic int Compare(KeyValuePair<string, int> x, KeyValuePair<string,int> y) => \\n\\t\\t\\t(x.Value == y.Value) ? (x.Key.CompareTo(y.Key)) : (y.Value-x.Value);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string, int> frequencyMap = new Dictionary<string, int>();\\n        \\n        foreach(string word in words) {\\n            if(!frequencyMap.ContainsKey(word)) {\\n                frequencyMap[word] = 0;\\n            }\\n            \\n            frequencyMap[word]++;\\n        }\\n        \\n        PriorityQueue<string, KeyValuePair<string, int>> maxHeap = new(new NameComparer());\\n        \\n        foreach(KeyValuePair<string, int> entry in frequencyMap)\\n        {\\n           maxHeap.Enqueue(entry.Key, entry);\\n        }\\n\\n        List<string> result = new List<string>();\\n        \\n        while(k > 0 && maxHeap.Count > 0) {\\n            string word = maxHeap.Dequeue();\\n            result.Add(word);\\n            k--;        \\n        }   \\n        \\n        return result;\\n    }\\n    \\n    public class NameComparer: IComparer<KeyValuePair<string, int>>\\n\\t{\\n\\t\\tpublic int Compare(KeyValuePair<string, int> x, KeyValuePair<string,int> y) => \\n\\t\\t\\t(x.Value == y.Value) ? (x.Key.CompareTo(y.Key)) : (y.Value-x.Value);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653228,
                "title": "easy-to-understand-in-c-comparator",
                "content": "class Solution {\\npublic:\\n    \\n    static bool comparator(pair<string,int> p1, pair<string,int> p2)\\n    {\\n        if(p1.second>p2.second || (p1.second==p2.second && p1.first<p2.first))\\n            return true;\\n        return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> m1;\\n        \\n        for(int i=0; i<words.size(); i++)\\n            m1[words[i]]++;\\n        \\n        vector<pair<string,int>> v1;\\n        for(auto it=m1.begin(); it!=m1.end(); it++)\\n            v1.push_back({it->first,it->second});\\n        \\n        sort(v1.begin(),v1.end(),comparator);\\n        \\n        vector<string> ans;\\n        for(int i=0; i<k; i++)\\n        {\\n            ans.push_back(v1[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    static bool comparator(pair<string,int> p1, pair<string,int> p2)\\n    {\\n        if(p1.second>p2.second || (p1.second==p2.second && p1.first<p2.first))\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1078241,
                "title": "c-solution-beats-98-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static compare(pair<int,string>& a , pair<int,string>& b){\\n        if(a.first>b.first)\\n            return true;\\n        else if(a.first==b.first){\\n            if(a.second<b.second)\\n                return true;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string , int> um;//frequency of each word\\n        for(auto st : words){\\n            um[st]++;\\n        }\\n        //priority_queue<pair<int , string>> pq;\\n        vector<pair<int, string>> pq;\\n        for( auto it : um){\\n            pq.push_back({it.second , it.first});\\n        }\\n        sort(pq.begin() ,pq.end() , compare); //sorting using compare fuction as per our requirements\\n        vector<string> result(k);\\n        for(int i=0;i<k;i++){ //pushing first k string \\n            result[i]= pq[i].second;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Happy coding**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static compare(pair<int,string>& a , pair<int,string>& b){\\n        if(a.first>b.first)\\n            return true;\\n        else if(a.first==b.first){\\n            if(a.second<b.second)\\n                return true;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string , int> um;//frequency of each word\\n        for(auto st : words){\\n            um[st]++;\\n        }\\n        //priority_queue<pair<int , string>> pq;\\n        vector<pair<int, string>> pq;\\n        for( auto it : um){\\n            pq.push_back({it.second , it.first});\\n        }\\n        sort(pq.begin() ,pq.end() , compare); //sorting using compare fuction as per our requirements\\n        vector<string> result(k);\\n        for(int i=0;i<k;i++){ //pushing first k string \\n            result[i]= pq[i].second;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071287,
                "title": "kotlin",
                "content": "```\\n    fun topKFrequent(words: Array<String>, k: Int) = words.groupingBy { it }.eachCount()\\n        .toList()\\n        .sortedBy { (s, _) -> s }\\n        .sortedByDescending { (_, v) -> v }\\n        .map { it.first }\\n        .take(k)\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun topKFrequent(words: Array<String>, k: Int) = words.groupingBy { it }.eachCount()\\n        .toList()\\n        .sortedBy { (s, _) -> s }\\n        .sortedByDescending { (_, v) -> v }\\n        .map { it.first }\\n        .take(k)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 996134,
                "title": "python-multiple-solutions-heap-sort-quick-select",
                "content": "**#1: Quick Select** (Fastest solution\\uD83C\\uDFC6)\\n\\nTime: O(n+klogk)\\nSpace: O(n)\\n\\n```python\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        def partition(A, l, r):\\n            pivot = A[r]\\n            pStart = l\\n            for i in range(l, r):\\n                if A[i] < pivot:\\n                    A[i], A[pStart] = A[pStart], A[i]\\n                    pStart += 1\\n            A[r], A[pStart] = A[pStart], A[r]\\n            return pStart\\n        \\n        def quickSelect(A, l, r):\\n            if l < r:\\n                pIndex = partition(A, l, r)\\n                if pIndex < k:\\n                    quickSelect(A, pIndex+1, r)\\n                elif pIndex > k:\\n                    quickSelect(A, l, pIndex-1)\\n                else:\\n                    return\\n            return\\n\\t\\n        counts = collections.Counter(words)\\n        heap = [(-freq, word) for word, freq in counts.items()]\\n        quickSelect(heap, 0, len(heap)-1)\\n        out = heap[:k]\\n        out.sort()\\n        return [word for _, word in out]   \\n```\\n\\n**#2: Sorting** (Most intuitive solution)\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```python\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        count = collections.Counter(words)\\n        candidates = count.keys()\\n        candidates.sort(key = lambda word: (-count[word], word))\\n        return candidates[:k]\\n```\\n\\n**#3: Heap**\\n\\nTime: O(nlogk)\\nSpace: O(n)\\n\\n```python\\nclass Element(object):\\n    def __init__(self, freq, word):\\n        self.freq = freq\\n        self.word = word\\n    def __cmp__(self, other):\\n        if self.freq != other.freq:\\n            return cmp(self.freq, other.freq)\\n        else:\\n            return cmp(other.word, self.word)\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        counts = collections.Counter(words)\\n        hq = []\\n        for word, freq in counts.items():\\n            heapq.heappush(hq, Element(freq, word))\\n            if len(hq) >k:\\n                heapq.heappop(hq)\\n        return [heapq.heappop(hq).word for _ in xrange(k)][::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        def partition(A, l, r):\\n            pivot = A[r]\\n            pStart = l\\n            for i in range(l, r):\\n                if A[i] < pivot:\\n                    A[i], A[pStart] = A[pStart], A[i]\\n                    pStart += 1\\n            A[r], A[pStart] = A[pStart], A[r]\\n            return pStart\\n        \\n        def quickSelect(A, l, r):\\n            if l < r:\\n                pIndex = partition(A, l, r)\\n                if pIndex < k:\\n                    quickSelect(A, pIndex+1, r)\\n                elif pIndex > k:\\n                    quickSelect(A, l, pIndex-1)\\n                else:\\n                    return\\n            return\\n\\t\\n        counts = collections.Counter(words)\\n        heap = [(-freq, word) for word, freq in counts.items()]\\n        quickSelect(heap, 0, len(heap)-1)\\n        out = heap[:k]\\n        out.sort()\\n        return [word for _, word in out]   \\n```\n```python\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        count = collections.Counter(words)\\n        candidates = count.keys()\\n        candidates.sort(key = lambda word: (-count[word], word))\\n        return candidates[:k]\\n```\n```python\\nclass Element(object):\\n    def __init__(self, freq, word):\\n        self.freq = freq\\n        self.word = word\\n    def __cmp__(self, other):\\n        if self.freq != other.freq:\\n            return cmp(self.freq, other.freq)\\n        else:\\n            return cmp(other.word, self.word)\\n\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        counts = collections.Counter(words)\\n        hq = []\\n        for word, freq in counts.items():\\n            heapq.heappush(hq, Element(freq, word))\\n            if len(hq) >k:\\n                heapq.heappop(hq)\\n        return [heapq.heappop(hq).word for _ in xrange(k)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894072,
                "title": "python-intuitive-solution-52ms-best-space-usage-of-python",
                "content": "Runtime: 52 ms, faster than 90.49% of Python3 online submissions for Top K Frequent Words.\\nMemory Usage: 14.2 MB, less than 100.00% of Python3 online submissions for Top K Frequent Words.\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        d={}\\n        for i in set(words):\\n            v=words.count(i)\\n            d[v]=d.get(v,[])+[i]\\n        ans=[]\\n        for i in sorted(d.keys(),reverse=True):\\n            ans+=sorted(d[i])\\n        return ans[:k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        d={}\\n        for i in set(words):\\n            v=words.count(i)\\n            d[v]=d.get(v,[])+[i]\\n        ans=[]\\n        for i in sorted(d.keys(),reverse=True):\\n            ans+=sorted(d[i])\\n        return ans[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843696,
                "title": "python-short-and-simple-explained-solution-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n    # keep frequency of each word:\\n        freq = Counter(words)\\n        words = list(set(words))\\n        res = []\\n\\t# sort by alphabetical order:\\n        words.sort()\\n    # sort by frequency:\\n        words.sort(key = lambda a:freq[a], reverse = True)\\n    # return k highest:\\n        return words[:k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n    # keep frequency of each word:\\n        freq = Counter(words)\\n        words = list(set(words))\\n        res = []\\n\\t# sort by alphabetical order:\\n        words.sort()\\n    # sort by frequency:\\n        words.sort(key = lambda a:freq[a], reverse = True)\\n    # return k highest:\\n        return words[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712076,
                "title": "python-simple-and-elegant-n-log-k-solution",
                "content": "Store the frequencies of all words in a hash table and then find the k frequent using a heap. Here we would have to use a custom comparator for heap because of this reason :- \\nsuppose you have : - (1,\"abc\") and (1,\"cdb\") . First element is frequency and second is the actual word. Now according to the question if we have k = 1 answer should be (1,\"abc\"). According to the defualt heap comparison, the smallest tuple would be (1,\"abc\") and would be removed from the heap but this should be retained and \"cdb\" should  be popped. So we develop a custom comparator so that if two frequencies are equal keep the largest string at the top so that it is the first to be removed.\\n\\nTime complexity :- N log k since we never have more than k elements in the heap\\n\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass heapItem:\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    def __lt__(self, item):\\n        if self.a == item.a:\\n            return self.b > item.b\\n        else:\\n            return self.a < item.a\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq = defaultdict(int)\\n        for word in words:\\n            freq[word] += 1\\n        \\n        q = []\\n        for key in freq:\\n            cnt = freq[key]\\n            heapq.heappush(q,heapItem(cnt, key))\\n            if len(q) > k:\\n                heapq.heappop(q)\\n        res = []\\n        while(q):\\n            res.append((heapq.heappop(q)).b)\\n        res.reverse()\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "Store the frequencies of all words in a hash table and then find the k frequent using a heap. Here we would have to use a custom comparator for heap because of this reason :- \\nsuppose you have : - (1,\"abc\") and (1,\"cdb\") . First element is frequency and second is the actual word. Now according to the question if we have k = 1 answer should be (1,\"abc\"). According to the defualt heap comparison, the smallest tuple would be (1,\"abc\") and would be removed from the heap but this should be retained and \"cdb\" should  be popped. So we develop a custom comparator so that if two frequencies are equal keep the largest string at the top so that it is the first to be removed.\\n\\nTime complexity :- N log k since we never have more than k elements in the heap\\n\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass heapItem:\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    def __lt__(self, item):\\n        if self.a == item.a:\\n            return self.b > item.b\\n        else:\\n            return self.a < item.a\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq = defaultdict(int)\\n        for word in words:\\n            freq[word] += 1\\n        \\n        q = []\\n        for key in freq:\\n            cnt = freq[key]\\n            heapq.heappush(q,heapItem(cnt, key))\\n            if len(q) > k:\\n                heapq.heappop(q)\\n        res = []\\n        while(q):\\n            res.append((heapq.heappop(q)).b)\\n        res.reverse()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 506407,
                "title": "c-with-linq-priorityqueue-sortedset-and-bucket-sort",
                "content": "Linq:\\n\\n```\\npublic IList<string> TopKFrequent(string[] words, int k) => words\\n    .GroupBy(word => word)\\n    .OrderByDescending(freq => freq.Count())\\n    .ThenBy(freq => freq.Key)\\n    .Take(k)\\n    .Select(freq => freq.Key)\\n    .ToList();\\n```\\n\\nPriorityQueue (via SortedSet and IComparer)\\n\\n```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var frequencyMap = new Dictionary<string, int>();\\n    foreach (var word in words) {\\n        frequencyMap.TryGetValue(word, out int count);\\n        frequencyMap[word] = count + 1;\\n    }\\n\\n    var sortedWords = new SortedSet<string>(\\n        frequencyMap.Keys,\\n        new WordAndFrequencyComparer(frequencyMap));\\n\\n    var result = new List<string>();\\n    foreach (var word in sortedWords) {\\n        if (result.Count == k) {\\n            break;\\n        }\\n        result.Add(word);\\n    }\\n    return result;\\n}\\n\\nprivate class WordAndFrequencyComparer : IComparer<string> {\\n    private readonly Dictionary<string, int> frequencyMap;\\n\\n    public WordAndFrequencyComparer(Dictionary<string, int> frequencyMap) {\\n        this.frequencyMap = frequencyMap;\\n    }\\n\\n    public int Compare(string left, string right) {\\n        int frequencyComparison = frequencyMap[right].CompareTo(frequencyMap[left]);\\n        if (frequencyComparison == 0) {\\n            return left.CompareTo(right);\\n        }\\n        return frequencyComparison;\\n    }\\n}\\n```\\n\\nBucket sort with sorted sets instead of lists of string:\\n\\n```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var frequencyMap = new Dictionary<string, int>();\\n    foreach (var word in words) {\\n        frequencyMap.TryGetValue(word, out int count);\\n        frequencyMap[word] = count + 1;\\n    }\\n\\n    var buckets = new SortedSet<string>[frequencyMap.Count + 1];\\n    foreach (var frequency in frequencyMap) {\\n        if (buckets[frequency.Value] == null) {\\n            buckets[frequency.Value] = new SortedSet<string> { frequency.Key };\\n        } else {\\n            buckets[frequency.Value].Add(frequency.Key);\\n        }\\n    }\\n\\n    var result = new List<string>();\\n    for (int frequency = frequencyMap.Count; frequency > 0 && result.Count < k; frequency--) {\\n        if (buckets[frequency] != null) {\\n            foreach (var word in buckets[frequency]) {\\n                if (result.Count == k) {\\n                    break;\\n                }\\n                result.Add(word);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic IList<string> TopKFrequent(string[] words, int k) => words\\n    .GroupBy(word => word)\\n    .OrderByDescending(freq => freq.Count())\\n    .ThenBy(freq => freq.Key)\\n    .Take(k)\\n    .Select(freq => freq.Key)\\n    .ToList();\\n```\n```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var frequencyMap = new Dictionary<string, int>();\\n    foreach (var word in words) {\\n        frequencyMap.TryGetValue(word, out int count);\\n        frequencyMap[word] = count + 1;\\n    }\\n\\n    var sortedWords = new SortedSet<string>(\\n        frequencyMap.Keys,\\n        new WordAndFrequencyComparer(frequencyMap));\\n\\n    var result = new List<string>();\\n    foreach (var word in sortedWords) {\\n        if (result.Count == k) {\\n            break;\\n        }\\n        result.Add(word);\\n    }\\n    return result;\\n}\\n\\nprivate class WordAndFrequencyComparer : IComparer<string> {\\n    private readonly Dictionary<string, int> frequencyMap;\\n\\n    public WordAndFrequencyComparer(Dictionary<string, int> frequencyMap) {\\n        this.frequencyMap = frequencyMap;\\n    }\\n\\n    public int Compare(string left, string right) {\\n        int frequencyComparison = frequencyMap[right].CompareTo(frequencyMap[left]);\\n        if (frequencyComparison == 0) {\\n            return left.CompareTo(right);\\n        }\\n        return frequencyComparison;\\n    }\\n}\\n```\n```\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var frequencyMap = new Dictionary<string, int>();\\n    foreach (var word in words) {\\n        frequencyMap.TryGetValue(word, out int count);\\n        frequencyMap[word] = count + 1;\\n    }\\n\\n    var buckets = new SortedSet<string>[frequencyMap.Count + 1];\\n    foreach (var frequency in frequencyMap) {\\n        if (buckets[frequency.Value] == null) {\\n            buckets[frequency.Value] = new SortedSet<string> { frequency.Key };\\n        } else {\\n            buckets[frequency.Value].Add(frequency.Key);\\n        }\\n    }\\n\\n    var result = new List<string>();\\n    for (int frequency = frequencyMap.Count; frequency > 0 && result.Count < k; frequency--) {\\n        if (buckets[frequency] != null) {\\n            foreach (var word in buckets[frequency]) {\\n                if (result.Count == k) {\\n                    break;\\n                }\\n                result.Add(word);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352420,
                "title": "python-maxheap-using-heapq",
                "content": "```\\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        table = {}\\n        for word in words:\\n            if word in table:\\n                table[word] += 1\\n            else:\\n                table[word] = 1\\n        # set up a max heap\\n        heap = []\\n        heapq.heapify(heap)\\n        for key in table:\\n            heapq.heappush(heap, (-table[key], key))\\n        # pop top k\\n        res = []\\n        for i in range(k):\\n            popped = heapq.heappop(heap)\\n            res.append(popped)\\n        # sort res alphabetically\\n        res.sort()\\n        newres = []\\n        for word in res:\\n            newres.append(word[1])\\n        return newres\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        table = {}\\n        for word in words:\\n            if word in table:\\n                table[word] += 1\\n            else:\\n                table[word] = 1\\n        # set up a max heap\\n        heap = []\\n        heapq.heapify(heap)\\n        for key in table:\\n            heapq.heappush(heap, (-table[key], key))\\n        # pop top k\\n        res = []\\n        for i in range(k):\\n            popped = heapq.heappop(heap)\\n            res.append(popped)\\n        # sort res alphabetically\\n        res.sort()\\n        newres = []\\n        for word in res:\\n            newres.append(word[1])\\n        return newres\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3718319,
                "title": "java-hashmap-heap-priorityqueue-beats-99-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use a priority queue (min heap) to store pairs of words and their respective frequencies. The priority queue is sorted based on the frequencies in descending order. If two words have the same frequency, they are sorted lexicographically in ascending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a priority queue pq with a custom comparator that compares pairs based on their frequencies and lexicographical order.\\n2. Create a HashMap map to store the frequencies of each word in the given array.\\n3. Iterate through the words array and update the frequencies in the map.\\n4. Iterate through the map entries and add each entry as a pair to the priority queue.\\n5. Create an ArrayList ans to store the top K frequent words.\\n6. While the priority queue is not empty and K is greater than 0, extract the word with the highest frequency from the priority queue and add it to the ans list. Decrease K by 1.\\n7. Return the ans list containing the top K frequent words.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    The time complexity of the code is *O(N log N)* in the worst case, dominated by the step of adding map entries to the priority queue. Note that comparing strings takes *O(log M)* time, where M is the length of the longest string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    The space complexity of the code is *O(M)* in the worst case, where M is the number of unique words in the array.\\n\\n# Code\\n```\\nclass Pair{\\n    String obj;\\n    int count;\\n    Pair(String x, int y){\\n        obj = x;\\n        count = y;\\n    }\\n}\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.count==b.count){\\n                    return a.obj.compareTo(b.obj);\\n                }\\n                return b.count - a.count;\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<words.length; i++){\\n            map.put(words[i], map.getOrDefault(words[i],0)+1);\\n        }\\n        for(Map.Entry<String, Integer> x: map.entrySet()){\\n            pq.add(new Pair(x.getKey(), x.getValue()));\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        while(!pq.isEmpty() && k>0){\\n            ans.add(pq.poll().obj);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair{\\n    String obj;\\n    int count;\\n    Pair(String x, int y){\\n        obj = x;\\n        count = y;\\n    }\\n}\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.count==b.count){\\n                    return a.obj.compareTo(b.obj);\\n                }\\n                return b.count - a.count;\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<words.length; i++){\\n            map.put(words[i], map.getOrDefault(words[i],0)+1);\\n        }\\n        for(Map.Entry<String, Integer> x: map.entrySet()){\\n            pq.add(new Pair(x.getKey(), x.getValue()));\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        while(!pq.isEmpty() && k>0){\\n            ans.add(pq.poll().obj);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733255,
                "title": "using-comparator-faster-than-99-c-simple-and-clean-code",
                "content": "class Solution {\\nprivate:\\n    static bool comp(pair<string,int> &a, pair<string,int>&b){\\n        if(a.second!=b.second) return a.second<b.second;\\n        else if(a.second==b.second) return a.first>b.first;\\n        return false;\\n    }\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int> map;\\n        for(auto&i:words) map[i]++;\\n        vector<pair<string,int>> vpair; \\n        for(auto&i:map) vpair.push_back(make_pair(i.first,i.second));\\n        sort(vpair.begin(),vpair.end(),comp);\\n        reverse(vpair.begin(),vpair.end());\\n        \\n   //     for(auto&i:vpair) cout<<i.first<<\" \"<<i.second<<endl;\\n         vector<string>ans;\\n        for(int i=0;i<k;i++) ans.push_back(vpair[i].first);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    static bool comp(pair<string,int> &a, pair<string,int>&b){\\n        if(a.second!=b.second) return a.second<b.second;\\n        else if(a.second==b.second) return a.first>b.first;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2722113,
                "title": "java-simple-approach-with-explanation-and-comments",
                "content": "**Working**\\n* Store all the words in a map with their frequency.\\n* Create a Priority Queue of Pair type with custom comparator, which will sort the Pair first on the basis of frequency and later on the lexicographical order of their words.\\n* Add all the elements from map to priority queue.\\n* Get the top k elements from Priority queue and add it to answer list.\\n* Return the list.\\n\\n\\n```\\nclass Solution {\\n    \\n\\t// Pair class to store each word and their frequency.\\n    class Pair{\\n        String word;\\n        int freq;\\n        \\n        Pair(String word, int freq){\\n            this.word = word;\\n            this.freq = freq;\\n        }\\n        \\n    }\\n    \\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n\\t\\t// Map to store word and their frequencies.\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < words.length; i++){\\n\\t\\t\\t// Add all the words in map.\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        \\n\\t\\t// PriorityQueue of type Pair. Each Pair contains the word and its freqency. \\n\\t\\t// We have to create a custom comparator to sort the words first on frequency and then on lexicographical order.\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n\\t\\t\\t\\n\\t\\t\\t\\t// If frequency  of any two pair is equal.\\n                if(a.freq == b.freq){\\n\\t\\t\\t\\t\\t// compare them lexicographically.\\n                    return a.word.compareTo(b.word);\\n                }\\n                \\n\\t\\t\\t\\t// If frequency is not equal then greater frequency Pair is given the priority.\\n                return b.freq - a.freq;\\n            }\\n        });\\n        \\n\\t\\t// Add all the word from map to Priority Queue with their frequency.\\n        for(String word : map.keySet()){\\n            Pair temp = new Pair(word, map.get(word));\\n            pq.add(temp);\\n        }\\n        \\n\\t\\t// To store the answer.\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// Run while loop \"k\" times. We need top k elements.\\n        while(k-- != 0){\\n\\t\\t\\n\\t\\t\\t// Add the top element from priority queue to answer.\\n            list.add(pq.poll().word);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// Pair class to store each word and their frequency.\\n    class Pair{\\n        String word;\\n        int freq;\\n        \\n        Pair(String word, int freq){\\n            this.word = word;\\n            this.freq = freq;\\n        }\\n        \\n    }\\n    \\n    public List<String> topKFrequent(String[] words, int k) {\\n        \\n\\t\\t// Map to store word and their frequencies.\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < words.length; i++){\\n\\t\\t\\t// Add all the words in map.\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        \\n\\t\\t// PriorityQueue of type Pair. Each Pair contains the word and its freqency. \\n\\t\\t// We have to create a custom comparator to sort the words first on frequency and then on lexicographical order.\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n\\t\\t\\t\\n\\t\\t\\t\\t// If frequency  of any two pair is equal.\\n                if(a.freq == b.freq){\\n\\t\\t\\t\\t\\t// compare them lexicographically.\\n                    return a.word.compareTo(b.word);\\n                }\\n                \\n\\t\\t\\t\\t// If frequency is not equal then greater frequency Pair is given the priority.\\n                return b.freq - a.freq;\\n            }\\n        });\\n        \\n\\t\\t// Add all the word from map to Priority Queue with their frequency.\\n        for(String word : map.keySet()){\\n            Pair temp = new Pair(word, map.get(word));\\n            pq.add(temp);\\n        }\\n        \\n\\t\\t// To store the answer.\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// Run while loop \"k\" times. We need top k elements.\\n        while(k-- != 0){\\n\\t\\t\\n\\t\\t\\t// Add the top element from priority queue to answer.\\n            list.add(pq.poll().word);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721136,
                "title": "python-solution-10-lines-of-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counts={}\\n        for word in words:\\n            counts[word]=counts.get(word,0)+1\\n        s_dict = {val[0] : val[1] for val in sorted(counts.items(), key = lambda x: (-x[1], x[0]))}\\n        # print(s_dict)\\n        lst=[]\\n        x=0\\n        for i,j in s_dict.items():\\n            if(x<k):\\n                lst.append(i)\\n                x+=1\\n        return lst\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counts={}\\n        for word in words:\\n            counts[word]=counts.get(word,0)+1\\n        s_dict = {val[0] : val[1] for val in sorted(counts.items(), key = lambda x: (-x[1], x[0]))}\\n        # print(s_dict)\\n        lst=[]\\n        x=0\\n        for i,j in s_dict.items():\\n            if(x<k):\\n                lst.append(i)\\n                x+=1\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720528,
                "title": "easy-python-solution-o-nlogn",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        word_count = {}\\n        for word in words:\\n            if word in word_count:\\n                 word_count[word] += 1\\n            else:\\n                 word_count[word] = 1\\n        print(word_count)\\n        ans = sorted(word_count, key = lambda x: (-word_count[x], x))\\n        return ans[:k]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        word_count = {}\\n        for word in words:\\n            if word in word_count:\\n                 word_count[word] += 1\\n            else:\\n                 word_count[word] = 1\\n        print(word_count)\\n        ans = sorted(word_count, key = lambda x: (-word_count[x], x))\\n        return ans[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720472,
                "title": "short-and-sweet-solution-beats-97-space-82-time",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0) + 1\\n        \\n        res = sorted(d, key=lambda word: (-d[word], word))\\n        return res[:k]\\n```\\nIf it helped or you learned a new way, kindly upvote. Thanks :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0) + 1\\n        \\n        res = sorted(d, key=lambda word: (-d[word], word))\\n        return res[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720360,
                "title": "c-map-and-priority-queue-solution",
                "content": "# Approach\\nI counted the string frequency using a `map`. Since we have used a `map`, the storage and appearance of `string` inside the `map` will remain sorted in expected order.\\n\\nAnd then insert those string and their frequency into a `priority_queue` of size `k`. In this way we can find our top `k` frequent string. As `priority_queue` is a `max-heap` and we need to remove less frequent `string` from the list, we will insert the string based on their negative frequency so that the `most frequent string` goes stored at the end of the `heap` and vice versa.\\n\\nLater we just insert them into a vector and the sort them according to their frequency. And returned the vector.\\n\\n# Complexity\\n- Time complexity: $$O(nlog_2k)$$\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        \\n        map<string, int>word_db;\\n        int words_size= words.size();\\n        for(int i=0; i<words_size; i++){\\n            word_db[words[i]]++;\\n        }\\n\\n        priority_queue<pair<int, string>>top_k;\\n        for(auto &it: word_db){\\n            top_k.push(make_pair(-it.second, it.first));\\n            if(top_k.size() > k){\\n                top_k.pop();\\n            }\\n        }\\n\\n        vector<pair<int, string>>candidate_list;\\n        while(!top_k.empty()){\\n            candidate_list.emplace_back(top_k.top());\\n            top_k.pop();\\n        }\\n        sort(candidate_list.begin(), candidate_list.end());\\n\\n        vector<string>ans;\\n        for(int i=0; i<candidate_list.size(); i++){\\n            ans.push_back(candidate_list[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Trie",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        \\n        map<string, int>word_db;\\n        int words_size= words.size();\\n        for(int i=0; i<words_size; i++){\\n            word_db[words[i]]++;\\n        }\\n\\n        priority_queue<pair<int, string>>top_k;\\n        for(auto &it: word_db){\\n            top_k.push(make_pair(-it.second, it.first));\\n            if(top_k.size() > k){\\n                top_k.pop();\\n            }\\n        }\\n\\n        vector<pair<int, string>>candidate_list;\\n        while(!top_k.empty()){\\n            candidate_list.emplace_back(top_k.top());\\n            top_k.pop();\\n        }\\n        sort(candidate_list.begin(), candidate_list.end());\\n\\n        vector<string>ans;\\n        for(int i=0; i<candidate_list.size(); i++){\\n            ans.push_back(candidate_list[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720145,
                "title": "c-easy-solution-using-hash-table",
                "content": "```\\nbool comp(pair<string, int>&p1, pair<string, int>& p2){\\n    if(p1.second==p2.second)\\n        return p1.first<p2.first;\\n    return p1.second>p2.second;\\n}\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int>m;\\n        for(int i=0; i<words.size(); i++){\\n            m[words[i]]++;\\n        }\\n        vector<pair<string, int>>v;\\n        for(auto it:m){\\n            v.push_back(make_pair(it.first, it.second));\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        vector<string> res;\\n        for(int i=0; i<k; i++){\\n            res.push_back(v[i].first);\\n        }\\n        return (res);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool comp(pair<string, int>&p1, pair<string, int>& p2){\\n    if(p1.second==p2.second)\\n        return p1.first<p2.first;\\n    return p1.second>p2.second;\\n}\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int>m;\\n        for(int i=0; i<words.size(); i++){\\n            m[words[i]]++;\\n        }\\n        vector<pair<string, int>>v;\\n        for(auto it:m){\\n            v.push_back(make_pair(it.first, it.second));\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        vector<string> res;\\n        for(int i=0; i<k; i++){\\n            res.push_back(v[i].first);\\n        }\\n        return (res);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671596,
                "title": "java-beats-99-89-submissions-map-priorityqueue",
                "content": "```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> count = new HashMap<>();\\n        Queue<Map.Entry<String, Integer>> queue = new PriorityQueue<>((a, b) ->{\\n                                                                          if(a.getValue() == b.getValue())\\n                                                                              return a.getKey().compareTo(b.getKey());\\n                                                                          return b.getValue() - a.getValue();\\n                                                                      });\\n        List<String> ans = new ArrayList<>();\\n        \\n        for(String w : words)\\n            count.put(w, count.getOrDefault(w, 0) + 1);\\n        \\n        for(Map.Entry<String, Integer> e : count.entrySet())\\n            queue.add(e);\\n        \\n        while(k-- > 0)\\n            ans.add(queue.remove().getKey());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> count = new HashMap<>();\\n        Queue<Map.Entry<String, Integer>> queue = new PriorityQueue<>((a, b) ->{\\n                                                                          if(a.getValue() == b.getValue())\\n                                                                              return a.getKey().compareTo(b.getKey());\\n                                                                          return b.getValue() - a.getValue();\\n                                                                      });\\n        List<String> ans = new ArrayList<>();\\n        \\n        for(String w : words)\\n            count.put(w, count.getOrDefault(w, 0) + 1);\\n        \\n        for(Map.Entry<String, Integer> e : count.entrySet())\\n            queue.add(e);\\n        \\n        while(k-- > 0)\\n            ans.add(queue.remove().getKey());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647585,
                "title": "c-hashmap-custom-comparator-solution",
                "content": "First create frequency map for each string using dictionary.\\nNext, convert to KVP list and sort by frequency then by alphabetical order.\\nFinally, add first k elements to list and return.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string, int> freq = new Dictionary<string, int>();\\n        foreach(var s in words){\\n            if(freq.ContainsKey(s)) freq[s]++;\\n            else freq.Add(s, 1);\\n        }\\n        var resList = freq.ToList();\\n        resList.Sort((p1, p2)=>{\\n            if(p2.Value - p1.Value == 0) return String.Compare(p1.Key, p2.Key);\\n            return p2.Value - p1.Value;\\n        });\\n        List<string> ans = new List<string>();\\n        int i = 0;\\n        foreach(var n in resList){\\n            ans.Add(n.Key);\\n            if(++i == k) return ans;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string, int> freq = new Dictionary<string, int>();\\n        foreach(var s in words){\\n            if(freq.ContainsKey(s)) freq[s]++;\\n            else freq.Add(s, 1);\\n        }\\n        var resList = freq.ToList();\\n        resList.Sort((p1, p2)=>{\\n            if(p2.Value - p1.Value == 0) return String.Compare(p1.Key, p2.Key);\\n            return p2.Value - p1.Value;\\n        });\\n        List<string> ans = new List<string>();\\n        int i = 0;\\n        foreach(var n in resList){\\n            ans.Add(n.Key);\\n            if(++i == k) return ans;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338435,
                "title": "priorityqueue-hashmap-java-solution-7ms",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> list=new ArrayList<>();\\n        Queue<Map.Entry<String,Integer>> queue=new PriorityQueue<>((a,b)->(a.getValue()==b.getValue()\\n                                                                           ?(a.getKey().compareToIgnoreCase(b.getKey()))\\n                                                                           :b.getValue()-a.getValue()));\\n        Map<String,Integer> hashMap=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word=words[i];\\n            Integer occurence=hashMap.get(word);\\n            if(occurence==null)\\n                hashMap.put(word,1);\\n            else \\n                hashMap.put(word,occurence+1);\\n        }\\n        for(Map.Entry<String,Integer> entry:hashMap.entrySet())\\n        { \\n            queue.add(entry);\\n        }\\n        \\n        while(k>0)\\n        {\\n            list.add(queue.poll().getKey());\\n            k--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> list=new ArrayList<>();\\n        Queue<Map.Entry<String,Integer>> queue=new PriorityQueue<>((a,b)->(a.getValue()==b.getValue()\\n                                                                           ?(a.getKey().compareToIgnoreCase(b.getKey()))\\n                                                                           :b.getValue()-a.getValue()));\\n        Map<String,Integer> hashMap=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word=words[i];\\n            Integer occurence=hashMap.get(word);\\n            if(occurence==null)\\n                hashMap.put(word,1);\\n            else \\n                hashMap.put(word,occurence+1);\\n        }\\n        for(Map.Entry<String,Integer> entry:hashMap.entrySet())\\n        { \\n            queue.add(entry);\\n        }\\n        \\n        while(k>0)\\n        {\\n            list.add(queue.poll().getKey());\\n            k--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231556,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/3baf14df-cf60-4fdc-bf97-a9ef79a68cbe_1656839015.9852874.png)\\n\\n```\\nstruct pair {\\n    char* str;\\n    int cnt;\\n};\\n\\nint cmpstr(const void* a, const void* b) {\\n    const char* pa = *(const char**) a;\\n    const char* pb = *(const char**) b;\\n    return strcmp(pa, pb);\\n}\\n\\nint cmpobj(const void* a, const void* b) {\\n    const struct pair pa = *(const struct pair*) a;\\n    const struct pair pb = *(const struct pair*) b;\\n    return pb.cnt - pa.cnt;\\n}\\n\\nchar** topKFrequent(char** words, int wordsSize, int k, int* returnSize) {\\n    qsort(words, wordsSize, sizeof(char**), cmpstr);\\n    \\n    int idx = 0;\\n    struct pair* obj = (struct pair*) malloc(wordsSize * sizeof(struct pair));\\n    for (int i = 0; i < wordsSize; i++) {\\n        obj[idx].str = words[i];\\n        obj[idx].cnt = 1;\\n        for (int j = i + 1; j < wordsSize; j++) {\\n            if (strcmp(words[i], words[j]) != 0) {\\n                i = j - 1;\\n                idx++;\\n                break;\\n            } else {\\n                (obj[idx].cnt)++;\\n            }\\n            if (j == wordsSize - 1) i = j + 1;\\n        }\\n    }\\n    idx++;\\n    \\n    qsort(obj, idx, sizeof(struct pair), cmpobj);\\n    \\n    (*returnSize) = 0;\\n    for (int i = 0; i < k; i++) {\\n        words[(*returnSize)] = obj[(*returnSize)].str;\\n        (*returnSize)++;\\n    }\\n    free(obj);\\n    return words;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstruct pair {\\n    char* str;\\n    int cnt;\\n};\\n\\nint cmpstr(const void* a, const void* b) {\\n    const char* pa = *(const char**) a;\\n    const char* pb = *(const char**) b;\\n    return strcmp(pa, pb);\\n}\\n\\nint cmpobj(const void* a, const void* b) {\\n    const struct pair pa = *(const struct pair*) a;\\n    const struct pair pb = *(const struct pair*) b;\\n    return pb.cnt - pa.cnt;\\n}\\n\\nchar** topKFrequent(char** words, int wordsSize, int k, int* returnSize) {\\n    qsort(words, wordsSize, sizeof(char**), cmpstr);\\n    \\n    int idx = 0;\\n    struct pair* obj = (struct pair*) malloc(wordsSize * sizeof(struct pair));\\n    for (int i = 0; i < wordsSize; i++) {\\n        obj[idx].str = words[i];\\n        obj[idx].cnt = 1;\\n        for (int j = i + 1; j < wordsSize; j++) {\\n            if (strcmp(words[i], words[j]) != 0) {\\n                i = j - 1;\\n                idx++;\\n                break;\\n            } else {\\n                (obj[idx].cnt)++;\\n            }\\n            if (j == wordsSize - 1) i = j + 1;\\n        }\\n    }\\n    idx++;\\n    \\n    qsort(obj, idx, sizeof(struct pair), cmpobj);\\n    \\n    (*returnSize) = 0;\\n    for (int i = 0; i < k; i++) {\\n        words[(*returnSize)] = obj[(*returnSize)].str;\\n        (*returnSize)++;\\n    }\\n    free(obj);\\n    return words;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1702822,
                "title": "python3-runtime-44-ms-faster-than-93-91-memory-14-4-mb-less-than-67-47",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        ans=[]\\n        words = Counter(words)\\n        s = sorted(words.items(), key = lambda a: (-a[1], a[0]))\\n        for i in s:\\n            ans.append(i[0])\\n        return ans[:k]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        ans=[]\\n        words = Counter(words)\\n        s = sorted(words.items(), key = lambda a: (-a[1], a[0]))\\n        for i in s:\\n            ans.append(i[0])\\n        return ans[:k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702564,
                "title": "clean-code-c-using-hash-table-and-bucket-sort",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    template<typename t>\\n    void Insertion(vector<t> &arr)\\n    {\\n        int sz = arr.size();\\n        for(int i = 1; i < sz; i++)\\n        {\\n            t tmp = arr[i];\\n            int j = i-1;\\n            while(j >= 0 and arr[j] > tmp)\\n            {\\n                arr[j+1] = arr[j];\\n                j--;\\n            }\\n            arr[j+1] = tmp;\\n        }\\n        return;\\n    }\\n\\n    vector<string> topKFrequent(vector<string> &words, int k)\\n    {\\n        unordered_map<string, int> m;\\n        for (auto word : words)\\n            m[word]++;\\n\\n        vector<vector<string>> freqBucket(words.size() + 1); // 0th bucket would be empty, as we won\\'t be storing frequency 0\\n        for (auto pair : m)\\n            freqBucket[pair.second].push_back(pair.first);\\n\\n        for (auto &bucket : freqBucket)\\n            Insertion(bucket);\\n        \\n        vector<string> ans;\\n        for (int i = freqBucket.size() - 1; i >= 0 and ans.size() < k; i--)\\n        {\\n            for (int j = 0; j < freqBucket[i].size(); j++)\\n            {\\n                ans.push_back(freqBucket[i][j]);\\n                if (ans.size() == k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    template<typename t>\\n    void Insertion(vector<t> &arr)\\n    {\\n        int sz = arr.size();\\n        for(int i = 1; i < sz; i++)\\n        {\\n            t tmp = arr[i];\\n            int j = i-1;\\n            while(j >= 0 and arr[j] > tmp)\\n            {\\n                arr[j+1] = arr[j];\\n                j--;\\n            }\\n            arr[j+1] = tmp;\\n        }\\n        return;\\n    }\\n\\n    vector<string> topKFrequent(vector<string> &words, int k)\\n    {\\n        unordered_map<string, int> m;\\n        for (auto word : words)\\n            m[word]++;\\n\\n        vector<vector<string>> freqBucket(words.size() + 1); // 0th bucket would be empty, as we won\\'t be storing frequency 0\\n        for (auto pair : m)\\n            freqBucket[pair.second].push_back(pair.first);\\n\\n        for (auto &bucket : freqBucket)\\n            Insertion(bucket);\\n        \\n        vector<string> ans;\\n        for (int i = freqBucket.size() - 1; i >= 0 and ans.size() < k; i--)\\n        {\\n            for (int j = 0; j < freqBucket[i].size(); j++)\\n            {\\n                ans.push_back(freqBucket[i][j]);\\n                if (ans.size() == k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690865,
                "title": "simple-heap-with-dictionary-python-faster-than-99-55",
                "content": "Create a dictionary (hash map) to count the number of occurences of each word in ```words```. Heapify it and pop the first k elements from the heap. Return these as an array.\\n\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        a = {}\\n        \\n\\t\\tfor word in words:\\n            if word in a:\\n                a[word] += 1\\n            else:\\n                a[word] = 1\\n        \\n\\t\\tl = list(a.items())\\n        l = [(-j,i) for i,j in l]\\n        heapq.heapify(l)\\n        ret = []\\n        for i in range(k):\\n            _,w = heapq.heappop(l)\\n            ret.append(w)\\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```words```\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        a = {}\\n        \\n\\t\\tfor word in words:\\n            if word in a:\\n                a[word] += 1\\n            else:\\n                a[word] = 1\\n        \\n\\t\\tl = list(a.items())\\n        l = [(-j,i) for i,j in l]\\n        heapq.heapify(l)\\n        ret = []\\n        for i in range(k):\\n            _,w = heapq.heappop(l)\\n            ret.append(w)\\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657184,
                "title": "python-o-nlogk-heapq-solution-with-explanation",
                "content": "I am explaining my solution using the heapq function and I am providing some references of how the heapq function works in Python so that you can use it for the other questions you solve. \\n\\nWhen the question asked for a O(NlogK) solution, the first thing that should come to our mind is heaps because sorting the entire counts array takes O(NlogN) and we can achieve a O(NlogK) solution only if we use a heap that maintains the top K elements in sorted order. Do read this reference to understand this algorithm [1]. **Remember: Don\\'t get carried away thinking that a heap is the answer, the answer is a heap of size K, then only can we achieve a time complexity of O(NlogK).**\\n\\nThen, the problem of the implementation comes up. The heap creates a minmax(my made up term :)) scenario because when the heap wants to remove an item it should remove the item with the smallest count since it is a min heap. But when the counts are equal it should remove the element with the larger keyword since that is considered less in the question. The workaround for this is to implement your custom class with the *\\\\__lt__* function which the heapq function will use to compare the elements[2]. \\n\\nBut its not over yet :(, because now you need to reverse your heap and return the answer but aha reversing your heap will reverse the elements with similar counts into the wrong lexicographical order. Therefore, first you need to sort them lexicographically in the smallest order once again and then reverse sort them based on their counts. By doing this, we can ensure that the lexographical order of the elements in the reverse count is preserved.\\n\\n```\\nclass Count:\\n    def __init__(self, count, keyword):\\n        self.count = count\\n        self.keyword = keyword\\n    \\n    def __lt__(self, countObj):\\n        if self.count==countObj.count:\\n            return self.keyword>countObj.keyword\\n        return self.count<countObj.count\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        count = defaultdict(int)\\n        \\n        for i in range(len(words)):\\n            count[words[i]]+=1\\n        \\n        values = []\\n        for (key, count) in count.items():\\n            heapq.heappush(values, Count(count, key))\\n            if len(values)>k:\\n                heapq.heappop(values)\\n                \\n        values = sorted(values, key=lambda x: x.keyword)\\n        values = sorted(values, key=lambda x: x.count, reverse=True)\\n        return [val.keyword for val in values]\\n```\\n\\n[1] https://levelup.gitconnected.com/patterns-for-coding-interviews-top-k-elements-1a1368c4cbf0\\n[2] https://stackoverflow.com/a/59956131/6687668\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Count:\\n    def __init__(self, count, keyword):\\n        self.count = count\\n        self.keyword = keyword\\n    \\n    def __lt__(self, countObj):\\n        if self.count==countObj.count:\\n            return self.keyword>countObj.keyword\\n        return self.count<countObj.count\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        count = defaultdict(int)\\n        \\n        for i in range(len(words)):\\n            count[words[i]]+=1\\n        \\n        values = []\\n        for (key, count) in count.items():\\n            heapq.heappush(values, Count(count, key))\\n            if len(values)>k:\\n                heapq.heappop(values)\\n                \\n        values = sorted(values, key=lambda x: x.keyword)\\n        values = sorted(values, key=lambda x: x.count, reverse=True)\\n        return [val.keyword for val in values]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540091,
                "title": "c-using-min-heap-with-custom-comparator",
                "content": "It is funny how cool ```custom comparator```  sounds, I must not be the only one who thinks it sounds cool :-| or probably, who knows :-O\\nJust remember whenever custom comparator returns true, it means no swap.\\n```\\ntypedef pair<int, string> pi;\\ntypedef pair<int, int> ppi;\\nclass CustomGreat{\\n    public:\\n\\t\\n\\t// () operator is overloaded\\n    bool operator () (pi &a, pi &b){\\n        //TRUE MEANS NO SWAP\\n        //Compare frequency \\n        if(a.first > b.first) {\\n            return true;\\n        }\\n        //If frequency of both elements is equal, compare the values\\n        else if(a.first == b.first){\\n            if(a.second < b.second) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        if(words.empty()) return {};\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        for(auto &c:words) m[c]++;\\n        priority_queue<pi, vector<pi>,CustomGreat> minHeap;\\n        for(auto &d:m) {\\n            pair temp = {d.second, d.first};\\n            minHeap.push(temp);\\n            if(minHeap.size()>k) minHeap.pop();\\n        }\\n        while(!minHeap.empty()){\\n            res.push_back(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```custom comparator```\n```\\ntypedef pair<int, string> pi;\\ntypedef pair<int, int> ppi;\\nclass CustomGreat{\\n    public:\\n\\t\\n\\t// () operator is overloaded\\n    bool operator () (pi &a, pi &b){\\n        //TRUE MEANS NO SWAP\\n        //Compare frequency \\n        if(a.first > b.first) {\\n            return true;\\n        }\\n        //If frequency of both elements is equal, compare the values\\n        else if(a.first == b.first){\\n            if(a.second < b.second) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        if(words.empty()) return {};\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        for(auto &c:words) m[c]++;\\n        priority_queue<pi, vector<pi>,CustomGreat> minHeap;\\n        for(auto &d:m) {\\n            pair temp = {d.second, d.first};\\n            minHeap.push(temp);\\n            if(minHeap.size()>k) minHeap.pop();\\n        }\\n        while(!minHeap.empty()){\\n            res.push_back(minHeap.top().second);\\n            minHeap.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466533,
                "title": "python-3-o-nlogk",
                "content": "```\\nimport heapq\\nclass heapItem:\\n    def __init__(self,count,ch):\\n        self.ch = ch\\n        self.count = count\\n    def __lt__(self, item):#(count,ch) 5,ab  5,ba\\n        if self.count == item.count:\\n            return self.ch > item.ch\\n        else:\\n            return self.count < item.count\\n\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        counter = {}\\n        for word in words:\\n            counter[word] = 1+counter.get(word,0)\\n        #print(counter.items())\\n        \\n        heap = []\\n        for word,count in counter.items():\\n            if len(heap) < k:\\n                heapq.heappush(heap,heapItem(count,word))\\n            else:\\n                heapq.heappushpop(heap,heapItem(count,word))\\n        return [heapq.heappop(heap).ch for _ in range(k)][::-1]\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def topKFrequent(self, words, k):\\n        counter = {}",
                "codeTag": "Java"
            },
            {
                "id": 1440039,
                "title": "java-priorityqueue-o-nlog-k-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        Queue<String> queue = new PriorityQueue<>((a, b)->map.get(a)-map.get(b)==0?b.compareTo(a):map.get(a)-map.get(b));\\n        for (String key: map.keySet()) {\\n            queue.offer(key);\\n            if (queue.size()>k) queue.poll();\\n        }\\n        \\n        LinkedList<String> res = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            res.add(0, queue.poll());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0)+1);\\n        }\\n        Queue<String> queue = new PriorityQueue<>((a, b)->map.get(a)-map.get(b)==0?b.compareTo(a):map.get(a)-map.get(b));\\n        for (String key: map.keySet()) {\\n            queue.offer(key);\\n            if (queue.size()>k) queue.poll();\\n        }\\n        \\n        LinkedList<String> res = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            res.add(0, queue.poll());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403790,
                "title": "python-priority-queue-solution",
                "content": "```\\nimport heapq\\nfrom collections import Counter\\n\\n\\nclass MaxHeap:\\n    def __init__(self):\\n        self._queue = []\\n        \\n    def push(self, word, count):\\n        heapq.heappush(self._queue, (-count, word))\\n    \\n    def pop(self):\\n        return heapq.heappop(self._queue)[-1]\\n        \\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counter = Counter(words)\\n        \\n        heap = MaxHeap()\\n        \\n        for word, count in counter.items():\\n            heap.push(word, count)\\n            \\n        return [heap.pop() for _ in range(k)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nfrom collections import Counter\\n\\n\\nclass MaxHeap:\\n    def __init__(self):\\n        self._queue = []\\n        \\n    def push(self, word, count):\\n        heapq.heappush(self._queue, (-count, word))\\n    \\n    def pop(self):\\n        return heapq.heappop(self._queue)[-1]\\n        \\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        counter = Counter(words)\\n        \\n        heap = MaxHeap()\\n        \\n        for word, count in counter.items():\\n            heap.push(word, count)\\n            \\n        return [heap.pop() for _ in range(k)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368280,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var topKFrequent = function(words, k) {\\n        let map = {}\\n    \\n        for(let word of words) {\\n            if(!map[word]) {\\n                map[word] = 1\\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n        // O(nlogn) where n is number of words\\n        let sorted = Object.keys(map).sort((a,b) => {\\n            if(map[a] == map[b]) {\\n                return a > b ? 1 : -1\\n            } else {\\n                return map[b] - map[a]\\n            }\\n        })\\n    \\n        return sorted.slice(0, k);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var topKFrequent = function(words, k) {\\n        let map = {}\\n    \\n        for(let word of words) {\\n            if(!map[word]) {\\n                map[word] = 1\\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n        // O(nlogn) where n is number of words\\n        let sorted = Object.keys(map).sort((a,b) => {\\n            if(map[a] == map[b]) {\\n                return a > b ? 1 : -1\\n            } else {\\n                return map[b] - map[a]\\n            }\\n        })\\n    \\n        return sorted.slice(0, k);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 835689,
                "title": "c",
                "content": "public class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string,int> dict = new Dictionary<string,int>();\\n        \\n        foreach(string item in words){\\n            if(!dict.ContainsKey(item)){\\n                dict.Add(item,1);\\n            }\\n          else  dict[item]++;\\n        }\\n        // dictionary in C# has inbuilt method for sorting both key and value \\n\\t   // Sort first by frequency and then by key in case of tie like same frequency \\n \\n        return dict.OrderByDescending(x=>x.Value).ThenBy(x=>x.Key).Select(x=>x.Key).Take(k).ToList();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<string> TopKFrequent(string[] words, int k) {\\n        Dictionary<string,int> dict = new Dictionary<string,int>();\\n        \\n        foreach(string item in words){\\n            if(!dict.ContainsKey(item)){\\n                dict.Add(item,1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 770167,
                "title": "python-heap-custom-compare-100-space",
                "content": "We use a heap to maintain k frequent items.\\nCreated custom compare class for utility\\n\\n```\\nclass CustomCompare:\\n    def __init__(self, word, occurences):\\n        self.word = word\\n        self.occurences = occurences\\n        \\n    def __lt__(self, other):\\n        if self.occurences != other.occurences:\\n            return self.occurences < other.occurences\\n        else:\\n            return self.word > other.word\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        top_k = []\\n        output = deque()\\n        \\n        def insert_to_heap(word, occurences):\\n            if len(top_k) < k or top_k[0] < CustomCompare(word, occurences):\\n                heappush(top_k, CustomCompare(word, occurences))\\n                \\n            if len(top_k) > k:\\n                heappop(top_k)\\n            \\n        for word, occurences in Counter(words).items():\\n            insert_to_heap(word, occurences)\\n          \\n        while top_k:\\n            customCompare = heappop(top_k)\\n            output.appendleft(customCompare.word)\\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass CustomCompare:\\n    def __init__(self, word, occurences):\\n        self.word = word\\n        self.occurences = occurences\\n        \\n    def __lt__(self, other):\\n        if self.occurences != other.occurences:\\n            return self.occurences < other.occurences\\n        else:\\n            return self.word > other.word\\n\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        top_k = []\\n        output = deque()\\n        \\n        def insert_to_heap(word, occurences):\\n            if len(top_k) < k or top_k[0] < CustomCompare(word, occurences):\\n                heappush(top_k, CustomCompare(word, occurences))\\n                \\n            if len(top_k) > k:\\n                heappop(top_k)\\n            \\n        for word, occurences in Counter(words).items():\\n            insert_to_heap(word, occurences)\\n          \\n        while top_k:\\n            customCompare = heappop(top_k)\\n            output.appendleft(customCompare.word)\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651071,
                "title": "trie-solution-trie-bucketsort-no-hashmap",
                "content": "you can use Trie  and good old fashioned bucket sort\\n\\n```java\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        String word = \"\";\\n        int cnt = 0;       \\n    }\\n    \\n    TrieNode head;\\n    int max;\\n    List<String>[] buckets;\\n    public List<String> topKFrequent(String[] words, int k) {\\n        head = new TrieNode();\\n        max = 0;\\n        insert(words, head);\\n        \\n        buckets = new List[max + 1];\\n        dfs(head);\\n        \\n        List<String> res = new ArrayList();\\n        for (int i = max; i >= 0; i--){\\n            if (buckets[i] == null) continue;\\n            int j = 0;\\n            while(j < buckets[i].size() && k > 0){\\n                res.add(buckets[i].get(j));\\n                j++;\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(TrieNode head){\\n        // go from back to front\\n        TrieNode cur = head;\\n        if (cur.cnt > 0){\\n            if (buckets[cur.cnt] == null){\\n                buckets[cur.cnt] = new ArrayList();\\n            }\\n            buckets[cur.cnt].add(cur.word);\\n        }\\n        for (int i = 0; i <= 25; i++){\\n            if (cur.children[i] != null){\\n                dfs(cur.children[i]);\\n            }\\n        }\\n    }\\n    \\n    private void insert(String[] words, TrieNode head){\\n        TrieNode cur = head;\\n        for(String w : words){\\n            cur = head;\\n            for (char c : w.toCharArray()){\\n                if(cur.children[c - \\'a\\'] == null){\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n            }\\n            cur.word = w;\\n            cur.cnt++;\\n            max = Math.max(max, cur.cnt);\\n        }\\n    }\\n}\\n```\\n\\nbut some how the performance is only on par with priority queue, so i guess during interview for simplicity sake just use priority queue",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```java\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        String word = \"\";\\n        int cnt = 0;       \\n    }\\n    \\n    TrieNode head;\\n    int max;\\n    List<String>[] buckets;\\n    public List<String> topKFrequent(String[] words, int k) {\\n        head = new TrieNode();\\n        max = 0;\\n        insert(words, head);\\n        \\n        buckets = new List[max + 1];\\n        dfs(head);\\n        \\n        List<String> res = new ArrayList();\\n        for (int i = max; i >= 0; i--){\\n            if (buckets[i] == null) continue;\\n            int j = 0;\\n            while(j < buckets[i].size() && k > 0){\\n                res.add(buckets[i].get(j));\\n                j++;\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(TrieNode head){\\n        // go from back to front\\n        TrieNode cur = head;\\n        if (cur.cnt > 0){\\n            if (buckets[cur.cnt] == null){\\n                buckets[cur.cnt] = new ArrayList();\\n            }\\n            buckets[cur.cnt].add(cur.word);\\n        }\\n        for (int i = 0; i <= 25; i++){\\n            if (cur.children[i] != null){\\n                dfs(cur.children[i]);\\n            }\\n        }\\n    }\\n    \\n    private void insert(String[] words, TrieNode head){\\n        TrieNode cur = head;\\n        for(String w : words){\\n            cur = head;\\n            for (char c : w.toCharArray()){\\n                if(cur.children[c - \\'a\\'] == null){\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n            }\\n            cur.word = w;\\n            cur.cnt++;\\n            max = Math.max(max, cur.cnt);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482633,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "```\\npublic class Solution\\n{\\n    public IList<string> TopKFrequent(string[] words, int k)\\n    {\\n        // loop through to find occurances \\n        // store the pair of word(K) and freq(V) in to map and the words in a list\\n\\t\\t// sort the words using comparator\\n        var map = new Dictionary<string, int>();\\n        var allwords = new List<string>();\\n\\n        foreach (string word in words)\\n        {            \\n            if (!map.ContainsKey(word))\\n            {\\n                map.Add(word, 0);\\n                allwords.Add(word);\\n            }\\n            \\n            map[word]++;\\n        }\\n        \\n        // sort the array based on map\\n        allwords.Sort((x, y) => map[x].CompareTo(map[y]) != 0 ? map[y].CompareTo(map[x]) : x.CompareTo(y));\\n        return allwords.Take(k).ToList();\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> TopKFrequent(string[] words, int k)\\n    {\\n        // loop through to find occurances \\n        // store the pair of word(K) and freq(V) in to map and the words in a list\\n\\t\\t// sort the words using comparator\\n        var map = new Dictionary<string, int>();\\n        var allwords = new List<string>();\\n\\n        foreach (string word in words)\\n        {            \\n            if (!map.ContainsKey(word))\\n            {\\n                map.Add(word, 0);\\n                allwords.Add(word);\\n            }\\n            \\n            map[word]++;\\n        }\\n        \\n        // sort the array based on map\\n        allwords.Sort((x, y) => map[x].CompareTo(map[y]) != 0 ? map[y].CompareTo(map[x]) : x.CompareTo(y));\\n        return allwords.Take(k).ToList();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376954,
                "title": "java-min-heap-beats-99-explained",
                "content": "Problem can be solved via min heap. First - create map with qty of every word. Then iterate over every word in map (order doesnt matter) and put it to the min heap. Every time we hit k + 1 size of the heap - poll top element from it. In the end we\\'ll have k elements in heap. Now to need to return them in order, wich will be reversed one compared to the heap. So we take out elements from the heap and put it to the list in reversed order.\\n\\nComplexity - O(n) for space - O(n) for map, O(k) for heap. Time - O(n lgk) - O(n) to form the map, n x O(lgk) lgk put element to the heap, do it n times (for every element)\\n\\n```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> res = new ArrayList();\\n        //comparator for our object - first based on quantity then\\n        //if the same frequency - based on string (lexicographical order) \\n        Comparator<Obj> comp = new Comparator<Obj>() {\\n            public int compare(Obj o1, Obj o2) {\\n                if (o1.n != o2.n)\\n                    return o1.n - o2.n;\\n                return o2.w.compareTo(o1.w);\\n            }\\n        };\\n\\n        PriorityQueue<Obj> pq = new PriorityQueue(comp);\\n        Map<String, Obj> m = new HashMap();\\n        //count how many times we met each word\\n        for (String w : words) {\\n            if (m.containsKey(w)) {\\n                m.get(w).n++;\\n            } else {\\n                m.put(w, new Obj(1, w));\\n            }\\n        }\\n        //iterate over unique words\\n        Set<String> keys = m.keySet();\\n        for (String key : keys) {\\n            pq.add(m.get(key));\\n            //if we have more than k - poll the min one as per our comparator\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        //for the result list, heap gives us the reverse order, so insert every next element to the 0 index, move \\n        //the rest to the right\\n        while(!pq.isEmpty()) {\\n            if (res.isEmpty())\\n                res.add(pq.poll().w);\\n            else\\n                res.add(0, pq.poll().w);\\n        }\\n        return res;\\n    }\\n    \\n    class Obj {\\n        //num of times we met this word\\n        int n;\\n        //word\\n        String w;\\n        Obj(int n, String w) {\\n            this.n = n;\\n            this.w = w;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> res = new ArrayList();\\n        //comparator for our object - first based on quantity then\\n        //if the same frequency - based on string (lexicographical order) \\n        Comparator<Obj> comp = new Comparator<Obj>() {\\n            public int compare(Obj o1, Obj o2) {\\n                if (o1.n != o2.n)\\n                    return o1.n - o2.n;\\n                return o2.w.compareTo(o1.w);\\n            }\\n        };\\n\\n        PriorityQueue<Obj> pq = new PriorityQueue(comp);\\n        Map<String, Obj> m = new HashMap();\\n        //count how many times we met each word\\n        for (String w : words) {\\n            if (m.containsKey(w)) {\\n                m.get(w).n++;\\n            } else {\\n                m.put(w, new Obj(1, w));\\n            }\\n        }\\n        //iterate over unique words\\n        Set<String> keys = m.keySet();\\n        for (String key : keys) {\\n            pq.add(m.get(key));\\n            //if we have more than k - poll the min one as per our comparator\\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        //for the result list, heap gives us the reverse order, so insert every next element to the 0 index, move \\n        //the rest to the right\\n        while(!pq.isEmpty()) {\\n            if (res.isEmpty())\\n                res.add(pq.poll().w);\\n            else\\n                res.add(0, pq.poll().w);\\n        }\\n        return res;\\n    }\\n    \\n    class Obj {\\n        //num of times we met this word\\n        int n;\\n        //word\\n        String w;\\n        Obj(int n, String w) {\\n            this.n = n;\\n            this.w = w;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293139,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic = {}\\n        for word in words:\\n            if word not in dic:\\n                dic[word] = 1\\n            else:\\n                dic[word] += 1\\n        dic = sorted(dic.items(), key=lambda x: (-x[1], x[0]))\\n        return [d[0] for d in dic][:k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic = {}\\n        for word in words:\\n            if word not in dic:\\n                dic[word] = 1\\n            else:\\n                dic[word] += 1\\n        dic = sorted(dic.items(), key=lambda x: (-x[1], x[0]))\\n        return [d[0] for d in dic][:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272400,
                "title": "python-3-o-nlgk-o-n",
                "content": "\\n```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        # O(nlgk) + O(n), use an object with (freq, word), override its __lt__ and __eq__ functions\\n        class FreqWord(object):\\n            def __init__(self, freq, word):\\n                self.freq = freq\\n                self.word = word\\n            def __eq__(self, other):\\n                return self.freq == other.freq and self.word == other.word\\n            def __lt__(self, other):\\n                return self.freq < other.freq or (self.freq == other.freq and self.word > other.word)\\n        \\n        d = collections.Counter(words)        \\n        pq = [FreqWord(-float(\\'inf\\'), \\'\\') for _ in range(k)]\\n        for word, count in d.items():\\n            heapq.heappushpop(pq, FreqWord(count, word))\\n        \\n        return [fw.word for fw in pq][::-1]\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\n```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        # O(nlgk) + O(n), use an object with (freq, word), override its __lt__ and __eq__ functions\\n        class FreqWord(object):\\n            def __init__(self, freq, word):\\n                self.freq = freq\\n                self.word = word\\n            def __eq__(self, other):\\n                return self.freq == other.freq and self.word == other.word\\n            def __lt__(self, other):\\n                return self.freq < other.freq or (self.freq == other.freq and self.word > other.word)\\n        \\n        d = collections.Counter(words)        \\n        pq = [FreqWord(-float(\\'inf\\'), \\'\\') for _ in range(k)]\\n        for word, count in d.items():\\n            heapq.heappushpop(pq, FreqWord(count, word))\\n        \\n        return [fw.word for fw in pq][::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 230640,
                "title": "c-unordered-map-partial-sort-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> count;\\n        for (string& w : words) {\\n            count[w]++;\\n        }\\n        vector<pair<string, int>> freq;\\n        for (auto c : count) {\\n            freq.push_back(make_pair(c.first, c.second));\\n        }\\n        partial_sort(freq.begin(), freq.begin()+k, freq.end(), [] (auto& l, auto& r) {\\n            if (l.second == r.second) {\\n                return l.first < r.first;\\n            }\\n            return l.second > r.second;});\\n        vector<string> ans;\\n        for (int i = 0; i < k; i++) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> count;\\n        for (string& w : words) {\\n            count[w]++;\\n        }\\n        vector<pair<string, int>> freq;\\n        for (auto c : count) {\\n            freq.push_back(make_pair(c.first, c.second));\\n        }\\n        partial_sort(freq.begin(), freq.begin()+k, freq.end(), [] (auto& l, auto& r) {\\n            if (l.second == r.second) {\\n                return l.first < r.first;\\n            }\\n            return l.second > r.second;});\\n        vector<string> ans;\\n        for (int i = 0; i < k; i++) {\\n            ans.push_back(freq[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121946,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        return [w for w, v in sorted(collections.Counter(words).items(), key = lambda x: (-x[1], x[0])) [:k]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words, k):\\n        return [w for w, v in sorted(collections.Counter(words).items(), key = lambda x: (-x[1], x[0])) [:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362926,
                "title": "java-one-line-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n       return Arrays.stream(words).collect(Collectors.groupingBy(x -> x , Collectors.counting())).entrySet().stream().sorted((a , b) -> b.getValue()!= a.getValue() ? (int)(b.getValue() - a.getValue()) : a.getKey().compareTo(b.getKey())).limit(k).map(Map.Entry::getKey).toList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n       return Arrays.stream(words).collect(Collectors.groupingBy(x -> x , Collectors.counting())).entrySet().stream().sorted((a , b) -> b.getValue()!= a.getValue() ? (int)(b.getValue() - a.getValue()) : a.getKey().compareTo(b.getKey())).limit(k).map(Map.Entry::getKey).toList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263982,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Using Map and Comparator Sort\\n\\n\\n# Code\\n```\\nbool cmp(pair<string, int> a, pair<string, int> b) {\\n    // Reverse Sort by 2nd, 1st Sorted\\n    if(a.second == b.second) return a.first < b.first;\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> mp;\\n        for(auto x: words) mp[x]++;\\n        vector<pair<string, int>> vec;\\n        for(auto x: mp) {\\n            vec.push_back({x.first, x.second});\\n        }\\n        sort(vec.begin(), vec.end(), cmp);\\n        vector<string> ans;\\n        for(int i=0; i<k; i++) {\\n            ans.push_back(vec[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool cmp(pair<string, int> a, pair<string, int> b) {\\n    // Reverse Sort by 2nd, 1st Sorted\\n    if(a.second == b.second) return a.first < b.first;\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> mp;\\n        for(auto x: words) mp[x]++;\\n        vector<pair<string, int>> vec;\\n        for(auto x: mp) {\\n            vec.push_back({x.first, x.second});\\n        }\\n        sort(vec.begin(), vec.end(), cmp);\\n        vector<string> ans;\\n        for(int i=0; i<k; i++) {\\n            ans.push_back(vec[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146570,
                "title": "44-ms-beats-99-63-with-explanation",
                "content": "# Explanation\\n1. ```dct = ...``` **sort keys by values**, where **key** is **word** and **value** is **frequency** of this word\\n2. create defaultdict (to collect keys in integer), make values are keys and **for every key sort the values**\\n3. print first k words in values\\n\\n# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        answer, temp, cnt = [], defaultdict(), 0\\n\\n        dct = {k: v for k, v in sorted(Counter(words).items(), reverse = True, key=lambda item: item[1])}\\n\\n        for i in dct:\\n            if dct[i] not in temp:\\n                temp[dct[i]] = [i]\\n            else:\\n                temp[dct[i]].append(i)\\n            temp[dct[i]].sort()\\n\\n        for i in temp.values():\\n            for j in i:\\n                answer.append(j)\\n                if len(answer) == k:\\n                    return answer\\n```\\n![image.png](https://assets.leetcode.com/users/images/cc54cdab-adec-4af0-86ed-4d2549a0bc5b_1675606419.6101193.png)\\n\\nUPD: \\n![image.png](https://assets.leetcode.com/users/images/2eacb9f4-b9b4-4f11-be49-a05a27a09210_1675607212.6467423.png)\\n\\n\\n**Feel free to ask anything** **[Telegram](https://t.me/ulyanovmmm)**\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```dct = ...```\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        answer, temp, cnt = [], defaultdict(), 0\\n\\n        dct = {k: v for k, v in sorted(Counter(words).items(), reverse = True, key=lambda item: item[1])}\\n\\n        for i in dct:\\n            if dct[i] not in temp:\\n                temp[dct[i]] = [i]\\n            else:\\n                temp[dct[i]].append(i)\\n            temp[dct[i]].sort()\\n\\n        for i in temp.values():\\n            for j in i:\\n                answer.append(j)\\n                if len(answer) == k:\\n                    return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126714,
                "title": "c-solution-using-map-and-priority-queue-with-custom-compare-function-tc-o-n-k-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse map to get every word\\'s frequency, then use priority_queue to get the top k frequent words.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Use map to get every word\\'s frequency, then push them into the priority_queue with custom compare function. \\nThe compare function would sort words by the frequency from highest to lowest, and the words with same frequency are sorted by lexicographical order. \\n# Complexity\\n- Time complexity: O((n+k)log(n))\\n1. insertion in priority_queuue : O(log(n)), n elements ==> O(nlog(n))\\n2. extract max elements : O(log(n)), top k ==> O(klog(n))\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. map O(n)\\n2. priority_queue O(n)\\n3. vector answer O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(pair<int, string> x, pair<int, string> y) {\\n            if (x.first == y.first) {\\n                return x.second > y.second;\\n            } else {\\n                return x.first < y.first;\\n            }\\n        }\\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> M;\\n        for (auto word : words) {\\n            M[word] += 1;\\n        }\\n        priority_queue<pair<int, string>, vector<pair<int, string>>, cmp> pq;\\n        for (auto it = M.begin(); it != M.end(); it++) {\\n            pq.push({(*it).second, (*it).first});\\n        }\\n\\n        vector<string> ans;\\n        for (int i = 0; i < k; i++) {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(pair<int, string> x, pair<int, string> y) {\\n            if (x.first == y.first) {\\n                return x.second > y.second;\\n            } else {\\n                return x.first < y.first;\\n            }\\n        }\\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string, int> M;\\n        for (auto word : words) {\\n            M[word] += 1;\\n        }\\n        priority_queue<pair<int, string>, vector<pair<int, string>>, cmp> pq;\\n        for (auto it = M.begin(); it != M.end(); it++) {\\n            pq.push({(*it).second, (*it).first});\\n        }\\n\\n        vector<string> ans;\\n        for (int i = 0; i < k; i++) {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114620,
                "title": "easiest-c-solution-using-priority-queue-map-and-comparator-class",
                "content": "```\\nclass Solution {\\npublic:\\n    class cmp{  //  a comparator class\\n        public:\\n        bool operator()( pair<int,string> &p1,const pair<int,string> &p2)\\n        {\\n            if(p1.first==p2.first) return p1.second>p2.second; // smaller string at top\\n            \\n               return p1.first<p2.first;  // larger string at top// larger freq at top\\n        }\\n        \\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> mp;  // taken a map to store the frequency of all the strings\\n        for(int i=0;i< words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        priority_queue<pair<int,string>,vector<pair<int,string>>,cmp> pq; t// max heap\\n        for(auto it: mp)\\n        {\\n            pq.push({it.second,it.first});  // since we have to first prioritize the frequency i.e string with highest frequency at top\\n        \\n        }\\n\\t\\t// now at this point first k elements from the top of the prioriy queue is the answer\\n        vector<string> ans;  // this will store answer string\\n         \\n        while(!pq.empty() && k--)\\n        {\\n          \\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n           \\n            \\n        }\\n       \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n/*    BRIEF EXPLANATION\\n so here we have to store the string with highest freuency at first, and if there is two strings with same frequency then we have to give priority to the lexiographically smallest one. We have to return first k elements.\\n   so my approach will be that first take a map will will give me the frequency of all the string\\n    After that i have to take a priority queue(max heap) but little modification will be done ,which will be done through comparator class int which i have to take string with highest frequency at top , and if two strings have same frequency then i have to prioritize string which is lexiographically small.\\n\\t    class cmp{  //  a comparator class\\n        public:\\n        bool operator()( pair<int,string> &p1,const pair<int,string> &p2)\\n        {\\n            if(p1.first==p2.first) return p1.second>p2.second; // smaller string at top\\n            \\n               return p1.first<p2.first;  // larger string at top// larger freq at top\\n        }\\n        \\n    };\\n\\tAfter that take out k elements from priority queue and store it in answer vector\\n\\t\\n\\t vector<string> ans;  // this will store answer string\\n         \\n        while(!pq.empty() && k--)\\n        {\\n          \\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n           \\n            \\n        }\\n       \\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class cmp{  //  a comparator class\\n        public:\\n        bool operator()( pair<int,string> &p1,const pair<int,string> &p2)\\n        {\\n            if(p1.first==p2.first) return p1.second>p2.second; // smaller string at top\\n            \\n               return p1.first<p2.first;  // larger string at top// larger freq at top\\n        }\\n        \\n    };\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> mp;  // taken a map to store the frequency of all the strings\\n        for(int i=0;i< words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        priority_queue<pair<int,string>,vector<pair<int,string>>,cmp> pq; t// max heap\\n        for(auto it: mp)\\n        {\\n            pq.push({it.second,it.first});  // since we have to first prioritize the frequency i.e string with highest frequency at top\\n        \\n        }\\n\\t\\t// now at this point first k elements from the top of the prioriy queue is the answer\\n        vector<string> ans;  // this will store answer string\\n         \\n        while(!pq.empty() && k--)\\n        {\\n          \\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n           \\n            \\n        }\\n       \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n/*    BRIEF EXPLANATION\\n so here we have to store the string with highest freuency at first, and if there is two strings with same frequency then we have to give priority to the lexiographically smallest one. We have to return first k elements.\\n   so my approach will be that first take a map will will give me the frequency of all the string\\n    After that i have to take a priority queue(max heap) but little modification will be done ,which will be done through comparator class int which i have to take string with highest frequency at top , and if two strings have same frequency then i have to prioritize string which is lexiographically small.\\n\\t    class cmp{  //  a comparator class\\n        public:\\n        bool operator()( pair<int,string> &p1,const pair<int,string> &p2)\\n        {\\n            if(p1.first==p2.first) return p1.second>p2.second; // smaller string at top\\n            \\n               return p1.first<p2.first;  // larger string at top// larger freq at top\\n        }\\n        \\n    };\\n\\tAfter that take out k elements from priority queue and store it in answer vector\\n\\t\\n\\t vector<string> ans;  // this will store answer string\\n         \\n        while(!pq.empty() && k--)\\n        {\\n          \\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n           \\n            \\n        }\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027906,
                "title": "python3-collections-counter-and-sort-list-with-a-tuple-as-key",
                "content": "**Solution 1: Counter() and sort()**  \\nhttps://leetcode.com/submissions/detail/875157545/\\nRuntime: **57 ms**, faster than 88.57% of Python3 online submissions for Top K Frequent Words.  \\nMemory Usage: 13.9 MB, less than 94.23% of Python3 online submissions for Top K Frequent Words.  \\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        l = [(v,k) for k,v in Counter(words).items()]\\n        l.sort(key=lambda x:(-x[0], x[1]))\\n        return [w for f,w in l[:k]]\\n```\\n\\n**Solution 2: naive dictionary** \\nhttps://leetcode.com/submissions/detail/825652552/  \\n110 / 110 test cases passed.  \\nStatus: Accepted  \\nRuntime: **96 ms**  \\nMemory Usage: 13.8 MB  \\n```\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        d = {}\\n        for word in set(words):\\n            n = words.count(word)\\n            if n in d:\\n                d[n].append(word)\\n            else:\\n                d[n] = [word]\\n \\n        res = []      \\n        for n in sorted(d, reverse=True):\\n            l = d[n]\\n            l.sort()\\n            if len(l)<k-len(res):\\n                res += l\\n            else:\\n                res += l[:k-len(res)]\\n                break\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        l = [(v,k) for k,v in Counter(words).items()]\\n        l.sort(key=lambda x:(-x[0], x[1]))\\n        return [w for f,w in l[:k]]\\n```\n```\\nclass Solution(object):\\n    def topKFrequent(self, words, k):\\n        \"\"\"\\n        :type words: List[str]\\n        :type k: int\\n        :rtype: List[str]\\n        \"\"\"\\n        d = {}\\n        for word in set(words):\\n            n = words.count(word)\\n            if n in d:\\n                d[n].append(word)\\n            else:\\n                d[n] = [word]\\n \\n        res = []      \\n        for n in sorted(d, reverse=True):\\n            l = d[n]\\n            l.sort()\\n            if len(l)<k-len(res):\\n                res += l\\n            else:\\n                res += l[:k-len(res)]\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776451,
                "title": "easy-c-solution-faster-than-85-of-c-submission",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static bool comp(pair<string,int>a, pair<string,int>b)\\n  {\\n    if(a.second==b.second)/*When frequency is same then sort on the basis of there alphabetical order*/\\n    {\\n        string temp=min(a.first,b.first);\\n        return a.first==temp; // return true;\\n    }\\n    return a.second>b.second; // sort on the basis of frequency\\n  }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       vector<string>ans; \\n       map<string,int>m;\\n\\n       for(auto i:words) ++m[i]; // storing frequency of elements.\\n\\n       vector<pair<string,int>>v(m.begin(),m.end()); // putting it into the vector container to sort them accoring to frequecy.\\n\\n       sort(v.begin(),v.end(),comp); // passes comp function to sort according to frequency.\\n\\n       int i=-1;\\n\\n       while(k--) ans.push_back(v[++i].first); // taking k most frequent element\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool comp(pair<string,int>a, pair<string,int>b)\\n  {\\n    if(a.second==b.second)/*When frequency is same then sort on the basis of there alphabetical order*/\\n    {\\n        string temp=min(a.first,b.first);\\n        return a.first==temp; // return true;\\n    }\\n    return a.second>b.second; // sort on the basis of frequency\\n  }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       vector<string>ans; \\n       map<string,int>m;\\n\\n       for(auto i:words) ++m[i]; // storing frequency of elements.\\n\\n       vector<pair<string,int>>v(m.begin(),m.end()); // putting it into the vector container to sort them accoring to frequecy.\\n\\n       sort(v.begin(),v.end(),comp); // passes comp function to sort according to frequency.\\n\\n       int i=-1;\\n\\n       while(k--) ans.push_back(v[++i].first); // taking k most frequent element\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726394,
                "title": "simple-solution-using-python-dictionaries",
                "content": "1. Create a dictionary \"dic{}\" for the count of each words\\n2. Create dictionary \"simlarfreuency{}\" to store words of similar frequency.\\n3. Using sort find the required result\\\\\\n\\n**Runtime: 55 ms, faster than 97.45% of Python3 online submissions for Top K Frequent Words.**\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic={}\\n        for i in words:\\n            if i not in dic:\\n                dic[i]=0\\n            else:\\n                dic[i] +=1\\n                \\n        similarfrequency ={}\\n        for i in dic:\\n            if dic[i] not in similarfrequency:\\n                similarfrequency[dic[i]]=[i]\\n            else:\\n                similarfrequency[dic[i]].append(i)\\n\\n        result=[]\\n        for i in sorted(similarfrequency,reverse = True):\\n            for j in sorted(similarfrequency[i]):\\n                if k>0:\\n                    result.append(j)\\n                    k-=1\\n        return result        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dic={}\\n        for i in words:\\n            if i not in dic:\\n                dic[i]=0\\n            else:\\n                dic[i] +=1\\n                \\n        similarfrequency ={}\\n        for i in dic:\\n            if dic[i] not in similarfrequency:\\n                similarfrequency[dic[i]]=[i]\\n            else:\\n                similarfrequency[dic[i]].append(i)\\n\\n        result=[]\\n        for i in sorted(similarfrequency,reverse = True):\\n            for j in sorted(similarfrequency[i]):\\n                if k>0:\\n                    result.append(j)\\n                    k-=1\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724754,
                "title": "java-8-working-with-streams",
                "content": "This is a `O(nlogn)` solution, but the idea is to practice working with Java streams API, as it is heavilty used in enterprise environments.\\n\\n# Code\\n```\\nimport java.lang.Comparable;\\n\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass WordFreq implements Comparable<WordFreq> {\\n    public String word;\\n    public int freq;\\n    \\n    public WordFreq(String word, int freq) {\\n        this.word = word;\\n        this.freq = freq;\\n    }\\n    \\n    public String getWord() {\\n        return word;\\n    }\\n    \\n    public int compareTo(WordFreq other) {\\n        if (other.freq != freq) {\\n            // return freq - other.freq;\\n            return other.freq - freq; // Reverse order\\n        }\\n        \\n        return word.compareTo(other.word);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Long> freq = countWordFrequency(words);\\n        List<WordFreq> wordFreqList = freq\\n            .entrySet()\\n            .stream()\\n            .map(entry -> new WordFreq(entry.getKey(), entry.getValue().intValue() ))\\n            .toList();\\n        \\n        return wordFreqList\\n            .stream()\\n            .sorted()\\n            .map(WordFreq::getWord)\\n            .limit(k)\\n            .toList();\\n    }\\n    \\n    private Map<String, Long> countWordFrequency(String[] words) {\\n        return Arrays\\n            .stream(words)\\n            .collect(\\n                Collectors.groupingBy(\\n                    x -> x,\\n                    Collectors.counting()\\n                )\\n            );\\n    }\\n}\\n```\\n\\n\\n# Improved by not terminating the stream pipeline twice\\n```\\nimport java.lang.Comparable;\\n\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\n// Must implement Comparable<T> or create Comparator<T> class to sort\\nclass WordFreq implements Comparable<WordFreq> {\\n    public String word;\\n    public int freq;\\n    \\n    public WordFreq(String word, int freq) {\\n        this.word = word;\\n        this.freq = freq;\\n    }\\n    \\n    public String getWord() {\\n        return word;\\n    }\\n    \\n    public int compareTo(WordFreq other) {\\n        if (other.freq != freq) {\\n            // return freq - other.freq;\\n            return other.freq - freq; // Reverse order\\n        }\\n        \\n        return word.compareTo(other.word);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Long> freq = countWordFrequency(words);\\n        return freq\\n            .entrySet()\\n            .stream()\\n            .map(entry -> new WordFreq(entry.getKey(), entry.getValue().intValue() ))\\n            .sorted()\\n            .map(WordFreq::getWord)\\n            .limit(k)\\n            .toList();\\n    }\\n    \\n    private Map<String, Long> countWordFrequency(String[] words) {\\n        return Arrays\\n            .stream(words)\\n            .collect(\\n                Collectors.groupingBy(\\n                    x -> x,\\n                    Collectors.counting()\\n                )\\n            );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.lang.Comparable;\\n\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass WordFreq implements Comparable<WordFreq> {\\n    public String word;\\n    public int freq;\\n    \\n    public WordFreq(String word, int freq) {\\n        this.word = word;\\n        this.freq = freq;\\n    }\\n    \\n    public String getWord() {\\n        return word;\\n    }\\n    \\n    public int compareTo(WordFreq other) {\\n        if (other.freq != freq) {\\n            // return freq - other.freq;\\n            return other.freq - freq; // Reverse order\\n        }\\n        \\n        return word.compareTo(other.word);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Long> freq = countWordFrequency(words);\\n        List<WordFreq> wordFreqList = freq\\n            .entrySet()\\n            .stream()\\n            .map(entry -> new WordFreq(entry.getKey(), entry.getValue().intValue() ))\\n            .toList();\\n        \\n        return wordFreqList\\n            .stream()\\n            .sorted()\\n            .map(WordFreq::getWord)\\n            .limit(k)\\n            .toList();\\n    }\\n    \\n    private Map<String, Long> countWordFrequency(String[] words) {\\n        return Arrays\\n            .stream(words)\\n            .collect(\\n                Collectors.groupingBy(\\n                    x -> x,\\n                    Collectors.counting()\\n                )\\n            );\\n    }\\n}\\n```\n```\\nimport java.lang.Comparable;\\n\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\n// Must implement Comparable<T> or create Comparator<T> class to sort\\nclass WordFreq implements Comparable<WordFreq> {\\n    public String word;\\n    public int freq;\\n    \\n    public WordFreq(String word, int freq) {\\n        this.word = word;\\n        this.freq = freq;\\n    }\\n    \\n    public String getWord() {\\n        return word;\\n    }\\n    \\n    public int compareTo(WordFreq other) {\\n        if (other.freq != freq) {\\n            // return freq - other.freq;\\n            return other.freq - freq; // Reverse order\\n        }\\n        \\n        return word.compareTo(other.word);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        Map<String, Long> freq = countWordFrequency(words);\\n        return freq\\n            .entrySet()\\n            .stream()\\n            .map(entry -> new WordFreq(entry.getKey(), entry.getValue().intValue() ))\\n            .sorted()\\n            .map(WordFreq::getWord)\\n            .limit(k)\\n            .toList();\\n    }\\n    \\n    private Map<String, Long> countWordFrequency(String[] words) {\\n        return Arrays\\n            .stream(words)\\n            .collect(\\n                Collectors.groupingBy(\\n                    x -> x,\\n                    Collectors.counting()\\n                )\\n            );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722712,
                "title": "python-2-liner",
                "content": "```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        pairs = sorted(Counter(words).items(), key = lambda p: (-p[1], p[0]))\\n        return [word for word, _ in pairs[0:k]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        pairs = sorted(Counter(words).items(), key = lambda p: (-p[1], p[0]))\\n        return [word for word, _ in pairs[0:k]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2722372,
                "title": "c-custom-comparator-priority-queue",
                "content": "Built my very own **custom comparator** via a class, from the scratch.\\nGreat way to implement my concepts though.\\nPlease upvote if you find the solution clean and concise.\\n***Thank You!!***\\n### Complexity\\nTime complexity: O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass pi {\\n    public:\\n    int val; string s;\\n    pi (int val ,string s) {\\n        this->val= val; this->s = s;\\n    }\\n    bool operator < (const pi& pi1) const {\\n        if(val == pi1.val) {\\n            return s.compare(pi1.s) < 0;\\n        }\\n        return val > pi1.val;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> mp;\\n        for(string &s : words) mp[s]++;\\n        priority_queue<pi> pq;\\n        for(auto &p : mp) {\\n            pq.push(pi(p.second, p.first));\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<string> res;\\n        while(pq.size()) {\\n            res.push_back(pq.top().s), pq.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pi {\\n    public:\\n    int val; string s;\\n    pi (int val ,string s) {\\n        this->val= val; this->s = s;\\n    }\\n    bool operator < (const pi& pi1) const {\\n        if(val == pi1.val) {\\n            return s.compare(pi1.s) < 0;\\n        }\\n        return val > pi1.val;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string,int> mp;\\n        for(string &s : words) mp[s]++;\\n        priority_queue<pi> pq;\\n        for(auto &p : mp) {\\n            pq.push(pi(p.second, p.first));\\n            if(pq.size() > k) pq.pop();\\n        }\\n        vector<string> res;\\n        while(pq.size()) {\\n            res.push_back(pq.top().s), pq.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721791,
                "title": "java-solution-hashmap-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> arr = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        PriorityQueue<Map.Entry<String, Integer>> que = new PriorityQueue<>(new MyComparator());\\n        for (String word : words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        que.addAll(map.entrySet());\\n        while (k-- > 0) {\\n            arr.add(Objects.requireNonNull(que.poll()).getKey());\\n        }\\n        return arr;\\n    }\\n}\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    @Override\\n    public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {\\n        if (a.getValue().equals(b.getValue())) {\\n            return a.getKey().compareTo(b.getKey());\\n        } else {\\n            return b.getValue() - a.getValue();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> topKFrequent(String[] words, int k) {\\n        List<String> arr = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        PriorityQueue<Map.Entry<String, Integer>> que = new PriorityQueue<>(new MyComparator());\\n        for (String word : words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        que.addAll(map.entrySet());\\n        while (k-- > 0) {\\n            arr.add(Objects.requireNonNull(que.poll()).getKey());\\n        }\\n        return arr;\\n    }\\n}\\nclass MyComparator implements Comparator<Map.Entry<String, Integer>> {\\n    @Override\\n    public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {\\n        if (a.getValue().equals(b.getValue())) {\\n            return a.getKey().compareTo(b.getKey());\\n        } else {\\n            return b.getValue() - a.getValue();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721552,
                "title": "c-simple-solution-hashmap-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    // Comparator for increasing frequency and lexicographical order.\\n    static bool comparator(pair<string,int> a,pair<string,int> b){\\n        if(a.second==b.second){\\n            return a.first<b.first; // lexicographic\\n        }\\n        return a.second>b.second; // frequency\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        int n=words.size();\\n        unordered_map<string,int> hashmap;\\n        for(int i=0;i<n;i++){  // frequency of unique words\\n            hashmap[words[i]]++;\\n        }\\n        vector<pair<string,int>> freq; // using freq array for sorting\\n        for(auto itr : hashmap){  \\n            freq.push_back(make_pair(itr.first,itr.second));\\n        }\\n        sort(freq.begin(),freq.end(),comparator);  //sort here\\n        vector<string> ans;\\n        for(int i=0;i<k;i++){  // add top k elements to ans.\\n            ans.push_back(freq[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Comparator for increasing frequency and lexicographical order.\\n    static bool comparator(pair<string,int> a,pair<string,int> b){\\n        if(a.second==b.second){\\n            return a.first<b.first; // lexicographic\\n        }\\n        return a.second>b.second; // frequency\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        int n=words.size();\\n        unordered_map<string,int> hashmap;\\n        for(int i=0;i<n;i++){  // frequency of unique words\\n            hashmap[words[i]]++;\\n        }\\n        vector<pair<string,int>> freq; // using freq array for sorting\\n        for(auto itr : hashmap){  \\n            freq.push_back(make_pair(itr.first,itr.second));\\n        }\\n        sort(freq.begin(),freq.end(),comparator);  //sort here\\n        vector<string> ans;\\n        for(int i=0;i<k;i++){  // add top k elements to ans.\\n            ans.push_back(freq[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721318,
                "title": "python-3-2-line-code-using-collections-65ms-86-13mb-64-49-fast-and-easy",
                "content": "Here is the two line answer.\\n\\n        # sort to  lexicographical order\\n\\t\\twords.sort()\\n\\t\\t\\n        # return k most frequent strings as list\\n\\t\\treturn dict(collections.Counter(words).most_common(k)).keys()\\n\\t\\t\\nyou can expand as follow to get clear understand\\n\\n        # sort to  lexicographical order\\n\\t\\twords.sort()\\n\\t\\t\\n\\t\\t# make counter using collections package\\n\\t\\tcounter = collections.Counter(words)\\n\\t\\t\\n\\t\\t# get k most frequent strings\\n\\t\\tk_items = counter.most_common(k)\\n\\t\\t\\n\\t\\t# return the result as a list\\n\\t\\treturn dict(k_items).keys()",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is the two line answer.\\n\\n        # sort to  lexicographical order\\n\\t\\twords.sort()\\n\\t\\t\\n        # return k most frequent strings as list\\n\\t\\treturn dict(collections.Counter(words).most_common(k)).keys()\\n\\t\\t\\nyou can expand as follow to get clear understand\\n\\n        # sort to  lexicographical order\\n\\t\\twords.sort()\\n\\t\\t\\n\\t\\t# make counter using collections package\\n\\t\\tcounter = collections.Counter(words)\\n\\t\\t\\n\\t\\t# get k most frequent strings\\n\\t\\tk_items = counter.most_common(k)\\n\\t\\t\\n\\t\\t# return the result as a list\\n\\t\\treturn dict(k_items).keys()",
                "codeTag": "Unknown"
            },
            {
                "id": 2721219,
                "title": "c-very-easy-solution-without-priority-queue-hashmap-solution",
                "content": "\\n\\n```\\nvector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int>mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]++;\\n        }\\n      \\n        vector<string>ans;\\n        map<int,set<string>>mp2;\\n        for(auto i:mp){\\n            mp2[i.second].insert(i.first);\\n        }\\n        \\n        for(auto it=mp2.rbegin();it!=mp2.rend();it++){\\n            if(k>0){\\n                for(auto c: it->second){\\n                    if(k==0) break;\\n                    ans.push_back(c);\\n                    k--;\\n                }\\n                \\n            }\\n                \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> topKFrequent(vector<string>& words, int k) {\\n        map<string,int>mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]++;\\n        }\\n      \\n        vector<string>ans;\\n        map<int,set<string>>mp2;\\n        for(auto i:mp){\\n            mp2[i.second].insert(i.first);\\n        }\\n        \\n        for(auto it=mp2.rbegin();it!=mp2.rend();it++){\\n            if(k>0){\\n                for(auto c: it->second){\\n                    if(k==0) break;\\n                    ans.push_back(c);\\n                    k--;\\n                }\\n                \\n            }\\n                \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720697,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        String val;\\n        int freq;\\n             Pair(String val, int freq){\\n                 this.val=val;\\n                 this.freq=freq;\\n             }\\n    }\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String,Integer>map=new HashMap();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->{\\n            if(a.freq!=b.freq){\\n                return a.freq-b.freq;\\n            }\\n            return b.val.compareTo(a.val);\\n        });\\n        for(String key : map.keySet()){\\n            if(pq.size()<k){\\n                pq.add(new Pair(key,map.get(key)));\\n            }else{\\n                if(pq.peek().freq<map.get(key)){\\n                    pq.remove();\\n                    pq.add(new Pair(key,map.get(key)));\\n                }else if(pq.peek().freq==map.get(key)){\\n                     pq.add(new Pair(key,map.get(key)));\\n                    }\\n                }\\n            }\\n            while(pq.size()>k){\\n                pq.remove();\\n            }\\n        List<String>ans=new ArrayList();\\n        while(pq.size()>0){\\n            ans.add(0,pq.remove().val);\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        String val;\\n        int freq;\\n             Pair(String val, int freq){\\n                 this.val=val;\\n                 this.freq=freq;\\n             }\\n    }\\n    public List<String> topKFrequent(String[] words, int k) {\\n        HashMap<String,Integer>map=new HashMap();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->{\\n            if(a.freq!=b.freq){\\n                return a.freq-b.freq;\\n            }\\n            return b.val.compareTo(a.val);\\n        });\\n        for(String key : map.keySet()){\\n            if(pq.size()<k){\\n                pq.add(new Pair(key,map.get(key)));\\n            }else{\\n                if(pq.peek().freq<map.get(key)){\\n                    pq.remove();\\n                    pq.add(new Pair(key,map.get(key)));\\n                }else if(pq.peek().freq==map.get(key)){\\n                     pq.add(new Pair(key,map.get(key)));\\n                    }\\n                }\\n            }\\n            while(pq.size()>k){\\n                pq.remove();\\n            }\\n        List<String>ans=new ArrayList();\\n        while(pq.size()>0){\\n            ans.add(0,pq.remove().val);\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720645,
                "title": "c-most-easy-and-understandable-solution-runtime-27-ms-beats-45-47-memory-12-7-mb-beats-39-56",
                "content": "# Approach\\nThe apporach I\\'ve used is sorting the priority queue(min heap in this case) on the basis of custom comparator and then storing the top k elements in an array.\\n\\n# Complexity\\n- Time complexity:\\nStoring the elements in a map - O(n)\\nStoring in the priority queue - O(n);\\nStoring top ```k``` elements in array - O(k);\\nSo total complexity = ```O(2n + k)```.\\n\\n- Space complexity:\\n2 additional spaces are used - 1 map + 1 queue\\nSo Space Complexity = ```O(2n)```.\\n\\nHope you guys loved my solution.\\n``` \\n    if(loved == true)\\n        upvote ++;\\n    else\\n        correctMe++;\\n```\\n### ***Happy Coding!!!*** \\n# Code\\n```\\nstruct cmp {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, cmp> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```k```\n```O(2n + k)```\n```O(2n)```\n``` \\n    if(loved == true)\\n        upvote ++;\\n    else\\n        correctMe++;\\n```\n```\\nstruct cmp {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, cmp> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720388,
                "title": "c-2-approaches-n-log-n-nlog-k",
                "content": "```\\n//Youtube Video : https://www.youtube.com/watch?v=zW-8-6A2gxM\\n\\n//Approach-1 (Time : O(nlogn), Space : O(n))\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<pair<int, string>> vp;\\n        unordered_map<string, int> mp;\\n        \\n        for(string &word : words) {\\n            mp[word]++;\\n        }\\n        \\n        for(auto &it : mp) {\\n            vp.push_back({it.second, it.first});\\n        }\\n        \\n        auto lambda = [](pair<int, string>& p1, pair<int, string>& p2) {\\n            if(p1.first == p2.first)\\n                return p1.second < p2.second;\\n            \\n            return p1.first > p2.first;\\n        };\\n        \\n        sort(begin(vp), end(vp), lambda);\\n        \\n        int i = 0;\\n        vector<string> result(k);\\n        while(i < k) {\\n            result[i] = vp[i].second;\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Using Heap - Time : O(nlogk), Space : O(n))\\nclass Solution {\\npublic:\\n    typedef pair<string, int> P;\\n    \\n    struct lambda {\\n        bool operator()(P& a, P& b){\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        }  \\n    };\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &word : words) {\\n            mp[word]++;\\n        }\\n        \\n        for(auto &it : mp) {\\n            pq.push({it.first, it.second});\\n            \\n            if(pq.size() > k)\\n                pq.pop();\\n        }\\n        \\n        int i = k-1;\\n        vector<string> result(k);\\n        while(!pq.empty()) {\\n            result[i] = pq.top().first;\\n            pq.pop();\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Youtube Video : https://www.youtube.com/watch?v=zW-8-6A2gxM\\n\\n//Approach-1 (Time : O(nlogn), Space : O(n))\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<pair<int, string>> vp;\\n        unordered_map<string, int> mp;\\n        \\n        for(string &word : words) {\\n            mp[word]++;\\n        }\\n        \\n        for(auto &it : mp) {\\n            vp.push_back({it.second, it.first});\\n        }\\n        \\n        auto lambda = [](pair<int, string>& p1, pair<int, string>& p2) {\\n            if(p1.first == p2.first)\\n                return p1.second < p2.second;\\n            \\n            return p1.first > p2.first;\\n        };\\n        \\n        sort(begin(vp), end(vp), lambda);\\n        \\n        int i = 0;\\n        vector<string> result(k);\\n        while(i < k) {\\n            result[i] = vp[i].second;\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Using Heap - Time : O(nlogk), Space : O(n))\\nclass Solution {\\npublic:\\n    typedef pair<string, int> P;\\n    \\n    struct lambda {\\n        bool operator()(P& a, P& b){\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        }  \\n    };\\n    \\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &word : words) {\\n            mp[word]++;\\n        }\\n        \\n        for(auto &it : mp) {\\n            pq.push({it.first, it.second});\\n            \\n            if(pq.size() > k)\\n                pq.pop();\\n        }\\n        \\n        int i = k-1;\\n        vector<string> result(k);\\n        while(!pq.empty()) {\\n            result[i] = pq.top().first;\\n            pq.pop();\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720191,
                "title": "js-very-easy-and-very-fast-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f423b418-b8e7-4cee-8bc4-55167636aa6a_1666146314.0181627.png)\\n```\\nvar topKFrequent = function(words, k) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        if (!hashmap.has(word)) {\\n            hashmap.set(word, 1);\\n        } else {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        }\\n    }\\n    \\n    const arr = [...hashmap.entries()].sort((a, b) => b[1] !== a[1] ? b[1] - a[1] : a[0].localeCompare(b[0]));\\n    \\n    return arr.slice(0, k).map(item => item[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar topKFrequent = function(words, k) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        if (!hashmap.has(word)) {\\n            hashmap.set(word, 1);\\n        } else {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        }\\n    }\\n    \\n    const arr = [...hashmap.entries()].sort((a, b) => b[1] !== a[1] ? b[1] - a[1] : a[0].localeCompare(b[0]));\\n    \\n    return arr.slice(0, k).map(item => item[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720190,
                "title": "c-1-liner-linq",
                "content": "This solution using LINQ and `GroupBy` to get the number of times each word occurs. `GroupBy` returns a list of `IGrouping` objects which can be used in conjunction with `TryGetNonEnumeratedCount`. Each call to this method runs in constant time due to the underlying object implementing the `ICollection` interface.\\n\\nRuntime: `O(n log n)`\\n\\n```cs\\npublic IList<string> TopKFrequent(string[] words, int k) => words\\n    .GroupBy(w => w)\\n    .OrderByDescending(g => g.TryGetNonEnumeratedCount(out int c) ? c : g.Count())\\n    .ThenBy(g => g.Key)\\n    .Select(g => g.Key)\\n    .Take(k)\\n    .ToList();\\n```\\n\\nThe next solution is *not* a 1-liner, but it does have a faster runtime, I do not think it is possible to improve on the above runtime using only LINQ. A `SortedSet` and `Dictionary` are used in conjunction. Access time for `SortedSet` is logarithmic relative to its size and we are adding and removing elements during loop iteration, always ensuring it never grows beyond `k`.\\n\\nRuntime: `O(n log k)`\\n\\n```cs\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var ss = new SortedSet<(int f, string w)>();\\n    var map = new Dictionary<string, int>();\\n    foreach (var w in words) {\\n        if (map.TryGetValue(w, out int f)) {\\n            ss.Remove((f, w));\\n        }\\n        map[w] = --f;\\n        ss.Add((f, w));\\n        if (ss.Count > k) {\\n            ss.Remove(ss.Max);\\n        }\\n    }\\n    return ss.Select(x => x.w).ToList();\\n}\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic IList<string> TopKFrequent(string[] words, int k) => words\\n    .GroupBy(w => w)\\n    .OrderByDescending(g => g.TryGetNonEnumeratedCount(out int c) ? c : g.Count())\\n    .ThenBy(g => g.Key)\\n    .Select(g => g.Key)\\n    .Take(k)\\n    .ToList();\\n```\n```cs\\npublic IList<string> TopKFrequent(string[] words, int k) {\\n    var ss = new SortedSet<(int f, string w)>();\\n    var map = new Dictionary<string, int>();\\n    foreach (var w in words) {\\n        if (map.TryGetValue(w, out int f)) {\\n            ss.Remove((f, w));\\n        }\\n        map[w] = --f;\\n        ss.Add((f, w));\\n        if (ss.Count > k) {\\n            ss.Remove(ss.Max);\\n        }\\n    }\\n    return ss.Select(x => x.w).ToList();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719959,
                "title": "easy-c-solution-fast",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam 95](https://github.com/Yaduttam95)\\n\\n## PLEASE UPVOTE IF YOU LIKE IT\\n\\n```\\nstruct Compare {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# If u reached till here and solution worked for you please upvote it",
                "solutionTags": [],
                "code": "```\\nstruct Compare {\\n    bool operator() (pair<int, string> a, pair<int, string> b) {\\n        if(a.first == b.first)\\n            return a.second > b.second;\\n        else\\n            return a.first < b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<words.size(); i++)\\n            m[words[i]]++;\\n        \\n        priority_queue<pair<int, string>, vector<pair<int, string>>, Compare> q;\\n        for(auto p : m)\\n            q.push({p.second, p.first});\\n        \\n        vector<string> ans;\\n        while(k--) {\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667206,
                "title": "just-pair-and-sort-comparator-nothing-fancy",
                "content": "```\\n   // compartor has to be static function , i\\'m sorting here firstly based on occurance of the string , if the occurance is equal then i go for alphabetical order\\n    static bool comp(const pair<string,int> &p1, const pair<string,int> &p2)\\n    {\\n       if(p1.second != p2.second) return p1.second > p2.second;\\n       else return p1.first < p2.first;\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n\\t// to keep track of how many times a string has occured , i\\'m using a map\\n        unordered_map<string , int > mp;\\n        for(auto a:words){\\n            mp[a]++;\\n        }\\n\\t\\t// to sort them based on occurance , using a pair \\n        vector<pair<string,int>> pr;\\n        for(auto itr= mp.begin();itr!=mp.end();itr++){\\n            pr.push_back(make_pair(itr->first, itr->second));\\n        }\\n\\t\\t// magic happens here \\n        sort(pr.begin(),pr.end(),comp);\\n\\t\\t// to return the answer , just take top k elements as we have alread sorted it\\n        vector<string> ans;\\n        int count = k;\\n        for(int i=0;i<pr.size();i++){\\n            if(k==0) break;\\n            else{\\n                k--;\\n                ans.push_back(pr[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nif there is any difficulty in understaning this , comment down ,i will add or edit the post with comments",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   // compartor has to be static function , i\\'m sorting here firstly based on occurance of the string , if the occurance is equal then i go for alphabetical order\\n    static bool comp(const pair<string,int> &p1, const pair<string,int> &p2)\\n    {\\n       if(p1.second != p2.second) return p1.second > p2.second;\\n       else return p1.first < p2.first;\\n    }\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n\\t// to keep track of how many times a string has occured , i\\'m using a map\\n        unordered_map<string , int > mp;\\n        for(auto a:words){\\n            mp[a]++;\\n        }\\n\\t\\t// to sort them based on occurance , using a pair \\n        vector<pair<string,int>> pr;\\n        for(auto itr= mp.begin();itr!=mp.end();itr++){\\n            pr.push_back(make_pair(itr->first, itr->second));\\n        }\\n\\t\\t// magic happens here \\n        sort(pr.begin(),pr.end(),comp);\\n\\t\\t// to return the answer , just take top k elements as we have alread sorted it\\n        vector<string> ans;\\n        int count = k;\\n        for(int i=0;i<pr.size();i++){\\n            if(k==0) break;\\n            else{\\n                k--;\\n                ans.push_back(pr[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658575,
                "title": "python-soln-using-dictionary",
                "content": "**Approach:** Using frequency of each element of words list and sorting them by their key *value*.\\n\\n```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq={}\\n        for i in words:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        temp=sorted(freq.items(),key=lambda v:(-v[1], v[0]))\\n        res=[]\\n        for i in range(k):\\n            res.append(temp[i][0])\\n        return res\\n```\\n\\n*Upvote if you got help :-)*",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        freq={}\\n        for i in words:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        temp=sorted(freq.items(),key=lambda v:(-v[1], v[0]))\\n        res=[]\\n        for i in range(k):\\n            res.append(temp[i][0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600402,
                "title": "python-solution",
                "content": "Runtime: 55 ms, faster than 97.51% of Python3 online submissions for Top K Frequent Words.\\nMemory Usage: 14.1 MB, less than 27.24% of Python3 online submissions for Top K Frequent Words.\\n\\n```python\\nimport heapq\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def topKFrequent(self, words: list[str], k: int) -> list[str]:\\n        counter = Counter(words)\\n\\n        # Negate count because heapq provides a min-heap.\\n        heap = [(-count, word) for word, count in counter.items()]\\n        heapq.heapify(heap)\\n\\n        out = []\\n        while k:\\n            _, word = heapq.heappop(heap)\\n            out.append(word)\\n            k -= 1\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nimport heapq\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def topKFrequent(self, words: list[str], k: int) -> list[str]:\\n        counter = Counter(words)\\n\\n        # Negate count because heapq provides a min-heap.\\n        heap = [(-count, word) for word, count in counter.items()]\\n        heapq.heapify(heap)\\n\\n        out = []\\n        while k:\\n            _, word = heapq.heappop(heap)\\n            out.append(word)\\n            k -= 1\\n\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474022,
                "title": "simple-hash-map-solution-beginner-friendly",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstatic bool mycmp(const pair<int, string> &p1, const pair<int, string> &p2)\\n\\t\\t{\\n\\t\\t\\tif(p1.first>p2.first ||(p1.first==p2.first && p1.second<p2.second))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<string> topKFrequent(vector<string>& words, int k)\\n\\t\\t{\\n\\t\\t\\tvector<pair<int,string>>v;\\n\\t\\t\\tunordered_map<string,int>mp;\\n\\t\\t\\tfor(auto it:words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[it]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto it:mp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(make_pair(it.second,it.first));\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(),v.end(),mycmp);\\n\\t\\t\\tvector<string>vec;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto it:v)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(count==k)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tvec.push_back(it.second);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}   \\n\\t\\t\\treturn vec;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstatic bool mycmp(const pair<int, string> &p1, const pair<int, string> &p2)\\n\\t\\t{\\n\\t\\t\\tif(p1.first>p2.first ||(p1.first==p2.first && p1.second<p2.second))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2354813,
                "title": "c-trie-based-soln-easy-explanation",
                "content": "Steps :\\n1. Insert all the words in the trie;\\n2. count all the similar word by maintaining `count` variable;\\n3. Sort the `words`  for Lexicographical check;\\n4. find k times the most frequent in the word vector;\\n```\\nstruct TrieNode\\n{\\n    TrieNode *links[26];\\n    int count = 0;\\n};\\nclass Trie\\n{\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string s)\\n    {\\n        TrieNode *node = root;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (!node->links[s[i] - \\'a\\'])\\n            {\\n                TrieNode *obj = new TrieNode();\\n                node->links[s[i] - \\'a\\'] = obj;\\n            }\\n            node = node->links[s[i] - \\'a\\'];\\n        }\\n        node->count++;\\n    }\\n    int wordcount(string s)\\n    {\\n        TrieNode *node = root;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            node = node->links[s[i] - \\'a\\'];\\n        }\\n        return node->count;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    vector<string> topKFrequent(vector<string> &words, int k)\\n    {\\n        Trie ark;\\n        vector<string> ans;\\n        for (auto word : words)\\n        {\\n            ark.insert(word);\\n        }\\n\\t\\t// words will lexicographically sorted\\n        sort(words.begin(), words.end());\\n\\t\\t//retrieving k frequents words\\n        while (k--)\\n        {\\n            int mx = -1;\\n            int x = 0;\\n            string temp;\\n\\t\\t\\t//finding most frequent in the vector currrently\\n            for (auto word : words)\\n            {\\n                x = ark.wordcount(word);\\n                if (mx < x)\\n                {\\n                    temp = word;\\n                    mx = x;\\n                }\\n            ans.push_back(temp);\\n\\t\\t\\t//erase the most frequent word till now\\n            words.erase(remove(words.begin(), words.end(), temp), words.end());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n##### If you like this solution, do **UPVOTE**.\\n##### Feel free to ask any **doubts** in the comment section.\\n##### Happy Coding :)\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nstruct TrieNode\\n{\\n    TrieNode *links[26];\\n    int count = 0;\\n};\\nclass Trie\\n{\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string s)\\n    {\\n        TrieNode *node = root;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (!node->links[s[i] - \\'a\\'])\\n            {\\n                TrieNode *obj = new TrieNode();\\n                node->links[s[i] - \\'a\\'] = obj;\\n            }\\n            node = node->links[s[i] - \\'a\\'];\\n        }\\n        node->count++;\\n    }\\n    int wordcount(string s)\\n    {\\n        TrieNode *node = root;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            node = node->links[s[i] - \\'a\\'];\\n        }\\n        return node->count;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    vector<string> topKFrequent(vector<string> &words, int k)\\n    {\\n        Trie ark;\\n        vector<string> ans;\\n        for (auto word : words)\\n        {\\n            ark.insert(word);\\n        }\\n\\t\\t// words will lexicographically sorted\\n        sort(words.begin(), words.end());\\n\\t\\t//retrieving k frequents words\\n        while (k--)\\n        {\\n            int mx = -1;\\n            int x = 0;\\n            string temp;\\n\\t\\t\\t//finding most frequent in the vector currrently\\n            for (auto word : words)\\n            {\\n                x = ark.wordcount(word);\\n                if (mx < x)\\n                {\\n                    temp = word;\\n                    mx = x;\\n                }\\n            ans.push_back(temp);\\n\\t\\t\\t//erase the most frequent word till now\\n            words.erase(remove(words.begin(), words.end(), temp), words.end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290992,
                "title": "clean-code-with-comments-c-heap-follow-up-followed-o-nlogk-time",
                "content": "**The CRUX is to choose which HEAP**\\n* If MAX heap choosed - then we need to make full insertion then pop and take top k elements from heap. WHICH DOES NOT Follow FOLLOW UP - Why?\\n* Bcoz we need O(n * log k ) sol not O(n* log n) sol. Bcoz each insertion O(log k) where k is the size of heap\\n* IF Go with MIN HEAP, then at last when we pop k element, the order is low to high frequency, we cannot change comparator as per size and all.\\n* So WHAT TO DO? \\n* We are putting the ans in reverse in the VECTOR.\\n\\n\\n```\\n#define ppi pair<int,string>\\nclass Solution {\\npublic:\\n    class Compare {\\n        public:\\n        bool operator()(ppi below, ppi above){\\n            if(below.first == above.first){\\n                //same freq\\n                return below.second < above.second; //larger word at TOP  - so that lexicographical order asc is maintained as we are gonna store from reverse\\n            }\\n            return below.first > above.first; // smaller freq at TOP - so that they are popped \\n        }\\n    };\\n    \\n    //MIN HEAP - as u want to pop Smallers and store largest freq in HEAP\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string> ans(k);\\n        \\n        priority_queue<ppi,vector<ppi>, Compare> minH;\\n        \\n        unordered_map<string, int>mpp;\\n        for(string s : words){ // O(N)\\n            mpp[s]++; //O(1) \\n        }\\n        \\n        for(auto m : mpp){ //O(N) loop\\n            \\n            minH.push({m.second,m.first});\\n            \\n            if(minH.size()>k){\\n                minH.pop(); // heapify happens O(log K)\\n            }\\n        }\\n        \\n        //now top K frequent words are there\\n        int j = k-1;\\n        while(minH.size()>0){\\n            ans[j]= minH.top().second;\\n            minH.pop();\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ppi pair<int,string>\\nclass Solution {\\npublic:\\n    class Compare {\\n        public:\\n        bool operator()(ppi below, ppi above){\\n            if(below.first == above.first){\\n                //same freq\\n                return below.second < above.second; //larger word at TOP  - so that lexicographical order asc is maintained as we are gonna store from reverse\\n            }\\n            return below.first > above.first; // smaller freq at TOP - so that they are popped \\n        }\\n    };\\n    \\n    //MIN HEAP - as u want to pop Smallers and store largest freq in HEAP\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n        vector<string> ans(k);\\n        \\n        priority_queue<ppi,vector<ppi>, Compare> minH;\\n        \\n        unordered_map<string, int>mpp;\\n        for(string s : words){ // O(N)\\n            mpp[s]++; //O(1) \\n        }\\n        \\n        for(auto m : mpp){ //O(N) loop\\n            \\n            minH.push({m.second,m.first});\\n            \\n            if(minH.size()>k){\\n                minH.pop(); // heapify happens O(log K)\\n            }\\n        }\\n        \\n        //now top K frequent words are there\\n        int j = k-1;\\n        while(minH.size()>0){\\n            ans[j]= minH.top().second;\\n            minH.pop();\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1651252,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1573536,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1569447,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1567022,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1567998,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1575117,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1574748,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1959098,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1941266,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1802610,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1651252,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1573536,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1569447,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1567022,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1567998,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1575117,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1574748,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1959098,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1941266,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            },
            {
                "id": 1802610,
                "content": [
                    {
                        "username": "Chouhan_Gourav",
                        "content": "The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).\\nIf this does\\'nt amaze you when you come to know this fact for the first time, then nothing will.\\n\\n```cpp\\n    \\n    //  O(N*log(N))\\n    priority_queue<int> p;\\n    for(auto x : arr) p.push(x);\\n\\n    // O(N)\\n    priority_queue<int> p(arr.begin(), arr.end());\\n    // It uses Floyds heapify algorithm\\n```"
                    },
                    {
                        "username": "dhpker",
                        "content": "In the example input where\\n\\n**Input**: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\\n**Output**: [\"i\", \"love\"]\\n\\nWhy are \"coding\" and \"leetcode\" not included in the example output, when the problem specifies the answer should be sorted by frequency from highest to lowest? \\n\\nWhereas for the 2nd example\\n\\n**Input**: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\\n**Output**: [\"the\", \"is\", \"sunny\", \"day\"]\\n\\n\"is\", \"sunny\", and \"day\" are included?"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "[@asa881977818](/asa881977818)  Because `coding` comes before `leetcode` lexicographically. "
                    },
                    {
                        "username": "akanksha-t",
                        "content": "So, the question says \"return the k most frequent strings\", not to return strings whose frequency is at most k. In example 1, we\\'re supposed to return a vector<string> whose size will be 2 and in the second, whose size will be 4. And the contents of vectors will be words that are sorted according to their frequency."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@asa881977818](/asa881977818) if frequency is same you have to take the lexcicographically smaller word"
                    },
                    {
                        "username": "asa881977818",
                        "content": "Excuse me\\n\\nInput words =[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"],k = 3\\nExpected is [\"i\",\"love\",\"coding\"]\\ninstead of this output [\"i\",\"love\",\"leetcode\"]\\n\\nwhy?"
                    },
                    {
                        "username": "sandipan72",
                        "content": "As for the first example we need to send back k number of strings sorted by frequency. As \\n\\nfreq(\"i\") -> 2\\nfreq(\"love\") -> 2 \\nfreq(\"leetcode\") -> 1\\nfreq(\"coding\") -> 1\\nand we need to send back 2 strings that\\'s why we are sending back only \"i\" and \"love\"."
                    },
                    {
                        "username": "user5667j",
                        "content": "Hi, \\nThe provided solution uses min heap for storing the (-frequency, word) tuples, and then pop out the most frequent words. It implies that heapq breaks tie when two tuples have the same prioriry, using the second element. \\nI tried to find a documentation about this in the stansard library doc and the following quote also implies that: \"Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\". \\nHowever, since I didn\\'t see this assumption written explicitly in the doc, I was wondering if you guys know for certain that indeed this is the case, and if you can refer me to your source. \\n\\nThanks so much!\\nAdva\\n"
                    },
                    {
                        "username": "amrinders433",
                        "content": "# **Top K Frequent Words**\\n![image](https://assets.leetcode.com/users/images/78051b8a-ae1a-4b5a-8b9c-79bc80483d8a_1614143491.5928714.png)\\n"
                    },
                    {
                        "username": "JadenPan",
                        "content": "I spend several hours on this follow up , I trie to apply heap, bucket sort, and even similar partition method like what we did on problem \"top k elements\", but all failed because I can not think about how we can do that with O(k) space if a hashmap used. And as long as we use something like heap the time cost will be O(nlogk).\\nThen I saw \"Trie\" in the tag, and looked for some materials, finally I found one solution online that solve this problem with trie:\\nhttp://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/\\nThis is a heap+trie solution.  But I think it's still not good enough for O(n) time O(k) space.\\nIn this solution, the heap's size is restricted to O(k) but the trie could go very large if we have long strings. Also, though we solve it in one pass but we still need O(logk) time on each turn.\\nSo any genius have great solutions?"
                    },
                    {
                        "username": "stillanovice",
                        "content": "Hi All,\\n\\n***Question/Doubt***\\nJust wanted to know that are we really allowed to use internal functions something like **heapq.heapify** in python to solve this particular question in an interview let\\'s say in a real amazon interview, once we tell the approach to the interviewer. \\n\\nAnother example can be LRU cache where we can easily use Ordered Dict to implement things with same complexity or is it intuitive that interviewer wants to check our skills and will ask explicitly to use DLL in the problem and actually implement LRU cache.\\n\\n***Why I am asking this?***\\nI come from a heavy C background, and in an actual interview writing these utility stuff like min/max heap etc..takes time.\\n\\nThanks in advance for the help & motivation this community provides."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "you need to ask the interviewer. The safest is to study both ways of doing them. That being said if you are interviewing for a python job, it is more likely you are allowed to use stdlib items and third party libs like bisect."
                    },
                    {
                        "username": "Xing13682047257",
                        "content": "return words.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count()).OrderByDescending(x => x.Value).ThenBy(x => x.Key).Take(k).Select(x => x.Key).ToArray();"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Don\\'t know where i am doing mistake ..Someone please help!!!!\\n\\n\\nclass Solution {\\npublic:\\n    vector<string> topKFrequent(vector<string>& words, int k) {\\n       map<string,int>m;\\n\\n       for(auto i: words){\\n           m[i]++;\\n       } \\n\\n       priority_queue<pair<int,string>>pq;\\n       for(auto i:m){\\n           pq.push({i.second,i.first});\\n       }\\n\\n vector<string> s;\\n for(int i=0;i<k;i++){\\n     s.push_back(pq.top().second);\\n     pq.pop();\\n }\\n int count=0;\\n int start=0;\\n\\n for(int i=0;i<s.size()-1;i++){\\n   if(m[s[i]]==m[s[i+1]]){\\n       count++;\\n       if(i==s.size()-2){\\n           sort(s.begin()+start,s.end());\\n       }\\n   }  \\n   else {\\n         sort(s.begin()+start,s.begin()+start+count+1);\\n         start=i+1;\\n         count=0;\\n   }\\n }\\n return s;\\n\\n    }\\n};"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "the n log k approach in python is maddening"
                    },
                    {
                        "username": "keratonjava",
                        "content": "Just lot of code :("
                    }
                ]
            }
        ]
    }
]