[
    {
        "title": "Super Washing Machines",
        "question_content": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n&nbsp;\nExample 1:\n\nInput: machines = [1,0,5]\nOutput: 3\nExplanation:\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\nExample 2:\n\nInput: machines = [0,3,0]\nOutput: 2\nExplanation:\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\nExample 3:\n\nInput: machines = [0,2,0]\nOutput: -1\nExplanation:\nIt's impossible to make all three washing machines have the same number of dresses.\n\n&nbsp;\nConstraints:\n\n\tn == machines.length\n\t1 <= n <= 104\n\t0 <= machines[i] <= 105",
        "solutions": [
            {
                "id": 99177,
                "title": "very-intuitive-o-n-solution",
                "content": "Instead of using some DP methodology to solve the problem, I have a very intuitive way to approach the solution. \\n\\nThink about the machine ```i```, after we make all machines have the same dresses, **how many dresses will be passed through machine ```i```**?\\nLet's denote the current sum of dresses of machines ```[0...i-1]``` as ```leftSums[i]```, and the current sum of dresses of machines ```[i+1...n-1]``` as rightSums[i].\\nLet's denote the expected sum of dresses of machines ```[0...i-1]``` as ```expLeft```, which means after all dresses are equally distributed, the sum of address in machines ```[0...i-1]``` should be ```expLeft```. The same logic applies to machines ```[i+1...n-1]```, denoted as ```expRight```.\\n\\nThen the above question should be clearly answered. If ```expLeft``` is larger than ```leftSums[i]```, that means no matter how you move the dresses, there will be at least ```expLeft - leftSums[i]``` dresses being moved to left of machine ```i```, which means pass through machine ```i```. For the right machines of machine i, the logic remains the same. So we could conclude that the minimum dresses passed through machine ```i``` will be:\\n```\\nleft = expLeft > leftSums[i] ? expLeft - leftSums[i] : 0;\\nright = expRight > rightSums[i] ? expRight - rightSums[i] : 0;\\ntotal = left + right;\\n```\\n\\nWith this answer in mind, we could know that the minimum moves is the maximum dresses that pass through for each single machine, because for each dress, it will require at least one move. Hence the following solution. The code could be more concise, but I will leave it here for purpose of explanation. \\n\\nIf you have any doubts or suggestions for this solution, any comments are welcome.\\n\\n```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int sum = 0;\\n        for (int num : machines) {\\n            sum += num;\\n        }\\n        if (sum % n != 0) {\\n            return -1;\\n        }\\n        int avg = sum / n;\\n        int[] leftSums = new int[n];\\n        int[] rightSums = new int[n];\\n        for (int i = 1; i < n; i ++) {\\n            leftSums[i] = leftSums[i-1] + machines[i-1];\\n        }\\n        for (int i = n - 2; i >= 0; i --) {\\n            rightSums[i] = rightSums[i+1] + machines[i+1];\\n        }\\n        int move = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int expLeft = i * avg;\\n            int expRight = (n - i - 1) * avg;\\n            int left = 0;\\n            int right = 0;\\n            if (expLeft > leftSums[i]) {\\n                left = expLeft - leftSums[i];\\n            } \\n            if (expRight > rightSums[i]) {\\n                right = expRight - rightSums[i];\\n            }\\n            move = Math.max(move, left + right);\\n        }\\n        return move;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```i```\n```[0...i-1]```\n```leftSums[i]```\n```[i+1...n-1]```\n```[0...i-1]```\n```expLeft```\n```[0...i-1]```\n```expLeft```\n```[i+1...n-1]```\n```expRight```\n```expLeft```\n```leftSums[i]```\n```expLeft - leftSums[i]```\n```i```\n```i```\n```i```\n```\\nleft = expLeft > leftSums[i] ? expLeft - leftSums[i] : 0;\\nright = expRight > rightSums[i] ? expRight - rightSums[i] : 0;\\ntotal = left + right;\\n```\n```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int sum = 0;\\n        for (int num : machines) {\\n            sum += num;\\n        }\\n        if (sum % n != 0) {\\n            return -1;\\n        }\\n        int avg = sum / n;\\n        int[] leftSums = new int[n];\\n        int[] rightSums = new int[n];\\n        for (int i = 1; i < n; i ++) {\\n            leftSums[i] = leftSums[i-1] + machines[i-1];\\n        }\\n        for (int i = n - 2; i >= 0; i --) {\\n            rightSums[i] = rightSums[i+1] + machines[i+1];\\n        }\\n        int move = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int expLeft = i * avg;\\n            int expRight = (n - i - 1) * avg;\\n            int left = 0;\\n            int right = 0;\\n            if (expLeft > leftSums[i]) {\\n                left = expLeft - leftSums[i];\\n            } \\n            if (expRight > rightSums[i]) {\\n                right = expRight - rightSums[i];\\n            }\\n            move = Math.max(move, left + right);\\n        }\\n        return move;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99185,
                "title": "super-short-easy-java-o-n-solution",
                "content": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0; \\n        for(int i: machines) total+=i;\\n        if(total%machines.length!=0) return -1;\\n        int avg = total/machines.length, cnt = 0, max = 0;\\n        for(int load: machines){\\n            cnt += load-avg; //load-avg is \"gain/lose\"\\n            max = Math.max(Math.max(max, Math.abs(cnt)), load-avg);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nLet me use an example to briefly explain this. For example, your machines[] is [0,0,11,5]. So your total is 16 and the target value for each machine is 4. Convert the machines array to a kind of gain/lose array, we get: [-4,-4,7,1]. Now what we want to do is go from the first one and try to make all of them 0.\\nTo make the 1st machines 0, you need to give all its \"load\" to the 2nd machines. \\nSo we get: [0,-8,7,1]\\nthen: [0,0,-1,1]\\nlastly: [0,0,0,0], done. \\nYou don't have to worry about the details about how these machines give load to each other. In this process, the least steps we need to eventually finish this process is determined by the peak of abs(cnt) and the max of \"gain/lose\" array. In this case, the peak of abs(cnt) is 8 and the max of gain/lose array is 7. So the result is 8.\\n\\n\\nSome other example:\\nmachines: [0,3,0]; gain/lose array: [-1,2,-1]; max = 2, cnt = 0, -1, 1, 0, its abs peak is 1. So result is 2. \\nmachines: [1,0,5]; gain/lose array: [-1,-2,3]; max = 3, cnt = 0, -1, -3, 0, its abs peak is 3. So result is 3.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0; \\n        for(int i: machines) total+=i;\\n        if(total%machines.length!=0) return -1;\\n        int avg = total/machines.length, cnt = 0, max = 0;\\n        for(int load: machines){\\n            cnt += load-avg; //load-avg is \"gain/lose\"\\n            max = Math.max(Math.max(max, Math.abs(cnt)), load-avg);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99181,
                "title": "c-16ms-o-n-solution-with-trivial-proof",
                "content": "First we check the sum of dresses in all machines. if that number cannot be divided by count of machines, there is no solution.\\n\\nOtherwise, we can always transfer a dress from one machine to another, one at a time until every machines reach the same number, so there must be a solution. In this way, the total actions is sum of operations on every machine.\\n\\nSince we can operate several machines at the same time, the minium number of moves is the maximum number of necessary operations on every machine.\\n\\nFor a single machine, necessary operations is to transfer dresses from one side to another until sum of both sides and itself reaches the average number. We can calculate (required dresses) - (contained dresses) of each side as L and R:\\n\\nL > 0 && R > 0: both sides lacks dresses, and we can only export one dress from current machines at a time, so result is abs(L) + abs(R)\\nL < 0 && R < 0: both sides contains too many dresses, and we can import dresses from both sides at the same time, so result is max(abs(L), abs(R))\\nL < 0 && R > 0 or L >0 && R < 0: the side with a larger absolute value will import/export its extra dresses from/to current machine or other side, so result is max(abs(L), abs(R))\\n\\nFor example, [1, 0, 5], average is 2\\nfor 1, L = 0 * 2 - 0 = 0, R = 2 * 2 - 5= -1, result = 1\\nfor 0, L = 1 * 2 - 1= 1, R = 1 * 2 - 5 = -3, result = 3\\nfor 5, L = 2 * 2 - 1= 3, R = 0 * 2 - 0= 0, result = 3\\nso minium moves is 3\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int len = machines.size();\\n        vector<int> sum(len + 1, 0);\\n        for (int i = 0; i < len; ++i)\\n            sum[i + 1] = sum[i] + machines[i];\\n\\n        if (sum[len] % len) return -1;\\n\\n        int avg = sum[len] / len;\\n        int res = 0;\\n        for (int i = 0; i < len; ++i)\\n        {\\n            int l = i * avg - sum[i];\\n            int r = (len - i - 1) * avg - (sum[len] - sum[i] - machines[i]);\\n\\n            if (l > 0 && r > 0)\\n                res = std::max(res, std::abs(l) + std::abs(r));\\n            else\\n                res = std::max(res, std::max(std::abs(l), std::abs(r)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int len = machines.size();\\n        vector<int> sum(len + 1, 0);\\n        for (int i = 0; i < len; ++i)\\n            sum[i + 1] = sum[i] + machines[i];\\n\\n        if (sum[len] % len) return -1;\\n\\n        int avg = sum[len] / len;\\n        int res = 0;\\n        for (int i = 0; i < len; ++i)\\n        {\\n            int l = i * avg - sum[i];\\n            int r = (len - i - 1) * avg - (sum[len] - sum[i] - machines[i]);\\n\\n            if (l > 0 && r > 0)\\n                res = std::max(res, std::abs(l) + std::abs(r));\\n            else\\n                res = std::max(res, std::max(std::abs(l), std::abs(r)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99187,
                "title": "java-c-python-o-1-space",
                "content": "## **Explanation**\\n`toRight` means the clothes that we need to pass to the right number.\\n\\n## **Time Complexity**:\\nTime `O(N)` for two passes\\nSpace `O(1)` for no extra space\\n\\n**Java:**\\n```java\\n    public int findMinMoves(int[] machines) {\\n        int total = 0, n = machines.length;\\n        for (int m : machines)\\n            total += m;\\n        if (total % n > 0) return -1;\\n        int target = total / n, res = 0, toRight = 0;\\n        for (int m : machines) {\\n            toRight = m + toRight - target;\\n            res = Math.max(res, Math.max(Math.abs(toRight), m - target));\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int findMinMoves(vector<int>& machines) {\\n        int total = 0, n = machines.size();\\n        for (int m : machines)\\n            total += m;\\n        if (total % n) return -1;\\n        int target = total / n, res = 0, toRight = 0;\\n        for (int m : machines) {\\n            toRight = m + toRight - target;\\n            res = max(res, max(abs(toRight), m - target));\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def findMinMoves(self, machines):\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, toRight = total / n, 0, 0\\n        for m in machines:\\n            toRight = m + toRight - target\\n            res = max(res, abs(toRight), m - target)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int findMinMoves(int[] machines) {\\n        int total = 0, n = machines.length;\\n        for (int m : machines)\\n            total += m;\\n        if (total % n > 0) return -1;\\n        int target = total / n, res = 0, toRight = 0;\\n        for (int m : machines) {\\n            toRight = m + toRight - target;\\n            res = Math.max(res, Math.max(Math.abs(toRight), m - target));\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int findMinMoves(vector<int>& machines) {\\n        int total = 0, n = machines.size();\\n        for (int m : machines)\\n            total += m;\\n        if (total % n) return -1;\\n        int target = total / n, res = 0, toRight = 0;\\n        for (int m : machines) {\\n            toRight = m + toRight - target;\\n            res = max(res, max(abs(toRight), m - target));\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def findMinMoves(self, machines):\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, toRight = total / n, 0, 0\\n        for m in machines:\\n            toRight = m + toRight - target\\n            res = max(res, abs(toRight), m - target)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 99188,
                "title": "java-o-n-dp-solution",
                "content": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0, target = 0, result = 0, n = machines.length;\\n        for (int d : machines) total += d;\\n        if (total == 0) return 0;\\n        if (total % n != 0) return -1;\\n        target = total / n;\\n        \\n        int[] move = new int[n];\\n        for (int i = 0; i < n - 1; i++) {\\n            if (machines[i] > target) {\\n                move[i] += machines[i] - target;\\n                machines[i + 1] += machines[i] - target;\\n                machines[i] = target;\\n                result = Math.max(result, move[i]);\\n            }\\n            else {\\n                move[i + 1] = target - machines[i];\\n                machines[i + 1] -= target - machines[i];\\n                machines[i] = target;\\n                result = Math.max(result, move[i + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0, target = 0, result = 0, n = machines.length;\\n        for (int d : machines) total += d;\\n        if (total == 0) return 0;\\n        if (total % n != 0) return -1;\\n        target = total / n;\\n        \\n        int[] move = new int[n];\\n        for (int i = 0; i < n - 1; i++) {\\n            if (machines[i] > target) {\\n                move[i] += machines[i] - target;\\n                machines[i + 1] += machines[i] - target;\\n                machines[i] = target;\\n                result = Math.max(result, move[i]);\\n            }\\n            else {\\n                move[i + 1] = target - machines[i];\\n                machines[i + 1] -= target - machines[i];\\n                machines[i] = target;\\n                result = Math.max(result, move[i + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654317,
                "title": "explanation-proof-of-why-the-solution-works",
                "content": "Although the official solution is indeed correct, it lacks reasonable explanation on the solution page and doesn\\'t show convictively why it works. Almost all the posts in discussion only give the code implementation and/or mere explanation of **how** the code processes the input rather than **why**. There are only 2 posts that point out it: [Formal-proof-of-the-solution](https://leetcode.com/problems/super-washing-machines/discuss/591578/Formal-proof-of-the-solution), and [Follow-up:-What-if-the-question-require-detailed-operation-for-each-step](https://leetcode.com/problems/super-washing-machines/discuss/216790/Follow-up%3A-What-if-the-question-require-detailed-operation-for-each-step). (Unfortunately, the proof in the former post is incorrect.)\\n\\nThe solution essentially only tells the lower bound of the total number of moves, without touching on the reachability of this lower bound at all. One could ask a follow-up question like \\'How do you go about a detailed movement procedure that costs the minimum possible number of moves?\\'. This post is going to give you the guarantee that this lower bound is in fact reachable for any input.\\n\\nLet\\'s make some assumptions first to ignore the trivial cases:\\n* Assume *n* >= 2, and *n* is a divisor of the total number of dresses (i.e. answer is not -1);\\n* Assume the list `machines` is already normalized by deducting `avg` to have an average of zero;\\n* Assume the values in `machines` are not all zeros (i.e. there exist at least one positive and one negative in `machines`).\\n\\nThere are totally *n*-1 demarcation lines that can split all the machines into two groups - group on the left and group on the right. We need a variable to denote these demarcation lines. Let `D` be a list of length *n*-1. `D[i]`(i=0, ..., n-2) represents the line that stands between `machines[i]` and `machines[i+1]` thus split all machines into two groups: `machines[0]`, ..., `machines[i]` on the left, and `machines[i+1]`, ..., `machines[n-1]` on the right hand. The value stored in `D[i]` stands for the number of essential transfer(s) that must take place across this line. If the transfer(s) need to be from left to right(i.e. from `D[i]` to `D[i+1]`), we make `D[i]` be positve; otherwise if the transfer(s) need to be from right to left(i.e. from `D[i+1]` to `D[i]`) we make `D[i]` be negative.  For example, for `machines` = [-4, -4, 7, 1], `D` = [-4, -8, -1]; for `machines` = [3, -2, -1], `D`= [3, 1].\\n<img src=\"https://assets.leetcode.com/users/xirenzhou/image_1590504865.png\" width=50% height=50%>\\n\\n\\nIt is easy to see that `max{abs(D)}` is the lower bound of the final answer. However this lower bound is not tight enough. For example, for `machines` = [-2, 5, -3], `D` = [-2, 3]. The minimum number of moves for this input is actually 5 rather than 3. The reason is that each machine can only pass at most one dress at each step.\\n\\nLet `M` = `max{abs(D), machines} = max{max{abs(D)}, max{machines}}`. We claim that `M` is the minimum number of moves, which is exactly what the official solution claims. The following part of the article is going to prove that the lower bound `M` is actually reachable for any valid input list `machines`.\\n\\nWe will conduct the proof by constructing a specific movement policy and showing that after each time step the updated `M` corresponding to the resulting `machines` list is one less than the former one. \\n\\nOne more notation: let `L[i]` denote the number of dresses that machine *i* need to pass to its left neighbor (can be negetive); and `R[i]` denote the number of dresses that machine *i* need to pass to its right neighbor. It is obvious that `L[i] = -D[i-1]` (i=1, ..., n-1); and `R[i] = D[i]` (i=0, ..., n-2).\\n\\n**We design the movement policy as below:**\\n```\\n# At each time step, do the following:\\nmachines_updated = machines.copy()\\nfor i in range(n):\\n\\tif machines[i] >= 0:\\n\\t\\tif i > 0 and L[i] > 0:\\n\\t\\t\\t# move one dress from machine i to machine i-1\\n\\t\\t\\tmachines_updated[i] -= 1\\n\\t\\t\\tmachines_updated[i-1] += 1\\n\\t\\telif i < n-1 and R[i] > 0:\\n\\t\\t\\t# move one dress from machine i to machine i+1\\n\\t\\t\\tmachines_updated[i] -= 1\\n\\t\\t\\tmachines_updated[i+1] += 1\\nmachines = machines_updated # used for the subsequent time step\\n```\\nAlthough the above procedure is written as a *for* loop, it represents all operations that we do at only one single time step. (i.e. all the operations inside the *for* loop can be performed simultaneously.)\\n\\nAnother thing to note is that we won\\'t come across the situation where there is not enough dress in the current machine to pass to its neighbor, because `machines[i]` >= 0 means machine i has at least `avg` dresses left, and for each machine we will move at most one dress out of it.\\n\\nThen we provide several lemmas which are helpful for the final proof.\\n\\n***Lemma 1.*** After each time step, for every 0 <= *i* <= n-2, the `D_updated[i]` (corresponding to `machines_updated`) is no more than its previous value `D[i]`. More precisely, `D_updated[i]` is either `D[i]` or `D[i]-1`.\\n(The proof of Lemma 1 is left to readers, which is fairly easy. Hint: for each demarcation line, there is at most one dress passed across this line at each time step.)\\n\\n***Lemma 2.*** If `machines[i] > 0`, at least one of `L[i]` and `R[i]` is positive.\\n\\nFollowing *Lemma 2*, it is easy to derive *lemma 3*:\\n***Lemma 3.*** For any `machines[i] >= 0`(i.e. if old value no less than `avg`), `machines_updated[i] <= machines[i]`, more precisely, `machines_updated[i]` is either `machines[i]` or `machines[i]-1`.\\n\\nThe above lemmas ensure that by following the above procedure, after each time step, `M_updated  = max{max{abs(D_updated)}, max{machines_updated}}` is no more than its previous value `M` (`M_updated` is either `M` or `M - 1`). Then we are going to show that `M_updated` is definitely equal to `M - 1`.\\n\\n***Lemma 4*** If there exists a machine i s.t. `machines[i] = M`, then both `L[i]` and `R[i]` is non-negative, and at least one of `L[i]` and `R[i]` is positive. \\n(*Lemma 4* can be easily proven by contradiction)\\n\\nDirectly following *Lemma 4*, we get the following corollary:\\n***Corollary 1*** After each time step, the value `max{machines}` decreases exactly by one (until reaches zero).\\n\\n***Lemma 5*** If `abs(D[i]) = max{abs(D)}`, let integer 0 <= `x` <= i, and integer i+1 <= `y` <= n-1, and `machines[x]` denote the nearest non-zero value to the lefthand of the demarcation line D[i] (i.e. `x` is the largest integer <= i s.t. `machines[x]` != 0), `machines[y]` denote the nearest non-zero value to the righthand of D[i] (i.e. `y` is the smallest integer >= i+1 s.t. `machines[y]` != 0), then `machines[x]` and `machines[y]` must be a combination of a positive and a negative (i.e. either `machines[x] > 0` and `machines[y] < 0`, or, `machines[x] < 0` and `machines[y] > 0`. Also, one could figure out that \\'`machines[x] > 0` and `machines[y] < 0`\\' corresponds to `D[i] > 0`; and that \\'`machines[x] < 0` and `machines[y] > 0`\\' corresponds to `D[i] < 0`).\\n(*Lemma 5* is easy to prove by contradiction: assume `machines[x]` and `machines[y]` are both positive/negative...)\\n\\n*Lemma 5* basically says that the demarcation line with the largest absolute transfer value lies between a positive-valued machine (# dresses > `avg`) and a negative-valued machine (# dresses < `avg`). There might be some zero-valued machines lying in between, but we will see that it won\\'t affect our analysis.\\n\\n\\n**Now let\\'s analyze any *i* s.t. `abs(D[i]) = max{abs(D)}`**. Without loss of generality, let\\'s assume `machines[x] > 0` and `machines[y] < 0`, as the below picture demonstrates.\\n<img src=\"https://assets.leetcode.com/users/xirenzhou/image_1590536031.png\" width=70% height=70%>\\nObviously, for any integer j s.t. x <= j <= y-1. D[x] = D[i] = D[y-1] = D[j].\\nLet\\'s divide the problem into different cases:\\n**i.** L[x] <= 0. \\nThat means `machines[x] <= abs(D[i]) = max(abs(D))`. In this case, we only care about D[i]. According to the earlier mentioned movement policy, after one time step `D[i]` will decrease by one, i.e. D_updated[i] = D[i] - 1.\\n\\n**ii.** L[x] > 0. \\nThat means `machines[x] > abs(D[i]) = max(abs(D))`. In such case, we don\\'t care about `D[i]` at all - whether it decreases or not does not affect the update for `M`.\\n\\nTogether with *Corollary 1*, we conclude that `M` will decrease by one for each time step (until it reaches zero) following our movement policy. And it is easy to recognize that if the current list `machines` is valid, the resulting updated `machines` list is also valid. Therefore, the minimum number of moves to balance all dresses is `M = max{max{abs(D)}, max{machines}}`.\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n# At each time step, do the following:\\nmachines_updated = machines.copy()\\nfor i in range(n):\\n\\tif machines[i] >= 0:\\n\\t\\tif i > 0 and L[i] > 0:\\n\\t\\t\\t# move one dress from machine i to machine i-1\\n\\t\\t\\tmachines_updated[i] -= 1\\n\\t\\t\\tmachines_updated[i-1] += 1\\n\\t\\telif i < n-1 and R[i] > 0:\\n\\t\\t\\t# move one dress from machine i to machine i+1\\n\\t\\t\\tmachines_updated[i] -= 1\\n\\t\\t\\tmachines_updated[i+1] += 1\\nmachines = machines_updated # used for the subsequent time step\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99203,
                "title": "c-12-ms-o-n-8-lines",
                "content": "First. we determine the target dresses we should have in each machine (total dresses / # of machines), and return -1 if it's not an integer.\\n\\nWe then go from left to right, tracking the running balance of dresses we need to move through each machine. If, for example, we have 5 extra dresses so far, and this machine has 2 extra dresses, we need to pass total 7 dresses through that machine (requires 7 steps). Also, we need to track the number of dresses we need to offload from a particular machine (machine[i] - target dresses). This number may be higher than the running balance if dresses are passed both ways, as shown in the example 2. \\n\\nExample 1: [1, 1, 6, 6, 1], total dresses: 15, target dresses: 3, maximum offload is 3 (6 - 3).\\nRunning balance:[-2][-4][ -1][  2][  0]\\nAnswer: max(3, abs(-4)) = 4.\\n\\nExample 2: [1, 1, 4, 8, 1], total dresses: 15, target dresses: 3, maximum offload is 5 (8 - 3).\\nRunning balance:[-2][-4][ -3][  2][  0]\\nAnswer: max(5, abs(-4)) = 5\\n\\n```\\nint findMinMoves(vector<int>& machines) {\\n    int totalDresses = 0, size = machines.size();\\n    for (auto i = 0; i < size; ++i) totalDresses += machines[i];\\n    if (totalDresses % size != 0) return -1;\\n    \\n    auto targetDresses = totalDresses / size, totalMoves = 0, ballance = 0;\\n    for (auto i = 0; i < size; ++i) {\\n        ballance += machines[i] - targetDresses;\\n        totalMoves = max(totalMoves, max(machines[i] - targetDresses, abs(ballance)));\\n    }\\n    return totalMoves;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findMinMoves(vector<int>& machines) {\\n    int totalDresses = 0, size = machines.size();\\n    for (auto i = 0; i < size; ++i) totalDresses += machines[i];\\n    if (totalDresses % size != 0) return -1;\\n    \\n    auto targetDresses = totalDresses / size, totalMoves = 0, ballance = 0;\\n    for (auto i = 0; i < size; ++i) {\\n        ballance += machines[i] - targetDresses;\\n        totalMoves = max(totalMoves, max(machines[i] - targetDresses, abs(ballance)));\\n    }\\n    return totalMoves;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304628,
                "title": "clearest-explanation",
                "content": "Look at the washing machine on the left. Does it have too many dresses or not enough?\\nNow look at the two washing machines on the left. Do these two machines have too many dresses or not enough?\\nRepeat for three washing machines, etc.\\n\\nFor example: `[1, 0, 5]` (average dresses per machine = 2)\\nLook at the washing machine on the left `[1]` and see that it needs 1 more dress.\\nLook at the two washing machines on the left `[1, 0]` and see that they need a total of 3 more dresses.\\n\\nSo we are taking the `[1, 0, 5]` and partitioning it into left and right parts like `[1, 0, \\u2194 5]` and asking how many dresses need to be added to the left or removed from the left. If we need to move 3 dresses, that requires 3 moves.\\n\\nThe only other case to handle is when a machine has too many dresses. If it has X too many dresses, then we need X moves.\\n\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum = 0;\\n        for (int i : machines)\\n            sum+=i;\\n        if (sum%machines.length!=0)return -1;\\n        int goal = sum/machines.length; // goal = average dresses per machine\\n        \\n        int res = 0, psum=0;\\n        for (int i = 0; i < machines.length; i++) {\\n\\t\\t    // psum is the partial sum of dresses in machines [0, i]\\n            psum+=machines[i];\\n\\t\\t\\t\\n\\t\\t\\t// the machines on the left (indexes [0,i]) have too many dresses or need more dresses\\n            res = Math.max(res, Math.abs(psum - (i+1)*goal));\\n\\t\\t\\t\\n\\t\\t\\t// machine [i] has X too many dresses\\n            res = Math.max(res, machines[i] - goal);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum = 0;\\n        for (int i : machines)\\n            sum+=i;\\n        if (sum%machines.length!=0)return -1;\\n        int goal = sum/machines.length; // goal = average dresses per machine\\n        \\n        int res = 0, psum=0;\\n        for (int i = 0; i < machines.length; i++) {\\n\\t\\t    // psum is the partial sum of dresses in machines [0, i]\\n            psum+=machines[i];\\n\\t\\t\\t\\n\\t\\t\\t// the machines on the left (indexes [0,i]) have too many dresses or need more dresses\\n            res = Math.max(res, Math.abs(psum - (i+1)*goal));\\n\\t\\t\\t\\n\\t\\t\\t// machine [i] has X too many dresses\\n            res = Math.max(res, machines[i] - goal);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227312,
                "title": "c-o-n-with-simple-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n\\t\\t// Calculate sum of total clothes to check whether they\\n\\t\\t// can be equally divided or not in \\'n\\' machines.\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\t\\n\\t\\t// Now, you\\'re assure your answer is present, so check for each machines \\n\\t\\t// requirement by sum/n.\\n\\t\\t\\n\\t\\t// Now for every machine check whether it has extra clothes to give or \\n\\t\\t// it want some clothes\\n\\t\\t// Ex: { 0,0,11,5 } req = 16/4 => 4\\n\\t\\t// { -4, -8, -1, 0 }\\n\\t\\t// Here absolute max of extra is 8 and so is the answer.\\n\\t\\t// Run on example {0,3,0} you will get better vision\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Hope this helps you : )**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n\\t\\t// Calculate sum of total clothes to check whether they\\n\\t\\t// can be equally divided or not in \\'n\\' machines.\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\t\\n\\t\\t// Now, you\\'re assure your answer is present, so check for each machines \\n\\t\\t// requirement by sum/n.\\n\\t\\t\\n\\t\\t// Now for every machine check whether it has extra clothes to give or \\n\\t\\t// it want some clothes\\n\\t\\t// Ex: { 0,0,11,5 } req = 16/4 => 4\\n\\t\\t// { -4, -8, -1, 0 }\\n\\t\\t// Here absolute max of extra is 8 and so is the answer.\\n\\t\\t// Run on example {0,3,0} you will get better vision\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566158,
                "title": "python-solution-o-n-time-o-1-space-comprehensive-explanation",
                "content": "Thanks to @Mrsuyi\\'s solution, I finnaly managed to work this problem out. This post is composed of 6 parts:\\n\\nA. Code\\n\\nB. Calculate `avg`\\n\\nC. Calculate Net Transitions (`ti`) between Machine `i ` and Machine `i+1`\\n\\nD. Calculate Minimal Moves (`Ti`) for Machine `i`\\n\\nE. Get the Answer\\n\\nF. Correctness Proof\\n\\n------------------------------------------------\\n\\n## A. Code\\n\\nOne pass is used to get the sum of machines and another pass is used to calculate the result. Apparently, it takes `O(n)` time and `O(1)` space.\\n\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        avg, t, tp, ans = total//n, 0, 0, 0\\n        for num in machines:\\n            t += num-avg\\n            T = tp+t if tp >= 0 and t >= 0 else max(abs(tp), abs(t))\\n            if T > ans: ans = T\\n            tp = -t\\n        return ans\\n```\\n\\n------------------------------------------------\\n\\n## B. Calculate `avg`\\n\\n`avg = mean(machines)`, if `avg` is not an integer, return -1. Otherwise, solution definitely exists.\\n\\n------------------------------------------------\\n\\n## C. Calculate Net Transitions (`ti`) between Machine `i ` and Machine `i+1`\\n\\nConsider **prefix sum of residuals** (`Li`) and **suffix sum of residuals** (`Ri`), which are respectively defined as follows:\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586158071.png)\\nApprarently, `Li + Ri = 0`.\\n\\n1. `Li >= 0`:\\n\\n   Machine `0` ~ machine `i` all together have `ti = Li` redundant dresses,\\n\\n   and machine `i+1` ~ machine `n-1` all together lack `ti` dresses. \\n\\n   Therefore there must be at least `ti` **net transitions** from machine `i` to machine `i+1`.\\n\\n   These transitions need `ti` moves to be finished.\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586158087.png)\\n\\n\\n2. `Li < 0`:\\n\\n   Machine `0` ~ machine `i` all together lack `ti = -Li` dresses,\\n\\n   and machine `i+1` ~ machine `n-1` all together have  `ti` redundant dresses. \\n\\n   Therefore, there must be at least `ti` **net transitions** from machine `i+1` to machine `i`.\\n\\n   These transitions need `ti` moves to be finished.\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586158093.png)\\n\\n------------------------------------------------\\n\\n## D. Calculate Minimal Moves (`Ti`) for Machine `i`\\n\\nFor example, all the **net transitions** between adjacent machines would look like this:\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586158099.png)\\nIn order to minimize the **number of moves**, transitions need to be as simultaneous as possible.\\n\\n1. For machines **giving dresses to both sides**, \\n\\n   since one machine can only pass one dress to either side at one move,\\n\\n   `t(i-1)` and `ti` can not be simultaneous.\\n\\n   Therefore, it takes at least `Ti = t(i-1) + ti` moves to finish the transitions.\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586159013.png)\\n\\n\\n2. For machines **receiving dresses from both sides** or **receiving from one side and give to another**,\\n\\n   `t(i-1)` and `ti` can be simultaneous.\\n\\n   Therefore, it takes at least `Ti = max(t(i-1), ti)` moves to finish the transitions.\\n![image](https://assets.leetcode.com/users/selim_pride/image_1586158105.png)\\n\\n------------------------------------------------\\n\\n## E. Get the Answer\\n\\nFinally, the minimal **number of moves** to make every machine have exactly `avg` dresses is calculated as: `T = max(Ti)` .\\n\\n------------------------------------------------\\n\\n## F. Correctness Proof\\n\\n\\n[*Feasibility*] **It\\'s obvious that the transitions above can indeed make every machine have exactly `avg` dresses.**\\n\\n**Proof**\\n\\n|       Case        |         Remnants after Transitions `t(i-1)` and `ti`         |\\n| :---------------: | :----------------------------------------------------------: |\\n|  Both-sides out   | `remnants[i] = machines[i] - t(i-1) - ti = machines[i] - (-L(i-1)) - Li = avg` |\\n|   Both-sides in   | `remnants[i] = machines[i] + t(i-1) + ti = machines[i] + L(i-1) + (-Li) = avg` |\\n| Left out Right in | `remnants[i] = machines[i] - t(i-1) + ti = machines[i] - (-L(i-1)) + (-Li) = avg` |\\n| Left in Right out | `remnants[i] = machines[i] + t(i-1) - ti = machines[i] + L(i-1) - Li = avg` |\\n\\n\\n[*Optimality*] **It\\'s impossible to make every machine have exactly `avg` dresses with less than `T` moves.**\\n\\n**Proof**\\n\\nSuppose `Tk = T` and after `T0 < T` moves, every machine have exactly `avg` dresses.\\n\\nSo, transitions `t(i-1)` and `ti` must have been finished.\\n\\nHowever, it takes at least `Tk > T0` moves to finish these two transitions, which is contradictory.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        avg, t, tp, ans = total//n, 0, 0, 0\\n        for num in machines:\\n            t += num-avg\\n            T = tp+t if tp >= 0 and t >= 0 else max(abs(tp), abs(t))\\n            if T > ans: ans = T\\n            tp = -t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369787,
                "title": "",
                "content": "\\u9996\\u5148\\u6C42\\u51FA\\u6700\\u7EC8\\u7684\\u76EE\\u6807target\\uFF0C\\u5982\\u679C\\u6CA1\\u6709\\u6700\\u7EC8\\u76EE\\u6807\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DE-1.\\n\\u5BF9\\u4E8E\\u6BCF\\u4E2A\\u6D17\\u8863\\u673A\\uFF0C\\u6211\\u4EEC\\u8BA1\\u7B97\\u4ED6\\u9700\\u8981\\u79FB\\u8D70\\u591A\\u5C11\\u8863\\u670D\\uFF08\\u8D1F\\u6570\\u8868\\u793A\\u4ED6\\u9700\\u8981\\u83B7\\u5F97\\u591A\\u5C11\\u8863\\u670D\\uFF09\\n\\u4ECE\\u4EFB\\u610F\\u4E00\\u8FB9\\u5F00\\u59CB\\u8BA1\\u7B97\\uFF0C\\u6BD4\\u5982\\u4ECE\\u5DE6\\u8FB9\\uFF1A\\n\\u7B2C\\u4E00\\u4E2A\\u6D17\\u8863\\u673A\\u5982\\u679C\\u79FB\\u8D70\\u4E86\\u8863\\u670D\\uFF0C\\u90A3\\u4E48\\u80AF\\u5B9A\\u79FB\\u7ED9\\u4E86\\u4ED6\\u53F3\\u8FB9\\u7684\\u6D17\\u8863\\u673A\\uFF0C\\u6240\\u4EE5\\u53F3\\u8FB9\\u7684\\u6D17\\u8863\\u673A\\u5728\\u904D\\u5386\\u65F6\\uFF0C\\u8981\\u52A0\\u4E0A\\u5DE6\\u8FB9\\u9700\\u8981\\u79FB\\u8D70\\u7684\\uFF1B\\u5982\\u679C\\u4E00\\u4E2A\\u6D17\\u8863\\u673A\\u9700\\u8981\\u79FB\\u6765\\u8863\\u670D\\uFF0C\\u4ED6\\u4E5F\\u662F\\u4ECE\\u53F3\\u8FB9\\u7684\\u6D17\\u8863\\u673A\\u83B7\\u5F97\\uFF0C\\u53F3\\u8FB9\\u7684\\u6D17\\u8863\\u673A\\u9700\\u8981\\u79FB\\u6765\\u7684\\u8863\\u670D\\u4E5F\\u662F\\u8981\\u52A0\\u4E0A\\u5DE6\\u8FB9\\u7684\\uFF0C\\u6545over\\u8FD9\\u4E2A\\u53D8\\u91CF\\u8981\\u4E00\\u76F4\\u52A0\\u4E0B\\u53BB\\u3002\\u800C\\u4E14\\uFF0C\\u4ED6\\u4E3A\\u8D1F\\u5C31\\u8868\\u793A\\u4ECE\\u53F3\\u8FB9\\u7D22\\u8981\\uFF0C\\u4ED6\\u4E3A\\u6B63\\uFF0C\\u8BF4\\u660E\\u5DE6\\u8FB9\\u6765\\u7684\\u5DF2\\u7ECF\\u8D85\\u51FA\\u4E86\\u9700\\u8981\\uFF0C\\u8F6C\\u79FB\\u7ED9\\u53F3\\u8FB9\\u3002\\n\\u5BF9\\u4E8E\\u4EFB\\u4F55\\u4E00\\u4E2A\\u6D17\\u8863\\u673A\\uFF0C\\u5982\\u679C\\u4ED6\\u9700\\u8981\\u79FB\\u8D70\\u7684\\u8863\\u670D\\u662F\\u6B63\\u6570\\uFF0C\\u6700\\u7EC8\\u79FB\\u52A8\\u7684\\u6570\\u91CF\\u80AF\\u5B9A\\u8981\\u5927\\u4E8E\\u8FD9\\u4E2A\\u6570\\uFF08\\u663E\\u7136\\uFF09\\uFF0C\\u5982\\u679C\\u662F\\u8D1F\\u6570\\uFF0C\\u5C31\\u4E0D\\u7528\\u5927\\u4E8E\\u4ED6\\u7684\\u7EDD\\u5BF9\\u503C\\u4E86\\uFF08\\u56E0\\u4E3A\\u53EF\\u4EE5\\u4ECE\\u4E24\\u8FB9\\u79FB\\u52A8\\u5230\\u8FD9\\u91CC\\uFF09\\u3002\\u800C\\u5BF9\\u4E8E\\u81EA\\u5DF1\\u672C\\u6765\\u5C31\\u6BD4\\u76EE\\u6807\\u5927\\u7684\\uFF0C\\u6700\\u7EC8\\u79FB\\u52A8\\u7684\\u6B21\\u6570\\u4E00\\u5B9A\\u5927\\u4E8E\\u81EA\\u5DF1\\u8863\\u670D\\u51CF\\u53BB\\u76EE\\u6807\\u6570\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u7BA1\\u662F\\u5DE6\\u8FB9\\u9700\\u8981\\uFF0C\\u8FD8\\u662F\\u53F3\\u8FB9\\u9700\\u8981\\uFF0C\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u6D17\\u8863\\u673A\\uFF0C\\u6BCF\\u6B21\\u90FD\\u6700\\u591A\\u53EA\\u80FD\\u51FA\\u4E00\\u4E2A\\u3002\\u8FD9\\u4E2A\\u6700\\u7EC8\\u79FB\\u52A8\\u7684\\u4E0B\\u754C\\u5C31\\u662F\\u7B54\\u6848\\uFF08\\u4ED6\\u5B58\\u5728\\u5417\\uFF1F\\u5B58\\u5728\\uFF0C\\u53EA\\u8981\\u6309\\u7167\\u6211\\u4EEC\\u904D\\u5386\\u7684\\u987A\\u5E8F\\u53BB\\u505A\\uFF0C\\u6309\\u7167over\\u6307\\u793A\\u7684\\u53BB\\u505A\\u5C31\\u53EF\\u4EE5\\u8FBE\\u5230\\uFF09\\n\\u6709\\u70B9\\u50CF\\u4E4B\\u524D\\u4E8C\\u53C9\\u6811\\u4E0A\\u9762\\u53BB\\u5206\\u644A\\u5747\\u5300\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u9898\\u53F7\\u4E0D\\u8BB0\\u5F97\\u4E86\\u3002\\n```c++\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % machines.size() != 0) return -1;\\n        int target = total / machines.size();\\n        int over = 0;\\n        int res = 0;\\n        for (auto m : machines) {\\n            over = over + m - target;\\n            res = max(res, max(abs(over), m - target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % machines.size() != 0) return -1;\\n        int target = total / machines.size();\\n        int over = 0;\\n        int res = 0;\\n        for (auto m : machines) {\\n            over = over + m - target;\\n            res = max(res, max(abs(over), m - target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383342,
                "title": "c-o-n-time-o-1-space-with-detailed-explanation",
                "content": "See more code in my repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n---\\n\\nLet `total` be the total number of dresses in the machines. It\\'s obvious that the problem is solvable if `total` is divisible by `N`.\\n\\nLet `avg = total / N`, which is the target number for all the machines.\\n\\nLet `diff[i] = machines[i] - avg`.\\n\\nNow consider we separate the machines into two parts.\\n\\n```\\n[ left part ] | [ right part ]\\n```\\n\\nThe `diff` must satisfy the following equation for any `0 <= k < N` so as to reach balance.\\n\\n```\\nsum{ diff[i] | 0 <= i < k } = -sum{ diff[i] | k <= i < N }\\n```\\n\\nThe minimum number of moves must be at least euqal to `| sum{ diff[i] | 0 <= i < k } |`.\\n\\nLet `sum(k) = sum{ diff[i] | 0 <= i < k }`, we know the answer is at least `| sum(k) |` for any `0 <= k < N`.\\n\\nIn other words, the answer is at least `max{ |sum(i)| | 0 <= i < N }`.\\n\\nIs there any other situations to consider?\\n\\nYes, what if the `| diff |` is greater than `| sum |`?\\n\\nFor example, assume `diff = [-3, 5]`, we have `sum = [-3, 2]` and thus `| sum | = [3, 2]`. But `max(|sum|) = 3` is not enough because `max(|diff|) = 5`. We at least need 5 moves to reach balance.\\n\\nThen we should consider `max(|diff|)` ? Not really. We only need to consider `max(diff)`.\\n\\nWhy doesn\\'t `diff` matters when it\\'s negative?\\n\\nBecause it can add `2` in a single move. For example, for input `[3, 0, 3]`, `diff = [1, -2, 1]`, we can balance the machine in the middle in only one move.\\n\\nIn sum, the minimum number of moves is `max( max(|sum|), max(diff) )`.\\n\\nNow let\\'s consider some examples:\\n\\ninput | 1 | 0 | 5\\n---|---|---|---\\ndiff | -1 | -2 | 3\\nsum | -1 | -3 | 0\\n\\nSo `max(diff) = 3, max(|sum|) = 3`, the result is `3`.\\n\\ninput | 0 | 3 | 0\\n---|---|---|---\\ndiff | -1 | 2 | -1\\nsum | -1 | 1 | 0\\n\\nSo `max(diff) = 2, max(|sum|) = 1`, the result is `2`.\\n\\ninput | 0 | 0 | 3 | 5\\n---|---|---|---|---\\ndiff | -2|-2|1|3\\nsum | -2|-4|-3|0\\n\\nSo `max(diff) = 3, max(|sum|) = 4`, the result is `4`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/super-washing-machines/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/super-washing-machines/solution/\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int N = machines.size(), total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % N) return -1;\\n        int avg = total / N, sum = 0, maxAbsSum = 0, maxDiff = 0;\\n        for (int n : machines) {\\n            int diff = n - avg;\\n            maxDiff = max(maxDiff, diff);\\n            sum += diff;\\n            maxAbsSum = max(maxAbsSum, abs(sum));\\n        }\\n        return max(maxAbsSum, maxDiff);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[ left part ] | [ right part ]\\n```\n```\\nsum{ diff[i] | 0 <= i < k } = -sum{ diff[i] | k <= i < N }\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/super-washing-machines/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/super-washing-machines/solution/\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int N = machines.size(), total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % N) return -1;\\n        int avg = total / N, sum = 0, maxAbsSum = 0, maxDiff = 0;\\n        for (int n : machines) {\\n            int diff = n - avg;\\n            maxDiff = max(maxDiff, diff);\\n            sum += diff;\\n            maxAbsSum = max(maxAbsSum, abs(sum));\\n        }\\n        return max(maxAbsSum, maxDiff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367678,
                "title": "python-3-4-lines-w-explanation-t-m-100-97",
                "content": "Here\\'s the plan:\\n1. We can arrive at the final state `arr = [n,n,n..,n]` (where`n`is the average of the elements of`machine`) if and only if`n*len(arr) == sum(machines)`). If not, we return -1. \\n2. If so, we revise the problem to a simpler, equivalent probem by decrementing each element in`machines`by`n`, which means the final state we seek becomes`arr = [0,0,0..,0]`. Now, one of two conditions will determine the minimum number of moves.  \\n3. The first condition is to determine `max(machines)`. (Think about how many dresses must be removed from this machine to empty the machine, one per move.)\\n4. The second condtion is the greatest absolute value of any element of the prefix sum of`machines`. The number of moves to the right or left must exceed or equal num or -num, respectively. (Think about how many dresses must pass through this machine, one per move.)\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))    # <\\u2013 1.\\n        if rem: return -1                                 #\\n        \\n        machines = [m - ave for m in machines]            # <\\u2013 2.\\n\\n        return max(max(machines),                         # <\\u2013 3.\\n                   max(map(abs,(accumulate(machines)))))  # <\\u2013 4.\\n```\\n[https://leetcode.com/problems/super-washing-machines/submissions/926204715/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))    # <\\u2013 1.\\n        if rem: return -1                                 #\\n        \\n        machines = [m - ave for m in machines]            # <\\u2013 2.\\n\\n        return max(max(machines),                         # <\\u2013 3.\\n                   max(map(abs,(accumulate(machines)))))  # <\\u2013 4.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502437,
                "title": "c-8ms-o-n-short-easy-understanding-solution",
                "content": "- step1. It is easy to turn the origin array into the gain/lose array by decreasing the avg for each element.\\n  eg. origin array is [4, 12, 4, 4] -> gain/lose array [-2, 6, -2, -2]\\n- step2. `Then if we observe this gain/lose array from left to right, we can notice that the number of dresses passing to (or taking from) the right adjacent machine is fixed. `\\n   (Consider the left most machine (with value gain/lose -2), in order to reduce its gain/lose value into 0, it has to take 2 dresses from its right. Then the second machine also also can only pass its dresses to right, in which the situation reduces into to the left most one.)\\n  eg. gain/lose array is  [-2, 6, -2, -2] -> sum array is [-2, 4, 2, 0] -> passing/taking array is [(2 <-), (4 ->), (2 ->), (0 -)]\\n  \\n- step3. Obviously, the answer is no less than each element in the passing/taking array. Also the answer must be no less than the largest element in the gain/lose array. \\n\\n- code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for (auto t : machines) sum += t;\\n        if (sum % machines.size() != 0) return -1;\\n        \\n        int middle = sum / machines.size();\\n        int ans = 0;\\n        sum = 0;\\n        for (int i=0; i<machines.size(); ++i) {\\n            auto diff = machines[i] - middle;\\n            if (diff > 0) ans = max(ans, diff);\\n            sum += diff;\\n            ans = max(ans, abs(sum));\\n        }\\n        return ans;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for (auto t : machines) sum += t;\\n        if (sum % machines.size() != 0) return -1;\\n        \\n        int middle = sum / machines.size();\\n        int ans = 0;\\n        sum = 0;\\n        for (int i=0; i<machines.size(); ++i) {\\n            auto diff = machines[i] - middle;\\n            if (diff > 0) ans = max(ans, diff);\\n            sum += diff;\\n            ans = max(ans, abs(sum));\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237890,
                "title": "python-linear-scan-from-left-to-right-with-dp-o-n",
                "content": "*  For each machines, the number of moves it conducts is the number of dresses it sends out.\\n*  Start scanning from left\\n\\t*  if it has >target dresses, send the surplus to right\\n\\t*  if it has <targer dresses, let its right neighbor send the deficit to it (regardless of how many dresses this neighbor has at the momnet)\\n\\t*  Don\\'t worry about the aggregated surplus or deficit, it eventually will be taken care by later machines.\\n\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: \\'List[int]\\') -> \\'int\\':\\n        N = len(machines)\\n        D = sum(machines)\\n        if D % N != 0:\\n            return -1\\n        \\n        target = D // N\\n        ans = 0\\n        send_out = [0] * N\\n        for i in range(N-1):\\n            if machines[i] > target:\\n                send_out[i] += machines[i] - target\\n            elif machines[i] < target:\\n                send_out[i+1] = target - machines[i]\\n            machines[i+1] += machines[i] - target\\n            ans = max(ans, send_out[i], send_out[i+1])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: \\'List[int]\\') -> \\'int\\':\\n        N = len(machines)\\n        D = sum(machines)\\n        if D % N != 0:\\n            return -1\\n        \\n        target = D // N\\n        ans = 0\\n        send_out = [0] * N\\n        for i in range(N-1):\\n            if machines[i] > target:\\n                send_out[i] += machines[i] - target\\n            elif machines[i] < target:\\n                send_out[i+1] = target - machines[i]\\n            machines[i+1] += machines[i] - target\\n            ans = max(ans, send_out[i], send_out[i+1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616037,
                "title": "c-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& v) {\\n        int sum = 0, n = v.size();\\n        for(auto &i: v)sum += i;\\n        if(sum%n)return -1;\\n        sum /= n;\\n        int k = 0;\\n        int ans = 0;\\n        for(auto &i: v){\\n            k += i-sum;\\n            ans = max({(i-sum),ans,abs(k)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& v) {\\n        int sum = 0, n = v.size();\\n        for(auto &i: v)sum += i;\\n        if(sum%n)return -1;\\n        sum /= n;\\n        int k = 0;\\n        int ans = 0;\\n        for(auto &i: v){\\n            k += i-sum;\\n            ans = max({(i-sum),ans,abs(k)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367563,
                "title": "python-3-4-lines-w-map-accumulate-t-m-99-6",
                "content": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))\\n        if rem: return -1\\n        \\n        machines = [m - ave for m in machines]\\n\\n        return max(*machines,*map(abs,(accumulate(machines))))\\n```\\n[https://leetcode.com/problems/super-washing-machines/submissions/926167284/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))\\n        if rem: return -1\\n        \\n        machines = [m - ave for m in machines]\\n\\n        return max(*machines,*map(abs,(accumulate(machines))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289130,
                "title": "517-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Get the length of the list \\'machines\\' and the sum of all the dresses.\\n2. Check if the total number of dresses is evenly divisible by the number of machines. If not, it is not possible to make all the machines have the same number of dresses, return -1.\\n3. Calculate the target number of dresses that each machine should have.\\n4. Initialize \\'moves\\' and \\'dresses_so_far\\' to 0.\\n5. Iterate through the machines.\\n6. Calculate the difference between the current number of dresses in the machine and the target number of dresses.\\n7. Add this difference to \\'dresses_so_far\\'.\\n8. Calculate the maximum value of abs(dresses_so_far), which indicates the maximum number of dresses that needs to be moved in a single move.\\n9. Calculate the maximum value of (machines[i] - target_dresses), which indicates the maximum number of dresses that needs to be moved from this machine.\\n10. Take the maximum of the above two values and update \\'moves\\'.\\n11. Return \\'moves\\'.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        n = len(machines)\\n        total_dresses = sum(machines)\\n        \\n        if total_dresses % n != 0:\\n            return -1\\n        \\n        target_dresses = total_dresses // n\\n        moves = 0\\n        dresses_so_far = 0\\n        \\n        for i in range(n):\\n            dresses_so_far += machines[i] - target_dresses\\n            # The maximum value of abs(dresses_so_far) indicates the \\n            # maximum number of dresses that needs to be moved in a single move\\n            moves = max(moves, abs(dresses_so_far), machines[i] - target_dresses)\\n        \\n        return moves\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        n = len(machines)\\n        total_dresses = sum(machines)\\n        \\n        if total_dresses % n != 0:\\n            return -1\\n        \\n        target_dresses = total_dresses // n\\n        moves = 0\\n        dresses_so_far = 0\\n        \\n        for i in range(n):\\n            dresses_so_far += machines[i] - target_dresses\\n            # The maximum value of abs(dresses_so_far) indicates the \\n            # maximum number of dresses that needs to be moved in a single move\\n            moves = max(moves, abs(dresses_so_far), machines[i] - target_dresses)\\n        \\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494249,
                "title": "c-517-super-washing-machines",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int total = accumulate(machines.begin(), machines.end(), 0); \\n        if (total % machines.size()) return -1; // impossible\\n\\n        int avg = total / machines.size(), ans = 0, prefix = 0; \\n        for (auto& x : machines) {\\n            ans = max({ans, abs(prefix), x - avg}); \\n            prefix += x - avg; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int total = accumulate(machines.begin(), machines.end(), 0); \\n        if (total % machines.size()) return -1; // impossible\\n\\n        int avg = total / machines.size(), ans = 0, prefix = 0; \\n        for (auto& x : machines) {\\n            ans = max({ans, abs(prefix), x - avg}); \\n            prefix += x - avg; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255190,
                "title": "python-solution-with-explanatioin",
                "content": "* we could choose any m machines at each step, and those k machines do not have to be connected. For example, supose we have [4,0,0,4], we could choose the first and the fourth machine at one step.\\n* The sum of all dresses must be divisible by the nunber of machines(even = sum(machines)/len(machines)), otherwise we can return -1\\n* First key point: if abs(machines[i]-even) == k, we need at least k steps to make machines[i] == k\\n* Second key point: if abs(machines[i]-even) == p(p>0), abs(machines[i+1]-even) == q(q<0), then we need at least max(p, -q) steps to make machines[i] == even and machines[i+1] == even\\n\\nclass Solution:\\n\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total/len(machines) != round(total/len(machines)):\\n            return -1\\n        even = int(total/len(machines))\\n        ans = diff = 0\\n        for i in range(len(machines)):\\n            diff += machines[i]-even\\n            ans = max(ans, abs(diff))\\n            ans = max(ans, machines[i]-even)\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "* we could choose any m machines at each step, and those k machines do not have to be connected. For example, supose we have [4,0,0,4], we could choose the first and the fourth machine at one step.\\n* The sum of all dresses must be divisible by the nunber of machines(even = sum(machines)/len(machines)), otherwise we can return -1\\n* First key point: if abs(machines[i]-even) == k, we need at least k steps to make machines[i] == k\\n* Second key point: if abs(machines[i]-even) == p(p>0), abs(machines[i+1]-even) == q(q<0), then we need at least max(p, -q) steps to make machines[i] == even and machines[i+1] == even\\n\\nclass Solution:\\n\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total/len(machines) != round(total/len(machines)):\\n            return -1\\n        even = int(total/len(machines))\\n        ans = diff = 0\\n        for i in range(len(machines)):\\n            diff += machines[i]-even\\n            ans = max(ans, abs(diff))\\n            ans = max(ans, machines[i]-even)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 368475,
                "title": "o-n-runtime-o-1-extra-memory-solution-with-breakdown-of-cases",
                "content": "I thought of this problem entirely as \"deltas\" from a machine\\'s starting state to it\\'s desired final state. For example, a machine starting with 50 dresses with an overall target of 20 has a delta of 30. Thinking of the problem in this way reveals two possible cases for an answer:\\n1. There exists some single machine who \"bottlenecks\" the entire problem by having a delta that \"dominates\" the entire problem. (\\n\\t- e.g. `[1000,0,0,0]` in this cases the deltas are `[750, -250, -250, -250]` and the answer is therefore `750`)\\n2. There exists some group of machines who\\'s assumulated delta \"dominates\" the problem, but no single machine dominates. In this case, that accumulate delta will need to travel through a \"bottle neck\" machine to the other side where the accumulate delta is exactly negative of the dominating side.\\n\\t- e.g. `[150, 150, 150, 150, 100, 0, 0]`  in this case the target is `100`, and therefore the deltas are `[50, 50, 50, 50, 0, -100, -100]`. We can find the bottleneck by finding the largest absolute accumulated delta `= [50, 100, 150, 200, 200, 100, 0]`, implicitly we know that the \"100\" matchine is the bottleneck, but that\\'s not necessary to know to find the answer. We can just take the biggest absolute running delta - therefore the answer is `200`.\\n\\t- Note that if we apply the first approach to this example, the answer would be `100` because there is no one \"source\" or \"sink\" machine we\\'re waiting on. We\\'re waiting on the bottleneck \"tunnel\" machine that splits the problem in two and makes it slow.\\n\\nSolution 2 happens to solve my first example problem as well, but there are some cases where it does not. e.g. for deltas `[-5, 25, -20, -10, 0, 10, 20, -20]` in this case the accumulated deltas are `[-5, 20, 0, -10, -10, 0, 20, 0]`, and the max accumulated delta would be `20`, but the answer is `25` because the machine `25` will first distribute 5 of its dressed to the left machine (in 5 turns) and then 20 of its dresses to the right (in 20 turns). Taking the subset sum doesn\\'t take into account when a single machine needs to distribute dressed both to its left and its right (it can\\'t do so in parallel. If this problem allowed a single machine to distribute both to its left and right in one turn, you would not need to consider the first case I wrote).\\n\\nWe don\\'t need to explicitly determine which of these two cases a particular answer falls under, we can just take the max of these two approaches to find the answer -- absolute delta for one machine, and accumulate delta for multiple machines.\\n\\n```c++\\nclass Solution {\\npublic:\\n  int findMinMoves(vector<int> &machines) {\\n    int maxBucket = 0;\\n    int sum = 0;\\n    int runningSum = 0;\\n    for (int val : machines) {\\n      sum += val;\\n      maxBucket = max(maxBucket, val);\\n    }\\n    if (sum % machines.size())\\n      return -1;\\n    sum /= machines.size();\\n    int maxBucketSpill = abs(sum - maxBucket);\\n\\n    int runningDelta = 0;\\n    int biggestRunningDelta = 0;\\n    for (int val : machines) {\\n      int delta = val - sum;\\n      runningDelta += delta;\\n      biggestRunningDelta = max(biggestRunningDelta, abs(runningDelta));\\n    }\\n    return max(maxBucketSpill, biggestRunningDelta);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n  int findMinMoves(vector<int> &machines) {\\n    int maxBucket = 0;\\n    int sum = 0;\\n    int runningSum = 0;\\n    for (int val : machines) {\\n      sum += val;\\n      maxBucket = max(maxBucket, val);\\n    }\\n    if (sum % machines.size())\\n      return -1;\\n    sum /= machines.size();\\n    int maxBucketSpill = abs(sum - maxBucket);\\n\\n    int runningDelta = 0;\\n    int biggestRunningDelta = 0;\\n    for (int val : machines) {\\n      int delta = val - sum;\\n      runningDelta += delta;\\n      biggestRunningDelta = max(biggestRunningDelta, abs(runningDelta));\\n    }\\n    return max(maxBucketSpill, biggestRunningDelta);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494245,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total % len(machines): return -1 # impossible \\n        avg = total // len(machines)\\n        \\n        ans = prefix = 0\\n        for i, x in enumerate(machines): \\n            ans = max(ans, abs(prefix), x - avg)\\n            prefix += x - avg\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total % len(machines): return -1 # impossible \\n        avg = total // len(machines)\\n        \\n        ans = prefix = 0\\n        for i, x in enumerate(machines): \\n            ans = max(ans, abs(prefix), x - avg)\\n            prefix += x - avg\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082178,
                "title": "java-solution-100-faster",
                "content": "```\\n\\tpublic int findMinMoves(int[] machines) {\\n        int extra = 0;\\n        int maxMoves = 0;\\n        int totalClothes = 0;\\n        \\n        for(int i=0;i<machines.length; i++){\\n            totalClothes += machines[i];\\n        }\\n        \\n        int n=machines.length;\\n        if(totalClothes%n != 0){\\n            return -1;\\n        }\\n        \\n        int partition = totalClothes/n;\\n        for(int i=0; i<machines.length; i++){\\n            int delta = machines[i]-partition;\\n            extra+=delta;\\n            maxMoves = Math.max(Math.max(maxMoves, delta), Math.abs(extra));\\n        }\\n        \\n        return maxMoves;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int findMinMoves(int[] machines) {\\n        int extra = 0;\\n        int maxMoves = 0;\\n        int totalClothes = 0;\\n        \\n        for(int i=0;i<machines.length; i++){\\n            totalClothes += machines[i];\\n        }\\n        \\n        int n=machines.length;\\n        if(totalClothes%n != 0){\\n            return -1;\\n        }\\n        \\n        int partition = totalClothes/n;\\n        for(int i=0; i<machines.length; i++){\\n            int delta = machines[i]-partition;\\n            extra+=delta;\\n            maxMoves = Math.max(Math.max(maxMoves, delta), Math.abs(extra));\\n        }\\n        \\n        return maxMoves;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918863,
                "title": "how-to-understand-the-keypoint",
                "content": "The keypoint is that the least steps to eventually finish this process is the max of `accumulated gain/lose` and `gain` array.\\nBut how to understand this?\\n\\nCondition 1. Why the least steps maybe max `gain`?\\n\\tSince we could only remove one dress at the same time at most, so we need at least `gain = (n_dresses - average)` steps to make one machine back to average.\\n\\tIf we miss condition1, we will miss some cases such like [0,3,0], we need two steps to make 3 back to the average(it\\'s 1 in this case).\\n\\nCondition 2. Why the least steps maybe max of `accumulated gain/lose`?\\n\\tHowever, if we only focus on condition1, we will miss some case such like [3,3,0] -- the max of gain is 1, but we need at least two steps obviously.\\n\\nTo solve condition2, we must think it abstractly:\\nWe could consider one subarray as concat of three subarray : `gain`, `average`, `lose`. The `gain` part subarray have dress more than average; the `average` part have average dresses, The `lose` part have dresses less than average. No matter how long average is, we could move one and only one dress from `gain` part to `lose` part every step. So we need `accumulated gain/lose` steps to make it balanced.\\n\\nHere is my code:\\n```py\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        sum_clothes = sum(machines)\\n        if sum_clothes % len(machines) != 0:\\n            return -1\\n\\n        average = sum_clothes // len(machines)\\n        res = 0\\n\\n        curr = 0\\n        for num in machines:\\n            delta = num - average\\n            curr += delta\\n\\n            res = max(res, curr, delta)\\n\\n        curr = 0\\n        for num in machines[::-1]:\\n            delta = num - average\\n            curr += delta\\n\\n            res = max(res, curr, delta)\\n\\n        return res\\n\\n```\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        sum_clothes = sum(machines)\\n        if sum_clothes % len(machines) != 0:\\n            return -1\\n\\n        average = sum_clothes // len(machines)\\n        res = 0\\n\\n        curr = 0\\n        for num in machines:\\n            delta = num - average\\n            curr += delta\\n\\n            res = max(res, curr, delta)\\n\\n        curr = 0\\n        for num in machines[::-1]:\\n            delta = num - average\\n            curr += delta\\n\\n            res = max(res, curr, delta)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701881,
                "title": "cpp-solution",
                "content": "// Runtime: 20 ms, faster than 71.67% of C++ online submissions for Super Washing Machines.\\n// Memory Usage: 13.1 MB, less than 55.48% of C++ online submissions for Super Washing Machines.\\n```\\nclass Solution {\\n    //goal is to have avg number of element at every i\\n    //if every machine j is achieving avg from one machine i then max will be machine[i] - avg\\n    //cases can be max pass to reuire to give and achieve avg or max pass require to take and achieve avg and third case is when we need to pass to others and take for ourselves too\\n    //eg [4,12,4,4] --> [6,6,6,6] from 12 so max will be 12 - 6 = 6\\n    //otherwise eg [0,4,5] --> [3,3,3] 0 requires 3 movements then 4 requires 1 movement but this movement is already added in 0\\'s movement and will be cancelled total movemnts will be -3 + 1 which will be two now while 5 will require 2 movements but it will move while 0 was taking total becomes -3 + 1 + 2 = 0 so we need to record just the peak movement and it will cover the least movement\\n    //[0,0,11,5] --> [4,4,4,4] index 1 requires 8 to have 4 and pass 4 \\n    \\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int i, sum = 0;\\n        int n = machines.size();\\n        for(i = 0; i < n; i++) sum += machines[i];\\n        if(sum % n != 0) return -1;\\n        int avg = sum / n;\\n        int total = 0;\\n        int needCount = 0;\\n         for(i = 0; i < n ; i++){\\n            needCount += (machines[i] - avg);//it will cancel pass and take  at the end so any point can be peak point\\n            total = max(max(abs(needCount), machines[i]-avg), total);// recording the peak point\\n        }\\n        return total;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    //goal is to have avg number of element at every i\\n    //if every machine j is achieving avg from one machine i then max will be machine[i] - avg\\n    //cases can be max pass to reuire to give and achieve avg or max pass require to take and achieve avg and third case is when we need to pass to others and take for ourselves too\\n    //eg [4,12,4,4] --> [6,6,6,6] from 12 so max will be 12 - 6 = 6\\n    //otherwise eg [0,4,5] --> [3,3,3] 0 requires 3 movements then 4 requires 1 movement but this movement is already added in 0\\'s movement and will be cancelled total movemnts will be -3 + 1 which will be two now while 5 will require 2 movements but it will move while 0 was taking total becomes -3 + 1 + 2 = 0 so we need to record just the peak movement and it will cover the least movement\\n    //[0,0,11,5] --> [4,4,4,4] index 1 requires 8 to have 4 and pass 4 \\n    \\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int i, sum = 0;\\n        int n = machines.size();\\n        for(i = 0; i < n; i++) sum += machines[i];\\n        if(sum % n != 0) return -1;\\n        int avg = sum / n;\\n        int total = 0;\\n        int needCount = 0;\\n         for(i = 0; i < n ; i++){\\n            needCount += (machines[i] - avg);//it will cancel pass and take  at the end so any point can be peak point\\n            total = max(max(abs(needCount), machines[i]-avg), total);// recording the peak point\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 679301,
                "title": "python-solution-in-o-n-time-and-o-1-space",
                "content": "This solution uses simple idea. We don\\'t need to care about how the clothes move in each step, but to reach the ideal state, every machine should have same amount of clothes. Thus for the machines with *N_i* clothes, it must **at least** move *abs(N_i - average)* steps. In another case, if we treat a group of machines together and calculate its total number of clothes, let\\'s say, we count *m* machines, and the total clothes is *C*, then for this group, it needs to move in/out *abs(C - m\\\\*average)* clothes.\\nThus we track three variables in one pass: *r* is the final result, *d* is the value for case I, and *diff* is the value for case II. We always track the maximum value.\\n\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        if (total := sum(machines)) % len(machines) != 0:\\n            return -1\\n        avr = total // len(machines)\\n        r, diff = 0, 0\\n        for m in machines:\\n            diff += (d := m - avr)\\n            r = max(r, abs(diff), d)\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        if (total := sum(machines)) % len(machines) != 0:\\n            return -1\\n        avr = total // len(machines)\\n        r, diff = 0, 0\\n        for m in machines:\\n            diff += (d := m - avr)\\n            r = max(r, abs(diff), d)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602541,
                "title": "java-o-n-solution-2ms-time-complete-explaination-with-example",
                "content": "Find the clothes needed to be passed from each machine towards the left and towards the right of it. As the clothes will be passed from the machines having greater number of clothes than required, so we can find clothes for only the machines that are having greater number of clothes :\\n1) ***leftneed*** (clothes that will be passed from this machine to the machines lying on left side of it)  \\n2) ***rightneed*** ( clothes that will be passed from this machine to the machine lying on the right side of it)\\n3) As in one turn from any machine only 1 cloth can be passed, so total number of clothes that will be passed will be ***(leftneed+rightneed)*** , hence these many moves will be required from this machine ,as at once either the cloth will be passed to the left side or to the right side.\\n4) So find the maximum moves that are required from any machine , and that will be the required answer.\\nNow to find the leftneed and rightneed:\\nSuppose I have machines array as : \\n[3,9,1,6,7,4]\\nCheck if its possible to divide the clothes in all machines equally: \\n*Total*= 3+9+1+6+7+4=30 , *numberofmachines* = 6, and *Total%numberofmachines* is 0, hence it is possible.\\nNow finding the prefixsum array and the suffixsum array to find the number of clothes that are present on left side and right side of any machine.\\n*prefixsum[]= [3,12,13,19,26,30]\\nsuffixsum[]= [30,27,18,17,11,4]*\\nso each machine must have , *sum = 30/6 = 5* clothes\\nNow for the machines havinf clothes greater than 5, we will find the clothes that will be passed to the leftside and to the rightside.\\n*leftneed[i]= Math.max((isum)-prefixsum[i-1],0)*\\n*rightneed[i]= Math.max((numberofmachines-i-1)sum - suffixsum[i+1],0)*\\ni=1: leftneed=2 , rightneed= 2 , leftneed+rightneed= 4\\ni=3: leftneed=2 , rightneed= 0 , leftneed+rightneed=2\\ni=4: leftneed=1,  rightneed= 1 , leftneed+rightneed=2\\nSo, **Maxmoves= max(4,2,2) = 4**\\n\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int len = machines.length;\\n\\t\\tif(len<2){ return 0; }\\n\\t\\tint total= 0;\\n\\t\\tint sum=0;\\n\\t\\tint prefixsum[]= new int[len];\\n\\t\\tint suffixsum[]= new int[len];\\n\\t\\tprefixsum[0]=machines[0];\\n\\t\\tfor(int i=1;i<len;i++){\\n\\t\\t\\tprefixsum[i]= prefixsum[i-1]+machines[i];\\n\\t\\t}\\n        if(prefixsum[len-1]%len!=0){ return -1; }\\n        sum = prefixsum[len-1]/len;\\n\\t\\tsuffixsum[len-1]=machines[len-1];\\n\\t\\tfor(int i=len-2;i>=0;i--){\\n\\t\\t\\tsuffixsum[i]= suffixsum[i+1]+machines[i];\\n\\t\\t}\\n\\t\\tint leftneed=0;\\n\\t\\tint rightneed=0;\\n\\t\\tint turns=0;\\n\\t\\tfor(int i=0;i<len;i++){\\n\\t\\t\\tif(machines[i] > sum){\\n\\t\\t\\t\\tint expected_lsum=i*sum;\\n                int expected_rsum=(len-i-1)*sum;\\n                leftneed= i==0 ? 0: expected_lsum-prefixsum[i-1];\\n                rightneed= i==len-1 ? 0: expected_rsum-suffixsum[i+1];\\n                leftneed= Math.max(0,leftneed);\\n                rightneed= Math.max(0,rightneed);\\n                turns= Math.max(turns, leftneed+rightneed);  \\n            } \\n\\t\\t}\\n\\t\\treturn turns;\\t\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int len = machines.length;\\n\\t\\tif(len<2){ return 0; }\\n\\t\\tint total= 0;\\n\\t\\tint sum=0;\\n\\t\\tint prefixsum[]= new int[len];\\n\\t\\tint suffixsum[]= new int[len];\\n\\t\\tprefixsum[0]=machines[0];\\n\\t\\tfor(int i=1;i<len;i++){\\n\\t\\t\\tprefixsum[i]= prefixsum[i-1]+machines[i];\\n\\t\\t}\\n        if(prefixsum[len-1]%len!=0){ return -1; }\\n        sum = prefixsum[len-1]/len;\\n\\t\\tsuffixsum[len-1]=machines[len-1];\\n\\t\\tfor(int i=len-2;i>=0;i--){\\n\\t\\t\\tsuffixsum[i]= suffixsum[i+1]+machines[i];\\n\\t\\t}\\n\\t\\tint leftneed=0;\\n\\t\\tint rightneed=0;\\n\\t\\tint turns=0;\\n\\t\\tfor(int i=0;i<len;i++){\\n\\t\\t\\tif(machines[i] > sum){\\n\\t\\t\\t\\tint expected_lsum=i*sum;\\n                int expected_rsum=(len-i-1)*sum;\\n                leftneed= i==0 ? 0: expected_lsum-prefixsum[i-1];\\n                rightneed= i==len-1 ? 0: expected_rsum-suffixsum[i+1];\\n                leftneed= Math.max(0,leftneed);\\n                rightneed= Math.max(0,rightneed);\\n                turns= Math.max(turns, leftneed+rightneed);  \\n            } \\n\\t\\t}\\n\\t\\treturn turns;\\t\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580102,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum=0;int res=0;int remain=0;\\n        for(int n:machines)sum+=n;\\n        if(sum%machines.length!=0)return -1;\\n        int t=sum/machines.length;\\n        for(int i=0;i<machines.length;i++){\\n            int dif=machines[i]-t;\\n            if(dif>0){//pass out\\n                res=Math.max(res,dif);\\n                remain+=dif;\\n                res=Math.max(res,remain);\\n            }\\n            else{//how many we still need\\n                res=Math.max(res,t-machines[i]-remain);\\n                remain+=dif;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum=0;int res=0;int remain=0;\\n        for(int n:machines)sum+=n;\\n        if(sum%machines.length!=0)return -1;\\n        int t=sum/machines.length;\\n        for(int i=0;i<machines.length;i++){\\n            int dif=machines[i]-t;\\n            if(dif>0){//pass out\\n                res=Math.max(res,dif);\\n                remain+=dif;\\n                res=Math.max(res,remain);\\n            }\\n            else{//how many we still need\\n                res=Math.max(res,t-machines[i]-remain);\\n                remain+=dif;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235584,
                "title": "explanation-of-java-o-n-solution",
                "content": "There are several post that try to explain this, and I still found it difficult to follow.  I figure I\\'ll give it a shot in explaining and I hope people can follow.  I reference the examples in  https://leetcode.com/problems/super-washing-machines/discuss/99203/C%2B%2B-12-ms-O(n)-8-lines, but gave my own spin on the explanation.\\n\\n```\\n\\n  public int findMinMoves(int[] machines) {\\n        int moves = 0;\\n        \\n        int total = 0;\\n        for(int clothes: machines) {\\n            total += clothes;\\n        }\\n        \\n        if(total%machines.length != 0) {\\n            return -1;\\n        }\\n        \\n        int avg = total/machines.length;\\n        int maxRunningBalance = 0;\\n        int maxOffLoad = 0;\\n        int runningBalance = 0;\\n        \\n        for(int clothes: machines) {\\n            int offload = clothes - avg;\\n            runningBalance += offload;\\n            maxRunningBalance = Math.max(maxRunningBalance, Math.abs(runningBalance));\\n            maxOffLoad = Math.max(maxOffLoad, offload);\\n        }\\n        \\n        return Math.max(maxOffLoad, maxRunningBalance);\\n    }\\n\\t\\n```\\n\\nThe goal is to distribute all the dresses evenly between the washing machines.  \\n\\n**How do we determine how many dresses has ot exist in each machine?  This part is pretty straight forward. **\\n\\n1) Calculate the sum of the dresses\\n2) Calculate the avg dress that needs to be in each washing machine.\\n\\n**How do we use the avg info to determine the min amount of moves?**\\nThere are a couple things that you need to understand from the question:\\n1) only 1 dress can be moved from a machine during 1 move.  If there are multiple machines n, that means that a dress from each machine can move so that there is at most n dress can move during 1 move. \\n\\nFor example: [1, 1, 4, 8, 1] \\nIf a dress was to move left from each washing machine except the first one, that would be consider one move and the output would be [2,1,4,8,0].  \\n\\nThere are two factors that we need to account for:\\n1) The Running balance.  If you start from the first washing machine and traverse to the last machine, a running balance can be calculated.  The absolute value of the running balance at any time (let\\'s call that MAX_RUNNING_BALANCE)  tells you that at least that amount of moves has to be made.  That is based on the fact that during a move only 1 dress can move from a machine. The running balance can be calculated from left to right or from right to left; taking abs of the difference will output the same max value. \\n2) The running balance only accounts for the flow in one direction.  However, dresses can flow in both directions.  Because of this, we need to account the max offload which is the number of dresses - the expected average (let\\'s call this MAX_OFFLOAD).  This will tell you that at any machine there is at least that MAX_OFFLOAD moves.\\n\\nYou may ask why can\\'t we just usee the MAX_OFFLOAD to figure out the min amount of moves.  That is because you need the overall view of the accumlation of dresses (dresses moving through multiple machinese) which the MAX_OFFLOAD doesn\\'t tell you.\\n\\nYou can see the Running Balance as the overview of all the machines together and the MAX_OFFLOAD view at each machine.  With both the info, we can compute the min by grabbing the max of the two.  \\n\\nBased on the above two factors, the min amount of moves is = max(MAX_RUNNING_BALANCE,  MAX_OFFLOAD)\\n```\\nExample 2: [1, 1, 4, 8, 1], total dresses: 15, target dresses: 3, maximum offload is 5 (8 - 3).\\n            0  1  2  3  4\\n         \\nRunning balance:[-2][-4][ -3][ 2][ 0]\\nAnswer: max(5, abs(-4)) = 5\\n ```  \\n \\nIn this example, \\n```\\n1 <-1 <- 4 <- 8  1   [2,1,4,7,1]\\n2 <-1 <- 4 <- 7  1   [3,1,4,6,1]\\n3 <-1 <- 4 <- 6  1   [3,2,4,5,1]\\n3   2 <- 4    5->1   [3,3,3,4,2]\\n3   3    3    4->2   [3,3,3,3,3]\\n```\\n\\nIn this example, there are min of five moves. \\n\\n\\n```\\nThe offload would be:\\n            [ 1,  1, 4, 8,  1]   average = 15 / 5 = 3 dresses each\\noffload =    -2, -2, 1, 5, -2   \\n```\\n\\nWhen looking at the offload, the max is 5.   What this means is that, no matter what there will be at least 5 moves to distribute the dress to the other washing machine.  This is because you can only move one dress at a time from one machine.  We only account for positive numbers because we only care about the number of dresses that will move vs. the number of dresses the machine needs.\\n\\n\\n```\\nInput: [ 1,  1, 4, 8,   1]  average = 15 / 5 = 3 dresses each\\nRunning balance: [ -2 -4 -3 2 0]\\n```\\n\\nThe other factor we need to consider is the running balance.  The running balance is saying that there is at leasWhat the running balance is saying is that this is the amount that will carry over to the next washing machine is equivalent of saying that there is at least x amount of dresses that 4 dresses that move from one machine to the next.\\n\\nThe final answer is the = max ( max running balance at any time, max offload amount).  In this case, the answer is 5\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n  public int findMinMoves(int[] machines) {\\n        int moves = 0;\\n        \\n        int total = 0;\\n        for(int clothes: machines) {\\n            total += clothes;\\n        }\\n        \\n        if(total%machines.length != 0) {\\n            return -1;\\n        }\\n        \\n        int avg = total/machines.length;\\n        int maxRunningBalance = 0;\\n        int maxOffLoad = 0;\\n        int runningBalance = 0;\\n        \\n        for(int clothes: machines) {\\n            int offload = clothes - avg;\\n            runningBalance += offload;\\n            maxRunningBalance = Math.max(maxRunningBalance, Math.abs(runningBalance));\\n            maxOffLoad = Math.max(maxOffLoad, offload);\\n        }\\n        \\n        return Math.max(maxOffLoad, maxRunningBalance);\\n    }\\n\\t\\n```\n```\\nExample 2: [1, 1, 4, 8, 1], total dresses: 15, target dresses: 3, maximum offload is 5 (8 - 3).\\n            0  1  2  3  4\\n         \\nRunning balance:[-2][-4][ -3][ 2][ 0]\\nAnswer: max(5, abs(-4)) = 5\\n ```\n```\\n1 <-1 <- 4 <- 8  1   [2,1,4,7,1]\\n2 <-1 <- 4 <- 7  1   [3,1,4,6,1]\\n3 <-1 <- 4 <- 6  1   [3,2,4,5,1]\\n3   2 <- 4    5->1   [3,3,3,4,2]\\n3   3    3    4->2   [3,3,3,3,3]\\n```\n```\\nThe offload would be:\\n            [ 1,  1, 4, 8,  1]   average = 15 / 5 = 3 dresses each\\noffload =    -2, -2, 1, 5, -2   \\n```\n```\\nInput: [ 1,  1, 4, 8,   1]  average = 15 / 5 = 3 dresses each\\nRunning balance: [ -2 -4 -3 2 0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204135,
                "title": "javascript-12-line-solution-count-the-minimal-move-for-each-machine",
                "content": "I noticed there\\'s no topic with JavaScript implementation, here\\'s one. The idea is simple: **count the minimal move for each machine**.\\n\\nIf the sum cannot be evenly divided, return false. Then there always be an answer, we normalize the whole array firstly.\\n\\nThen for each machine i:\\n\\n* If both left and right total are zero, machine i should not be touched, that always leads to a worse answer.\\n* Otherwise, each step we move one cloth leftward or rightward, exclusively. For each side:\\n\\t* Move enough cloths until the total for this side is zero, that\\'s enough because both left and right part can be then adjusted by themselves.\\n* leftward moves + rightward moves is the minimal move for this machine. Cannot be smaller, it\\'s obvious.\\n\\nAfterward, we get the max move for each machine and that woule be the answer.\\n\\nNote:\\n\\n* I mean **no better** by **worse** in the above text, just for simpicity.\\n* The normalization and the left total computation can be done in one pass.\\n* Time: O(N), Space: O(1)\\n\\n```javascript\\nvar findMinMoves = function(machines) {\\n    let sum = machines.reduce((sum, num) => sum + num, 0);\\n    let avg = Math.floor(sum / machines.length);\\n    if (avg * machines.length !== sum) return -1;\\n    let ans = 0;\\n    for(let i = 0, leftTotal = 0; i < machines.length; leftTotal += machines[i++]) {\\n        machines[i] -= avg;\\n        let rightTotal = -leftTotal - machines[i];\\n        ans = Math.max(ans, Math.max(0, -leftTotal) + Math.max(0, -rightTotal));\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar findMinMoves = function(machines) {\\n    let sum = machines.reduce((sum, num) => sum + num, 0);\\n    let avg = Math.floor(sum / machines.length);\\n    if (avg * machines.length !== sum) return -1;\\n    let ans = 0;\\n    for(let i = 0, leftTotal = 0; i < machines.length; leftTotal += machines[i++]) {\\n        machines[i] -= avg;\\n        let rightTotal = -leftTotal - machines[i];\\n        ans = Math.max(ans, Math.max(0, -leftTotal) + Math.max(0, -rightTotal));\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112216,
                "title": "this-is-an-interesting-question-i-will-try-to-explain-it",
                "content": "Solution first:\\n\\n```\\n    public int findMinMoves(int[] machines) {\\n        int sum = IntStream.of(machines).sum();\\n        if (sum % machines.length != 0) {\\n            return -1;\\n        }\\n        int target = sum / machines.length;\\n        int current = 0;\\n        int minMove = 0;\\n        for (int machine : machines) {\\n            minMove = Math.max(minMove, Math.abs(current));\\n            minMove = Math.max(minMove, machine - target);\\n            current += machine - target;\\n        }\\n        return minMove;\\n    }\\n```\\n\\nWe all know that eventually we want every machine to have **target** number of dresses, so as long as the **sum** is dividable by number of machines, we should always have a solution.\\n\\nThe idea is that we go through the list of machines, and we keep track of how many dresses we currently owe or have extra with variable **current**. Then for each new machine, we either need to add some dresses to it or move dresses from it, represented by **machine - target**.\\n\\nThe first max operation in for loop means: Right now the dresses that are needed or have extra will have to be balanced by following machines, and they will have to move **current** times to fulfill this imbalance of **current**.\\n\\nThe second max operation in for loop means: For each machine, we need to move **machine - target** dresses out of it (if that's a positive value) to make it even. The reason we don't use **Math.abs(machine - target)** is that if a machine needs more dresses, it can receive more than 1 dress at one pass, so it's not possible to count it.\\n\\nIn the end of the for loop, you update the **current** variable.",
                "solutionTags": [],
                "code": "```\\n    public int findMinMoves(int[] machines) {\\n        int sum = IntStream.of(machines).sum();\\n        if (sum % machines.length != 0) {\\n            return -1;\\n        }\\n        int target = sum / machines.length;\\n        int current = 0;\\n        int minMove = 0;\\n        for (int machine : machines) {\\n            minMove = Math.max(minMove, Math.abs(current));\\n            minMove = Math.max(minMove, machine - target);\\n            current += machine - target;\\n        }\\n        return minMove;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99189,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not machines:\\n            return 0\\n        n = len(machines)\\n        s = sum(machines)\\n        if s % n:\\n            return -1\\n        avg = s / n\\n        ans = 0\\n        left_sum = 0\\n        for x in machines:\\n            delta = x - avg\\n            ans = max(ans, -left_sum, delta + max(0, left_sum))\\n            left_sum += delta\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not machines:\\n            return 0\\n        n = len(machines)\\n        s = sum(machines)\\n        if s % n:\\n            return -1\\n        avg = s / n\\n        ans = 0\\n        left_sum = 0\\n        for x in machines:\\n            delta = x - avg\\n            ans = max(ans, -left_sum, delta + max(0, left_sum))\\n            left_sum += delta\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414960,
                "title": "beginner-level-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        int n = machines.size();\\n        for(auto it: machines)sum += it ;\\n        if(sum % n != 0)return -1;\\n        int avg = sum/n ;\\n\\n        int extra = 0, ans = 0;\\n        for(int i=0; i<n; i++){\\n            extra += machines[i]-avg; // how much dresses to put in\\n            ans = max(ans, max(machines[i]-avg, abs(extra))); // how much dresses to put out & max with put in \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        int n = machines.size();\\n        for(auto it: machines)sum += it ;\\n        if(sum % n != 0)return -1;\\n        int avg = sum/n ;\\n\\n        int extra = 0, ans = 0;\\n        for(int i=0; i<n; i++){\\n            extra += machines[i]-avg; // how much dresses to put in\\n            ans = max(ans, max(machines[i]-avg, abs(extra))); // how much dresses to put out & max with put in \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385203,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& ms) {\\n        int n = ms.size();\\n        int sum = 0;\\n        for (int &i : ms) sum += i;\\n        if (sum % n) return -1;\\n        int t = sum / n;\\n        int ans = 0, toRight = 0;\\n        for (int &i : ms) {\\n            toRight = toRight + i - t;\\n            ans = max(ans, max(abs(toRight), i - t));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))\\n        if rem: return -1\\n        \\n        machines = [m - ave for m in machines]\\n        abspref = max(map(abs,(accumulate(machines))))\\n\\n        return max(max(machines),abspref)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0;\\n        for(int i: machines){\\n            total += i;\\n        } \\n        if(total % machines.length != 0){\\n            return -1;\\n        }\\n        int avg = total / machines.length;\\n        int count = 0;\\n        int max = 0;\\n        for(int load: machines){\\n            count = count + load - avg;\\n            max = Math.max(Math.max(max, Math.abs(count)), load-avg);\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& ms) {\\n        int n = ms.size();\\n        int sum = 0;\\n        for (int &i : ms) sum += i;\\n        if (sum % n) return -1;\\n        int t = sum / n;\\n        int ans = 0, toRight = 0;\\n        for (int &i : ms) {\\n            toRight = toRight + i - t;\\n            ans = max(ans, max(abs(toRight), i - t));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n\\n        ave, rem = divmod(sum(machines),len(machines))\\n        if rem: return -1\\n        \\n        machines = [m - ave for m in machines]\\n        abspref = max(map(abs,(accumulate(machines))))\\n\\n        return max(max(machines),abspref)\\n```\n```Java []\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int total = 0;\\n        for(int i: machines){\\n            total += i;\\n        } \\n        if(total % machines.length != 0){\\n            return -1;\\n        }\\n        int avg = total / machines.length;\\n        int count = 0;\\n        int max = 0;\\n        for(int load: machines){\\n            count = count + load - avg;\\n            max = Math.max(Math.max(max, Math.abs(count)), load-avg);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356998,
                "title": "java-simple-o-n-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int avg = 0;\\n\\n        for(int i = 0; i < machines.length; i++){\\n            avg += machines[i];\\n            \\n        }\\n\\n        if(avg % machines.length != 0){\\n            return -1;\\n        }\\n\\n        int res = 0, cnt = 0;\\n        avg = avg / machines.length;\\n        for (int m : machines) {\\n            cnt += m - avg;\\n            res = Math.max(res, Math.max(Math.abs(cnt), m - avg));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int avg = 0;\\n\\n        for(int i = 0; i < machines.length; i++){\\n            avg += machines[i];\\n            \\n        }\\n\\n        if(avg % machines.length != 0){\\n            return -1;\\n        }\\n\\n        int res = 0, cnt = 0;\\n        avg = avg / machines.length;\\n        for (int m : machines) {\\n            cnt += m - avg;\\n            res = Math.max(res, Math.max(Math.abs(cnt), m - avg));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941152,
                "title": "c-greedy-beginner-friendly-explained-with-examples",
                "content": "```\\n\\n-> Compute the total number of clothes in the washing machines -> Say N\\n-> To assign every washing machine equal number of clothes we have to give each washing machine\\n   N/(number of machines) clothes.\\n-> If N is not divisible by number of machines then answer is not possible return -1\\n\\n   Intuition :-\\n\\n-> Start from the left and keep finding the requirement at each washing machine that it needs\\n   from the right part\\n-> If the variable \\'right\\' is negative that means we have a deficit at this particular position\\n   and we would require clothes from the right part\\n-> For eg :- 1, 2, 4, 5, 3, 3\\n             ^\\n             |\\n   At idx = 0 we see that we require 2 units of clothes from the right part so \\'right\\' becomes\\n   -2. And ans till now becomes 2 as from the right part it would take 2 steps to make the \\n   clothes available at index 0 (considering 1 unit clothe from different machines can move to \\n   different machine in one step).\\n   \\n   At idx = 1, we see that the requirement here is of machines[i] + right - req = 2 + (-2) - 3 = -3\\n   So we need 3 units of clothes from the right part such that this idx value would take 1 and pass on\\n   2 to idx = 0.\\n   \\n   At idx = 2, the requirement is 4 + (-3) - 3 = -2. Here 4 has an extra clothe to give and additonally\\n   it would need 2 clothes from the right such that it could pass on 3 clothes in total to the left.\\n   \\n   At idx = 3, the requirement here from the right is 5 + (-2) - 3 = 0, at this point our \\n   requirement becomes 0 from the right as 5 has additional 2 clothe to pass and 4 had 1 extra clothe\\n   to pass making a total of 3 clothes which 1 and 2 needed.\\n   \\n   A thing to keep in mind here is that the passing of clothes takes place simultaneously from all \\n   washing machines such that each washing passes exactly 1 unit clothe to its adjacent\\n   \\n   In action :\\n   \\n   Step 1 -> 1   2   4   5   3   3\\n                    <-1 <-1\\n             1   3   4   4   3   3\\n             \\n   Step 2 -> 1   3   4   4   3   3\\n                <-1  <-1 <-1\\n             2   3   4   3   3   3\\n             \\n   Step 3 -> 2   3   4   3   3   3\\n               <-1  <-1 \\n             3   3   3   3   3   3\\n             \\n   Total Steps Required are 3\\n   \\n  Conclusion :\\n     |-> \\n     | -> ans can be the max clothes that are required from the left or the right at this particular idx\\nMax  |    for distribution\\n     | -> or it can be the the number of surplus clothes at a particular location that needs to be \\n     |    distributed from this index to the other idxs.\\n     |->\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for(auto clothes : machines)\\n            sum += clothes;\\n        \\n        if(sum % (machines.size()) != 0)\\n            return -1;\\n        \\n        // If division is possible\\n        int req = sum/(machines.size());\\n        int right = 0;\\n        int ans = 0;\\n\\t\\t\\n        // When right is positive it means that clothes have to be sent to the right\\n        // When right is negative it means that clothes have to sent to the left\\n        for(int i=0; i<machines.size(); i++) {\\n            right = machines[i] + right - req;\\n            ans = max(ans, max(abs(right), machines[i]-req));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\n-> Compute the total number of clothes in the washing machines -> Say N\\n-> To assign every washing machine equal number of clothes we have to give each washing machine\\n   N/(number of machines) clothes.\\n-> If N is not divisible by number of machines then answer is not possible return -1\\n\\n   Intuition :-\\n\\n-> Start from the left and keep finding the requirement at each washing machine that it needs\\n   from the right part\\n-> If the variable \\'right\\' is negative that means we have a deficit at this particular position\\n   and we would require clothes from the right part\\n-> For eg :- 1, 2, 4, 5, 3, 3\\n             ^\\n             |\\n   At idx = 0 we see that we require 2 units of clothes from the right part so \\'right\\' becomes\\n   -2. And ans till now becomes 2 as from the right part it would take 2 steps to make the \\n   clothes available at index 0 (considering 1 unit clothe from different machines can move to \\n   different machine in one step).\\n   \\n   At idx = 1, we see that the requirement here is of machines[i] + right - req = 2 + (-2) - 3 = -3\\n   So we need 3 units of clothes from the right part such that this idx value would take 1 and pass on\\n   2 to idx = 0.\\n   \\n   At idx = 2, the requirement is 4 + (-3) - 3 = -2. Here 4 has an extra clothe to give and additonally\\n   it would need 2 clothes from the right such that it could pass on 3 clothes in total to the left.\\n   \\n   At idx = 3, the requirement here from the right is 5 + (-2) - 3 = 0, at this point our \\n   requirement becomes 0 from the right as 5 has additional 2 clothe to pass and 4 had 1 extra clothe\\n   to pass making a total of 3 clothes which 1 and 2 needed.\\n   \\n   A thing to keep in mind here is that the passing of clothes takes place simultaneously from all \\n   washing machines such that each washing passes exactly 1 unit clothe to its adjacent\\n   \\n   In action :\\n   \\n   Step 1 -> 1   2   4   5   3   3\\n                    <-1 <-1\\n             1   3   4   4   3   3\\n             \\n   Step 2 -> 1   3   4   4   3   3\\n                <-1  <-1 <-1\\n             2   3   4   3   3   3\\n             \\n   Step 3 -> 2   3   4   3   3   3\\n               <-1  <-1 \\n             3   3   3   3   3   3\\n             \\n   Total Steps Required are 3\\n   \\n  Conclusion :\\n     |-> \\n     | -> ans can be the max clothes that are required from the left or the right at this particular idx\\nMax  |    for distribution\\n     | -> or it can be the the number of surplus clothes at a particular location that needs to be \\n     |    distributed from this index to the other idxs.\\n     |->\\n```\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for(auto clothes : machines)\\n            sum += clothes;\\n        \\n        if(sum % (machines.size()) != 0)\\n            return -1;\\n        \\n        // If division is possible\\n        int req = sum/(machines.size());\\n        int right = 0;\\n        int ans = 0;\\n\\t\\t\\n        // When right is positive it means that clothes have to be sent to the right\\n        // When right is negative it means that clothes have to sent to the left\\n        for(int i=0; i<machines.size(); i++) {\\n            right = machines[i] + right - req;\\n            ans = max(ans, max(abs(right), machines[i]-req));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779812,
                "title": "c-easy-faster-than-all",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746483,
                "title": "super-washing-machines-java-solution",
                "content": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int sum = 0;\\n        for (int num : machines) {\\n            sum += num;\\n        }\\n        if (sum % n != 0) {\\n            return -1;\\n        }\\n        int avg = sum / n;\\n        int[] leftSums = new int[n];\\n        int[] rightSums = new int[n];\\n        for (int i = 1; i < n; i ++) {\\n            leftSums[i] = leftSums[i-1] + machines[i-1];\\n        }\\n        for (int i = n - 2; i >= 0; i --) {\\n            rightSums[i] = rightSums[i+1] + machines[i+1];\\n        }\\n        int move = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int expLeft = i * avg;\\n            int expRight = (n - i - 1) * avg;\\n            int left = 0;\\n            int right = 0;\\n            if (expLeft > leftSums[i]) {\\n                left = expLeft - leftSums[i];\\n            } \\n            if (expRight > rightSums[i]) {\\n                right = expRight - rightSums[i];\\n            }\\n            move = Math.max(move, left + right);\\n        }\\n        return move;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int sum = 0;\\n        for (int num : machines) {\\n            sum += num;\\n        }\\n        if (sum % n != 0) {\\n            return -1;\\n        }\\n        int avg = sum / n;\\n        int[] leftSums = new int[n];\\n        int[] rightSums = new int[n];\\n        for (int i = 1; i < n; i ++) {\\n            leftSums[i] = leftSums[i-1] + machines[i-1];\\n        }\\n        for (int i = n - 2; i >= 0; i --) {\\n            rightSums[i] = rightSums[i+1] + machines[i+1];\\n        }\\n        int move = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int expLeft = i * avg;\\n            int expRight = (n - i - 1) * avg;\\n            int left = 0;\\n            int right = 0;\\n            if (expLeft > leftSums[i]) {\\n                left = expLeft - leftSums[i];\\n            } \\n            if (expRight > rightSums[i]) {\\n                right = expRight - rightSums[i];\\n            }\\n            move = Math.max(move, left + right);\\n        }\\n        return move;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720698,
                "title": "simple-c-code",
                "content": "\\nint findMinMoves(int* machines, int machinesSize){\\nint totalnoofdress=0,i;\\nfor(int i=0;i<machinesSize;i++){\\n    totalnoofdress+=machines[i];\\n}\\nif(totalnoofdress%machinesSize!=0){\\n    return -1;\\n}\\nint target= totalnoofdress/machinesSize;\\nint current=0,moves=0;\\nfor(int i=0;i<machinesSize;i++){\\n    current=current+(machines[i]-target);\\n    moves=abs(current)>moves?abs(current):moves;\\n    moves=machines[i]-target>moves?machines[i]-target:moves;\\n}\\nreturn moves;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\nint findMinMoves(int* machines, int machinesSize){\\nint totalnoofdress=0,i;\\nfor(int i=0;i<machinesSize;i++){\\n    totalnoofdress+=machines[i];\\n}\\nif(totalnoofdress%machinesSize!=0){\\n    return -1;\\n}\\nint target= totalnoofdress/machinesSize;\\nint current=0,moves=0;\\nfor(int i=0;i<machinesSize;i++){\\n    current=current+(machines[i]-target);\\n    moves=abs(current)>moves?abs(current):moves;\\n    moves=machines[i]-target>moves?machines[i]-target:moves;\\n}\\nreturn moves;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2425876,
                "title": "explanation-and-cases-analysis",
                "content": "Some explanation to the python solution: https://leetcode.com/problems/super-washing-machines/discuss/99187/JavaC%2B%2BPython-O(1)-Space by @lee215\\n\\nFirst we need to find how many more or fewer dresses each machine has. For example, given `machines=[0,0,11,5]`, we have `diffs=[-4,-4,+7,+1]`.\\n\\n**Case 1:** For each machine `x` that has more than desired dresses, it has to **distribute** `diffs[x]` dresses to other machines in `diffs[x]` time.\\nThis corresponds to `m-target` in the original solution.\\n\\n**Case 2:** If we cut the `diffs` array in half at any index `i`, there are `sum(diffs[:i])` dresses \"**flowing**\" to or from `machines[:i]` to the right half depending on the sum is negative or positive respectively. Because we want to make all entries of `diffs` to be 0 in the end. This process takes `abs(sum(diffs[i]))` time.\\nThis corresponds to `abs(toRight)` in the original solution.\\n\\n**Wrong Case 2:** For machine `y` that has fewer dresses, it may receive `diffs[y]` dresses in **less than or equal to** `diffs[y]` time because it may get dresses from both left(`L`) and right(`R`) concurrently. The actual time is `max(L,R) <= diffs[y]` with `L+R=diffs[y]`.\\nExample case `machines=[3,0,2,3]` with answer 1.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Some explanation to the python solution: https://leetcode.com/problems/super-washing-machines/discuss/99187/JavaC%2B%2BPython-O(1)-Space by @lee215\\n\\nFirst we need to find how many more or fewer dresses each machine has. For example, given `machines=[0,0,11,5]`, we have `diffs=[-4,-4,+7,+1]`.\\n\\n**Case 1:** For each machine `x` that has more than desired dresses, it has to **distribute** `diffs[x]` dresses to other machines in `diffs[x]` time.\\nThis corresponds to `m-target` in the original solution.\\n\\n**Case 2:** If we cut the `diffs` array in half at any index `i`, there are `sum(diffs[:i])` dresses \"**flowing**\" to or from `machines[:i]` to the right half depending on the sum is negative or positive respectively. Because we want to make all entries of `diffs` to be 0 in the end. This process takes `abs(sum(diffs[i]))` time.\\nThis corresponds to `abs(toRight)` in the original solution.\\n\\n**Wrong Case 2:** For machine `y` that has fewer dresses, it may receive `diffs[y]` dresses in **less than or equal to** `diffs[y]` time because it may get dresses from both left(`L`) and right(`R`) concurrently. The actual time is `max(L,R) <= diffs[y]` with `L+R=diffs[y]`.\\nExample case `machines=[3,0,2,3]` with answer 1.",
                "codeTag": "Unknown"
            },
            {
                "id": 2309704,
                "title": "c-simple-loop",
                "content": "For each washing machine we have to choose maxi,u, from:\\n1. Answer for the previous machine\\n2. Total disbalance between left (before the machine) and right (after the machine)\\n3. Dresses we want to remove from the machine \\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    \\n    public int FindMinMoves(int[] machines) {\\n        int sum = machines.Sum();\\n        \\n        if (sum % machines.Length != 0)\\n            return -1;\\n        \\n        int wanted = sum / machines.Length;\\n        \\n        int result = 0;\\n        int delta = 0;\\n        \\n        foreach (int value in machines) \\n            result = Math.Max(Math.Max(result, Math.Abs(delta += value - wanted)), value - wanted);\\n                \\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int FindMinMoves(int[] machines) {\\n        int sum = machines.Sum();\\n        \\n        if (sum % machines.Length != 0)\\n            return -1;\\n        \\n        int wanted = sum / machines.Length;\\n        \\n        int result = 0;\\n        int delta = 0;\\n        \\n        foreach (int value in machines) \\n            result = Math.Max(Math.Max(result, Math.Abs(delta += value - wanted)), value - wanted);\\n                \\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177435,
                "title": "python-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def findMinMoves(self, x: List[int]) -> int:\\n        total=sum(x)\\n        l=len(x)\\n        if total%l!=0:return -1\\n        su=total//l\\n        s=0\\n        ans=0\\n        for i in range(l):\\n            ans=max(ans,max(su*i-s,0)+max(su*(l-i-1)-(total-s-x[i]),0))\\n            s+=x[i]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, x: List[int]) -> int:\\n        total=sum(x)\\n        l=len(x)\\n        if total%l!=0:return -1\\n        su=total//l\\n        s=0\\n        ans=0\\n        for i in range(l):\\n            ans=max(ans,max(su*i-s,0)+max(su*(l-i-1)-(total-s-x[i]),0))\\n            s+=x[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172711,
                "title": "a-massive-solution-but-clearly-explain-the-actual-problem",
                "content": "The actuall problem is how to make each container containing the same number of elements, which should be the average value.\\n\\nSo, let\\'s first do a preprocess, normalize the array by average,  every element becomes \"source\"(larger than average) and \"sink\" (smaller than average). Those equals to average doesn\\'t matter, we just discard them.\\n\\nThe problem becomes how to flow sources to sinks, makes every elements becomes 0.  I will describe the problem as \"flowing water\" instead of clothes, which is more intuitive.\\n\\nEach source can only flow 1 unit per time, but each sink can recieve multiple units per time. \\n\\nNotice that we can merge consecutive \"sinks\", but \"source\" can\\'t be merged, think of the following case, \"sink1 source1 source2 source3 sink2\", source1 and source 3 can flow to different sink in parallel.\\n\\nBut if there are consecutive sources at the end of the array, we can merge them, since either way those sources can\\'t flow in parallel.\\n\\nNext, we want to determine for each source, how many water flow to left and to right. The rule is simple, we calculate the culmulative sum of array. \\nFor each source, if the previouse cum_sum is positive, means there are additional water flow to me, so I would never flow may water leftwards, all water flow to right.\\n\\nIf previouse cul_sum is negative, means there is a \"big sink\" left to me, I will try filling the sink using as many water as possible. And the flow the remaining water to right, if still some.\\n\\n\\nNow we have a very good recursive structure, we are looping through every \"sources\", at each source, there are cases:\\n\\n1.  There is additional flux to next source, so my water will flow cross next source. Notice that flowing these bunch of water can happens in parallel with \\n\\n\\n\\n```\\nfrom typing import List\\n\\n\\ndef pre_proc(a):\\n    total_sum = sum(a)\\n    avg = total_sum / len(a)\\n    avg_round = total_sum // len(a)\\n\\n    if avg != avg_round:\\n        return None\\n\\n    stack = []\\n\\n    for v in a:\\n        v = v - avg_round\\n        if v == 0:\\n            continue\\n\\n        if not stack:\\n            stack.append(v)\\n        else:\\n            last_val = stack[-1]\\n            if last_val < 0 and v < 0:\\n                stack[-1] += v\\n            else:\\n                stack.append(v)\\n\\n    if len(stack) >= 2:\\n        while len(stack) >= 2:\\n            if stack[-2] < 0 or stack[-1] < 0:\\n                break\\n\\n            if stack[-1] > 0 and stack[-2] > 0:\\n                stack[-2] = stack[-1] + stack[-2]\\n                stack.pop()\\n\\n    return stack\\n\\n\\ndef calc_flux_dist(a):\\n    last_sum = 0\\n    r = []\\n    cul_sum = []\\n    for v in a:\\n        if v > 0:\\n            # All current flow to right\\n            if last_sum >= 0:\\n                cell = (0, v)\\n\\n            # All current flow to left\\n            elif abs(last_sum) >= v:\\n                cell = (v, 0)\\n\\n            # Cancel left, and remaining to right\\n            else:\\n                cell = (-last_sum, v + last_sum)\\n        else:\\n            cell = None\\n\\n        last_sum += v\\n        r.append(cell)\\n        cul_sum.append(last_sum)\\n\\n    return r, cul_sum\\n\\n\\ndef so_search(cul_sum, norm_array, flux_dist, ptr):\\n\\n    n = len(flux_dist)\\n\\n    if norm_array[ptr] < 0:\\n        assert ptr < n - 1\\n        return so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n    assert norm_array[ptr] > 0\\n    left_flux, right_flux = flux_dist[ptr]\\n\\n    if ptr == n - 1:\\n        assert right_flux == 0\\n        return left_flux\\n    elif ptr == n - 2 and norm_array[n - 1] < 0:\\n        return max(left_flux + right_flux, abs(norm_array[n - 1]))\\n\\n    # What actually matters is the outgoing_flux to next source\\n    # Which is the cul_sum\\n    total_right_flux = cul_sum[ptr]\\n    if norm_array[ptr + 1] > 0:\\n        outgoing_flux = cul_sum[ptr]\\n    else:\\n        outgoing_flux = total_right_flux - abs(norm_array[ptr + 1])\\n\\n    # Means I have to cross some sources reach to other sink\\n    if outgoing_flux > 0:\\n        # First drain next sink\\n        if norm_array[ptr + 1] < 0:\\n            current_steps = abs(norm_array[ptr + 1])\\n        else:\\n            current_steps = 0\\n\\n        # Next steps include outgoing_flux, which is not parallel_steps\\n\\n        next_steps = so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n        assert next_steps > outgoing_flux\\n\\n        independent_steps = next_steps - outgoing_flux\\n\\n        # take current_steps while taking it, you can take as many independent_steps as possible\\n        total_steps = current_steps\\n        remaining_independent_steps = independent_steps - current_steps\\n        remaining_independent_steps = max(remaining_independent_steps, 0)\\n\\n        # while taking remaining_independent_steps, you can take as many left_flux as possible\\n        total_steps += remaining_independent_steps\\n        remaining_left_flux = left_flux - remaining_independent_steps\\n        remaining_left_flux = max(remaining_left_flux, 0)\\n\\n        # Finally we take remaining_left_flux and outgoing_flux\\n        total_steps += remaining_left_flux + outgoing_flux\\n\\n        return total_steps\\n\\n    # No outgoing_flux, nothing goes to next source, we calculate how many steps with prev\\n    else:\\n        next_steps = so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n        # There could be a sink left to me which is not filled by my water\\n        if ptr == 0:\\n            leftover_sink = 0\\n        else:\\n            leftover_sink = norm_array[ptr] + cul_sum[ptr - 1]\\n\\n        # left sink is totally cancelled by me\\n        if leftover_sink == 0:\\n            assert cul_sum[ptr] <= norm_array[ptr]\\n            # assert norm_array[ptr + 1] < 0\\n            final_steps = max(norm_array[ptr], next_steps)\\n            return final_steps\\n\\n        # No sink flow after me, the next node can not be source, because we know nothing flow to next source\\n        elif leftover_sink > 0:\\n            assert norm_array[ptr + 1] < 0\\n            final_steps = max(norm_array[ptr], cul_sum[ptr], next_steps)\\n            return final_steps\\n\\n        # There is left sink which is not filled by me, I have to borrow some steps from next steps\\n        else:\\n\\n            curr_steps = left_flux\\n            assert right_flux == 0\\n\\n            assert next_steps >= abs(leftover_sink)\\n\\n            independent_steps = next_steps - abs(leftover_sink)\\n\\n            final_steps = 0\\n\\n            # While taking curr_steps, we can take as many independent_steps as possible\\n            final_steps += curr_steps\\n            remaining_independent_steps = independent_steps - curr_steps\\n            remaining_independent_steps = max(remaining_independent_steps, 0)\\n\\n            # And then finish remaining_independent_steps and leftover_sink\\n            final_steps += remaining_independent_steps + abs(leftover_sink)\\n\\n            return final_steps\\n\\n\\nclass Solution:\\n    def findMinMoves(self, machines: List[int], debug=False) -> int:\\n        if len(machines) == 1:\\n            return 0\\n\\n        norm_array = pre_proc(machines)\\n        if norm_array is None:\\n            return -1\\n\\n        if not norm_array:\\n            return 0\\n        flux_dist, cul_sum = calc_flux_dist(norm_array)\\n\\n        if debug:\\n            print(norm_array)\\n            print(cul_sum)\\n            print(flux_dist)\\n\\n        first_ptr = 0 if norm_array[0] > 0 else 1\\n\\n        return so_search(cul_sum, norm_array, flux_dist, ptr=first_ptr)\\n\\n\\nif __name__ == \\'__main__\\':\\n    m = [1, 0, 5]\\n    r = Solution().findMinMoves(m, debug=True)\\n    print(r)\\n\\n\\ndef cases():\\n    r = [\\n        ([78,73,63,87,83,32,14,59,89,92], 49),\\n        ([0,0,14,0,10,0,0,0], 11),\\n        ([0,0,4,0,5,0,5,0,4], 4),\\n        ([0,0,10,0,0,0,10,0,0,0], 8),\\n        ([74,27,12,75,68,47,61,57,67,52], 49)\\n    ]\\n    return r\\n\\n\\n```",
                "solutionTags": [
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\ndef pre_proc(a):\\n    total_sum = sum(a)\\n    avg = total_sum / len(a)\\n    avg_round = total_sum // len(a)\\n\\n    if avg != avg_round:\\n        return None\\n\\n    stack = []\\n\\n    for v in a:\\n        v = v - avg_round\\n        if v == 0:\\n            continue\\n\\n        if not stack:\\n            stack.append(v)\\n        else:\\n            last_val = stack[-1]\\n            if last_val < 0 and v < 0:\\n                stack[-1] += v\\n            else:\\n                stack.append(v)\\n\\n    if len(stack) >= 2:\\n        while len(stack) >= 2:\\n            if stack[-2] < 0 or stack[-1] < 0:\\n                break\\n\\n            if stack[-1] > 0 and stack[-2] > 0:\\n                stack[-2] = stack[-1] + stack[-2]\\n                stack.pop()\\n\\n    return stack\\n\\n\\ndef calc_flux_dist(a):\\n    last_sum = 0\\n    r = []\\n    cul_sum = []\\n    for v in a:\\n        if v > 0:\\n            # All current flow to right\\n            if last_sum >= 0:\\n                cell = (0, v)\\n\\n            # All current flow to left\\n            elif abs(last_sum) >= v:\\n                cell = (v, 0)\\n\\n            # Cancel left, and remaining to right\\n            else:\\n                cell = (-last_sum, v + last_sum)\\n        else:\\n            cell = None\\n\\n        last_sum += v\\n        r.append(cell)\\n        cul_sum.append(last_sum)\\n\\n    return r, cul_sum\\n\\n\\ndef so_search(cul_sum, norm_array, flux_dist, ptr):\\n\\n    n = len(flux_dist)\\n\\n    if norm_array[ptr] < 0:\\n        assert ptr < n - 1\\n        return so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n    assert norm_array[ptr] > 0\\n    left_flux, right_flux = flux_dist[ptr]\\n\\n    if ptr == n - 1:\\n        assert right_flux == 0\\n        return left_flux\\n    elif ptr == n - 2 and norm_array[n - 1] < 0:\\n        return max(left_flux + right_flux, abs(norm_array[n - 1]))\\n\\n    # What actually matters is the outgoing_flux to next source\\n    # Which is the cul_sum\\n    total_right_flux = cul_sum[ptr]\\n    if norm_array[ptr + 1] > 0:\\n        outgoing_flux = cul_sum[ptr]\\n    else:\\n        outgoing_flux = total_right_flux - abs(norm_array[ptr + 1])\\n\\n    # Means I have to cross some sources reach to other sink\\n    if outgoing_flux > 0:\\n        # First drain next sink\\n        if norm_array[ptr + 1] < 0:\\n            current_steps = abs(norm_array[ptr + 1])\\n        else:\\n            current_steps = 0\\n\\n        # Next steps include outgoing_flux, which is not parallel_steps\\n\\n        next_steps = so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n        assert next_steps > outgoing_flux\\n\\n        independent_steps = next_steps - outgoing_flux\\n\\n        # take current_steps while taking it, you can take as many independent_steps as possible\\n        total_steps = current_steps\\n        remaining_independent_steps = independent_steps - current_steps\\n        remaining_independent_steps = max(remaining_independent_steps, 0)\\n\\n        # while taking remaining_independent_steps, you can take as many left_flux as possible\\n        total_steps += remaining_independent_steps\\n        remaining_left_flux = left_flux - remaining_independent_steps\\n        remaining_left_flux = max(remaining_left_flux, 0)\\n\\n        # Finally we take remaining_left_flux and outgoing_flux\\n        total_steps += remaining_left_flux + outgoing_flux\\n\\n        return total_steps\\n\\n    # No outgoing_flux, nothing goes to next source, we calculate how many steps with prev\\n    else:\\n        next_steps = so_search(cul_sum, norm_array, flux_dist, ptr + 1)\\n\\n        # There could be a sink left to me which is not filled by my water\\n        if ptr == 0:\\n            leftover_sink = 0\\n        else:\\n            leftover_sink = norm_array[ptr] + cul_sum[ptr - 1]\\n\\n        # left sink is totally cancelled by me\\n        if leftover_sink == 0:\\n            assert cul_sum[ptr] <= norm_array[ptr]\\n            # assert norm_array[ptr + 1] < 0\\n            final_steps = max(norm_array[ptr], next_steps)\\n            return final_steps\\n\\n        # No sink flow after me, the next node can not be source, because we know nothing flow to next source\\n        elif leftover_sink > 0:\\n            assert norm_array[ptr + 1] < 0\\n            final_steps = max(norm_array[ptr], cul_sum[ptr], next_steps)\\n            return final_steps\\n\\n        # There is left sink which is not filled by me, I have to borrow some steps from next steps\\n        else:\\n\\n            curr_steps = left_flux\\n            assert right_flux == 0\\n\\n            assert next_steps >= abs(leftover_sink)\\n\\n            independent_steps = next_steps - abs(leftover_sink)\\n\\n            final_steps = 0\\n\\n            # While taking curr_steps, we can take as many independent_steps as possible\\n            final_steps += curr_steps\\n            remaining_independent_steps = independent_steps - curr_steps\\n            remaining_independent_steps = max(remaining_independent_steps, 0)\\n\\n            # And then finish remaining_independent_steps and leftover_sink\\n            final_steps += remaining_independent_steps + abs(leftover_sink)\\n\\n            return final_steps\\n\\n\\nclass Solution:\\n    def findMinMoves(self, machines: List[int], debug=False) -> int:\\n        if len(machines) == 1:\\n            return 0\\n\\n        norm_array = pre_proc(machines)\\n        if norm_array is None:\\n            return -1\\n\\n        if not norm_array:\\n            return 0\\n        flux_dist, cul_sum = calc_flux_dist(norm_array)\\n\\n        if debug:\\n            print(norm_array)\\n            print(cul_sum)\\n            print(flux_dist)\\n\\n        first_ptr = 0 if norm_array[0] > 0 else 1\\n\\n        return so_search(cul_sum, norm_array, flux_dist, ptr=first_ptr)\\n\\n\\nif __name__ == \\'__main__\\':\\n    m = [1, 0, 5]\\n    r = Solution().findMinMoves(m, debug=True)\\n    print(r)\\n\\n\\ndef cases():\\n    r = [\\n        ([78,73,63,87,83,32,14,59,89,92], 49),\\n        ([0,0,14,0,10,0,0,0], 11),\\n        ([0,0,4,0,5,0,5,0,4], 4),\\n        ([0,0,10,0,0,0,10,0,0,0], 8),\\n        ([74,27,12,75,68,47,61,57,67,52], 49)\\n    ]\\n    return r\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097295,
                "title": "python-solution-nothing-greedy-at-all",
                "content": "When I read the question and pressed on the \"related topics\" tab, it says \"Greedy\"\\nTherefore I thought maybe the answer is just the maximum difference of element from the mean... Of course that\\'s not enough, although it is an important factor to consider.\\n\\nI will be frank I read [@lee215 \\'s solution](https://leetcode.com/problems/super-washing-machines/discuss/99187/JavaC%2B%2BPython-O(1)-Space) before coming up with mine. And afterwards I checked the solutions available here, very few people gave a concise explanation, so I will put my two cents in. \\n\\nMy key points is: **focus on the flux, not the machines**. In other words, focus on the **pipes** between the machines rather than how many clothes the machines have at any time.\\nWhat limits the time for finishing the task are the following two facts:\\n1. Only one dress can pass through a pipe at any round\\n2. A source machine cannot send dresses to left and right simultaneously\\n\\nTo answer the question, one need to know how many dresses need to pass through a pipe for all machines to arrive at the target mean. Finding that is trivial, although the sign is important in here. The maximum flux found determines partially the final result (direction does not matter, we only need the magnitude). To get the correct result, one also need to consider the time to clear the source machines. \\nNote: on the other hand, we do not need to consider the sinks because they can receive clothes from both sides (Check out the [3,0,3] testcase)\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total % len(machines) != 0:\\n            return -1\\n        else:\\n            target = total // len(machines)\\n            # figure out the flux of dresses through each pipe\\n            # negative = to left, positive = to right\\n            # Idea: the time needed is limited by the amount of clothes to pass through a pipe\\n            # Also, as a machine cannot send out dress on both side simultaneously, the time is limited by source\\n            flux = [0 for i in range(len(machines)-1)]\\n            result = 0\\n            for i in range(len(machines)-1):\\n                if i == 0:\\n                    flux[i] = machines[i] - target\\n                else:\\n                    flux[i] = flux[i-1] + machines[i] - target\\n                result = max(result, abs(flux[i]))\\n            #print(flux)\\n            # Take care of sources\\n            for i in range(1, len(machines)-1):\\n                if flux[i] > 0 and flux[i-1] < 0:\\n                    result = max(result, flux[i] - flux[i-1])\\n            return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        if total % len(machines) != 0:\\n            return -1\\n        else:\\n            target = total // len(machines)\\n            # figure out the flux of dresses through each pipe\\n            # negative = to left, positive = to right\\n            # Idea: the time needed is limited by the amount of clothes to pass through a pipe\\n            # Also, as a machine cannot send out dress on both side simultaneously, the time is limited by source\\n            flux = [0 for i in range(len(machines)-1)]\\n            result = 0\\n            for i in range(len(machines)-1):\\n                if i == 0:\\n                    flux[i] = machines[i] - target\\n                else:\\n                    flux[i] = flux[i-1] + machines[i] - target\\n                result = max(result, abs(flux[i]))\\n            #print(flux)\\n            # Take care of sources\\n            for i in range(1, len(machines)-1):\\n                if flux[i] > 0 and flux[i-1] < 0:\\n                    result = max(result, flux[i] - flux[i-1])\\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978939,
                "title": "greedy-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int> &arr) {\\n        int sum = accumulate(arr.begin(),arr.end(),0);\\n        int n = arr.size();\\n        \\n        if(sum % n != 0) return -1;\\n        \\n        int target = sum/n;\\n        \\n        // to_right will always store how many dress we need in the left or\\n        // how many extra clothes we have so we can pass those clothes to the right\\n        int i = 0, ans = 0, extra_dress = 0;\\n        for(auto it : arr){\\n            extra_dress += it - target;\\n            ans = max({ans,abs(extra_dress),(it-target)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int> &arr) {\\n        int sum = accumulate(arr.begin(),arr.end(),0);\\n        int n = arr.size();\\n        \\n        if(sum % n != 0) return -1;\\n        \\n        int target = sum/n;\\n        \\n        // to_right will always store how many dress we need in the left or\\n        // how many extra clothes we have so we can pass those clothes to the right\\n        int i = 0, ans = 0, extra_dress = 0;\\n        for(auto it : arr){\\n            extra_dress += it - target;\\n            ans = max({ans,abs(extra_dress),(it-target)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873244,
                "title": "java-simple-o-n-solution-beats-100",
                "content": "```\\n    public int findMinMoves(int[] machines) {\\n        int total=0;\\n        for(int machine:machines) total+= machine;\\n        if(total%machines.length!=0) return -1;\\n        int goal = total/machines.length;\\n                \\n        int maxChanges=0, totalSoFar=0;\\n        for(int i=0; i<machines.length; i++){\\n            totalSoFar+=machines[i];            //Sum of dresses in machines so far [0...i]\\n            \\n            //So far have too many dresses or need more dresses\\n            maxChanges = Math.max(maxChanges, Math.abs((i+1)*goal-totalSoFar));\\n            \\n            //Current machine has too many dresses\\n            maxChanges = Math.max(maxChanges, machines[i]-goal);\\n        }\\n        \\n        return maxChanges;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int findMinMoves(int[] machines) {\\n        int total=0;\\n        for(int machine:machines) total+= machine;\\n        if(total%machines.length!=0) return -1;\\n        int goal = total/machines.length;\\n                \\n        int maxChanges=0, totalSoFar=0;\\n        for(int i=0; i<machines.length; i++){\\n            totalSoFar+=machines[i];            //Sum of dresses in machines so far [0...i]\\n            \\n            //So far have too many dresses or need more dresses\\n            maxChanges = Math.max(maxChanges, Math.abs((i+1)*goal-totalSoFar));\\n            \\n            //Current machine has too many dresses\\n            maxChanges = Math.max(maxChanges, machines[i]-goal);\\n        }\\n        \\n        return maxChanges;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1773834,
                "title": "c-efficient-linear-time-solution",
                "content": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n=machines.size();\\n        int dif=0,ans=0,avg,prefix=0;\\n        int sum=accumulate(machines.begin(),machines.end(),0);\\n        if(sum%n==0)\\n        { \\n            avg=sum/n;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                dif=machines[i]-avg;\\n                ans=max({ans,abs(prefix),dif});\\n                 prefix += machines[i]-avg; \\n            }\\n        }\\n        else{return -1;}\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n=machines.size();\\n        int dif=0,ans=0,avg,prefix=0;\\n        int sum=accumulate(machines.begin(),machines.end(),0);\\n        if(sum%n==0)\\n        { \\n            avg=sum/n;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                dif=machines[i]-avg;\\n                ans=max({ans,abs(prefix),dif}",
                "codeTag": "Java"
            },
            {
                "id": 1702358,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {number[]} machines\\n * @return {number}\\n */\\nvar findMinMoves = function(machines) {\\n    var sum=0;\\n    for(var i=0; i<machines.length; i++)\\n        sum+=machines[i];\\n    if((sum/machines.length)%1 != 0)\\n        return -1;\\n    let avg = sum/machines.length;\\n    let output = 0 , left=0;\\n    i=0;\\n;\\n    while(i < machines.length) \\n    {\\n        machines[i] -= avg;\\n        output = Math.max(output, Math.max(0, -left) + Math.max(0, -(-left - machines[i])));\\n        left += machines[i++];\\n    }\\n    return output;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} machines\\n * @return {number}\\n */\\nvar findMinMoves = function(machines) {\\n    var sum=0;\\n    for(var i=0; i<machines.length; i++)\\n        sum+=machines[i];\\n    if((sum/machines.length)%1 != 0)\\n        return -1;\\n    let avg = sum/machines.length;\\n    let output = 0 , left=0;\\n    i=0;\\n;\\n    while(i < machines.length) \\n    {\\n        machines[i] -= avg;\\n        output = Math.max(output, Math.max(0, -left) + Math.max(0, -(-left - machines[i])));\\n        left += machines[i++];\\n    }\\n    return output;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688334,
                "title": "python-110-ms-solution",
                "content": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        n = len(machines)\\n        if total % n != 0: return -1\\n        target = total//n\\n        count = 0\\n        toRight = 0\\n        for m in machines:\\n            toRight += m-target\\n            count = max(count,abs(toRight),m-target)\\n        return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total = sum(machines)\\n        n = len(machines)\\n        if total % n != 0: return -1\\n        target = total//n\\n        count = 0\\n        toRight = 0\\n        for m in machines:\\n            toRight += m-target\\n            count = max(count,abs(toRight),m-target)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560549,
                "title": "python-with-math-explanation",
                "content": "Consider average as `l` it is the value every waching machine should have at the end. Consider washing machine that has maximal dresses at the moment, it can reach `l` in `max(machines) - l` steps. \\n\\nConsider consequent prefix from `0 to k - 1` machines, they overall need to have `l * k` dresses at the end, but if now they have `sum(machines[0:k])` dresses, if it is less than `l * k` then at each step this sum can increase only by one! since the dress will need to come from `k`th machine in front one at a time. Thus to make prefix satisfy final condition we need `l * k - sum(machines[0:k])` steps, similar for all prefixes and suffixes. And mathematical magic is that taking maximum of these values is the answer! \\n\\nTo prove it we need to show that each step we can decrease this maximum by one, it will take long technical details but we can show that the following procedure at each step actually works (it doesnt need to be coded, just for a proof). Consider any waching machine that currently has `d` dresses and `d >= l`. Consider left prefix before this machine and right suffix after this waching machine, check which one has higher value of `l * len(prefix) - sum(prefix)` or `l * len(suffix) - sum(suffix)`, then forward dress from the machine to the prefix or suffix with the higher mentioned value. \\n\\n```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        summ = sum(machines)\\n        n, l = len(machines), summ // len(machines)\\n        if summ % n != 0: return -1\\n\\n        maxx = max(machines) - l\\n        left_sum, right_sum = 0, 0\\n        for k in range(1, n + 1):\\n            left_sum += machines[k - 1]\\n            right_sum += machines[n - k]\\n            maxx = max(maxx, l * k - left_sum, l * k - right_sum)\\n\\n        return maxx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        summ = sum(machines)\\n        n, l = len(machines), summ // len(machines)\\n        if summ % n != 0: return -1\\n\\n        maxx = max(machines) - l\\n        left_sum, right_sum = 0, 0\\n        for k in range(1, n + 1):\\n            left_sum += machines[k - 1]\\n            right_sum += machines[n - k]\\n            maxx = max(maxx, l * k - left_sum, l * k - right_sum)\\n\\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037771,
                "title": "c-o-n-time-o-1-space-find-the-number-of-clothes-that-need-to-move-through-each-washing-machine",
                "content": "The number of clothes that have to move through a washing machine = abs(prefix clothes sum - suffix clothes sum)\\n```\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        int total = accumulate(machines.begin(), machines.end(), 0); \\n        if (total % n != 0) {\\n            return -1;\\n        }\\n        int final_ct = total/n;\\n        int suff = total;\\n        int pref = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            pref += machines[i];\\n            \\n            ans = max(ans, max(0, pref - (i + 1) * final_ct) + max(0, suff - (n - i) * final_ct)); \\n            suff -= machines[i];\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        int total = accumulate(machines.begin(), machines.end(), 0); \\n        if (total % n != 0) {\\n            return -1;\\n        }\\n        int final_ct = total/n;\\n        int suff = total;\\n        int pref = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            pref += machines[i];\\n            \\n            ans = max(ans, max(0, pref - (i + 1) * final_ct) + max(0, suff - (n - i) * final_ct)); \\n            suff -= machines[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 707942,
                "title": "java-o-n-solution",
                "content": "\\tclass Solution {\\n    public int findMinMoves(int[] arr) {\\n        int sum = 0;\\n        int N = arr.length;\\n        for (int i : arr) {\\n            sum += i;\\n        }\\n        if (sum % N != 0) {\\n            return -1;\\n        }\\n        int each = sum / N; \\n        int min = Integer.MIN_VALUE;\\n        int leftSum = 0;\\n       \\n        for (int i = 0; i < N; i++) {\\n            //\\u5DE6\\u4FA7\\u9700\\u8981\\u5904\\u7406\\u7684\\u4EF6\\u6570\\n            int leftToHandle = leftSum - i * each; \\n            //\\u53F3\\u4FA7\\u9700\\u8981\\u5904\\u7406\\u7684\\u4EF6\\u6570\\n            int rightToHandle = sum - leftSum - arr[i] - (N - i - 1) * each;\\n            if (leftToHandle < 0 && rightToHandle < 0) {\\n                min = Math.max(min, Math.abs(leftToHandle) + Math.abs(rightToHandle));\\n            } else {\\n                min = Math.max(min, Math.max(Math.abs(leftToHandle), Math.abs(rightToHandle)));\\n            }\\n             leftSum += arr[i]; //\\u5DE6\\u4FA7\\u7684\\u73B0\\u6709\\u603B\\u6570\\n        }\\n\\n        return min;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findMinMoves(int[] arr) {\\n        int sum = 0;\\n        int N = arr.length;\\n        for (int i : arr) {\\n            sum += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 420695,
                "title": "c-o-n-solution-with-constant-space",
                "content": "### Variable Explantion\\n1\\uFF09`sum`: the number of all dresses\\n2\\uFF09`need`: the average dresses that each machine need (`need = sum / n`)\\n3\\uFF09`cur`\\uFF1Athe moves of current machines \\n4\\uFF09`next`: the moves of next machines \\n\\n### Explantion\\n1\\uFF09Judge whether all machinesc can have the same number of dresses\\n2\\uFF09Suppose that `machines[i]` is the current machine, \\na\\uFF09If `machines[i] < need`, we need move `need - machines[i + 1]` dresses from `machines[i + 1]`, and thus update the  `next = need - machines[i]`;  \\nb\\uFF09If `machines[i] > need`, we need move `machines[i] - need` dresses to `machines[i + 1]`, and thus update that `cur += machines[i] - need;`\\nc\\uFF09Update the result ` res = max(res, max(cur, next));` \\nd\\uFF09Let `cur = next;  next = 0;` and process the next machine\\n\\n### Complexity\\nTime complexity: O(N)\\nSpace complexity: O(1)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        int sum = accumulate(machines.begin(), machines.end(), 0);\\n        if(sum % n != 0) return -1;\\n        \\n        int res = 0;\\n        int need = sum / n, cur = 0, next = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            machines[i + 1] += machines[i] - need;\\n            if(machines[i] > need) cur += machines[i] - need;\\n            else next = need - machines[i];\\n            res = max(res, max(cur, next));\\n            cur = next; next = 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        int sum = accumulate(machines.begin(), machines.end(), 0);\\n        if(sum % n != 0) return -1;\\n        \\n        int res = 0;\\n        int need = sum / n, cur = 0, next = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            machines[i + 1] += machines[i] - need;\\n            if(machines[i] > need) cur += machines[i] - need;\\n            else next = need - machines[i];\\n            res = max(res, max(cur, next));\\n            cur = next; next = 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417214,
                "title": "a-proof-by-each-machine-act-greedily-and-independently",
                "content": "Three key observations:\\n\\n1. For each washing machine,  a valid move is the machine actively pass a dress to its neighbor, not receiving a dress passively, therefore we only consider those **actively passing a dress**  as a valid move;\\n2. For indivisual washing machine, it has two objects, one is to balance itself, and another one is to balance its left neighbors and right neighbors, therefore each washing machine\\'s moves are composed of two parts, first move its surplus if it does have, second act as a communicate node to pass dresses from left to right (or right to left);\\n3. Each washing machine move greedily to achieve its goals and we can think of them act independently, therefore we only care about the one with the most moves to achieve its target\\n\\n```python\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, right, left = total // n, 0, total, 0\\n        for i in range(n):\\n            cur, left, right = machines[i], (0 if i==0 else left+machines[i-1]), right-machines[i]\\n            # print(i,left,cur,right)\\n            res = max(res,max(0,-(left-target*i)), max(0,cur-target), max(0,-(right-target*(n-1-i))))\\n            # print(res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, right, left = total // n, 0, total, 0\\n        for i in range(n):\\n            cur, left, right = machines[i], (0 if i==0 else left+machines[i-1]), right-machines[i]\\n            # print(i,left,cur,right)\\n            res = max(res,max(0,-(left-target*i)), max(0,cur-target), max(0,-(right-target*(n-1-i))))\\n            # print(res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179368,
                "title": "python-time-o-n-space-o-1",
                "content": "1.*sumneed*:record the number of dress needed until *i*, the step must be larger than *abs(sumneed)*. Because each machine at each step can get at most one dress from one direction.\\n2.When the number of dress in current machine is larger than *ave*, it must be offloaded. Each step can only offload one dress. \\n3.The maximum step is max(1,2). \\n```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tot = sum(machines)\\n        L = len(machines)\\n        if tot%L!=0:\\n            return -1\\n        ave = tot//L\\n        sumneed = 0\\n        res = 0\\n        for m in machines:\\n            sumneed += m-ave\\n            res = max(res,abs(sumneed),m-ave)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tot = sum(machines)\\n        L = len(machines)\\n        if tot%L!=0:\\n            return -1\\n        ave = tot//L\\n        sumneed = 0\\n        res = 0\\n        for m in machines:\\n            sumneed += m-ave\\n            res = max(res,abs(sumneed),m-ave)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149080,
                "title": "logical-thinking-with-java-code-beats-90-18",
                "content": "**Logical Thinking**\\nIf for any machine, its left part as a whole and right part as a whole satisfy their corresponding target sum, all the washing machines are promised to reach the target, i.e., `avg`.\\nFor a machine, it will need `dist` moves to enable its left part and right part satisfy their corresponding target sum. The final result `minDistToContainsAllDists` should be the maximum one among all `dist`s.\\n\\nHow do we calculate the `dist` for `machine[k]`?\\nWe need to figure out `dist`s of these two parts to reach their target separately, and decide whether they can be adjusted in the same move.\\n```\\n| --------- k ------- |\\n  leftDist   rightDist\\n```\\nWe define `leftSum` as cumulative sum for [0, k-1],  `leftDist` will be `leftSum - avg * k`. `rightSum` as cumulative sum for [k+1, machines.length - 1], `rightDist` will be `rightSum - avg * (machines.length - k - 1)`.\\n\\n**Clear Java Code**\\n```\\n    public int findMinMoves(int[] machines) {\\n\\n        int[] cumulativeSum = getCumulativeSum(machines);\\n\\n        if (cumulativeSum[machines.length - 1] % machines.length != 0) {\\n            return -1;\\n        }\\n        int avg = cumulativeSum[machines.length - 1] / machines.length;\\n        int leftSum = 0, rightSum = 0, leftDist = 0, rightDist = 0;\\n        int dist = 0, minDistToContainsAllDists = Integer.MIN_VALUE;\\n\\n        for (int k = 0; k < machines.length; k++) {\\n            leftSum = (k == 0) ? 0 : cumulativeSum[k - 1];\\n            leftDist = leftSum - k * avg;\\n            rightSum = cumulativeSum[machines.length - 1] - cumulativeSum[k];\\n            rightDist = rightSum - (machines.length - 1 - k) * avg;\\n            if (leftDist > 0 && rightDist > 0) {\\n                //just care the side with more moves that needs to be brought down. the side with less moves is covered by side of more moves\\n                dist = Math.max(leftDist, rightDist);\\n            } else if (leftDist < 0 && rightDist < 0) {\\n                //flowing from k to both sides, since one time only one side, so total movement is sum of both\\n                dist = -leftDist -rightDist;\\n            } else {\\n                //one positive, one negative, just imagine it is a gap(positive number) to fill\\n                dist = Math.max(Math.abs(leftDist) , Math.abs(rightDist));\\n            }\\n            minDistToContainsAllDists = Math.max(minDistToContainsAllDists, dist);\\n        }\\n\\n        return minDistToContainsAllDists;\\n    }\\n\\n    private int[] getCumulativeSum(int[] machines) {\\n        int[] cumulativeSum = new int[machines.length];\\n        for (int i = 0; i < machines.length; i++) {\\n            cumulativeSum[i] = (i == 0) ? machines[i] : cumulativeSum[i - 1] + machines[i];\\n        }\\n        return cumulativeSum;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n| --------- k ------- |\\n  leftDist   rightDist\\n```\n```\\n    public int findMinMoves(int[] machines) {\\n\\n        int[] cumulativeSum = getCumulativeSum(machines);\\n\\n        if (cumulativeSum[machines.length - 1] % machines.length != 0) {\\n            return -1;\\n        }\\n        int avg = cumulativeSum[machines.length - 1] / machines.length;\\n        int leftSum = 0, rightSum = 0, leftDist = 0, rightDist = 0;\\n        int dist = 0, minDistToContainsAllDists = Integer.MIN_VALUE;\\n\\n        for (int k = 0; k < machines.length; k++) {\\n            leftSum = (k == 0) ? 0 : cumulativeSum[k - 1];\\n            leftDist = leftSum - k * avg;\\n            rightSum = cumulativeSum[machines.length - 1] - cumulativeSum[k];\\n            rightDist = rightSum - (machines.length - 1 - k) * avg;\\n            if (leftDist > 0 && rightDist > 0) {\\n                //just care the side with more moves that needs to be brought down. the side with less moves is covered by side of more moves\\n                dist = Math.max(leftDist, rightDist);\\n            } else if (leftDist < 0 && rightDist < 0) {\\n                //flowing from k to both sides, since one time only one side, so total movement is sum of both\\n                dist = -leftDist -rightDist;\\n            } else {\\n                //one positive, one negative, just imagine it is a gap(positive number) to fill\\n                dist = Math.max(Math.abs(leftDist) , Math.abs(rightDist));\\n            }\\n            minDistToContainsAllDists = Math.max(minDistToContainsAllDists, dist);\\n        }\\n\\n        return minDistToContainsAllDists;\\n    }\\n\\n    private int[] getCumulativeSum(int[] machines) {\\n        int[] cumulativeSum = new int[machines.length];\\n        for (int i = 0; i < machines.length; i++) {\\n            cumulativeSum[i] = (i == 0) ? machines[i] : cumulativeSum[i - 1] + machines[i];\\n        }\\n        return cumulativeSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99196,
                "title": "c-o-n-with-o-1-space",
                "content": "Scan from left to right, at each point count how many net number of dresses needs to move through that point (could be a positive value if surplus on left side, or negative if surplus on right side). Point with maximum absolute value will decide how many total movements needed. However machines with surplus dresses can only give away one dress at a time, even though machines can receive multiple dresses at same time (one from left, another from right). Because of this constraint, machine with highest surplus would also become another bottleneck.\\n\\n```\\npublic int FindMinMoves(int[] machines) {\\n        int n = machines.Length, sum = 0;\\n        for(int i = 0; i < n; i++) sum += machines[i];\\n        \\n        if (sum % n != 0) return -1;\\n        int t = sum / n, d = 0, max = 0;\\n        for(int i = 0; i < n; i++) {\\n            int diff = (machines[i] - t); // dress surplus or deficit\\n            d += diff; // total surplus or deficit so far between index 0 .. i or how many dresses needs to move between 0..i and i..(n-1)\\n            max = Math.Max(max, Math.Abs(d)); // max point with maximum number of movement needed so far\\n            if (diff > 0) max = Math.Max(max, diff); // surplus machines cant give away more than one at a time\\n        }\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int FindMinMoves(int[] machines) {\\n        int n = machines.Length, sum = 0;\\n        for(int i = 0; i < n; i++) sum += machines[i];\\n        \\n        if (sum % n != 0) return -1;\\n        int t = sum / n, d = 0, max = 0;\\n        for(int i = 0; i < n; i++) {\\n            int diff = (machines[i] - t); // dress surplus or deficit\\n            d += diff; // total surplus or deficit so far between index 0 .. i or how many dresses needs to move between 0..i and i..(n-1)\\n            max = Math.Max(max, Math.Abs(d)); // max point with maximum number of movement needed so far\\n            if (diff > 0) max = Math.Max(max, diff); // surplus machines cant give away more than one at a time\\n        }\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99198,
                "title": "4-liner-8-liner-readable-o-n-solution-with-comments",
                "content": "If array `load[]` represent the load of each super washer, we define the following statistical variables:\\n* sum: `sum = accumulate(load.begin(), load.end(), 0)`;\\n* mean: `m = sum/load.size()`;\\n* deviation: `d[i] = load[i] - m`;\\n* accumulative deviation: `ad = d[0] + d[1] +...+ d[i]`.\\n\\n**Version 1:**\\n```\\n    int findMinMoves(vector<int>& load) {\\n      int sum = accumulate(load.begin(),load.end(),0), m = sum/load.size(), ad = 0, res = 0;\\n      if(sum%load.size()) return -1;\\n      for(int x: load) res = max(max(res,abs(ad += x-m)), x-m);\\n      return res;\\n    }\\n```\\n**Version 2:**\\n```\\n    int findMinMoves(vector<int>& load) {\\n        auto b = load.begin(), e = load.end();\\n        int sum = accumulate(b,e,0), m = sum/load.size(), ad = 0;\\n\\n        if(sum%load.size()) return -1; // no solution if not divisible\\n        \\n        transform(b,e,b,[&](int x){return x-=m;}); // convert to deviation array\\n        int maxD = *max_element(b,e); // max deviation\\n        \\n        transform(b,e,b,[&](int x){return abs(ad+=x);}); // convert to abs accumulative deviation array\\n        int maxAbsD = *max_element(b,e); // max accumulative abs deviation\\n        \\n        return max(maxD, maxAbsD);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    int findMinMoves(vector<int>& load) {\\n      int sum = accumulate(load.begin(),load.end(),0), m = sum/load.size(), ad = 0, res = 0;\\n      if(sum%load.size()) return -1;\\n      for(int x: load) res = max(max(res,abs(ad += x-m)), x-m);\\n      return res;\\n    }\\n```\n```\\n    int findMinMoves(vector<int>& load) {\\n        auto b = load.begin(), e = load.end();\\n        int sum = accumulate(b,e,0), m = sum/load.size(), ad = 0;\\n\\n        if(sum%load.size()) return -1; // no solution if not divisible\\n        \\n        transform(b,e,b,[&](int x){return x-=m;}); // convert to deviation array\\n        int maxD = *max_element(b,e); // max deviation\\n        \\n        transform(b,e,b,[&](int x){return abs(ad+=x);}); // convert to abs accumulative deviation array\\n        int maxAbsD = *max_element(b,e); // max accumulative abs deviation\\n        \\n        return max(maxD, maxAbsD);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99201,
                "title": "my-clean-and-concise-c-solution-by-checking-balance-and-maximum",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int sum=0,maxNum=0;\\n        for(int val:machines)\\n            sum+=val,maxNum=max(maxNum,val);\\n        if(!machines.size()||sum%machines.size()!=0)\\n            return -1;\\n        int ave=sum/machines.size(),res=maxNum-ave,balance=0;\\n        for(int val:machines)\\n        {\\n            balance+=val-ave;\\n            res=max(res,abs(balance));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int sum=0,maxNum=0;\\n        for(int val:machines)\\n            sum+=val,maxNum=max(maxNum,val);\\n        if(!machines.size()||sum%machines.size()!=0)\\n            return -1;\\n        int ave=sum/machines.size(),res=maxNum-ave,balance=0;\\n        for(int val:machines)\\n        {\\n            balance+=val-ave;\\n            res=max(res,abs(balance));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99202,
                "title": "very-simple-java-o-n-solution-with-explaination-in-the-comment",
                "content": "'''\\n \\n    public int findMinMoves(int[] machines) {\\n        if ((machines == null) || (machines.length <= 1)) return 0;\\n        long sum = 0;\\n        for (final int machine : machines) sum += machine;\\n        if ((sum % machines.length) != 0) return -1;\\n        final int avg = (int)(sum / machines.length);\\n        if (machines.length == 2) return Math.max(machines[0], machines[1]) - avg;\\n        \\n        /*\\n         * The main idea is that we only need to find out the machine which needs the maximum moves.\\n         * This maximum moves is the min moves to make all the machine having same dresses.\\n         */\\n\\t\\tint moves = 0, giveToNext = 0, tmp = 0;\\n\\t\\tfor (final int machine : machines) {\\n\\t\\t\\ttmp = machine + giveToNext -avg;\\n\\t\\t\\tmoves = Math.max(moves, getMoves(giveToNext, tmp));\\n\\t\\t\\tgiveToNext = tmp;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn moves;\\t\\n    }\\n    \\n    private static int getMoves(final int gotFromPrev, final int giveToNext) {\\n    \\tif (gotFromPrev >= 0) { \\n    \\t\\t/* \\n    \\t\\t * In this case, this machine has got some dresses from prev machine.\\n    \\t\\t * Then \\n    \\t\\t * (1) if giveToNext >= 0, it means this machine also needs to move some dresses to next machine,\\n    \\t\\t * so the giveToNext = the necessary moves happening on this machine.\\n    \\t\\t * (2) if giveToNext < 0, it means the next machine needs to move some dresses to this machine,\\n    \\t\\t * so the necessary moves happening on this machine itself = 0.\\n    \\t\\t */\\n    \\t\\treturn giveToNext >= 0 ? giveToNext : 0;\\n    \\t} else {\\n    \\t\\t/* \\n    \\t\\t * In this case, this machine has to move some dresses to prev machine.\\n    \\t\\t * So at least, the necessary moves on this machine is already (-gotFromPrev).\\n    \\t\\t * Then \\n    \\t\\t * (1) if giveToNext >= 0, it means this machine also needs to move some dresses to next machine,\\n    \\t\\t * so the necessary moves happening on this machine = giveToNext + (-gotFromPrev)\\n    \\t\\t * (2) if giveToNext < 0, it means the next machine needs to move some dresses to this machine,\\n    \\t\\t * so the necessary moves happening on this machine itself is just (-gotFromPrev).\\n    \\t\\t */\\n    \\t\\treturn giveToNext >= 0 ? giveToNext-gotFromPrev : -gotFromPrev;\\n    \\t}\\n    }\\n\\n'''",
                "solutionTags": [],
                "code": "'''\\n \\n    public int findMinMoves(int[] machines) {\\n        if ((machines == null) || (machines.length <= 1)) return 0;\\n        long sum = 0;\\n        for (final int machine : machines) sum += machine;\\n        if ((sum % machines.length) != 0) return -1;\\n        final int avg = (int)(sum / machines.length);\\n        if (machines.length == 2) return Math.max(machines[0], machines[1]) - avg;\\n        \\n        /*\\n         * The main idea is that we only need to find out the machine which needs the maximum moves.\\n         * This maximum moves is the min moves to make all the machine having same dresses.\\n         */\\n\\t\\tint moves = 0, giveToNext = 0, tmp = 0;\\n\\t\\tfor (final int machine : machines) {\\n\\t\\t\\ttmp = machine + giveToNext -avg;\\n\\t\\t\\tmoves = Math.max(moves, getMoves(giveToNext, tmp));\\n\\t\\t\\tgiveToNext = tmp;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn moves;\\t\\n    }\\n    \\n    private static int getMoves(final int gotFromPrev, final int giveToNext) {\\n    \\tif (gotFromPrev >= 0) { \\n    \\t\\t/* \\n    \\t\\t * In this case, this machine has got some dresses from prev machine.\\n    \\t\\t * Then \\n    \\t\\t * (1) if giveToNext >= 0, it means this machine also needs to move some dresses to next machine,\\n    \\t\\t * so the giveToNext = the necessary moves happening on this machine.\\n    \\t\\t * (2) if giveToNext < 0, it means the next machine needs to move some dresses to this machine,\\n    \\t\\t * so the necessary moves happening on this machine itself = 0.\\n    \\t\\t */\\n    \\t\\treturn giveToNext >= 0 ? giveToNext : 0;\\n    \\t} else {\\n    \\t\\t/* \\n    \\t\\t * In this case, this machine has to move some dresses to prev machine.\\n    \\t\\t * So at least, the necessary moves on this machine is already (-gotFromPrev).\\n    \\t\\t * Then \\n    \\t\\t * (1) if giveToNext >= 0, it means this machine also needs to move some dresses to next machine,\\n    \\t\\t * so the necessary moves happening on this machine = giveToNext + (-gotFromPrev)\\n    \\t\\t * (2) if giveToNext < 0, it means the next machine needs to move some dresses to this machine,\\n    \\t\\t * so the necessary moves happening on this machine itself is just (-gotFromPrev).\\n    \\t\\t */\\n    \\t\\treturn giveToNext >= 0 ? giveToNext-gotFromPrev : -gotFromPrev;\\n    \\t}\\n    }\\n\\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 99195,
                "title": "python-72ms-o-n-solution",
                "content": "Take any machine for example, calculate how many dresses its left-hand side machines need, and right-hand side, note those two number is `l` and `r`.\\n1. If l and r both are greater than 0, then the current machine should export its dresses, and in `l + r` moves.\\n2. If l and r are both less than or equal to 0, then the current machine should import or export dresses in `abs(l + r)` moves.\\n3. Elsewise, both left and right machines should export dresses to the current machine, but still in `abs(l + r)` moves.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length, sum0 = len(machines), sum(machines)\\n        if sum0 % length:\\n            return -1\\n        avg, most, sum1 = sum0 / length, 0, 0\\n        for idx, i in enumerate(machines):\\n            sum1 += idx and machines[idx-1]\\n            sum0 -= machines[idx]\\n            l = idx * avg - sum1\\n            r = (length - idx - 1) * avg - sum0\\n            if l > 0 and r > 0:\\n                most = max((l + r), most)\\n            else:\\n                most = max(most, abs(l), abs(r))\\n```\\n        return most",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length, sum0 = len(machines), sum(machines)\\n        if sum0 % length:\\n            return -1\\n        avg, most, sum1 = sum0 / length, 0, 0\\n        for idx, i in enumerate(machines):\\n            sum1 += idx and machines[idx-1]\\n            sum0 -= machines[idx]\\n            l = idx * avg - sum1\\n            r = (length - idx - 1) * avg - sum0\\n            if l > 0 and r > 0:\\n                most = max((l + r), most)\\n            else:\\n                most = max(most, abs(l), abs(r))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049772,
                "title": "easy-o-n-approach-prefix-sum",
                "content": "# Intuition\\nThe goal of this solution is to find the minimum number of moves required to distribute dresses evenly among a set of machines. The intuition behind the solution is to calculate the expected number of dresses each machine should have, and then iterate through the machines to calculate the difference between the actual number of dresses and the expected number of dresses for each machine. The maximum of these differences represents the minimum number of moves needed to balance the distribution.\\n\\n# Approach\\nHere\\'s a step-by-step approach to understand the solution:\\n\\n1. **Calculate the Total Number of Dresses**: Initialize a variable `dresses` to keep track of the total number of dresses in all the machines. Iterate through the `machines` vector and add up the number of dresses in each machine.\\n\\n2. **Check if Even Distribution is Possible**: If the total number of dresses (`dresses`) is not divisible by the number of machines (`n`), return -1 because it\\'s impossible to distribute the dresses evenly.\\n\\n3. **Calculate the Expected Number of Dresses Per Machine**: Divide the total number of dresses (`dresses`) by the number of machines (`n`) to calculate the expected number of dresses each machine should have. Store this value in the `distri` variable.\\n\\n4. **Initialize Variables**: Initialize two variables `k` and `ans` to keep track of the cumulative difference between the actual number of dresses and the expected number of dresses, and the maximum difference encountered so far, respectively. Initially, both `k` and `ans` are set to 0.\\n\\n5. **Iterate Through Machines**: Loop through the `machines` vector again. For each machine, calculate the difference between the actual number of dresses and the expected number of dresses (i.e., `dress - distri`) and add it to the `k` variable. Update the `ans` variable by taking the maximum value among the current difference, the previous `ans` value, and the absolute value of `k`. This step ensures that `ans` always stores the maximum imbalance encountered during the iteration.\\n\\n6. **Return the Minimum Moves**: After the loop, the `ans` variable will hold the minimum number of moves needed to balance the distribution of dresses. Return `ans` as the result.\\n\\nOverall, this solution effectively computes the minimum moves required to balance the distribution of dresses among machines by calculating the differences between the actual and expected dress counts for each machine and keeping track of the maximum difference encountered.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int dresses = 0, k = 0, ans = 0;\\n        int n = machines.size();\\n\\n        for(int dress: machines) {\\n            dresses += dress;\\n        }\\n\\n        if(dresses % n != 0)\\n            return -1;\\n        \\n        int distri = dresses / n;\\n\\n        for(int dress: machines){\\n            k += dress-distri;\\n            ans = max({(dress-distri),ans,abs(k)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int dresses = 0, k = 0, ans = 0;\\n        int n = machines.size();\\n\\n        for(int dress: machines) {\\n            dresses += dress;\\n        }\\n\\n        if(dresses % n != 0)\\n            return -1;\\n        \\n        int distri = dresses / n;\\n\\n        for(int dress: machines){\\n            k += dress-distri;\\n            ans = max({(dress-distri),ans,abs(k)});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038972,
                "title": "easy-and-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Calculate the total number of dresses (totalDresses) by summing up all elements in the machines array.\\n\\n- Check if the total number of dresses can be evenly distributed among the machines. If not, return -1.\\n\\n- Calculate the target number of dresses (target) that each machine should have. This is equal to totalDresses / n.\\n\\n- Initialize moves and accumulatedDiff to keep track of the minimum moves required and the accumulated difference between the dresses and the target.\\n\\n- Iterate through the machines:\\na. Calculate the difference (diff) between the number of dresses in the current machine and the target.\\nb. Update accumulatedDiff by adding diff.\\nc. Update moves to be the maximum of moves, abs(accumulatedDiff), and diff.\\n\\n- Return the minimum moves required.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        \\n        int totalDresses = 0;\\n        for (int machine : machines) {\\n            totalDresses += machine;\\n        }\\n        \\n        if (totalDresses % n != 0) {\\n            return -1; // If total dresses can\\'t be evenly distributed, return -1\\n        }\\n        \\n        int target = totalDresses / n; // Target number of dresses each machine should have\\n        \\n        int moves = 0;\\n        int accumulatedDiff = 0; // Accumulated difference between dresses and target\\n        \\n        for (int i = 0; i < n; i++) {\\n            int diff = machines[i] - target;\\n            accumulatedDiff += diff;\\n            moves = Math.max(moves, Math.max(Math.abs(accumulatedDiff), diff));\\n        }\\n        \\n        return moves;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        \\n        int totalDresses = 0;\\n        for (int machine : machines) {\\n            totalDresses += machine;\\n        }\\n        \\n        if (totalDresses % n != 0) {\\n            return -1; // If total dresses can\\'t be evenly distributed, return -1\\n        }\\n        \\n        int target = totalDresses / n; // Target number of dresses each machine should have\\n        \\n        int moves = 0;\\n        int accumulatedDiff = 0; // Accumulated difference between dresses and target\\n        \\n        for (int i = 0; i < n; i++) {\\n            int diff = machines[i] - target;\\n            accumulatedDiff += diff;\\n            moves = Math.max(moves, Math.max(Math.abs(accumulatedDiff), diff));\\n        }\\n        \\n        return moves;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016693,
                "title": "super-washing-machines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} machines\\n * @return {number}\\n */\\nvar findMinMoves = function(machines) {\\n    const totalDresses = machines.reduce((acc, dresses) => acc + dresses, 0);\\n    const numMachines = machines.length;\\n    if (totalDresses % numMachines !== 0) {\\n        return -1; // Cannot distribute dresses equally\\n    }\\n    const targetDresses = totalDresses / numMachines;\\n    let balance = 0;\\n    let maxImbalance = 0;\\n    for (let i = 0; i < numMachines; i++) {\\n        const imbalance = machines[i] - targetDresses;\\n        balance += imbalance;\\n        maxImbalance = Math.max(maxImbalance, Math.abs(balance), imbalance);\\n    }\\n    return maxImbalance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} machines\\n * @return {number}\\n */\\nvar findMinMoves = function(machines) {\\n    const totalDresses = machines.reduce((acc, dresses) => acc + dresses, 0);\\n    const numMachines = machines.length;\\n    if (totalDresses % numMachines !== 0) {\\n        return -1; // Cannot distribute dresses equally\\n    }\\n    const targetDresses = totalDresses / numMachines;\\n    let balance = 0;\\n    let maxImbalance = 0;\\n    for (let i = 0; i < numMachines; i++) {\\n        const imbalance = machines[i] - targetDresses;\\n        balance += imbalance;\\n        maxImbalance = Math.max(maxImbalance, Math.abs(balance), imbalance);\\n    }\\n    return maxImbalance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886152,
                "title": "python3-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        totalDresses = sum(machines)\\n        n = len(machines)\\n        \\n        # If total dresses is not divisible by number of machines, return -1\\n        if totalDresses % n != 0:\\n            return -1\\n        \\n        target = totalDresses // n\\n        moves = 0\\n        flow = 0\\n        \\n        for machine in machines:\\n            # Calculate the excess or deficiency for the current machine\\n            diff = machine - target\\n            \\n            # Update the flow\\n            flow += diff\\n            \\n            # Calculate moves for the current machine\\n            moves = max(moves, abs(flow), diff)\\n        \\n        return moves\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        totalDresses = sum(machines)\\n        n = len(machines)\\n        \\n        # If total dresses is not divisible by number of machines, return -1\\n        if totalDresses % n != 0:\\n            return -1\\n        \\n        target = totalDresses // n\\n        moves = 0\\n        flow = 0\\n        \\n        for machine in machines:\\n            # Calculate the excess or deficiency for the current machine\\n            diff = machine - target\\n            \\n            # Update the flow\\n            flow += diff\\n            \\n            # Calculate moves for the current machine\\n            moves = max(moves, abs(flow), diff)\\n        \\n        return moves\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878827,
                "title": "java-o-n-o-1-easy-to-understand-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution of the problem is based on few observations:\\n1. In each step, no matter how many or which machine you choose, only one cloth can be transfered (left->right or right->left) over a single machine. Therefore, at any machine you need to find how many cloths are transfered to left or right. \\n\\n2.  A machine can receieve two cloths from its left and right neighbors in one step. Therefore, if a machine has ($n$) cloths, which is less than the average ($avg$) number  of cloths, then it does not need $avg-n$ steps to reach the target. So, we ignore this case. \\n\\n3. A machine cannot send two cloths to its neighbors in one step. Therefore, if a machine has ($n$) cloths higher than the average ($avg$) number  of cloths it must need $n-avg$ steps to come down to the target. \\n\\nTo find out how many cloths are transfered over a machine, we need to calculate the difference array $n-avg$. Lets assume, the difference array is $[a,b,c,d,e,f,g,h]$. Now, say we want to calculate the number of transfered cloths over machine index $3$. There can be three cases:\\n1.  If $a+b+c+d$ is $0$ then no cloths will be transfered from the right side. \\n2.  If $a+b+c+d > 0$ then $a+b+c+d$ cloths will be transfered from the left side to the right side.\\n3.  If $a+b+c+d < 0$ then $-(a+b+c+d)$ cloths will be transfered from the right side to the left side. \\n\\nTherefore, the maximum number of steps needed is the maximum of these two observations in for each machine. In the implementation, the array is not used to optimize space. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum=0;\\n        for(int n: machines)\\n        {\\n            sum+=n;\\n        }        \\n        int N=machines.length;\\n        if(sum%N>0) return -1;\\n\\n        int avg=sum/N;\\n        int ret=0;\\n\\n        int prefix=0;\\n        for(int n: machines)\\n        {\\n            int diff=n-avg;\\n            prefix+=diff;\\n            ret=Math.max(ret, Math.abs(prefix));\\n            ret=Math.max(ret, diff);\\n        }\\n        return ret;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum=0;\\n        for(int n: machines)\\n        {\\n            sum+=n;\\n        }        \\n        int N=machines.length;\\n        if(sum%N>0) return -1;\\n\\n        int avg=sum/N;\\n        int ret=0;\\n\\n        int prefix=0;\\n        for(int n: machines)\\n        {\\n            int diff=n-avg;\\n            prefix+=diff;\\n            ret=Math.max(ret, Math.abs(prefix));\\n            ret=Math.max(ret, diff);\\n        }\\n        return ret;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815724,
                "title": "java-solution-with-approach-and-intuition-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEither machine has less clothes and needs to borrow or has more and needs to pass the clothes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us borrow and pass extra the clothes from/to right adjacent machine.\\n\\nSo if we do machine[i]-avg it will tell how many clothes are extra or required and we update the next machine with that number.\\n\\nIf change is <0 means we are taking from right we can say clothes passing from right machine(machines[i+1]) will be change, i.e ,what we are borrowing from right.\\n\\nNow if the change was >0 that means machines[i] have more clothes than required  and we are giving extra to right machine so clothes passing from machine[i] will be moves[i]+change meaning given to left + plus giving to right\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum = 0;\\n        for(int i : machines){\\n            sum+=i;\\n        }\\n\\n        if(sum % machines.length != 0) return -1;\\n        int avg = sum / machines.length;\\n        int moves[] = new int[machines.length];\\n        int ans = 0;\\n        for(int i=0;i<machines.length-1;i++){\\n            int change = machines[i]-avg;\\n            machines[i+1] = machines[i+1]+change;\\n            if(change>0){\\n                moves[i]=moves[i]+change;\\n            }else{\\n                moves[i+1]=-1*change;\\n            }\\n        }\\n        for(int i : moves){\\n            ans=Math.max(i,ans);\\n        }\\n        // System.out.println(Arrays.toString(moves));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int sum = 0;\\n        for(int i : machines){\\n            sum+=i;\\n        }\\n\\n        if(sum % machines.length != 0) return -1;\\n        int avg = sum / machines.length;\\n        int moves[] = new int[machines.length];\\n        int ans = 0;\\n        for(int i=0;i<machines.length-1;i++){\\n            int change = machines[i]-avg;\\n            machines[i+1] = machines[i+1]+change;\\n            if(change>0){\\n                moves[i]=moves[i]+change;\\n            }else{\\n                moves[i+1]=-1*change;\\n            }\\n        }\\n        for(int i : moves){\\n            ans=Math.max(i,ans);\\n        }\\n        // System.out.println(Arrays.toString(moves));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759500,
                "title": "detailed-explanation-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. `int findMinMoves(vector<int>& machines)`: This function takes a vector `machines` representing the number of dresses in each washing machine and returns the minimum number of moves required to equalize the number of dresses in all machines.\\n\\n2. `int n = machines.size()`: We initialize the variable `n` with the number of machines.\\n\\n3. `int sums = 0`: We initialize the variable `sums` to keep track of the total number of dresses in all machines.\\n\\n4. Next, we iterate through each machine in the `machines` vector using a range-based loop. In each iteration, we add the number of dresses in the current machine to the `sums` variable.\\n\\n5. After calculating the sum of dresses in all machines, we check if the sum is divisible by the number of machines (`n`). If it\\'s not divisible, it means an equal distribution of dresses is not possible. In such a case, we return -1 as the answer.\\n\\n6. If the sum is divisible by `n`, we proceed to calculate the average number of dresses that each machine should have after equal distribution. We calculate the average by dividing the total sum (`sums`) by the number of machines (`n`).\\n\\n7. We initialize two variables: `ans` and `count`. `ans` will store the maximum number of moves required, and `count` will keep track of the difference between the number of dresses in each machine and the average.\\n\\n8. Now, we iterate through each machine in the `machines` vector again.\\n\\n9. In each iteration, we update the `count` variable by adding the difference between the number of dresses in the current machine and the average number of dresses.\\n\\n\\n10. We also update the `ans` variable by taking the maximum of three values: the current value of `ans`, the absolute value of `count`, and the difference between the number of dresses in the current machine and the average. This is done to keep track of the maximum moves required to balance the dresses across machines.\\n\\n11. Finally, we return the value of `ans`, which represents the minimum number of moves required to equalize the number of dresses in all machines.\\n\\nIn summary, the code calculates the minimum number of moves required to balance the number of dresses across machines. It calculates the average number of dresses that each machine should have and then iterates through the machines, keeping track of the difference between the actual number of dresses and the average. By updating the maximum moves required (`ans`), the code finds the optimal solution.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n=machines.size();\\n        int sums=0;\\n        for(auto i:machines) sums+=i;\\n\\n        if(sums%n) return -1;\\n\\n        int avg=sums/n;\\n        int ans=0,count=0;\\n\\n        for(auto i:machines)\\n        {\\n            count+=i-avg;\\n            ans=max(ans,max(abs(count),i-avg));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n=machines.size();\\n        int sums=0;\\n        for(auto i:machines) sums+=i;\\n\\n        if(sums%n) return -1;\\n\\n        int avg=sums/n;\\n        int ans=0,count=0;\\n\\n        for(auto i:machines)\\n        {\\n            count+=i-avg;\\n            ans=max(ans,max(abs(count),i-avg));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682553,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findMinMoves(machines: Array[Int]): Int = {\\n      val total = machines.sum\\n      if (total % machines.length != 0) -1\\n      else {\\n        val avg = total / machines.length\\n        machines.foldLeft((0, 0)) { case ((cnt, max), load) =>\\n          (cnt + load - avg, math.max(math.max(max, math.abs(cnt)), load - avg))\\n        }._2\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findMinMoves(machines: Array[Int]): Int = {\\n      val total = machines.sum\\n      if (total % machines.length != 0) -1\\n      else {\\n        val avg = total / machines.length\\n        machines.foldLeft((0, 0)) { case ((cnt, max), load) =>\\n          (cnt + load - avg, math.max(math.max(max, math.abs(cnt)), load - avg))\\n        }._2\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3594540,
                "title": "c-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNor really\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMax (diff, accumulated diff) for each point, and the highst max\\n# Complexity\\n- Time complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {      \\n        int sum = accumulate(machines.begin(), machines.end(), 0);\\n        int n = machines.size();\\n        if (sum%n) return -1;\\n        int avg = sum/n;\\n        int extra = 0;\\n        int ans = 0;\\n        int m1 = 0;\\n        for(auto &m: machines)\\n        {\\n            extra = (m+extra-avg);\\n            ans = max(ans,max(m-avg,abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {      \\n        int sum = accumulate(machines.begin(), machines.end(), 0);\\n        int n = machines.size();\\n        if (sum%n) return -1;\\n        int avg = sum/n;\\n        int extra = 0;\\n        int ans = 0;\\n        int m1 = 0;\\n        for(auto &m: machines)\\n        {\\n            extra = (m+extra-avg);\\n            ans = max(ans,max(m-avg,abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557475,
                "title": "scala-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\niterate over the machines, adjusting the balance of items and keeping track of the maximum imbalance encountered.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nobject Solution {\\n    def findMinMoves(machines: Array[Int]): Int = {\\n        val sum = machines.sum\\n        val l = machines.length\\n        if (sum % l != 0) return -1\\n        if (l == 0) return 0\\n        val med = (sum / l).toInt\\n        var b = 0\\n        var r = 0\\n        machines.foreach(a =>{\\n            val c = a - med\\n            b += c\\n            r = r max (c max b.abs)\\n        })\\n        r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findMinMoves(machines: Array[Int]): Int = {\\n        val sum = machines.sum\\n        val l = machines.length\\n        if (sum % l != 0) return -1\\n        if (l == 0) return 0\\n        val med = (sum / l).toInt\\n        var b = 0\\n        var r = 0\\n        machines.foreach(a =>{\\n            val c = a - med\\n            b += c\\n            r = r max (c max b.abs)\\n        })\\n        r\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3548429,
                "title": "greedy-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- toLeft[i]: machine in ith position pass number of clothes to it\\'s left side\\n- toRight[i]: machine in ith position pass number of clothes to it\\'s right side\\n- -toLeft[i]: machine in (i-1)th position pass number of clothes to it\\'s right side, equals toRight[i - 1]\\n- -toRight[i]: machine in (i + 1)th position pass number of clothes to it\\'s left side, equals toLeft[i + 1]\\n- -toLeft[i + 1] = toRight[i]\\n- toLeft[i] + toRight[i] = m - target \\n- - toLeft = -toRight # for the above state\\n- - toRight = m + toRight - target # for the above state\\n- the final result can be pass from left or pass from right, or pass from left and right, here I used t for these 3 cases\\n- vote up if helps\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, toRight = total // n, 0, 0\\n        for m in machines:\\n            t = 0\\n            toLeft = -toRight\\n            toRight = m + toRight - target\\n            if toLeft >= 0: t += toLeft\\n            if toRight >= 0: t += toRight\\n            res = max(res, t)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total, n = sum(machines), len(machines)\\n        if total % n: return -1\\n        target, res, toRight = total // n, 0, 0\\n        for m in machines:\\n            t = 0\\n            toLeft = -toRight\\n            toRight = m + toRight - target\\n            if toLeft >= 0: t += toLeft\\n            if toRight >= 0: t += toRight\\n            res = max(res, t)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532945,
                "title": "rust-solution-with-prefix-sum-o-n-o-1",
                "content": "# Approach\\nThis solution uses prefix sums to solve the problem. The main idea is to calculate the average dresses for all machines, and then calculate the left and right transfer sum for each machine. We iterate over the machines and keep track of the maximum of these transfer sums as the minimum moves required. If the total number of dresses isn\\'t divisible by the number of machines, it means we can\\'t distribute the dresses evenly, and we return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    \\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        let total: i32 = machines.iter().sum();\\n        let machines_size = machines.len() as i32;\\n        \\n        if total % machines_size != 0 {\\n            return -1;\\n        }\\n\\n        let avg = total / machines_size;\\n        let mut cnt = 0;\\n        let mut max_cnt = 0;\\n\\n        for i in 0..machines_size {\\n            cnt += machines[i as usize] - avg;\\n            max_cnt = max_cnt.max((cnt.abs()).max(machines[i as usize] - avg));\\n        }\\n\\n        max_cnt\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution {\\n    \\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        let total: i32 = machines.iter().sum();\\n        let machines_size = machines.len() as i32;\\n        \\n        if total % machines_size != 0 {\\n            return -1;\\n        }\\n\\n        let avg = total / machines_size;\\n        let mut cnt = 0;\\n        let mut max_cnt = 0;\\n\\n        for i in 0..machines_size {\\n            cnt += machines[i as usize] - avg;\\n            max_cnt = max_cnt.max((cnt.abs()).max(machines[i as usize] - avg));\\n        }\\n\\n        max_cnt\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515255,
                "title": "c-soro",
                "content": "# Intuition\\nGive it a ```dry run```, you well get it.\\n\\n....\\nhey you, yes you.. please do vote this up and let leetcode know you are enjoying what you are watching.\\n\\n\\n# Complexity\\n- Time complexity: ```O(2n)```\\n\\n- Space complexity: ```O(1)``` Cosntant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for(int i = 0; i < machines.size(); i++) sum += machines[i];\\n        if (sum % machines.size() != 0) return -1;\\n    \\n        int dress = sum/machines.size();\\n        int gap = 0, ans = 0;\\n        \\n        for(int i = 0; i < machines.size(); i++){\\n            gap += machines[i] - dress;\\n            ans = max(ans, max(machines[i] - dress, abs(gap)));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dry run```\n```O(2n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum = 0;\\n        for(int i = 0; i < machines.size(); i++) sum += machines[i];\\n        if (sum % machines.size() != 0) return -1;\\n    \\n        int dress = sum/machines.size();\\n        int gap = 0, ans = 0;\\n        \\n        for(int i = 0; i < machines.size(); i++){\\n            gap += machines[i] - dress;\\n            ans = max(ans, max(machines[i] - dress, abs(gap)));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392053,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size() ;\\n        int sum = accumulate(machines.begin(), machines.end(), 0) ;\\n        if(sum % n != 0)\\n            return -1 ;\\n        int k = sum/n ;\\n        vector<int>left(n) ;\\n        vector<int>right(n) ;\\n        left[0] = 0 ;\\n        right[0] = machines[0] - k ;\\n        \\n        for(int i = 1; i < n; i++){\\n            left[i] = -right[i-1] ;\\n            right[i] = machines[i] - left[i] - k ;\\n        }\\n\\n        int ret = 0 ;\\n        for(int i = 0; i < n; i++){\\n            int out = 0 ; \\n            if(left[i] > 0)\\n                out += left[i] ;\\n            if(right[i] > 0)\\n                out += right[i] ;\\n            ret = max(ret, out) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size() ;\\n        int sum = accumulate(machines.begin(), machines.end(), 0) ;\\n        if(sum % n != 0)\\n            return -1 ;\\n        int k = sum/n ;\\n        vector<int>left(n) ;\\n        vector<int>right(n) ;\\n        left[0] = 0 ;\\n        right[0] = machines[0] - k ;\\n        \\n        for(int i = 1; i < n; i++){\\n            left[i] = -right[i-1] ;\\n            right[i] = machines[i] - left[i] - k ;\\n        }\\n\\n        int ret = 0 ;\\n        for(int i = 0; i < n; i++){\\n            int out = 0 ; \\n            if(left[i] > 0)\\n                out += left[i] ;\\n            if(right[i] > 0)\\n                out += right[i] ;\\n            ret = max(ret, out) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300623,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        n, total = len(machines), sum(machines)\\n\\n        if total%n != 0:\\n            return -1\\n\\n        target, running_sum, max_val = total//n, 0, 0\\n\\n        for i in machines:\\n            max_val = max(max_val,abs(running_sum),i-target)\\n            running_sum += i-target\\n\\n        return max_val\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines):\\n        n, total = len(machines), sum(machines)\\n\\n        if total%n != 0:\\n            return -1\\n\\n        target, running_sum, max_val = total//n, 0, 0\\n\\n        for i in machines:\\n            max_val = max(max_val,abs(running_sum),i-target)\\n            running_sum += i-target\\n\\n        return max_val\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298542,
                "title": "javascript-5-line-solution",
                "content": "# Intuition\\nAfter some thought, it stood out to me that since each machine can only move 1 dress per move, the answer would have to be greater than or equal to the greatest difference between the target amount of dresses and the starting amount of a machine. Additionally, the answer would have to be greater than or equal to the largest \"drought\" of dresses. By \"drought\", what I mean is the maximum difference (negative) between the dresses needed to far on an interation cycle, and the dresses possessed. \\n\\n# Approach\\nKeeps track of the surplus of accumulated dresses when iterating from left to right and from right to left. Sets the current answer to the maximum of the accumulated extras as well as the difference between the current machine\\'s extra dresses.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nvar findMinMoves = function(machines) {\\n    let tnum = machines.reduce((a, b)=> a+b)/machines.length,lt = -1,holder=0,rholder=0,x=-1, c=[1,-1];\\nwhile (tnum%1 == 0 && ((x+=c[0]) != - 2) && x >= 0 && x < machines.length && ((holder+=machines[x]-tnum)!= \\'p\\')&&((rholder+=machines[machines.length-(1+x)]-tnum)!= \\'p\\') ){\\n        lt = Math.max(holder, lt,machines[x]-tnum, machines[machines.length-(1+x)]-tnum,rholder, 0)\\n    }\\n     return lt\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMinMoves = function(machines) {\\n    let tnum = machines.reduce((a, b)=> a+b)/machines.length,lt = -1,holder=0,rholder=0,x=-1, c=[1,-1];\\nwhile (tnum%1 == 0 && ((x+=c[0]) != - 2) && x >= 0 && x < machines.length && ((holder+=machines[x]-tnum)!= \\'p\\')&&((rholder+=machines[machines.length-(1+x)]-tnum)!= \\'p\\') ){\\n        lt = Math.max(holder, lt,machines[x]-tnum, machines[machines.length-(1+x)]-tnum,rholder, 0)\\n    }\\n     return lt\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225495,
                "title": "python-3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        res = c = 0\\n        if (sum(machines)%len(machines)) != 0 :\\n            return -1\\n        a = int(sum(machines)/len(machines))\\n        for i in machines :\\n            diff = i - a\\n            c += diff\\n            res = max(abs(c),diff,res)\\n        return res    \\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        res = c = 0\\n        if (sum(machines)%len(machines)) != 0 :\\n            return -1\\n        a = int(sum(machines)/len(machines))\\n        for i in machines :\\n            diff = i - a\\n            c += diff\\n            res = max(abs(c),diff,res)\\n        return res    \\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135550,
                "title": "swift-solution-easy-approach",
                "content": "# Approach\\n1. If the sum of all the clothes is not divisible by the number of machines, return -1\\n2. Calculate the average number of clothes in each machine\\n3. Calculate the left sum and right sum of each machine\\n4. For each machine, calculate the expected number of clothes in the left and right\\n5. If the expected number of clothes in the left is greater than the left sum, add the difference to the left\\n6. If the expected number of clothes in the right is greater than the right sum, add the difference to the right\\n7. The maximum number of moves is the maximum of the left and right\\n8. Return the maximum number of moves\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func findMinMoves(_ machines: [Int]) -> Int {\\n        let n = machines.count\\n        var sum = 0\\n        for num in machines {\\n            sum += num\\n        }\\n        if sum % n != 0 {\\n            return -1\\n        }\\n        let avg = sum / n\\n        var leftSums = [Int](repeating: 0, count: n)\\n        var rightSums = [Int](repeating: 0, count: n)\\n        for i in 1 ..< n {\\n            leftSums[i] = leftSums[i-1] + machines[i-1]\\n        }\\n        for i in (0 ..< n - 1).reversed() {\\n            rightSums[i] = rightSums[i+1] + machines[i+1]\\n        }\\n        var move = 0\\n        for i in 0 ..< n {\\n            let expLeft = i * avg\\n            let expRight = (n - i - 1) * avg\\n            var left = 0\\n            var right = 0\\n            if expLeft > leftSums[i] {\\n                left = expLeft - leftSums[i]\\n            } \\n            if expRight > rightSums[i] {\\n                right = expRight - rightSums[i]\\n            }\\n            move = max(move, left + right)\\n        }\\n        return move\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findMinMoves(_ machines: [Int]) -> Int {\\n        let n = machines.count\\n        var sum = 0\\n        for num in machines {\\n            sum += num\\n        }\\n        if sum % n != 0 {\\n            return -1\\n        }\\n        let avg = sum / n\\n        var leftSums = [Int](repeating: 0, count: n)\\n        var rightSums = [Int](repeating: 0, count: n)\\n        for i in 1 ..< n {\\n            leftSums[i] = leftSums[i-1] + machines[i-1]\\n        }\\n        for i in (0 ..< n - 1).reversed() {\\n            rightSums[i] = rightSums[i+1] + machines[i+1]\\n        }\\n        var move = 0\\n        for i in 0 ..< n {\\n            let expLeft = i * avg\\n            let expRight = (n - i - 1) * avg\\n            var left = 0\\n            var right = 0\\n            if expLeft > leftSums[i] {\\n                left = expLeft - leftSums[i]\\n            } \\n            if expRight > rightSums[i] {\\n                right = expRight - rightSums[i]\\n            }\\n            move = max(move, left + right)\\n        }\\n        return move\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130088,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n       int total = 0; \\n        for(int i: machines) total+=i;\\n        if(total%machines.length!=0) return -1;\\n        int avg = total/machines.length, cnt = 0, max = 0;\\n        for(int load: machines){\\n            cnt += load-avg; //load-avg is \"gain/lose\"\\n            max = Math.max(Math.max(max, Math.abs(cnt)), load-avg);\\n        }\\n        return max;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n       int total = 0; \\n        for(int i: machines) total+=i;\\n        if(total%machines.length!=0) return -1;\\n        int avg = total/machines.length, cnt = 0, max = 0;\\n        for(int load: machines){\\n            cnt += load-avg; //load-avg is \"gain/lose\"\\n            max = Math.max(Math.max(max, Math.abs(cnt)), load-avg);\\n        }\\n        return max;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121682,
                "title": "antarnab-100-faster-cpp-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n        int n= machines.size();\\n        int sum=0;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += machines[i];\\n        }\\n        if(sum % n != 0)\\n            return -1;\\n        int req = sum/n;\\n\\t\\n\\t\\t\\n        int extra =0, ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            extra += machines[i]-req;\\n            ans = max(ans, max(machines[i]-req, abs(extra)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101978,
                "title": "c-o-n-greedy-approach",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        vector <int> x(1+n, 0);\\n        for (int i=1; i<=n; i++)\\n            x[i] = x[i-1] + machines[i-1];\\n        \\n        if (x[n]%n!=0)\\n            return -1;\\n        \\n        int each = x[n]/n;\\n        int ans = 0;\\n        for (int i=1; i<=n; i++)\\n        {\\n            int left = each*i - x[i];\\n            int right = each*(n-i+1) - (x[n]-x[i-1]);\\n            \\n            if (left<0 && right<0)\\n                ans = max(ans, abs(left)+abs(right));\\n            else \\n                ans = max(ans, max(left, right));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int n = machines.size();\\n        vector <int> x(1+n, 0);\\n        for (int i=1; i<=n; i++)\\n            x[i] = x[i-1] + machines[i-1];\\n        \\n        if (x[n]%n!=0)\\n            return -1;\\n        \\n        int each = x[n]/n;\\n        int ans = 0;\\n        for (int i=1; i<=n; i++)\\n        {\\n            int left = each*i - x[i];\\n            int right = each*(n-i+1) - (x[n]-x[i-1]);\\n            \\n            if (left<0 && right<0)\\n                ans = max(ans, abs(left)+abs(right));\\n            else \\n                ans = max(ans, max(left, right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3073987,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n       int n = machines.size(), sum = 0, ans = 0, mid, extra = 0;\\n        \\n        sum = accumulate(machines.begin(),machines.end(), 0);\\n        \\n        mid = sum / n;\\n        \\n        if(sum % n != 0)\\n        {\\n            return -1;\\n        }\\n        \\n        for(auto &x: machines)\\n        {\\n            extra += x - mid;\\n            \\n            ans = max(ans,max(x-mid, abs(extra)));\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) \\n    {\\n       int n = machines.size(), sum = 0, ans = 0, mid, extra = 0;\\n        \\n        sum = accumulate(machines.begin(),machines.end(), 0);\\n        \\n        mid = sum / n;\\n        \\n        if(sum % n != 0)\\n        {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2899143,
                "title": "easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        x=len(machines)\\n        s=sum(machines)\\n        if s%x!=0:\\n            return -1\\n        ave = s/x\\n        prefix = 0\\n        res = 0\\n        for i in range(x):\\n            l= max(i*ave - prefix, 0)\\n            r = max(prefix + machines[i] - (i+1)*ave, 0)\\n            prefix += machines[i]\\n            res = max(l+r, res)\\n        return int(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        x=len(machines)\\n        s=sum(machines)\\n        if s%x!=0:\\n            return -1\\n        ave = s/x\\n        prefix = 0\\n        res = 0\\n        for i in range(x):\\n            l= max(i*ave - prefix, 0)\\n            r = max(prefix + machines[i] - (i+1)*ave, 0)\\n            prefix += machines[i]\\n            res = max(l+r, res)\\n        return int(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886714,
                "title": "python3-clean-and-easy-solution-9-lines-only-o-n",
                "content": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        N, S = len(machines), sum(machines)\\n        if S%N!=0: return -1\\n        T = S//N\\n\\n        ans, run = 0, 0\\n        for i in range(N):\\n            dif = machines[i] - T\\n            run = run + dif\\n            ans = max(ans, dif, abs(run))\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        N, S = len(machines), sum(machines)\\n        if S%N!=0: return -1\\n        T = S//N\\n\\n        ans, run = 0, 0\\n        for i in range(N):\\n            dif = machines[i] - T\\n            run = run + dif\\n            ans = max(ans, dif, abs(run))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883420,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum=0;\\n        int n=machines.size();\\n        for(int i=0;i<machines.size();i++){\\n            sum+= machines[i];\\n        }\\n\\n        if(sum%n>0){\\n            return -1;\\n        }\\n        int req= sum/n;\\n        int right=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            right = machines[i] +right - req;\\n            ans = max(ans,max(abs(right),machines[i]-req));\\n        }\\n        return ans;   \\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int sum=0;\\n        int n=machines.size();\\n        for(int i=0;i<machines.size();i++){\\n            sum+= machines[i];\\n        }\\n\\n        if(sum%n>0){\\n            return -1;\\n        }\\n        int req= sum/n;\\n        int right=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            right = machines[i] +right - req;\\n            ans = max(ans,max(abs(right),machines[i]-req));\\n        }\\n        return ans;   \\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865945,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        let sum: i32 = machines.iter().sum();\\n        let n = machines.len();\\n        if sum % n as i32 != 0 {\\n            return -1;\\n        }\\n        let avg = sum / n as i32;\\n        let mut ans = 0;\\n        let mut cnt = 0;\\n        for &item in machines.iter().take(n) {\\n            cnt += item - avg;\\n            ans = std::cmp::max(ans, std::cmp::max(item - avg, cnt.abs()));\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        let sum: i32 = machines.iter().sum();\\n        let n = machines.len();\\n        if sum % n as i32 != 0 {\\n            return -1;\\n        }\\n        let avg = sum / n as i32;\\n        let mut ans = 0;\\n        let mut cnt = 0;\\n        for &item in machines.iter().take(n) {\\n            cnt += item - avg;\\n            ans = std::cmp::max(ans, std::cmp::max(item - avg, cnt.abs()));\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2760227,
                "title": "96-92-faster-short-simple-clean-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int findMinMoves(vector<int>& machines) {\\n        ll n=machines.size(),total=0;\\n        for(ll i=0;i<n;i++){\\n            total+=machines[i];\\n        }\\n        ll avg=total/n,answer=INT_MIN,pass=0;\\n        if(total%n!=0){\\n            return -1;\\n        }\\n        for(ll i=0;i<n;i++){\\n            pass+=(machines[i]-avg);\\n            answer=max(answer,max(abs(pass),machines[i]-avg));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int findMinMoves(vector<int>& machines) {\\n        ll n=machines.size(),total=0;\\n        for(ll i=0;i<n;i++){\\n            total+=machines[i];\\n        }\\n        ll avg=total/n,answer=INT_MIN,pass=0;\\n        if(total%n!=0){\\n            return -1;\\n        }\\n        for(ll i=0;i<n;i++){\\n            pass+=(machines[i]-avg);\\n            answer=max(answer,max(abs(pass),machines[i]-avg));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619649,
                "title": "java-solution-tc-o-n",
                "content": "public int findMinMoves(int[] machines) {\\n        \\n        int sum=0;\\n        for(int i:machines)\\n            sum+=i;\\n        \\n        if(sum%machines.length!=0)\\n            return -1;\\n        \\n        int target=sum/machines.length;\\n        int count=0,max=0;\\n        \\n            for(int i:machines){   //4,0,0,4\\n                count += i-target; \\n            max = Math.max(Math.max(max, Math.abs(count)), i-target); \\n            }\\n        \\n        return max;\\n    }",
                "solutionTags": [],
                "code": "public int findMinMoves(int[] machines) {\\n        \\n        int sum=0;\\n        for(int i:machines)\\n            sum+=i;\\n        \\n        if(sum%machines.length!=0)\\n            return -1;\\n        \\n        int target=sum/machines.length;\\n        int count=0,max=0;\\n        \\n            for(int i:machines){   //4,0,0,4\\n                count += i-target; \\n            max = Math.max(Math.max(max, Math.abs(count)), i-target); \\n            }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2485327,
                "title": "rant",
                "content": "Thank you for such a un-understandable problem statement. You ruined my day",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2429807,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        long long cnt = 0 , sm = accumulate(machines.begin(),machines.end(),0LL) , n = machines.size();\\n        long long e = sm/n , pref = 0;\\n        if(sm % n) return -1;  // can\\'t distribute \\n        for(int i=0; i<n; i++) {\\n             pref+=machines[i] - e; // remaining clothes \\n             cnt = max(cnt,max(abs(pref),machines[i] - e)); // absolute value of remaining clothes to handle clothes from right to left\\n             // machines[i] - e clothes we have to move , either left or right , we can only move 1 cloth so maximise it with other distributions\\n        }\\n       return cnt;\\n    }\\n};\\n/*\\ncounter approach to not pick the biggest value first at random location!\\nbut we should go from right to left & also left to right \\n// picking the biggest makes it worse , you might distribute unevenly & have to traverse the whole array for one position to make it optimal(equal to e)!\\n1 0 5 0 4\\n1 1 4 0 4\\n1 1 3 1 4\\n1 1 3 2 3\\n1 2 2 2 3\\n2 2 2 2 2\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        long long cnt = 0 , sm = accumulate(machines.begin(),machines.end(),0LL) , n = machines.size();\\n        long long e = sm/n , pref = 0;\\n        if(sm % n) return -1;  // can\\'t distribute \\n        for(int i=0; i<n; i++) {\\n             pref+=machines[i] - e; // remaining clothes \\n             cnt = max(cnt,max(abs(pref),machines[i] - e)); // absolute value of remaining clothes to handle clothes from right to left\\n             // machines[i] - e clothes we have to move , either left or right , we can only move 1 cloth so maximise it with other distributions\\n        }\\n       return cnt;\\n    }\\n};\\n/*\\ncounter approach to not pick the biggest value first at random location!\\nbut we should go from right to left & also left to right \\n// picking the biggest makes it worse , you might distribute unevenly & have to traverse the whole array for one position to make it optimal(equal to e)!\\n1 0 5 0 4\\n1 1 4 0 4\\n1 1 3 1 4\\n1 1 3 2 3\\n1 2 2 2 3\\n2 2 2 2 2\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411134,
                "title": "intuitive-learn-from-others",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int len = machines.size();\\n        int total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % len) return -1;\\n        \\n        int avg = total / len;\\n        vector<int> l2r(len);\\n        vector<int> r2l(len);\\n        \\n        for (int i = 1; i < len; ++i) {\\n            l2r[i] = l2r[i - 1] + machines[i - 1];\\n        }\\n        \\n        for (int i = len - 2; i >= 0; --i) {\\n            r2l[i] = r2l[i + 1] + machines[i + 1];\\n        }\\n        \\n        int move = 0;\\n        \\n        for (int i = 0; i < len; ++i) {\\n            int exp_left = i * avg;\\n            int exp_right = (len - i - 1) * avg;\\n            int left = max(0, exp_left - l2r[i]);\\n            int right = max(0, exp_right - r2l[i]);\\n            move = max(move, left + right);\\n        }\\n        return move;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        int len = machines.size();\\n        int total = accumulate(machines.begin(), machines.end(), 0);\\n        if (total % len) return -1;\\n        \\n        int avg = total / len;\\n        vector<int> l2r(len);\\n        vector<int> r2l(len);\\n        \\n        for (int i = 1; i < len; ++i) {\\n            l2r[i] = l2r[i - 1] + machines[i - 1];\\n        }\\n        \\n        for (int i = len - 2; i >= 0; --i) {\\n            r2l[i] = r2l[i + 1] + machines[i + 1];\\n        }\\n        \\n        int move = 0;\\n        \\n        for (int i = 0; i < len; ++i) {\\n            int exp_left = i * avg;\\n            int exp_right = (len - i - 1) * avg;\\n            int left = max(0, exp_left - l2r[i]);\\n            int right = max(0, exp_right - r2l[i]);\\n            move = max(move, left + right);\\n        }\\n        return move;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275796,
                "title": "8-4-6-3-3-6-in-3-steps-wrong-testing-set",
                "content": "This should take atleast 5 steps:\\n\\n[8, 4, 6, 3, 3, 6]\\n\\n[7, 4, 6, 3, 4, 6]\\n[6, 4, 6, 4, 4, 6]\\n[5, 5, 6, 4, 4, 6]\\n[5, 5, 5, 5, 4, 6]\\n[5, 5, 5, 5, 5, 5]\\n\\nThe expected says 3 but no way it\\'s possible in 3 !\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2249451,
                "title": "linear-runtime-itertools-soiution",
                "content": "```\\n```\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    \\n    def findMinMoves(self, machines: List[int]) -> int:\\n        n = len(machines)\\n        summation = sum(machines)\\n        if summation%n:\\n            return -1\\n        avg = summation//n\\n        left = list(accumulate(machines))\\n        result = 0\\n        for i in range(n):\\n            move_to_right = max(left[i] - (i+1)*avg, 0) \\n            move_to_left = max(left[-1]-(left[i-1] if i!=0 else 0) - (n-i)*avg, 1)\\n            result = max(result, move_to_right + move_to_left)\\n        return result\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200721,
                "title": "java-easy-o-n-solution",
                "content": "```\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length ,totalMoves = 0 ;;\\n        int[] leftSum = new int[n] , rightSum = new int[n];\\n        for(int i = 1; i < n ; i++)\\n            leftSum[i] = leftSum[i-1] + machines[i-1];\\n        int totalSum = leftSum[n-1] + machines[n-1] ;\\n        if(totalSum % n != 0)\\n            return -1;\\n        int average = totalSum/n ;\\n        \\n        for(int i = n-2 ; i>=0 ;i--)\\n            rightSum[i] = rightSum[i+1] + machines[i+1];\\n        //We can see it like this, for each index , how many dresses\\n        //will be passed through it to make its left equal to right \\n        for(int i = 0 ; i< n ; i++){\\n            int expLeftSum = average * i ;\\n            int expRightSum = average * (n-i-1);\\n            int leftPasses = 0 , rightPasses = 0 ;\\n            if(expLeftSum > leftSum[i])\\n                leftPasses = expLeftSum-leftSum[i] ;\\n            if (expRightSum > rightSum[i])\\n                rightPasses = expRightSum-rightSum[i] ;\\n            totalMoves = Math.max(totalMoves,leftPasses + rightPasses);\\n        }\\n        return totalMoves ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length ,totalMoves = 0 ;;\\n        int[] leftSum = new int[n] , rightSum = new int[n];\\n        for(int i = 1; i < n ; i++)\\n            leftSum[i] = leftSum[i-1] + machines[i-1];\\n        int totalSum = leftSum[n-1] + machines[n-1] ;\\n        if(totalSum % n != 0)\\n            return -1;\\n        int average = totalSum/n ;\\n        \\n        for(int i = n-2 ; i>=0 ;i--)\\n            rightSum[i] = rightSum[i+1] + machines[i+1];\\n        //We can see it like this, for each index , how many dresses\\n        //will be passed through it to make its left equal to right \\n        for(int i = 0 ; i< n ; i++){\\n            int expLeftSum = average * i ;\\n            int expRightSum = average * (n-i-1);\\n            int leftPasses = 0 , rightPasses = 0 ;\\n            if(expLeftSum > leftSum[i])\\n                leftPasses = expLeftSum-leftSum[i] ;\\n            if (expRightSum > rightSum[i])\\n                rightPasses = expRightSum-rightSum[i] ;\\n            totalMoves = Math.max(totalMoves,leftPasses + rightPasses);\\n        }\\n        return totalMoves ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145968,
                "title": "python3",
                "content": "```class Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        # check possiblity \\n        if sum(machines) % len(machines):\\n            return -1\\n        ret = 0\\n        target = sum(machines) // len(machines)\\n        left = [0 for i in machines]\\n        right = [0 for i in machines]\\n        #left[i] + right[i] = machines[i] - target         \\n        right[0] = machines[0] - target\\n        \\n        for i in range(1, len(machines)):\\n            left[i] = -right[i-1]\\n            right[i] = machines[i] - left[i] - target\\n        \\n        for x, y in zip(left, right):\\n            # we sum up the output for two different directions else we use the bigger output if they are in the same direction             \\n            ret = max(ret, (x + y)) if x >= 0 and y >= 0 else max(ret, max(x, y))\\n        \\n        return ret",
                "solutionTags": [],
                "code": "```class Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        # check possiblity \\n        if sum(machines) % len(machines):\\n            return -1\\n        ret = 0\\n        target = sum(machines) // len(machines)\\n        left = [0 for i in machines]\\n        right = [0 for i in machines]\\n        #left[i] + right[i] = machines[i] - target         \\n        right[0] = machines[0] - target\\n        \\n        for i in range(1, len(machines)):\\n            left[i] = -right[i-1]\\n            right[i] = machines[i] - left[i] - target\\n        \\n        for x, y in zip(left, right):\\n            # we sum up the output for two different directions else we use the bigger output if they are in the same direction             \\n            ret = max(ret, (x + y)) if x >= 0 and y >= 0 else max(ret, max(x, y))\\n        \\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 2001135,
                "title": "super-washing-machines-solution-java",
                "content": "class Solution {\\n  public int findMinMoves(int[] machines) {\\n    int dresses = Arrays.stream(machines).sum();\\n    if (dresses % machines.length != 0)\\n      return -1;\\n\\n    int ans = 0;\\n    int inout = 0;\\n    final int average = dresses / machines.length;\\n\\n    for (final int dress : machines) {\\n      inout += dress - average;\\n      ans = Math.max(ans, Math.max(Math.abs(inout), dress - average));\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "class Solution {\\n  public int findMinMoves(int[] machines) {\\n    int dresses = Arrays.stream(machines).sum();\\n    if (dresses % machines.length != 0)\\n      return -1;\\n\\n    int ans = 0;\\n    int inout = 0;\\n    final int average = dresses / machines.length;\\n\\n    for (final int dress : machines) {\\n      inout += dress - average;\\n      ans = Math.max(ans, Math.max(Math.abs(inout), dress - average));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1947981,
                "title": "simple-o-n-python-solution-with-explanation",
                "content": "```class Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total_clothes = sum(machines)\\n        # If clothes aren\\'t visible by the number of machines,\\n        # return -1.\\n        if total_clothes % len(machines) != 0:\\n            return -1\\n        \\n        # The number of clothes which should be in each machine at the end.\\n        clothes_per_machine = total_clothes / len(machines)\\n        \\n        # Count the number of clothes to the left of each machine.\\n        clothes_left = []\\n        total_c = 0\\n        for c in machines:\\n            clothes_left.append(total_c)\\n            total_c += c\\n\\n        # Count the number of clothes to the right of each machine.\\n        clothes_right = []\\n        total_c = 0\\n        for c in machines[::-1]:\\n            clothes_right.append(total_c)\\n            total_c += c\\n        clothes_right = clothes_right[::-1]\\n        \\n        # The number of moves each machine must make is equal to the number of left\\n        # passes + number of right passes. The number of left passes is equal\\n        # to the difference between the expected number of clothes to the left\\n        # and the actual number of clothes to the left, and the same to the right.\\n        # Therefore, the min moves is the min across all machines of the left\\n        # and right moves added together.\\n        min_moves = 0\\n        for i, (l, r) in enumerate(zip(clothes_left, clothes_right)):\\n            expected_clothes_left = i * clothes_per_machine\\n            left_moves = max(0, expected_clothes_left - l)\\n            expected_clothes_right = (len(machines) - i - 1) * clothes_per_machine\\n            right_moves = max(0, expected_clothes_right - r)\\n            min_moves = max(min_moves, left_moves + right_moves)\\n        return int(min_moves)\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        total_clothes = sum(machines)\\n        # If clothes aren\\'t visible by the number of machines,\\n        # return -1.\\n        if total_clothes % len(machines) != 0:\\n            return -1\\n        \\n        # The number of clothes which should be in each machine at the end.\\n        clothes_per_machine = total_clothes / len(machines)\\n        \\n        # Count the number of clothes to the left of each machine.\\n        clothes_left = []\\n        total_c = 0\\n        for c in machines:\\n            clothes_left.append(total_c)\\n            total_c += c\\n\\n        # Count the number of clothes to the right of each machine.\\n        clothes_right = []\\n        total_c = 0\\n        for c in machines[::-1]:\\n            clothes_right.append(total_c)\\n            total_c += c\\n        clothes_right = clothes_right[::-1]\\n        \\n        # The number of moves each machine must make is equal to the number of left\\n        # passes + number of right passes. The number of left passes is equal\\n        # to the difference between the expected number of clothes to the left\\n        # and the actual number of clothes to the left, and the same to the right.\\n        # Therefore, the min moves is the min across all machines of the left\\n        # and right moves added together.\\n        min_moves = 0\\n        for i, (l, r) in enumerate(zip(clothes_left, clothes_right)):\\n            expected_clothes_left = i * clothes_per_machine\\n            left_moves = max(0, expected_clothes_left - l)\\n            expected_clothes_right = (len(machines) - i - 1) * clothes_per_machine\\n            right_moves = max(0, expected_clothes_right - r)\\n            min_moves = max(min_moves, left_moves + right_moves)\\n        return int(min_moves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896007,
                "title": "python-greedy-o-n-easy-to-understand",
                "content": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        n = len(machines)\\n        summation = sum(machines)\\n        if summation%n:\\n            return -1\\n        avg = summation//n\\n        left = list(accumulate(machines))\\n        result = 0\\n        for i in range(n):\\n            move_to_right = max(left[i] - (i+1)*avg, 0) \\n            move_to_left = max(left[-1]-(left[i-1] if i!=0 else 0) - (n-i)*avg, 0)\\n            result = max(result, move_to_right + move_to_left)\\n        return result\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def findMinMoves(self, machines: List[int]) -> int:\\n        n = len(machines)\\n        summation = sum(machines)\\n        if summation%n:\\n            return -1\\n        avg = summation//n\\n        left = list(accumulate(machines))\\n        result = 0\\n        for i in range(n):\\n            move_to_right = max(left[i] - (i+1)*avg, 0) \\n            move_to_left = max(left[-1]-(left[i-1] if i!=0 else 0) - (n-i)*avg, 0)\\n            result = max(result, move_to_right + move_to_left)\\n        return result\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882036,
                "title": "easy-to-understand-o-n-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& a) {\\n        int n=a.size(),s=0,ans=0;\\n        int flow[n]; memset(flow,0,sizeof(flow));\\n        \\n        for(int i=0;i<n;i++)\\n            s+=a[i];\\n        if(s%n) return -1;\\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left_to_right_flow=sum-i*(s/n);\\n            int right_to_left_flow=s-sum-a[i]-(n-i-1)*(s/n);\\n            flow[i]=max({0,left_to_right_flow,right_to_left_flow});\\n            sum+=a[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            ans=max(ans,a[i]+flow[i]-s/n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& a) {\\n        int n=a.size(),s=0,ans=0;\\n        int flow[n]; memset(flow,0,sizeof(flow));\\n        \\n        for(int i=0;i<n;i++)\\n            s+=a[i];\\n        if(s%n) return -1;\\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left_to_right_flow=sum-i*(s/n);\\n            int right_to_left_flow=s-sum-a[i]-(n-i-1)*(s/n);\\n            flow[i]=max({0,left_to_right_flow,right_to_left_flow});\\n            sum+=a[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            ans=max(ans,a[i]+flow[i]-s/n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870268,
                "title": "c-0-n-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machine)\\n    {\\n        int n=machine.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=machine[i];\\n        }\\n        if(sum%n!=0)\\n            return -1;\\n        \\n        int each=sum/n;\\n        vector<int>left(n,0);\\n        int leftsum=machine[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int req=i*each;\\n            if(req>leftsum)\\n                left[i]=req-leftsum;\\n            \\n            leftsum+=machine[i];\\n        }\\n        vector<int>right(n,0);\\n        int rightsum=machine[n-1];\\n        int j=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int req=j*each;\\n            if(req>rightsum)\\n                right[i]=req-rightsum;\\n            rightsum+=machine[i];\\n            j++;\\n        }\\n        int maxsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int s=left[i]+right[i];\\n            if(s>maxsum)\\n                maxsum=s;\\n        }\\n        return maxsum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMinMoves(vector<int>& machine)\\n    {\\n        int n=machine.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=machine[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1840610,
                "title": "python-greedy-o-n-time-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        prev=0\\n        i=0\\n        for item in machines:\\n            machines[i]+=prev\\n            prev=machines[i]\\n            i+=1\\n        res=[]\\n        if machines[-1]%len(machines)!=0:\\n            return -1\\n        avg=machines[-1]//len(machines)\\n        curr=avg\\n        for i,item in enumerate(machines):\\n            step=0\\n            if i>0 and -machines[i-1]+curr-avg>0:\\n                step+=-machines[i-1]+curr-avg\\n            if machines[i]-curr>0:\\n                step+=machines[i]-curr\\n            res.append(step)\\n            curr+=avg\\n        return max(res)",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        prev=0\\n        i=0\\n        for item in machines:\\n            machines[i]+=prev\\n            prev=machines[i]\\n            i+=1\\n        res=[]\\n        if machines[-1]%len(machines)!=0:\\n            return -1\\n        avg=machines[-1]//len(machines)\\n        curr=avg\\n        for i,item in enumerate(machines):\\n            step=0\\n            if i>0 and -machines[i-1]+curr-avg>0:\\n                step+=-machines[i-1]+curr-avg\\n            if machines[i]-curr>0:\\n                step+=machines[i]-curr\\n            res.append(step)\\n            curr+=avg\\n        return max(res)",
                "codeTag": "Java"
            },
            {
                "id": 1751251,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        if machines.len() == 0 {\\n            return -1;\\n        }\\n\\n        let sum: i32 = machines.iter().sum();\\n\\n        if sum % (machines.len() as i32) != 0 {\\n            return -1;\\n        }\\n\\n        let target = sum / (machines.len() as i32);\\n\\n        let mut to_right = 0;\\n        let mut result = 0;\\n\\n        for machine in machines.iter() {\\n            to_right = machine + to_right - target;\\n            result = result.max((machine - target).max(to_right.abs()));\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_min_moves(machines: Vec<i32>) -> i32 {\\n        if machines.len() == 0 {\\n            return -1;\\n        }\\n\\n        let sum: i32 = machines.iter().sum();\\n\\n        if sum % (machines.len() as i32) != 0 {\\n            return -1;\\n        }\\n\\n        let target = sum / (machines.len() as i32);\\n\\n        let mut to_right = 0;\\n        let mut result = 0;\\n\\n        for machine in machines.iter() {\\n            to_right = machine + to_right - target;\\n            result = result.max((machine - target).max(to_right.abs()));\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378706,
                "title": "cpp-short-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        const int n = machines.size();\\n        int sum = accumulate(&machines[0],&machines[0] + n,0);\\n        if(sum%n != 0) return -1;\\n        int avg = sum/n;\\n        int ans = 0;\\n        for(int i = 0,leftSum = 0; i < n; i++){\\n            int leftRest = leftSum - avg * i;\\n            int rightRest = (sum - leftSum - machines[i]) - (n - 1 - i)*avg;\\n            if(leftRest <= 0 && rightRest <= 0) ans = max(ans,abs(leftRest) + abs(rightRest));\\n            else ans = max(ans,max(abs(leftRest),abs(rightRest)));\\n            leftSum += machines[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machines) {\\n        const int n = machines.size();\\n        int sum = accumulate(&machines[0],&machines[0] + n,0);\\n        if(sum%n != 0) return -1;\\n        int avg = sum/n;\\n        int ans = 0;\\n        for(int i = 0,leftSum = 0; i < n; i++){\\n            int leftRest = leftSum - avg * i;\\n            int rightRest = (sum - leftSum - machines[i]) - (n - 1 - i)*avg;\\n            if(leftRest <= 0 && rightRest <= 0) ans = max(ans,abs(leftRest) + abs(rightRest));\\n            else ans = max(ans,max(abs(leftRest),abs(rightRest)));\\n            leftSum += machines[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108873,
                "title": "plain-maybe-stupid-o-n-simulation-with-deque-12ms-code-with-comment",
                "content": "```c++\\nstruct Move {\\n    int result, average;\\n    \\n    deque<pair<int, int>> Q;  //There is one dress moved into current machine at Q[i].first-th move to Q[i].second-th move.\\n    \\n    Move(int average): result(0), average(average) {}\\n    \\n    Move(int average, pair<int, int> init): result(0), average(average) {\\n        Q.push_front(init);\\n    }\\n    \\n    void into(int ori) { // The current machine has ori dresses originally.\\n        int keep = 0;\\n        while (keep < average) {\\n            if (!Q.empty()) {\\n                // Keep the lastest dresses moved in for current machine.\\n                auto p = Q.back();\\n                Q.pop_back();\\n                if (keep + p.second - p.first + 1 <= average) {\\n                    // Keep the whole batch\\n                    keep += p.second - p.first + 1;\\n                } else {\\n                    // Split the batch\\n                    Q.push_back({p.first, p.second - (average - keep)});\\n                    keep = average;\\n                }\\n            } else {\\n                // All dresses from other machines are not enough, keep some of original dresses.\\n                ori -= average - keep;\\n                keep = average;\\n            }\\n        }\\n        \\n        // Now all dresses in Q and ori original dresses will be moved from current machine into next machine.\\n        while (!Q.empty() && Q.front().first <= ori) {\\n            // These dresses in Q will be moved out right after original dresses.\\n            ori += Q.front().second - Q.front().first + 1;\\n            Q.pop_front();\\n        }\\n        \\n        // Later dresses in Q will be moved at the next step after moving in.\\n        //for (auto& p: Q) p.first += 1, p.second += 1;\\n        Q.add_to_all(1);\\n        \\n        if (ori > 0) Q.push_front({1, ori});\\n        \\n        if (!Q.empty()) result = max(result, Q.back().second);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machine) {\\n        int n = machine.size();\\n        long long sum = 0;\\n        for (int dress: machine) sum += dress;\\n        if (sum % n) return -1;\\n        int average = sum / n;\\n        \\n        int current = 0;\\n        int result = 0;\\n        while (current < n) {\\n            if (machine[current] == average) {\\n                current += 1;\\n                continue;\\n            }\\n            if (machine[current] > average) {\\n                // From left to right\\n                Move move(average);\\n                long long remain = 0;\\n                while (current < n && remain + machine[current] >= average) {\\n                    move.into(machine[current]);\\n                    remain = remain + machine[current] - average;\\n                    current += 1;\\n                }\\n                if (remain > 0) machine[current] += remain;\\n                result = max(result, move.result);\\n            } else {\\n                // From right to left\\n                int left_most = current;\\n                int to_left = average - machine[current];\\n                current += 1;\\n                while (to_left + average - machine[current] > 0) {\\n                    to_left += average - machine[current];\\n                    current += 1;\\n                }\\n                int to_right = machine[current] - to_left - average;\\n                result = max(result, to_left + to_right);\\n                Move move(average, {to_right + 1, to_right + to_left}); // Move to_left after to_right.\\n                for (int i = current - 1; i >= left_most; --i)\\n                    move.into(machine[i]);\\n                machine[current] = to_right + average;\\n                result = max(result, move.result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nThe above code passes with 12ms but I am not sure the time complexity because of the part adding value to all deque\\'s elements. (Anyone could proof it or provide a  case to make it TLE?)\\nHowever, we can implement a deque supporting O(1) adding value to all elements, like an early question on leetcode but I can\\'t find it now.\\n\\n```c++\\nusing pii = pair<int, int>;\\n\\nstruct Item {\\n    int first, second, dec;\\n    Item() {}\\n    Item(pii p, int dec): first(p.first), second(p.second), dec(dec) {}\\n    pii to_pii(int inc) const { return {first + inc - dec, second + inc - dec}; }\\n};\\n\\n// A deque support O(1) adding val to all elements\\nstruct MyDeque: deque<Item> {\\n    int inc = 0;\\n    void push_front(pii p) { deque<Item>::push_front(Item(p, inc)); }\\n    void push_back(pii p) { deque<Item>::push_back(Item(p, inc)); }\\n    pii front() const { return deque<Item>::front().to_pii(inc); }\\n    pii back() const { return deque<Item>::back().to_pii(inc); }\\n    void add_to_all(int val) { inc += val; }\\n};\\n```\\n\\n```c++\\n    //deque<pair<int, int>> Q;  //There is one dress into current machine from Q[i].first-th move to Q[i].second-th move.\\n    MyDeque Q;\\n```\\n```c++\\n        // Later dresses in Q will be moved at the next step after moving in.\\n        //for (auto& p: Q) p.first += 1, p.second += 1;\\n        Q.add_to_all(1);\\n```\\n\\nMoving first dress to left or to right? when current machine has to move `to_left` dresses to left and move `to_right` dresses to right and no dress is moved into current machine:\\nAssume the first(and the furthest) dress to left/right finally stop at i-th machine:\\n1. All final dresses of all machines on the path(between the i-th and the current) are from current machine.\\n2. The number of machines on the path is not greater than `to_left` or `to_right`.\\n3. All `to_left+to_right` dresses will be delivered to their destination in `to_left+to_right` moves, in any order.",
                "solutionTags": [],
                "code": "```c++\\nstruct Move {\\n    int result, average;\\n    \\n    deque<pair<int, int>> Q;  //There is one dress moved into current machine at Q[i].first-th move to Q[i].second-th move.\\n    \\n    Move(int average): result(0), average(average) {}\\n    \\n    Move(int average, pair<int, int> init): result(0), average(average) {\\n        Q.push_front(init);\\n    }\\n    \\n    void into(int ori) { // The current machine has ori dresses originally.\\n        int keep = 0;\\n        while (keep < average) {\\n            if (!Q.empty()) {\\n                // Keep the lastest dresses moved in for current machine.\\n                auto p = Q.back();\\n                Q.pop_back();\\n                if (keep + p.second - p.first + 1 <= average) {\\n                    // Keep the whole batch\\n                    keep += p.second - p.first + 1;\\n                } else {\\n                    // Split the batch\\n                    Q.push_back({p.first, p.second - (average - keep)});\\n                    keep = average;\\n                }\\n            } else {\\n                // All dresses from other machines are not enough, keep some of original dresses.\\n                ori -= average - keep;\\n                keep = average;\\n            }\\n        }\\n        \\n        // Now all dresses in Q and ori original dresses will be moved from current machine into next machine.\\n        while (!Q.empty() && Q.front().first <= ori) {\\n            // These dresses in Q will be moved out right after original dresses.\\n            ori += Q.front().second - Q.front().first + 1;\\n            Q.pop_front();\\n        }\\n        \\n        // Later dresses in Q will be moved at the next step after moving in.\\n        //for (auto& p: Q) p.first += 1, p.second += 1;\\n        Q.add_to_all(1);\\n        \\n        if (ori > 0) Q.push_front({1, ori});\\n        \\n        if (!Q.empty()) result = max(result, Q.back().second);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& machine) {\\n        int n = machine.size();\\n        long long sum = 0;\\n        for (int dress: machine) sum += dress;\\n        if (sum % n) return -1;\\n        int average = sum / n;\\n        \\n        int current = 0;\\n        int result = 0;\\n        while (current < n) {\\n            if (machine[current] == average) {\\n                current += 1;\\n                continue;\\n            }\\n            if (machine[current] > average) {\\n                // From left to right\\n                Move move(average);\\n                long long remain = 0;\\n                while (current < n && remain + machine[current] >= average) {\\n                    move.into(machine[current]);\\n                    remain = remain + machine[current] - average;\\n                    current += 1;\\n                }\\n                if (remain > 0) machine[current] += remain;\\n                result = max(result, move.result);\\n            } else {\\n                // From right to left\\n                int left_most = current;\\n                int to_left = average - machine[current];\\n                current += 1;\\n                while (to_left + average - machine[current] > 0) {\\n                    to_left += average - machine[current];\\n                    current += 1;\\n                }\\n                int to_right = machine[current] - to_left - average;\\n                result = max(result, to_left + to_right);\\n                Move move(average, {to_right + 1, to_right + to_left}); // Move to_left after to_right.\\n                for (int i = current - 1; i >= left_most; --i)\\n                    move.into(machine[i]);\\n                machine[current] = to_right + average;\\n                result = max(result, move.result);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```c++\\nusing pii = pair<int, int>;\\n\\nstruct Item {\\n    int first, second, dec;\\n    Item() {}\\n    Item(pii p, int dec): first(p.first), second(p.second), dec(dec) {}\\n    pii to_pii(int inc) const { return {first + inc - dec, second + inc - dec}; }\\n};\\n\\n// A deque support O(1) adding val to all elements\\nstruct MyDeque: deque<Item> {\\n    int inc = 0;\\n    void push_front(pii p) { deque<Item>::push_front(Item(p, inc)); }\\n    void push_back(pii p) { deque<Item>::push_back(Item(p, inc)); }\\n    pii front() const { return deque<Item>::front().to_pii(inc); }\\n    pii back() const { return deque<Item>::back().to_pii(inc); }\\n    void add_to_all(int val) { inc += val; }\\n};\\n```\n```c++\\n    //deque<pair<int, int>> Q;  //There is one dress into current machine from Q[i].first-th move to Q[i].second-th move.\\n    MyDeque Q;\\n```\n```c++\\n        // Later dresses in Q will be moved at the next step after moving in.\\n        //for (auto& p: Q) p.first += 1, p.second += 1;\\n        Q.add_to_all(1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024369,
                "title": "c-solution-100-faster-import-solution-from-votrubac",
                "content": "Thanks to @votrubac code and explaantion. i have just imported it to c.\\nexplanation: https://leetcode.com/problems/super-washing-machines/discuss/99203/C%2B%2B-12-ms-O(n)-8-lines\\n```\\n#include<math.h>\\n\\nint findMinMoves(int* machines, int machinesSize){\\n  int totalDresses = 0, size = machinesSize;\\n    for (int i = 0; i < size; ++i) totalDresses += machines[i];\\n    if (totalDresses % size != 0) return -1;\\n    \\n    int targetDresses = totalDresses / size, totalMoves = 0, ballance = 0;\\n    for (int i = 0; i < size; ++i) {\\n        ballance += machines[i] - targetDresses;\\n        totalMoves = fmax(totalMoves, fmax(machines[i] - targetDresses, abs(ballance)));\\n    }\\n    return totalMoves;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include<math.h>\\n\\nint findMinMoves(int* machines, int machinesSize){\\n  int totalDresses = 0, size = machinesSize;\\n    for (int i = 0; i < size; ++i) totalDresses += machines[i];\\n    if (totalDresses % size != 0) return -1;\\n    \\n    int targetDresses = totalDresses / size, totalMoves = 0, ballance = 0;\\n    for (int i = 0; i < size; ++i) {\\n        ballance += machines[i] - targetDresses;\\n        totalMoves = fmax(totalMoves, fmax(machines[i] - targetDresses, abs(ballance)));\\n    }\\n    return totalMoves;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 962465,
                "title": "straightforward-js",
                "content": "```\\nconst findMinMoves = machines => {\\n    let load, tot = 0, max = 0\\n    const sum = machines.reduce( ( a, x ) => a + x )\\n    const target = sum / machines.length\\n    if ( target % 1 ) return -1\\n    \\n    machines.forEach( n => {\\n        load = n - target\\n        tot += load\\n        max = Math.max( max, Math.abs( tot ), load )\\n    })\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findMinMoves = machines => {\\n    let load, tot = 0, max = 0\\n    const sum = machines.reduce( ( a, x ) => a + x )\\n    const target = sum / machines.length\\n    if ( target % 1 ) return -1\\n    \\n    machines.forEach( n => {\\n        load = n - target\\n        tot += load\\n        max = Math.max( max, Math.abs( tot ), load )\\n    })\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930147,
                "title": "scala",
                "content": "```scala\\n  def findMinMoves(machines: Array[Int]): Int = {\\n    val sum = machines.sum\\n    if (sum % machines.length != 0) return -1\\n    val target = sum / machines.length\\n    var res = 0\\n    var balance = 0\\n    machines.indices.foreach(i => {\\n      balance += machines(i) - target\\n      res = res.max((machines(i) - target).max(balance.abs))\\n    })\\n    res\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\n  def findMinMoves(machines: Array[Int]): Int = {\\n    val sum = machines.sum\\n    if (sum % machines.length != 0) return -1\\n    val target = sum / machines.length\\n    var res = 0\\n    var balance = 0\\n    machines.indices.foreach(i => {\\n      balance += machines(i) - target\\n      res = res.max((machines(i) - target).max(balance.abs))\\n    })\\n    res\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 909954,
                "title": "faster-than-100",
                "content": "```\\nusing System;\\nusing System.Linq;\\n\\npublic class Solution\\n{\\n    public int FindMinMoves(int[] machines)\\n    {\\n        var sum = machines.Sum();\\n        if (sum % machines.Length != 0)\\n            return -1;\\n\\n        int fill = sum / machines.Length;\\n        int diff = 0;\\n\\n        int result = 0;\\n        foreach (var machine in machines)\\n        {\\n            diff += machine - fill;\\n            result = Math.Max(result, Math.Abs(diff));\\n            result = Math.Max(result, machine - fill);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Linq;\\n\\npublic class Solution\\n{\\n    public int FindMinMoves(int[] machines)\\n    {\\n        var sum = machines.Sum();\\n        if (sum % machines.Length != 0)\\n            return -1;\\n\\n        int fill = sum / machines.Length;\\n        int diff = 0;\\n\\n        int result = 0;\\n        foreach (var machine in machines)\\n        {\\n            diff += machine - fill;\\n            result = Math.Max(result, Math.Abs(diff));\\n            result = Math.Max(result, machine - fill);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870692,
                "title": "swift",
                "content": "```\\n{\\n        var result = 0\\n        let numberOfDresses = machines.reduce(0, +)\\n        if numberOfDresses % machines.count != 0 {\\n            return -1\\n        }\\n        let avg = numberOfDresses/machines.count\\n        var currentOffset = 0\\n        for machine in machines{\\n            let diff = machine - avg\\n            currentOffset += diff\\n            result = max(result, max(diff, abs(currentOffset)))\\n        }\\n        \\n        return result\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n{\\n        var result = 0\\n        let numberOfDresses = machines.reduce(0, +)\\n        if numberOfDresses % machines.count != 0 {\\n            return -1\\n        }\\n        let avg = numberOfDresses/machines.count\\n        var currentOffset = 0\\n        for machine in machines{\\n            let diff = machine - avg\\n            currentOffset += diff\\n            result = max(result, max(diff, abs(currentOffset)))\\n        }\\n        \\n        return result\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 863525,
                "title": "go",
                "content": "```\\nfunc findMinMoves(machines []int) int {\\n    a := machines\\n    sum := 0\\n    for _, v := range a {\\n        sum += v\\n    }\\n    if sum % len(a) != 0 {\\n        return -1\\n    }\\n    \\n    avg := sum / len(a)\\n    dp := make([]int, len(a))\\n    dp[0] = a[0] - avg \\n    for i := 1; i < len(dp); i++ {\\n        dp[i] = dp[i - 1] + a[i] - avg\\n    }\\n\\n    res := math.MinInt64\\n    for i, v := range dp {\\n        res = max(res, abs(v), a[i] - avg)\\n    }\\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n\\nfunc max(a... int) int {\\n    res := math.MinInt64\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findMinMoves(machines []int) int {\\n    a := machines\\n    sum := 0\\n    for _, v := range a {\\n        sum += v\\n    }\\n    if sum % len(a) != 0 {\\n        return -1\\n    }\\n    \\n    avg := sum / len(a)\\n    dp := make([]int, len(a))\\n    dp[0] = a[0] - avg \\n    for i := 1; i < len(dp); i++ {\\n        dp[i] = dp[i - 1] + a[i] - avg\\n    }\\n\\n    res := math.MinInt64\\n    for i, v := range dp {\\n        res = max(res, abs(v), a[i] - avg)\\n    }\\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n\\nfunc max(a... int) int {\\n    res := math.MinInt64\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756722,
                "title": "c-o-n",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& m) {\\n        int n=m.size();\\n        if(!n)return n;\\n        vector<int> let(n);\\n        vector<int> rigt(n);\\n        let[0]=m[0];\\n        rigt[n-1]=m[n-1];\\n        for(int i=1;i<n;i++)\\n            let[i]=let[i-1]+m[i];\\n        for(int i=n-2;i>=0;i--)\\n            rigt[i]=rigt[i+1]+m[i];\\n        if(let[n-1]%n)return -1;\\n        int avg=let[n-1]/n;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int total=0;\\n            int left=avg*i;\\n            int right=avg*(n-i-1);\\n            int l=0,r=0;\\n            if(i-1>=0)l=let[i-1];\\n            r=(i+1<n?rigt[i+1]:0);\\n            if(l<left)\\n                total+=left-l;\\n            if(r<right)\\n                total+=right-r;\\n            ans=max(ans,total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& m) {\\n        int n=m.size();\\n        if(!n)return n;\\n        vector<int> let(n);\\n        vector<int> rigt(n);\\n        let[0]=m[0];\\n        rigt[n-1]=m[n-1];\\n        for(int i=1;i<n;i++)\\n            let[i]=let[i-1]+m[i];\\n        for(int i=n-2;i>=0;i--)\\n            rigt[i]=rigt[i+1]+m[i];\\n        if(let[n-1]%n)return -1;\\n        int avg=let[n-1]/n;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int total=0;\\n            int left=avg*i;\\n            int right=avg*(n-i-1);\\n            int l=0,r=0;\\n            if(i-1>=0)l=let[i-1];\\n            r=(i+1<n?rigt[i+1]:0);\\n            if(l<left)\\n                total+=left-l;\\n            if(r<right)\\n                total+=right-r;\\n            ans=max(ans,total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733996,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int totalload = 0;\\n        for(int load : machines)\\n            totalload += load;\\n        \\n        if(totalload%n != 0)\\n            return -1;\\n        \\n        int avgLoad = totalload/n;\\n        \\n        int currOffload = 0;\\n        int totalOffload = 0;\\n        int max = 0;\\n        for(int load: machines){\\n            \\n            currOffload = load-avgLoad;\\n            totalOffload = totalOffload + currOffload;\\n            \\n            //Maximum of max, currOffload, totalOffload\\n            max = Math.max(currOffload, Math.max(max, Math.abs(totalOffload)));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinMoves(int[] machines) {\\n        int n = machines.length;\\n        int totalload = 0;\\n        for(int load : machines)\\n            totalload += load;\\n        \\n        if(totalload%n != 0)\\n            return -1;\\n        \\n        int avgLoad = totalload/n;\\n        \\n        int currOffload = 0;\\n        int totalOffload = 0;\\n        int max = 0;\\n        for(int load: machines){\\n            \\n            currOffload = load-avgLoad;\\n            totalOffload = totalOffload + currOffload;\\n            \\n            //Maximum of max, currOffload, totalOffload\\n            max = Math.max(currOffload, Math.max(max, Math.abs(totalOffload)));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616643,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& nums) {\\n        int s=0;\\n        for(auto m:nums){\\n            s+=m;\\n        }\\n        int n=nums.size();\\n        if(s%n!=0) return -1;\\n        else{\\n            int re=s/n,ans=0,co=0;\\n            for(int i=0;i<nums.size();i++){\\n                co+=nums[i]-re;\\n                ans=max(ans,max(abs(co),nums[i]-re));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& nums) {\\n        int s=0;\\n        for(auto m:nums){\\n            s+=m;\\n        }\\n        int n=nums.size();\\n        if(s%n!=0) return -1;\\n        else{\\n            int re=s/n,ans=0,co=0;\\n            for(int i=0;i<nums.size();i++){\\n                co+=nums[i]-re;\\n                ans=max(ans,max(abs(co),nums[i]-re));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591578,
                "title": "formal-proof-of-the-solution",
                "content": "All credits to @lixx2100, who originally proposed this proof in a thread discussion.\\nI am starting a thread, so that more people can see it.\\n______________________________________________________________________________________\\nFor each machine-i, we use L[i] to denote the number of dress it needs to pass to its left neighbor. And L[i] = 0 if machine-i does not need to transfer any dress to its left. Symmetrically, we define R[i].\\nTo compute these quantities, we break the array into two parts, say a[1 .. i] and a[i + 1 .. n] and it is easy to compute R[i] and L[i + 1], respectively.\\n\\nNow, define f[i] = L[i] + R[i], and let M = max(f[i]). We then claim that M is our answer. Clearly, M is a lower bound of this problem as every machine can only send one dress at a time. It then suffices to show that M is feasible by constructing a sequence of moves such that every machine will eventually contain an equal number of dresses. Below is the construction algorithm, where we don\\'t care about its runtime but only its correctness.\\n```\\nwhile(M > 0) {\\n    for (i = 1 to n)\\n        if (f[i] < M) Do nothing.\\n        else {\\n            if (R[i] > 0) Machine-i passes a dress to its right.\\n            else Machine-i passes a dress to its left.\\n        }\\n    Recompute M based on the current configuration.\\n}\\n```\\nTo see the correctness, it is clear that M will decrease by one after each iteration because all those bottleneck machines release a dress simultaneously. (This is because if R[i] > 0 then it is impossible to have L[i + 1] > 0, and vice versa.) Therefore, after M iterations M would become zero, which implicitly means that the workload in every machine is even.\\n\\nFinally, we still need to prove that at any time, every bottleneck machine has something in hand to pass by. The formal proof is given in the following lemma, and we are eventually done.\\n\\n**Lemma** : If f[i] == M, then a[i] must be positive, i.e., the i-th machine has at least one dress to pass.\\nProof.\\nFor a contradiction, assume a[i] == 0 instead.\\n\\nWe first show it is impossible to have L[i] > 0 && R[i] > 0. The reason behind that is simple: R[i] > 0 means the total dresses in a[i + 1 .. n] is insufficient; similarly, L[i] > 0 means a[1 .. i - 1] is lack of dresses. But since a[i] == 0 there is no way to fulfill these requirements. --- A contradiction.\\n\\nNow, without loss of generality let L[i] == 0 && R[i] > 0. We then show R[i - 1] > R[i] and, as such, f[i - 1] = L[i - 1] + R[i - 1] >= R[i - 1] > R[i] + 0 = f[i], which contradicts to the fact that f[i] == M.\\nWe left the question \"why R[i - 1] > R[i]?\" to the reader as a good exercise.\\n\\n_______________________________________________________________________________________\\n\\nP.S. - If a[i] == 0, then we require \\'avg\\' dresses at location i, which means R[i-1] should be R[i] + avg.\\n",
                "solutionTags": [],
                "code": "```\\nwhile(M > 0) {\\n    for (i = 1 to n)\\n        if (f[i] < M) Do nothing.\\n        else {\\n            if (R[i] > 0) Machine-i passes a dress to its right.\\n            else Machine-i passes a dress to its left.\\n        }\\n    Recompute M based on the current configuration.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532856,
                "title": "simple-c-solution-brief-explanation",
                "content": "Look at problem through every  single washing machine.\\nThere are 2 states for them\\n* machines[i] < target. It means that this machine can be only recepient - so the only thing you should know is excess of clothes right or left from i-th one\\n* machines[i] >= target. it means that we should free some clothes from that (machines[i] - target). Also this machine can be transitive (for example to provide excess from left to right or vise versa)\\n\\n```\\n    public class Solution\\n    {\\n        public int FindMinMoves(int[] machines)\\n        {\\n            checked\\n            {\\n                int[] sums = new int[machines.Length];\\n                int sum = 0;\\n                for (int i = 0; i < machines.Length; i++)\\n                {\\n                    sum += machines[i];\\n                    sums[i] = sum;\\n                }\\n\\n                if (sum % machines.Length != 0)\\n                {\\n                    return -1;\\n                }\\n\\n                int res = 0;\\n                int target = sum / machines.Length;\\n\\n                for (int i = 0; i < machines.Length; i++)\\n                {\\n                    int left = sums[i] - machines[i];\\n                    int right = sums[sums.Length - 1] - sums[i];\\n\\n                    int leftDiff = left - target * i;\\n                    int rightDiff = right - target * (sums.Length - (i + 1));\\n                    int transitivePart = 0;\\n\\n                    if (((long)leftDiff * rightDiff) < 0)\\n                    {\\n                        transitivePart = Math.Max(leftDiff, rightDiff);\\n                    }\\n\\n                    if (machines[i] < target)\\n                    {\\n                        res = Math.Max(res, transitivePart);\\n                    }\\n                    else\\n                    {\\n                        res = Math.Max(res, transitivePart + machines[i] - target);\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int FindMinMoves(int[] machines)\\n        {\\n            checked\\n            {\\n                int[] sums = new int[machines.Length];\\n                int sum = 0;\\n                for (int i = 0; i < machines.Length; i++)\\n                {\\n                    sum += machines[i];\\n                    sums[i] = sum;\\n                }\\n\\n                if (sum % machines.Length != 0)\\n                {\\n                    return -1;\\n                }\\n\\n                int res = 0;\\n                int target = sum / machines.Length;\\n\\n                for (int i = 0; i < machines.Length; i++)\\n                {\\n                    int left = sums[i] - machines[i];\\n                    int right = sums[sums.Length - 1] - sums[i];\\n\\n                    int leftDiff = left - target * i;\\n                    int rightDiff = right - target * (sums.Length - (i + 1));\\n                    int transitivePart = 0;\\n\\n                    if (((long)leftDiff * rightDiff) < 0)\\n                    {\\n                        transitivePart = Math.Max(leftDiff, rightDiff);\\n                    }\\n\\n                    if (machines[i] < target)\\n                    {\\n                        res = Math.Max(res, transitivePart);\\n                    }\\n                    else\\n                    {\\n                        res = Math.Max(res, transitivePart + machines[i] - target);\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527403,
                "title": "c-o-n-time-o-1-space-beat-100-in-time-and-100-in-space",
                "content": "\\n```\\npublic class Solution {\\n    public int FindMinMoves(int[] m) {\\n        \\n\\t//Get average number of dresses\\n\\tint sum = 0;\\n\\tfor(int i=0;i<m.Length;i++)\\n\\t{\\n\\t\\tsum+=m[i];\\n\\t}\\n\\tif(sum % m.Length !=0 )\\n\\t\\treturn -1;\\n\\n\\t//target number of dresses per machine\\n\\tint avg = sum/m.Length;\\n\\t//times to move\\n\\tint times = -1;\\n\\t\\n\\t//carry indicates number of dresses move between (i+1)th machine and i-th machine\\n\\t//carry < 0 means move direction is from i+1 th machine to ith machine\\n\\t//carry > 0 means move dirction is from ith machine to i+1 th machine\\n\\tint carry = 0;\\n\\tfor(int i=0;i < m.Length;i++)\\n\\t{\\n\\t\\tif(i == 0)\\n\\t\\t{\\n\\t\\t\\t//for 0th machine, no carry is required.\\n\\t\\t\\ttimes = Math.Max(times, Math.Abs(avg - m[i]));\\n\\t\\t\\tcarry = m[i] - avg;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttimes = Math.Max(Math.Abs(avg - (m[i]+carry)), Math.Max(times, Math.Abs(carry)));\\n\\t\\t\\tint carry1 = (m[i]+carry) - avg;\\n\\t\\t\\t\\n\\t\\t\\t//moving out at the same time is not allowed\\n\\t\\t\\t//but moving in at the same time is allowed.\\n\\t\\t\\t// so when forward moving out and backward moving out happens, add them up.\\n\\t\\t\\tif((carry < 0 && carry1 > 0))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttimes = Math.Max(times, Math.Abs(carry - carry1));\\n\\t\\t\\t}\\n\\t\\t\\tcarry = carry1;\\n\\t\\t}\\n\\t}\\n        \\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindMinMoves(int[] m) {\\n        \\n\\t//Get average number of dresses\\n\\tint sum = 0;\\n\\tfor(int i=0;i<m.Length;i++)\\n\\t{\\n\\t\\tsum+=m[i];\\n\\t}\\n\\tif(sum % m.Length !=0 )\\n\\t\\treturn -1;\\n\\n\\t//target number of dresses per machine\\n\\tint avg = sum/m.Length;\\n\\t//times to move\\n\\tint times = -1;\\n\\t\\n\\t//carry indicates number of dresses move between (i+1)th machine and i-th machine\\n\\t//carry < 0 means move direction is from i+1 th machine to ith machine\\n\\t//carry > 0 means move dirction is from ith machine to i+1 th machine\\n\\tint carry = 0;\\n\\tfor(int i=0;i < m.Length;i++)\\n\\t{\\n\\t\\tif(i == 0)\\n\\t\\t{\\n\\t\\t\\t//for 0th machine, no carry is required.\\n\\t\\t\\ttimes = Math.Max(times, Math.Abs(avg - m[i]));\\n\\t\\t\\tcarry = m[i] - avg;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttimes = Math.Max(Math.Abs(avg - (m[i]+carry)), Math.Max(times, Math.Abs(carry)));\\n\\t\\t\\tint carry1 = (m[i]+carry) - avg;\\n\\t\\t\\t\\n\\t\\t\\t//moving out at the same time is not allowed\\n\\t\\t\\t//but moving in at the same time is allowed.\\n\\t\\t\\t// so when forward moving out and backward moving out happens, add them up.\\n\\t\\t\\tif((carry < 0 && carry1 > 0))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttimes = Math.Max(times, Math.Abs(carry - carry1));\\n\\t\\t\\t}\\n\\t\\t\\tcarry = carry1;\\n\\t\\t}\\n\\t}\\n        \\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487673,
                "title": "c-easy-to-understand-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findMinMoves(vector<int>& machines) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tint n=machines.size();\\n\\t\\t\\tfor(auto& x:machines){\\n\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t}\\n\\t\\t\\tif(sum%n!=0){\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tint k=sum/n;\\n\\t\\t\\tvector<int> left(n,0);\\n\\t\\t\\tvector<int> right(n,0);\\n\\t\\t\\tright[0]=machines[0]-k;\\n\\t\\t\\tleft[n-1]=machines[n-1]-k;\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tleft[i]=-right[i-1];\\n\\t\\t\\t\\tright[i]=machines[i]-k-left[i];\\n\\t\\t\\t}\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint tem=0;\\n\\t\\t\\t\\tif(left[i]>0){\\n\\t\\t\\t\\t\\ttem+=left[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(right[i]>0){\\n\\t\\t\\t\\t\\ttem+=right[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres=max(res,tem);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findMinMoves(vector<int>& machines) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tint n=machines.size();\\n\\t\\t\\tfor(auto& x:machines){\\n\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 486311,
                "title": "go-o-n-solution-with-explanation",
                "content": "For more golang solutions please check https://github.com/yinfirefire/LeetCode-GoSol\\n\\n```go\\nfunc findMinMoves(machines []int) int {\\n\\t//since each machine can only transfer one dress at each step\\n\\t//the strategy is to find for each machine, the sum of dresses that passes left/right through this machine\\n\\t//among all the machine, the highest passes through number is also the steps to take\\n\\tsum := 0\\n\\tfor i := range machines {\\n\\t\\tsum += machines[i]\\n\\t}\\n\\tif sum%len(machines) != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tavg := sum / len(machines)\\n\\tleftSum := 0\\n\\tleftTarget := 0\\n\\trightTarget := sum + avg\\n\\tres := 0\\n\\tfor i := range machines {\\n\\t\\tleftSum += machines[i]                  //prefix sum, i included\\n\\t\\trightSum := sum - leftSum + machines[i] //suffix sum, i included\\n\\t\\tleftTarget += avg                       //prefix target, i included\\n\\t\\trightTarget -= avg                      //suffix target, i included\\n\\t\\ttoRight, toLeft := 0, 0\\n\\t\\tif leftSum > leftTarget {\\n\\t\\t\\ttoRight = leftSum - leftTarget\\n\\t\\t}\\n\\t\\tif rightSum > rightTarget {\\n\\t\\t\\ttoLeft = rightSum - rightTarget\\n\\t\\t}\\n\\t\\tres = max(res, toLeft+toRight)\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findMinMoves(machines []int) int {\\n\\t//since each machine can only transfer one dress at each step\\n\\t//the strategy is to find for each machine, the sum of dresses that passes left/right through this machine\\n\\t//among all the machine, the highest passes through number is also the steps to take\\n\\tsum := 0\\n\\tfor i := range machines {\\n\\t\\tsum += machines[i]\\n\\t}\\n\\tif sum%len(machines) != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tavg := sum / len(machines)\\n\\tleftSum := 0\\n\\tleftTarget := 0\\n\\trightTarget := sum + avg\\n\\tres := 0\\n\\tfor i := range machines {\\n\\t\\tleftSum += machines[i]                  //prefix sum, i included\\n\\t\\trightSum := sum - leftSum + machines[i] //suffix sum, i included\\n\\t\\tleftTarget += avg                       //prefix target, i included\\n\\t\\trightTarget -= avg                      //suffix target, i included\\n\\t\\ttoRight, toLeft := 0, 0\\n\\t\\tif leftSum > leftTarget {\\n\\t\\t\\ttoRight = leftSum - leftTarget\\n\\t\\t}\\n\\t\\tif rightSum > rightTarget {\\n\\t\\t\\ttoLeft = rightSum - rightTarget\\n\\t\\t}\\n\\t\\tres = max(res, toLeft+toRight)\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 448261,
                "title": "it-s-not-bad-c-17-16ms-solution-with-proof",
                "content": "This problem could fit into (zip, map, fold) pattern.  It is an exercise for the reader to combine them figure out how to assemble the pieces. \\n* In c++17, one could use std::inner_product as a possible implementation. However, it is not ideal and c++ won\\'t have lazy eval until c++20.\\n* Haskell/OCaml might be a good choice for this.\\n\\n\\n```\\n// [[Algorithm]]\\n// 1. compute presum[], where presum[i] = sum(machines) (1 .. i - 1)\\n// 2. compute postsum[], where postsum[i] = sum(machines) (i + 1, ..., size(machines) - 1)\\n// 3. fold right (max operation) over machines[], for each machines[i] compute left_to_right and right_to_left\\n//    and total_move[i] = left_to_right + right_to_left based on presum[i] and postsum[i]\\n// 4. the answer is the fold result provided that the problem is solvable, which we can judge easily before the fold.\\n\\n// [[Proof of correctness]]\\n// We claim that one of total_move[i] must be the answer. Suppose not, it must be the case that there are at least two moves\\n// in the form of machine[A] ->(pass 1) machine[B] and machine[B] ->(pass 1) machines[C] while B and C don\\'t pass anything in each single move.\\n// This is a contradiciton since these operations could be done simultaneously.\\n\\n\\nclass Solution {\\n public:\\n  int findMinMoves(vector<int>& machines) {\\n    const int total = std::accumulate(begin(machines), end(machines), 0);\\n    const int avg   = total / size(machines);\\n    if (total % size(machines) != 0)\\n      return -1;\\n\\n    const vector<int> presum = [&](int acc = 0) {\\n      vector<int> built;\\n      for (int i = 0; i < size(machines); ++i) {\\n        if (i == 0)\\n          built.emplace_back(0);\\n        else \\n          built.emplace_back(acc += machines[i - 1]);\\n      }\\n      return built;\\n    }();\\n\\n    const vector<int> postsum = [&](int acc = 0) {\\n      vector<int> built;\\n      for (int i = size(machines) - 1; i >= 0; --i) {\\n        if (i == size(machines) - 1)\\n          built.emplace_back(0);\\n        else \\n          built.emplace_back(acc += machines[i + 1]);\\n      }\\n\\n      return std::reverse(begin(built), end(built)), built;\\n    }();\\n\\n    const int solution = [&](int acc = INT_MIN) {\\n      for (int i = 0; i < size(machines); ++i) {\\n        optional<int> right_to_left;\\n        optional<int> left_to_right;\\n        if (i * avg > presum[i])\\n          right_to_left = std::abs(i * avg - presum[i]);\\n        if ((size(machines) - (i + 1)) * avg > postsum[i])\\n          left_to_right = std::abs(((int)size(machines) - (i + 1)) * avg - postsum[i]);\\n        acc = std::max(acc, right_to_left.value_or(0) + left_to_right.value_or(0));\\n      }\\n      return acc;\\n    }();\\n\\n    return solution;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// [[Algorithm]]\\n// 1. compute presum[], where presum[i] = sum(machines) (1 .. i - 1)\\n// 2. compute postsum[], where postsum[i] = sum(machines) (i + 1, ..., size(machines) - 1)\\n// 3. fold right (max operation) over machines[], for each machines[i] compute left_to_right and right_to_left\\n//    and total_move[i] = left_to_right + right_to_left based on presum[i] and postsum[i]\\n// 4. the answer is the fold result provided that the problem is solvable, which we can judge easily before the fold.\\n\\n// [[Proof of correctness]]\\n// We claim that one of total_move[i] must be the answer. Suppose not, it must be the case that there are at least two moves\\n// in the form of machine[A] ->(pass 1) machine[B] and machine[B] ->(pass 1) machines[C] while B and C don\\'t pass anything in each single move.\\n// This is a contradiciton since these operations could be done simultaneously.\\n\\n\\nclass Solution {\\n public:\\n  int findMinMoves(vector<int>& machines) {\\n    const int total = std::accumulate(begin(machines), end(machines), 0);\\n    const int avg   = total / size(machines);\\n    if (total % size(machines) != 0)\\n      return -1;\\n\\n    const vector<int> presum = [&](int acc = 0) {\\n      vector<int> built;\\n      for (int i = 0; i < size(machines); ++i) {\\n        if (i == 0)\\n          built.emplace_back(0);\\n        else \\n          built.emplace_back(acc += machines[i - 1]);\\n      }\\n      return built;\\n    }();\\n\\n    const vector<int> postsum = [&](int acc = 0) {\\n      vector<int> built;\\n      for (int i = size(machines) - 1; i >= 0; --i) {\\n        if (i == size(machines) - 1)\\n          built.emplace_back(0);\\n        else \\n          built.emplace_back(acc += machines[i + 1]);\\n      }\\n\\n      return std::reverse(begin(built), end(built)), built;\\n    }();\\n\\n    const int solution = [&](int acc = INT_MIN) {\\n      for (int i = 0; i < size(machines); ++i) {\\n        optional<int> right_to_left;\\n        optional<int> left_to_right;\\n        if (i * avg > presum[i])\\n          right_to_left = std::abs(i * avg - presum[i]);\\n        if ((size(machines) - (i + 1)) * avg > postsum[i])\\n          left_to_right = std::abs(((int)size(machines) - (i + 1)) * avg - postsum[i]);\\n        acc = std::max(acc, right_to_left.value_or(0) + left_to_right.value_or(0));\\n      }\\n      return acc;\\n    }();\\n\\n    return solution;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394692,
                "title": "cpp-8-12ms-9mb",
                "content": "We propagate the deficit / excess of dresses linearly from left to right: *nums[i]* is updated with the number of dresses that will go through machine *i* toward its right. minus sign indicates that machine *i* will receive a flow of dresses from its right.\\nThe minimal number of moves will be determined at point where flow changes direction ( there is a kind of decoupling of the left and right subproblems at such points ) or its intensity drops.\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& nums) {\\n        int n = nums.size();\\n        int res(0);\\n        int cumsum = std::accumulate(nums.begin(), nums.end(),0);\\n        if(cumsum%n){\\n            return -1;\\n        }\\n        int t = cumsum/n; // target number.\\n        nums[0] -= t; // we overwrite nums with default/excess of dresses. \\n        \\n        for(int i=0; i<n-1; ++i){\\n            // flow of dresses changes direction left -> right (exclusively outputting machine).\\n            if((nums[i+1]+=nums[i]-t)>= 0 && nums[i]<=0){ \\n                \\n                // we add flows because one machine cannot provide dresses to the left and to the right simultaneously.\\n                res = std::max(res,std::abs(nums[i])+nums[i+1]); \\n                \\n            }\\n            // flow of dresses changes direction right -> left (exclusively absorbing machine).\\n            else if(nums[i]>=0 && nums[i+1]<= 0 || \\n               std::abs(nums[i+1])<std::abs(nums[i])){ // or flow intensity drops.\\n                \\n                res = std::max(res,std::abs(nums[i]));\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nEdit: slightly improvement for the second *if*: We may also omit the second *if* if we pay the the price to update the result tentatively more often.\\n```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& nums) {\\n        int n = nums.size();\\n        int res(0);\\n        uint cumsum = std::accumulate(nums.begin(), nums.end(),0);\\n        if(cumsum%n){\\n            return -1;\\n        }\\n        uint t = cumsum/n; // target number.\\n        nums[0] -= t; // we overwrite nums with default/excess of dresses. \\n        \\n        for(int i=0; i<n-1; ++i){\\n            // flow of dresses changes direction left -> right (exclusively outputting machine).\\n            if((nums[i+1]+=nums[i]-t)>= 0 && nums[i]<0){ \\n                \\n                // we add flows because one machine cannot provide dresses to the left and to the right simultaneously.\\n                res = std::max(res,std::abs(nums[i])+nums[i+1]); \\n                \\n            }\\n            // or flow intensity drops.\\n            else if(std::abs(nums[i+1])<std::abs(nums[i])){ // or flow intensity drops.\\n                \\n                res = std::max(res,std::abs(nums[i]));\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinMoves(vector<int>& nums) {\\n        int n = nums.size();\\n        int res(0);\\n        int cumsum = std::accumulate(nums.begin(), nums.end(),0);\\n        if(cumsum%n){\\n            return -1;\\n        }\\n        int t = cumsum/n; // target number.\\n        nums[0] -= t; // we overwrite nums with default/excess of dresses. \\n        \\n        for(int i=0; i<n-1; ++i){\\n            // flow of dresses changes direction left -> right (exclusively outputting machine).\\n            if((nums[i+1]+=nums[i]-t)>= 0 && nums[i]<=0){ \\n                \\n                // we add flows because one machine cannot provide dresses to the left and to the right simultaneously.\\n                res = std::max(res,std::abs(nums[i])+nums[i+1]); \\n                \\n            }\\n            // flow of dresses changes direction right -> left (exclusively absorbing machine).\\n            else if(nums[i]>=0 && nums[i+1]<= 0 || \\n               std::abs(nums[i+1])<std::abs(nums[i])){ // or flow intensity drops.\\n                \\n                res = std::max(res,std::abs(nums[i]));\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363800,
                "title": "how-to-solve-this-case-0-0-3-0-2",
                "content": "The result should be 3 but according to test case it is 2, am I missing anything?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 338649,
                "title": "why-4-0-0-4-only-need-2-steps",
                "content": "Why [4, 0, 0, 4] Only need 2 steps? This problem is marked as HARD since it\\'s very hard to understand this problem!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 324998,
                "title": "go",
                "content": "```\\nimport \"math\"\\n\\nfunc max(a ...int) int {\\n    max := 0\\n    for i := 0; i < len(a); i++ {\\n        if a[i] > max {\\n           max = a[i] \\n        }\\n    }\\n    return max\\n}\\n\\nfunc findMinMoves(machines []int) int {\\n    length := len(machines)\\n    \\n    // sanity check\\n    dressCount := 0\\n    for i := 0; i < length; i++ {\\n        dressCount += machines[i]\\n    } \\n    \\n    if dressCount % length != 0 {\\n        //It\\'s not evenly dividable\\n        return -1\\n    }\\n    \\n    goal := dressCount / length\\n    \\n    // Normalize the data\\n    for i := 0; i < length; i++ {\\n        machines[i] -= goal\\n    }\\n    \\n    currentSum, maxSum, result := 0, 0, 0\\n    \\n    // Find the worst thing\\n    for _, m := range machines {\\n        currentSum += m\\n        maxSum = max(maxSum, int(math.Abs(float64(currentSum))))\\n        result = max(maxSum, m, result)\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"math\"\\n\\nfunc max(a ...int) int {\\n    max := 0\\n    for i := 0; i < len(a); i++ {\\n        if a[i] > max {\\n           max = a[i] \\n        }\\n    }\\n    return max\\n}\\n\\nfunc findMinMoves(machines []int) int {\\n    length := len(machines)\\n    \\n    // sanity check\\n    dressCount := 0\\n    for i := 0; i < length; i++ {\\n        dressCount += machines[i]\\n    } \\n    \\n    if dressCount % length != 0 {\\n        //It\\'s not evenly dividable\\n        return -1\\n    }\\n    \\n    goal := dressCount / length\\n    \\n    // Normalize the data\\n    for i := 0; i < length; i++ {\\n        machines[i] -= goal\\n    }\\n    \\n    currentSum, maxSum, result := 0, 0, 0\\n    \\n    // Find the worst thing\\n    for _, m := range machines {\\n        currentSum += m\\n        maxSum = max(maxSum, int(math.Abs(float64(currentSum))))\\n        result = max(maxSum, m, result)\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 260141,
                "title": "python-with-detailed-example-explanation",
                "content": "Below explanation is inspired by https://leetcode.com/problems/super-washing-machines/discuss/235584/Explanation-of-Java-O(n)-solution and I add my understanding as well.\\n\\nTake @darewreck54\\'s example,\\n1 <-1 <- 4 <- 8  &nbsp;1   [2,1,4,7,1]\\n2 <-1 <- 4 <- 7 &nbsp; 1   [3,1,4,6,1]\\n3 &nbsp;&nbsp; &nbsp;1 <- 4 <- 6 &nbsp;1   [3,2,4,5,1]\\n3 &nbsp;&nbsp; &nbsp;2 <- 4&nbsp;&nbsp; &nbsp;&nbsp;5->1   [3,3,3,4,2]\\n3 &nbsp;&nbsp; &nbsp;3&nbsp;&nbsp; &nbsp;&nbsp;3&nbsp;&nbsp; &nbsp;&nbsp;4->2   [3,3,3,3,3]\\n\\nI can conclude that for each node, its absolute accumulated defict to the average decides how many dress (=how many move) will flow THRU it. For example, the accumulated defict\\uFF08 or Running Balance) are [-2, -4, -3, 2, 0], the physical meaning is that for node 1, totally 2 dresses need to flow through it (see how many left arrow \"<-\" in above for node 1? it\\'s 2); for node 2, totally 4 dresses (sign indicates flow direction BTW).  The minimal number of move for a node is the max of absolute Runnning Balance IF there is only 1 direction. \\nHowever, in above example, I have 2 directions (see  the last node, it accept 2 address from its left node). Therefore, I need to compare max absolute Runnning Balance with (max dress - average dress). Refer to @darewreck54\\'s post for why (max dress - average dress)  can be a possible answer :)\\n\\n```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(machines) > 1 and sum(machines) % len(machines) > 0:\\n            return -1\\n        \\n        target = sum(machines) / len(machines)\\n        runningBalance = 0\\n        maxRB = 0\\n        for number in machines:\\n            runningBalance += number - target\\n            if abs(runningBalance) > maxRB:\\n                maxRB = abs(runningBalance)\\n        return max(max(machines) - target, maxRB)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(machines) > 1 and sum(machines) % len(machines) > 0:\\n            return -1\\n        \\n        target = sum(machines) / len(machines)\\n        runningBalance = 0\\n        maxRB = 0\\n        for number in machines:\\n            runningBalance += number - target\\n            if abs(runningBalance) > maxRB:\\n                maxRB = abs(runningBalance)\\n        return max(max(machines) - target, maxRB)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237981,
                "title": "easy-python-beats-100",
                "content": "tempsum at i represents the difference between real sum of values and the expected sum of values from beginning to the i-1 th machine.\\ntempmax represents the target value.\\ntemp represents the difference between value[i] and expected value[i].\\nif tempsum + temp <= 0, i.e. the deviation from beginning to the ith value is smaller than 0, then the ith machine will not move values to its right.\\nelse, the ith machine will move values to either direction.\\n```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(machines)\\n        nsum = sum(machines)\\n        if nsum%n: return -1\\n        val = nsum/n\\n        machines = [val] + machines + [val]\\n        tempmax,tempsum = 0, 0\\n        for i in xrange(1,n+1):\\n            temp = machines[i] - val\\n            if tempsum + temp <= 0:           \\n                tempmax = max(tempmax,abs(tempsum))\\n                tempsum += temp\\n            else:\\n                tempmax = max(tempmax,temp)\\n                machines[i+1] += machines[i] + tempsum - val\\n                tempsum = 0\\n        return tempmax\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(machines)\\n        nsum = sum(machines)\\n        if nsum%n: return -1\\n        val = nsum/n\\n        machines = [val] + machines + [val]\\n        tempmax,tempsum = 0, 0\\n        for i in xrange(1,n+1):\\n            temp = machines[i] - val\\n            if tempsum + temp <= 0:           \\n                tempmax = max(tempmax,abs(tempsum))\\n                tempsum += temp\\n            else:\\n                tempmax = max(tempmax,temp)\\n                machines[i+1] += machines[i] + tempsum - val\\n                tempsum = 0\\n        return tempmax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156276,
                "title": "why-4-0-0-4-needs-2-steps",
                "content": "The question shows that only one dress can be passed at one time.\\nI think [4,0,0,4] needs 4 steps. Why the answer is 2?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 131968,
                "title": "there-is-no-need-tracking-any-max",
                "content": "As long as dresses could be distributed evenly, you just need sum (load - avg) which load is greater.\\n\\n",
                "solutionTags": [],
                "code": "As long as dresses could be distributed evenly, you just need sum (load - avg) which load is greater.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 129309,
                "title": "solution-using-vlarray-and-partial-sum",
                "content": "```\\n    int findMinMoves(vector<int>& machines) {\\n        valarray<int> x(machines.data(), machines.size()),y( machines.size());\\n        float avg = x.sum()/(1.0*x.size());\\n        if(avg != floor(avg)) return -1; \\n        x= x- (int)avg; \\n        partial_sum(begin(x), end(x), begin(y) );\\n        return max(x.max(),abs(y).max());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findMinMoves(vector<int>& machines) {\\n        valarray<int> x(machines.data(), machines.size()),y( machines.size());\\n        float avg = x.sum()/(1.0*x.size());\\n        if(avg != floor(avg)) return -1; \\n        x= x- (int)avg; \\n        partial_sum(begin(x), end(x), begin(y) );\\n        return max(x.max(),abs(y).max());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99178,
                "title": "unreasonable-answer-given-by-leetcode",
                "content": "given custom output as [3,0,3]\\nshould be output 2\\nbut the expected output  is 1...",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 99179,
                "title": "o-n-time-o-1-space-python",
                "content": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total = sum(machines)\\n        if total%len(machines)!=0:\\n            return -1\\n        ave = total/len(machines)\\n        prefix = 0\\n        res = 0\\n        for i in range(len(machines)):\\n            leftNeeds = max(i*ave - prefix, 0)\\n            rightNeeds = max(prefix + machines[i] - (i+1)*ave, 0)\\n            prefix += machines[i]\\n            res = max(leftNeeds+rightNeeds, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinMoves(self, machines):\\n        \"\"\"\\n        :type machines: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total = sum(machines)\\n        if total%len(machines)!=0:\\n            return -1\\n        ave = total/len(machines)\\n        prefix = 0\\n        res = 0\\n        for i in range(len(machines)):\\n            leftNeeds = max(i*ave - prefix, 0)\\n            rightNeeds = max(prefix + machines[i] - (i+1)*ave, 0)\\n            prefix += machines[i]\\n            res = max(leftNeeds+rightNeeds, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99180,
                "title": "one-caveat-one-machine-can-take-2-at-the-same-time-but-not-give-2-at-the-same-time-from-to-both-left-and-right",
                "content": "OJ says [3, 0, 3] requires 1 step only, meaning 0 in the middle can take 2 from left and right at the same time. This explains the correct solutions do not take absolute values for some to avoid over counting in case the machine will need to take from both left and right sides.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 99183,
                "title": "why-does-5-2-4-2-2-returns-2",
                "content": "Is this allowed in one step?\\n[**5**,2,**4**,2,2] -> [4,3,3,2,2]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 99184,
                "title": "python-5-lines",
                "content": "`````\\n    def findMinMoves(self, ms):\\n        if sum(ms) % len(ms) != 0: return -1\\n        avg = sum(ms)/len(ms)\\n        ds = map(lambda x: x-avg, ms)\\n        dss = [abs(sum(ds[0:i])) for i in xrange(len(ds))]\\n        return max(dss + ds)\\n`````",
                "solutionTags": [],
                "code": "`````\\n    def findMinMoves(self, ms):\\n        if sum(ms) % len(ms) != 0: return -1\\n        avg = sum(ms)/len(ms)\\n        ds = map(lambda x: x-avg, ms)\\n        dss = [abs(sum(ds[0:i])) for i in xrange(len(ds))]\\n        return max(dss + ds)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 99191,
                "title": "4-lines-c-code",
                "content": "    int findMinMoves(vector<int>& machines) {\\n        int sum = accumulate(machines.begin(), machines.end(), 0), len = machines.size(), avg = sum / len, res = 0;\\n        if(sum % len) return -1; \\n        // carry can be accumulated from 0 to len - 1. if carry < 0, means some address need be transitioned to the left, else to the right. but the direction of transtion doesn't matters.  And please note when i = len - 1, carry = 0, this carry has no impacts on the final result.\\n\\n        // if current number is greater than avg, it needs be transitioned to left/right, one at time. so max = Math.max(max, machines[i] - avg)\\n        // but the if(machines[i] > avg) can be removed, since if machines[i] < avg, max is not changed, e.g. max = Math.max(max, machines[i] - avg). \\n        for(int i = 0, carry = 0; i < len; res = max(res, abs(carry)), carry += machines[i++] - avg) res = max(res, machines[i] - avg);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int findMinMoves(vector<int>& machines) {\\n        int sum = accumulate(machines.begin(), machines.end(), 0), len = machines.size(), avg = sum / len, res = 0;\\n        if(sum % len) return -1; \\n        // carry can be accumulated from 0 to len - 1. if carry < 0, means some address need be transitioned to the left, else to the right. but the direction of transtion doesn't matters.  And please note when i = len - 1, carry = 0, this carry has no impacts on the final result.\\n\\n        // if current number is greater than avg, it needs be transitioned to left/right, one at time. so max = Math.max(max, machines[i] - avg)\\n        // but the if(machines[i] > avg) can be removed, since if machines[i] < avg, max is not changed, e.g. max = Math.max(max, machines[i] - avg). \\n        for(int i = 0, carry = 0; i < len; res = max(res, abs(carry)), carry += machines[i++] - avg) res = max(res, machines[i] - avg);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565076,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1566515,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1566264,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1572852,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571761,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1572377,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1569257,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1723419,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571759,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571760,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1565076,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1566515,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1566264,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1572852,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571761,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1572377,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1569257,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1723419,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571759,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            },
            {
                "id": 1571760,
                "content": [
                    {
                        "username": "pilch",
                        "content": "It is not clear that the direction in which we pass a dress can be different for different machines during one round.\\nTo make that clear, we should add an example like:\\nInput: [2,0,0,2]\\nOuptut: 1\\nExplanation:\\n1st move:    2 --> 0     0 <-- 2    =>    1     1     1     1"
                    },
                    {
                        "username": "zyjdxtc",
                        "content": "my algorithm gives 7 steps and is considered wrong\\n\\n[0,0,11,5]:\\n\\n[1,1,10,4]\\n[2,2,9,3]\\n[3,3,8,2]\\n[3,3,7,3]\\n[3,4,6,3]\\n[4,4,5,3]\\n[4,4,4,4]\\n\\nis this path wrong?"
                    },
                    {
                        "username": "sharma_shubham",
                        "content": "It is not required to move only one cloth at a time. You can move any number of clothes (<=n) from machine."
                    },
                    {
                        "username": "legendaryengineer",
                        "content": "1. Calculate the average number of dresses per machine.\\n\\n2. Don't worry about each machine should borrow dresses or give out dresses, transform all to give-out  => machines[i] = machines[i] - average, yes you can give out a negative amount to dresses.\\n\\n3. Max(machines[i]) should be the answer, yes at least you need to do machines[i] operations to give out machines[i] dresses.\\n\\n4. Wait, what if there is an accumulated number of give-outs that's greater than Max(machines[i])? Then use that accumulated number as the answer since those two give-outs can happen simultaneously. Example: [1, 1, 1, 0, -5, 0, 2], 1 + 1 + 1 > 2, so answer is 1 + 1 + 1 = 3."
                    },
                    {
                        "username": "insmod88",
                        "content": "My answer gives the output 7 but the expected is 8. I was wondering if I understood the question correctly.\\n\\nFor input [0,0,11,5]\\nThe sequence would be\\n[1,1,10,4]   - move 1  (is this counted as 2 moves?)\\n[2,1,9,4] - move 2 .. etc (5 more moves from 9 (index2) to index 0 and 1))\\nThis adds up to 7.\\n\\nBut when i submit my answer, the expected output seems to be 8 ? Can someone please explain?"
                    },
                    {
                        "username": "zukaatoku",
                        "content": "4 --> 0 0 4\\n3 1 0 <-- 4\\n3 --> 1 1 3\\n2 2 1 <-- 3\\n2 2 2 2 // so - 4 steps? or am I wrong?"
                    },
                    {
                        "username": "blistok",
                        "content": "I have the same question. This test case seems wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Tanghaocheng",
                        "content": "I think most post only prove a theoritical lower bound for this problem, what if the problem wants us to output the detailed movement of each step?"
                    },
                    {
                        "username": "habibullah",
                        "content": "is it only me or this problem is harder than other hard problems in leetcode?"
                    },
                    {
                        "username": "blistok",
                        "content": "Testcase number 49 seems to be wrong. It\\'s impossible to make [4,0,0,4] in only 2 steps (as long as the constraint from the problem description that only one dress can be moved at a time is preserved)."
                    },
                    {
                        "username": "Pushkar21",
                        "content": "Pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n1st step - [3,1,1,3]\\n2nd step - [2,2,2,2]"
                    },
                    {
                        "username": "huaiyan",
                        "content": "We go through the array from left to right or reverse.\\n[1]count the all number of dress we need to operate with the other side up to now as A (that means the  dress we have to give out or we lack).\\n[2]in every step, the Math.abs(A) maybe final answer. \\n[3]for every machine, if it have more dress than avg, it must will take (his dress number)-(avg) times operate to make it be in avg. So it also maybe the final answer."
                    },
                    {
                        "username": "fallcreek",
                        "content": "If the washing machines are in a circle, not in a line, then how to solve it?"
                    }
                ]
            }
        ]
    }
]