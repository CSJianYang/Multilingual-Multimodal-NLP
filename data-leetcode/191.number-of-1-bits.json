[
    {
        "title": "Number of 1 Bits",
        "question_content": "Write a function that takes&nbsp;the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\nNote:\n\n\tNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n\tIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.\n\n&nbsp;\nExample 1:\n\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n\nExample 2:\n\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n\nExample 3:\n\nInput: n = 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n\n&nbsp;\nConstraints:\n\n\tThe input must be a binary string of length 32.\n\n&nbsp;\nFollow up: If this function is called many times, how would you optimize it?",
        "solutions": [
            {
                "id": 55099,
                "title": "simple-java-solution-bit-shifting",
                "content": "```\\npublic static int hammingWeight(int n) {\\n\\tint ones = 0;\\n    \\twhile(n!=0) {\\n    \\t\\tones = ones + (n & 1);\\n    \\t\\tn = n>>>1;\\n    \\t}\\n    \\treturn ones;\\n}\\n```\\n - An Integer in Java has 32 bits, e.g. 00101000011110010100001000011010.\\n - To count the 1s in the Integer representation we put the input int\\n   n in bit AND with 1 (that is represented as\\n   00000000000000000000000000000001, and if this operation result is 1,\\n   that means that the last bit of the input integer is 1. Thus we add it to the 1s count.\\n\\n> ones = ones + (n & 1);\\n\\n - Then we shift the input Integer by one on the right, to check for the\\n   next bit.\\n\\n> n = n>>>1;\\n\\nWe need to use bit shifting unsigned operation **>>>** (while **>>** depends on sign extension)\\n\\n - We keep doing this until the input Integer is 0.\\n\\nIn Java we need to put attention on the fact that the maximum integer is 2147483647. Integer type in Java is signed and there is no unsigned int. So the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means **Integer.MAX_VALUE+1==Integer.MIN_VALUE**).\\nThis force us to use \\n\\n> n!=0\\n\\n in the while condition and we cannot use \\n\\n> n>0\\n\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic static int hammingWeight(int n) {\\n\\tint ones = 0;\\n    \\twhile(n!=0) {\\n    \\t\\tones = ones + (n & 1);\\n    \\t\\tn = n>>>1;\\n    \\t}\\n    \\treturn ones;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55255,
                "title": "c-solution-n-n-1",
                "content": "    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\nn & (n - 1) drops the lowest set bit. It's a neat little bit trick.\\n\\nLet's use n = 00101100 as an example. This binary representation has three 1s.\\n\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\n\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\n\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\n\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n\\nn & (n - 1) drops the lowest set bit. It's a neat little bit trick.\\n\\nLet's use n = 00101100 as an example. This binary representation has three 1s.\\n\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\n\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\n\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\n\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.",
                "codeTag": "Unknown"
            },
            {
                "id": 1044775,
                "title": "python-n-n-1-trick-even-faster-explained",
                "content": "There are a lot of different ways to solve this problem, starting from transforming number to string and count number of ones. However there is a classical bit manipulation trick you should think about when you have bits problem.\\n\\nIf we have number `n`, then `n&(n-1)` **will remove the rightmost** in binary representation of `n`. For example if `n = 10110100`, then `n & (n-1) = 10110100 & 10110011 = 10110000`, where `&` means bitwize operation and. Very convinient, is it not? What we need to do now, just repeat this operation until we have `n = 0` and count number of steps.\\n\\n**Complexity** It is `O(1)` for sure, because we need to make no more than `32` operations here, but it is quite vague: all methods will be `O(1)`, why this one is better than others? In fact it has complexity `O(m)`, where `m` is number of `1`-bits in our number. In average it will be `16` bits, so it is more like `16` operations, not `32` here, which gives us 2-times gain. Space complexity is `O(1)`\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n-1)\\n            ans += 1\\n        return ans\\n```\\n\\n## just 5 operations\\nYou can stop on previous solution and interviewer will be OK with that. But if you show him the following solution, he will be really happy. Let us understand what is going on in the following code.\\n\\n1. First of all `0x55555555 = 01010101010101010101010101010101` in binary representation, so first step will deal with even and odd bits. What happens after first line of code computed: it will count number of non-zero bits in each pair. For simplicity imagine just first `8` bits with constant `0x55 = 01010101` and choose `n = 11000110`, then we have is `10 00 01 01`. Why? We have `2`, that is `10` ones in first pair, than we have `0` ones, than we have `1` one and finally we also have `1`.\\n2. Now, to the second step, we have `0x33333333 = 110011001100110011001100110011`. Again let us look at only first `8` bit, that is to `11001100`. What will happend after this step, number of non-zero bits in groups of `4` will be computed. We stopped on number `10 00 01 01`, now we have `0010 0010`, because there is `2 + 0` ones in first group and `1+1` ones in second group.\\n3. Next step is `0x0f0f0f0f = 1111000011110000111100001111` and we working with groups of `8`, so for our example we will have `00000100`, because we have `2` ones in each group.\\n\\n**Complexity**: we have only `5` iterations for `int32` number, it will be `6` for `int64`, `7` for `int128` and so on. For `int32` there will be not increase of speed, because even though it is `5` operations, each of them consists of several small steps, but for `int64` you can fill the difference. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        n = (n & (0x55555555)) + ((n >> 1) & (0x55555555))\\n        n = (n & (0x33333333)) + ((n >> 2) & (0x33333333))\\n        n = (n & (0x0f0f0f0f)) + ((n >> 4) & (0x0f0f0f0f))\\n        n = (n & (0x00ff00ff)) + ((n >> 8) & (0x00ff00ff))\\n        n = (n & (0x0000ffff)) + ((n >> 16) & (0x0000ffff))\\n        return n\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n-1)\\n            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        n = (n & (0x55555555)) + ((n >> 1) & (0x55555555))\\n        n = (n & (0x33333333)) + ((n >> 2) & (0x33333333))\\n        n = (n & (0x0f0f0f0f)) + ((n >> 4) & (0x0f0f0f0f))\\n        n = (n & (0x00ff00ff)) + ((n >> 8) & (0x00ff00ff))\\n        n = (n & (0x0000ffff)) + ((n >> 16) & (0x0000ffff))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55106,
                "title": "python-2-solutions-one-naive-solution-with-built-in-functions-one-trick-with-bit-operation",
                "content": "1.Built in solution with built-in function:\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(n).count(\\'1\\')\\n\\n2.Using bit operation to cancel a `1` in each round\\n\\nThink of a number in binary `n = XXXXXX1000`, `n - 1 is XXXXXX0111`. `n & (n - 1)` will be `XXXXXX0000` which is just remove the last significant  `1`\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n:\\n            n &= n - 1\\n            c += 1\\n        return c",
                "solutionTags": [],
                "code": "1.Built in solution with built-in function:\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return bin(n).count(\\'1\\')\\n\\n2.Using bit operation to cancel a `1` in each round\\n\\nThink of a number in binary `n = XXXXXX1000`, `n - 1 is XXXXXX0111`. `n & (n - 1)` will be `XXXXXX0000` which is just remove the last significant  `1`\\n\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n:\\n            n &= n - 1\\n            c += 1\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 1044799,
                "title": "c-bit-manipulation-4-approaches-beats-100-0ms-o-1",
                "content": "**Approach 1**\\nIterate the bits of an unsigned integer from right by using **right shift**, and at each iteration check the parity of the first bit from right.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 2**\\nMore **optimized** solution, no. of iteration will be equal to no. of set bits.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n\\t\\t\\t++cnt;\\n            n=n&(n-1); // change the first set bit from right to 0\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Approach 3**\\nUsing inbuilt function **__builtin_popcount** for counting set bits\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\\n\\n**Approach 4**\\nUsing inbuilt function **bitset**.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n\\t\\t\\t++cnt;\\n            n=n&(n-1); // change the first set bit from right to 0\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229926,
                "title": "best-c-3-solution-easy-solution-bit-manipulation-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            count += (n%2);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            int rmsb = n & -n;\\n            n -= rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            count += (n%2);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n != 0){\\n            int rmsb = n & -n;\\n            n -= rmsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55120,
                "title": "short-code-of-c-o-m-by-time-m-is-the-count-of-1-s-and-another-several-method-of-o-1-time",
                "content": "Each time of \"n &= n - 1\", we delete one '1' from n.\\n\\n    int hammingWeight(uint32_t n)\\n    {\\n        int res = 0;\\n        while(n)\\n        {\\n            n &= n - 1;\\n            ++ res;\\n        }\\n        return res;\\n    }\\n\\nAnother several method of O(1) time.\\n\\nAdd 1 by Tree:\\n\\n    // This is a naive implementation, shown for comparison, and to help in understanding the better functions. \\n    // It uses 24 arithmetic operations (shift, add, and).\\n    int hammingWeight(uint32_t n)\\n    {\\n        n = (n & 0x55555555) + (n >>  1 & 0x55555555); // put count of each  2 bits into those  2 bits \\n        n = (n & 0x33333333) + (n >>  2 & 0x33333333); // put count of each  4 bits into those  4 bits \\n        n = (n & 0x0F0F0F0F) + (n >>  4 & 0x0F0F0F0F); // put count of each  8 bits into those  8 bits \\n        n = (n & 0x00FF00FF) + (n >>  8 & 0x00FF00FF); // put count of each 16 bits into those 16 bits \\n        n = (n & 0x0000FFFF) + (n >> 16 & 0x0000FFFF); // put count of each 32 bits into those 32 bits \\n        return n;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with slow multiplication.\\n    // It uses 17 arithmetic operations.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; //put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); //put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; //put count of each 8 bits into those 8 bits\\n        n += n >> 8; // put count of each 16 bits into those 8 bits\\n        n += n >> 16; // put count of each 32 bits into those 8 bits\\n        return n & 0xFF;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with fast multiplication.\\n    // It uses 12 arithmetic operations, one of which is a multiply.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; // put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); // put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; // put count of each 8 bits into those 8 bits \\n        return n * 0x01010101 >> 24; // returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24)\\n    }\\n\\n\\u2014\\u2014From Wikipedia.",
                "solutionTags": [],
                "code": "Each time of \"n &= n - 1\", we delete one '1' from n.\\n\\n    int hammingWeight(uint32_t n)\\n    {\\n        int res = 0;\\n        while(n)\\n        {\\n            n &= n - 1;\\n            ++ res;\\n        }\\n        return res;\\n    }\\n\\nAnother several method of O(1) time.\\n\\nAdd 1 by Tree:\\n\\n    // This is a naive implementation, shown for comparison, and to help in understanding the better functions. \\n    // It uses 24 arithmetic operations (shift, add, and).\\n    int hammingWeight(uint32_t n)\\n    {\\n        n = (n & 0x55555555) + (n >>  1 & 0x55555555); // put count of each  2 bits into those  2 bits \\n        n = (n & 0x33333333) + (n >>  2 & 0x33333333); // put count of each  4 bits into those  4 bits \\n        n = (n & 0x0F0F0F0F) + (n >>  4 & 0x0F0F0F0F); // put count of each  8 bits into those  8 bits \\n        n = (n & 0x00FF00FF) + (n >>  8 & 0x00FF00FF); // put count of each 16 bits into those 16 bits \\n        n = (n & 0x0000FFFF) + (n >> 16 & 0x0000FFFF); // put count of each 32 bits into those 32 bits \\n        return n;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with slow multiplication.\\n    // It uses 17 arithmetic operations.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; //put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); //put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; //put count of each 8 bits into those 8 bits\\n        n += n >> 8; // put count of each 16 bits into those 8 bits\\n        n += n >> 16; // put count of each 32 bits into those 8 bits\\n        return n & 0xFF;\\n    }\\n\\n    // This uses fewer arithmetic operations than any other known implementation on machines with fast multiplication.\\n    // It uses 12 arithmetic operations, one of which is a multiply.\\n    int hammingWeight(uint32_t n)\\n    {\\n        n -= (n >> 1) & 0x55555555; // put count of each 2 bits into those 2 bits\\n        n = (n & 0x33333333) + (n >> 2 & 0x33333333); // put count of each 4 bits into those 4 bits\\n        n = (n + (n >> 4)) & 0x0F0F0F0F; // put count of each 8 bits into those 8 bits \\n        return n * 0x01010101 >> 24; // returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24)\\n    }\\n\\n\\u2014\\u2014From Wikipedia.",
                "codeTag": "Unknown"
            },
            {
                "id": 644682,
                "title": "easy-to-understand-faster-than-98-2-solutions-simple-python",
                "content": "```\\n    def using_inbuilt_counter(self, n):\\n        counter = collections.Counter(bin(n)[2:])\\n        return counter.get(\"1\", 0)\\n    \\n    def using_bit_manipulation(self, n):\\n        count = 0\\n        while n:\\n            if n & 1: count += 1\\n            n = n >> 1\\n        return count\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def using_inbuilt_counter(self, n):\\n        counter = collections.Counter(bin(n)[2:])\\n        return counter.get(\"1\", 0)\\n    \\n    def using_bit_manipulation(self, n):\\n        count = 0\\n        while n:\\n            if n & 1: count += 1\\n            n = n >> 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2742007,
                "title": "0ms-explained-solutions-c-bit-manipulation",
                "content": "There are 3 following approaches to the question:\\n\\n# 1st approach (not as much effective)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // let\\'s and(&) each bit with 1, if the result is 1 then we increment count by 1\\n            if (n&1 > 0) count++;\\n            // and then shift n by 1 bit [so that we can check the next bit is 1 or not]\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# 2nd approach (more effective method)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // when we substract n by 1, the Lowest significant 1 is affected first, thus \\n            // when we use and (&) operation the other 1\\'s stay intact and we increment count by 1\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# 3rd approach (also a good approach, but you must know bitset class)\\n\\nBitset is a array of bools (why are we using it here? because the values here are only in 0\\'s and 1\\'s similar to true and false which are 1 & 0 respectively)\\n\\nIt is a more compact version of arrays & vectors and have some other restrictions (like you must mention the total size at the time of declaration, etc)\\n\\nWe use count to see how many bools are true (or how many bits are 1, which we actually want)\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/2b404d99-9cdb-48ee-8899-f0c23a902759_1674631665.3592732.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // let\\'s and(&) each bit with 1, if the result is 1 then we increment count by 1\\n            if (n&1 > 0) count++;\\n            // and then shift n by 1 bit [so that we can check the next bit is 1 or not]\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while (n) {\\n            // when we substract n by 1, the Lowest significant 1 is affected first, thus \\n            // when we use and (&) operation the other 1\\'s stay intact and we increment count by 1\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519675,
                "title": "java-c-simple-optimised-faster-than-100-detailed-explanation",
                "content": "<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **10000000000000010000000000000001** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(m)**, where m is the number of set bits\\n* **Space: O(1)**, in-place\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **10000000000000010000000000000001** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(m)**, where m is the number of set bits\\n* **Space: O(1)**, in-place\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 1996783,
                "title": "javascript-solutions-notes-from-a-bootcamp-teacher",
                "content": "# **Hi, I\\'m Mike and I\\'m the Lead Instructor at [10x Code Camp](https://www.10xcodecamp.com/)**.\\n\\nI\\'m going to present as many reasonable solutions as possible. I will first write pseudo-code that will work for most languages. I will include links to relevant documentation. Then I will present the code for each solution.\\n\\nNote, I will not list the Runtime or Memory Usage percentages. Unfortunately, these can be inaccurate and lead learners down the wrong path. For example, you may submit a less optimal solution that gets a higher score than a more optimal one. Then you may think the less optimal one is better. LeetCode\\'s Runtime and Memory Usage are unpredictable and cannot be relied upon to find the most optimal solution. To test this, submit a solution and note its percentages. Then submit it again. You will frequently see discrepancies.\\n\\nInstead, I will display Grades for each solution. These are A through D. A is the highest grade. D is the lowest. These grades are based on Big O notation and best practices in real-world programming. I will sacrifice a millisecond of speed for a good variable name. This is a much better practice than giving variables hard-to-understand 1-letter names or cramming everything into 1 line. I\\'ll include comments too. I\\'ve interviewed and hired many developers, and everything I teach is what I like to see in potential programmers. **Please upvote if you like this style and would like me to continue.**\\n\\n# **Loop through a string | Grade: D**\\n* Convert the 32-bit unsigned integer to a string.\\n* Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n* Create a `count` variable with a value of 0.\\n* Loop through every character.\\n* Increase your count by 1 every time you encounter a 1 in the string.\\n* Return your count.\\n\\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2); // pass a radix parameter of 2 to keep it in base 2.\\n    let count = 0;\\n    for (let char of str) {\\n        if (char === \"1\") count++;\\n    }\\n    return count;    \\n};\\n```\\n\\n# **Filter an array of strings | Grade: D**\\n- Convert the 32-bit unsigned integer to a string.\\n- * Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Create an array of each character (using `split`).\\n- Filter the array for 1s.\\n- Return the length of the filtered array.\\n\\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2)\\n              .split(\"\")\\n              .filter(char => char === \"1\")\\n              .length;    \\n};\\n```\\n\\n# **String matching | Grade: C**\\n- Convert the 32-bit unsigned integer to a string.\\n- Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Use Regex `match` to return an array of all matches for the number 1 (`/1/g`).\\n- Return the length of this array.\\n- Remember to handle no matches (with a **[conditional](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)** or **[optional chaining: `?.`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)**).\\n\\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2)\\n    return str === \\'0\\' ? 0 : (str.match(/1/g)).length; \\n};\\n```\\n\\n\\n# **Convert to string, replace zeroes | Grade: C**\\n- Convert the 32-bit unsigned integer to a string.\\n- Note: we\\'ll have to pass a **[radix parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#parameters)** of 2 to keep it in **[base 2](https://www.expii.com/t/base-binary-numbers-9192)**.\\n- Remove the zeroes. Replace each zero with an empty string.\\n- Return the length of the resulting string.\\n\\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2).replaceAll(\"0\", \"\").length;    \\n};\\n```\\n\\n\\n# **While loop with integer manipulation | Grade: A**\\n* Converting to strings and arrays is slow. We can just manipulate the bits!\\n* Create a `count` variable with a value of 0.\\n* While the integer is not `0`\\n\\t* Check if the last bit is `1`. We can use a **[bitwise AND](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND)** to check for **[an odd bit (1) or an even bit (0)](https://catonmat.net/low-level-bit-hacks#bithack1)**.\\n\\t* If so, add it to the count.\\n\\t* Chop off the last (farthest right) bit of the integer. JavaScript has **[3 bitwise shift operators](http://speakingjs.com/es5/ch11.html#_bitwise_shift_operators)**.\\n\\t* We can use **[unsigned right shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift)**: `int = int >>> 1` or **[unsigned right shift assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift_assignment)**: `int >>>= 1`\\n* Return the count\\n\\n```\\nvar hammingWeight = function(int) {\\n    let count = 0;\\n    while (int !== 0) {\\n        const bitComparison = int & 1; // 1 & 1 will return 1. 0 & 1 will return 0.\\n        if (bitComparison === 1) count++;\\n        int >>>= 1; // unsigned right shift assignment (chop off the last bit and assign it)\\n    }  \\n    return count;\\n};\\n```\\n\\n\\n# **If this function is called many times, how would you optimize it?**\\n\\nIn theory, you could create a dictionary (also called a lookup table - in JavaScript this is an object) with all 32-bit unsigned integers as keys and all their Hamming Weights as their respective values.\\n\\nYou could create this programmatically once and then all future lookups would be as fast as possible.\\n\\nFrom the Wikipedia article on **[Hamming Weight](https://en.wikipedia.org/wiki/Hamming_weight)**:\\n\\n*If greater memory usage is allowed, we can calculate the Hamming weight faster than the above methods. With unlimited memory, we could simply create a large lookup table of the Hamming weight of every integer.*\\n\\nThe Wikipedia article also illustrates how you could compute the Hamming weight of every 32-bit integer if you have a dictionary (lookup table) of every 16-bit integer. So you could:\\n\\n- Have a lookup table of all 32-bit integers (fastest, but more needs more storage for a larger table).\\n- Or, have a lookup table of all 16-bit integers (a little slower, but only needs half the storage).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2); // pass a radix parameter of 2 to keep it in base 2.\\n    let count = 0;\\n    for (let char of str) {\\n        if (char === \"1\") count++;\\n    }\\n    return count;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2)\\n              .split(\"\")\\n              .filter(char => char === \"1\")\\n              .length;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    const str = int.toString(2)\\n    return str === \\'0\\' ? 0 : (str.match(/1/g)).length; \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    return int.toString(2).replaceAll(\"0\", \"\").length;    \\n};\\n```\n```\\nvar hammingWeight = function(int) {\\n    let count = 0;\\n    while (int !== 0) {\\n        const bitComparison = int & 1; // 1 & 1 will return 1. 0 & 1 will return 0.\\n        if (bitComparison === 1) count++;\\n        int >>>= 1; // unsigned right shift assignment (chop off the last bit and assign it)\\n    }  \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288353,
                "title": "amazing-logic-with-right-shift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].count(\\'1\\')\\n```\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            count+=n%2\\n            n=n>>1\\n        return count\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].count(\\'1\\')\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            count+=n%2\\n            n=n>>1\\n        return count\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074658,
                "title": "c-0ms-runtime-2-methods-explained",
                "content": "There are two types of Ideas which can be used here:\\n **1. Brute Force**\\nlets take a number in Binary : 1001 now just see that if it has last bit (least magnificient bit) is one or not if it is increase the count and rightshift our number and repeat same.\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nNote that: n = n/2 <==> n = n >> 1\\n\\n**2.Bit Manipulation**\\n\\nWe can see that if we do [n & (n - 1)] we will be reducing a one bit from the number. \\ne.g. 1001 & 1000 = 1000, 110 & (101) = 100.\\nwe can actually use this here.\\nin this case iterations required will be equal to number of set bits in a number.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            ans++;;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nin both solutions we can see **auxillary time complexity is O(1)** because we run loop for 32 times max. And obviously **Space complexity is also O(1)**\\n\\n**UPVOTE if it Helps**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            n = n & (n-1);\\n            ans++;;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55352,
                "title": "super-simple-java-solution",
                "content": "This is about the easiest possible answer in Java :)\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return Integer.bitCount(n);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return Integer.bitCount(n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3015716,
                "title": "java-easy-solution-beats-100-runtime-0ms",
                "content": "\\n# Approach\\nUsing Bit Manipulation-\\nWe first check the last bit of the number, whether its 1 or 0 by performing binary AND operation of the number n with 1 (i.e. n&1) and store it in a variable named \\'last_bit\\'. We then add the last_bit to the count variable which was initially set to 0 ,because by doing so, if the value of last bit of n is 1 ,then the count will be incremented by 1 ,and if the value of last bit of n is 0 then the count value will be incremented by 0 i.e. it will remain same. We now drop the last digit of the number n by performing the right shift operation of the number with 1 (i.e. n>>>1). We iterate or repeat  all these steps till the number is not equal to 0 as when the number becomes equal to 0 then it does not contain any \"1 bit\" and so we need not to iterate it further.\\n\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int last_bit= n & 1; //Stores the value of the last bit of the number n i.e.(1 or 0)\\n            count+= last_bit; // adds 0 if last bit is 0 and adds 1 if last bit is 1 \\n            n = n>>>1;  //Dropping the last bit of the binary number n \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int last_bit= n & 1; //Stores the value of the last bit of the number n i.e.(1 or 0)\\n            count+= last_bit; // adds 0 if last bit is 0 and adds 1 if last bit is 1 \\n            n = n>>>1;  //Dropping the last bit of the binary number n \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468836,
                "title": "python-js-java-go-c-o-lg-n-by-bit-manipulation",
                "content": "[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=BcLiDexMnvU)\\n\\nPython O( lg n ) sol. based on bit-manipulation\\n\\nNote: Assume the input is of int32.\\n\\n---\\n\\n\\n```python []\\nclass Solution:\\n\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Base case\\n        if n == 0 :\\n            return 0\\n        \\n        # General case:\\n        # n = n / 2 + LSB = n / 2 + odd bit = n / 2 + ( n & 1)\\n        \\n        # Python\\'s right shift operator is >>\\n        return (n & 1) + self.hammingWeight( n >> 1 )\\n```\\n\\n\\n---\\n\\nShare extra solutions\\n\\n---\\nin Python:\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        num_of_1s = 0\\n        \\n        for i in range(32):\\n            \\n            num_of_1s += (n & 1)\\n            \\n            n = n >> 1\\n            \\n        return num_of_1s\\n```\\n\\nExtra supplementary material, python has native binary string corversion function\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Convert to binary string\\n\\t\\t# then count the occurrence of \"1\"\\n        return bin(n).count(\"1\")\\n```\\n\\n---\\n\\nJava:\\n\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        for( int i = 0 ; i < 32 ; i++){\\n            \\n            // keep detecting LSB of n is 1 or 0\\n            onesCount += n & 1;\\n            \\n            // get next digit of n by right shift rotation\\n            n >>= 1;\\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n```\\n\\n\\nExtra supplementary material, Java has native bitCount function.\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        return Integer.bitCount(n);\\n    }\\n}\\n```\\n\\n---\\n\\nin JavaScript:\\n```\\nvar hammingWeight = function(n) {\\n    \\n    let num_of_1s = 0;\\n    \\n    for( let i=0 ; i < 32; i++ ){\\n        \\n        num_of_1s += n & 1;\\n        \\n        n >>= 1;\\n\\n    }\\n    \\n    return num_of_1s\\n};\\n```\\n\\n---\\nin Go:\\n\\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for i := 0 ; i < 32; i+=1 {\\n        \\n        if num & uint32(1) == 1{\\n            num_of_1s += 1    \\n        }\\n         \\n        num >>= 1\\n        \\n    }\\n    \\n    return num_of_1s\\n}\\n```\\n\\nExtra supplementary material, Go has native bit count method in package \"math/bits\"\\n\\n```\\nfunc hammingWeight(num uint32)int{\\n    \\n    return bits.OnesCount( uint(num) )\\n    \\n}\\n```\\n\\n---\\n\\nin C++\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        for( short bit = 0 ; bit < 32 ; bit++){\\n            \\n            // Check the 0/1 on LSB\\n            numOfOnes += n & 1;\\n            \\n            // input number right shift\\n            n >>= 1;    \\n        }\\n        \\n        return numOfOnes;\\n    }\\n};\\n```\\n\\nExtra supplementary material, GNU C++ has built-in bit count function.\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        return __builtin_popcount(n);\\n    }\\n};\\n\\n\\n```\\n\\n\\n---\\n---\\n\\nShare another implementation based on bit operation\\n\\nin Python:\\n\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        counter = 0\\n    \\n        while n:\\n            \\n            # this will take out the right-most 1 of n    \\n            n = n & (n-1)\\n            \\n            # update counter\\n            counter += 1\\n        \\n        return counter\\n```\\n\\n---\\n\\nJava:\\n\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        while( n != 0 ){\\n            \\n            // update counter when n is non-zero\\n            onesCount ++;\\n            \\n            // take out right most 1 of n\\n            n = n & (n-1);\\n            \\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n\\n```\\n\\n---\\n\\nin Javascript:\\n\\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\n\\nvar hammingWeight = function(n) {\\n    \\n    let count = 0;\\n    \\n    while( n ){\\n        \\n        // this will take out the right-most 1 of n    \\n        n = n & (n-1);\\n        \\n        // update counter\\n        count += 1\\n    }\\n    \\n    return count\\n};\\n```\\n\\n---\\n\\nin Go:\\n\\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for  ;  num != 0;  {\\n        \\n        // this will take out the right-most 1 of n    \\n        num = num & (num - 1)\\n        \\n        // update counter\\n        num_of_1s += 1\\n    }\\n    \\n    return num_of_1s\\n}\\n```\\n\\n---\\n\\nin C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        while( n ){\\n            \\n            // this will take out rightmost 1 in binary representation \\n            n = n & (n-1);\\n            \\n            numOfOnes++;\\n            \\n        }\\n        return numOfOnes;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```python []\\nclass Solution:\\n\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Base case\\n        if n == 0 :\\n            return 0\\n        \\n        # General case:\\n        # n = n / 2 + LSB = n / 2 + odd bit = n / 2 + ( n & 1)\\n        \\n        # Python\\'s right shift operator is >>\\n        return (n & 1) + self.hammingWeight( n >> 1 )\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        num_of_1s = 0\\n        \\n        for i in range(32):\\n            \\n            num_of_1s += (n & 1)\\n            \\n            n = n >> 1\\n            \\n        return num_of_1s\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        # Convert to binary string\\n\\t\\t# then count the occurrence of \"1\"\\n        return bin(n).count(\"1\")\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        for( int i = 0 ; i < 32 ; i++){\\n            \\n            // keep detecting LSB of n is 1 or 0\\n            onesCount += n & 1;\\n            \\n            // get next digit of n by right shift rotation\\n            n >>= 1;\\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        return Integer.bitCount(n);\\n    }\\n}\\n```\n```\\nvar hammingWeight = function(n) {\\n    \\n    let num_of_1s = 0;\\n    \\n    for( let i=0 ; i < 32; i++ ){\\n        \\n        num_of_1s += n & 1;\\n        \\n        n >>= 1;\\n\\n    }\\n    \\n    return num_of_1s\\n};\\n```\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for i := 0 ; i < 32; i+=1 {\\n        \\n        if num & uint32(1) == 1{\\n            num_of_1s += 1    \\n        }\\n         \\n        num >>= 1\\n        \\n    }\\n    \\n    return num_of_1s\\n}\\n```\n```\\nfunc hammingWeight(num uint32)int{\\n    \\n    return bits.OnesCount( uint(num) )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        for( short bit = 0 ; bit < 32 ; bit++){\\n            \\n            // Check the 0/1 on LSB\\n            numOfOnes += n & 1;\\n            \\n            // input number right shift\\n            n >>= 1;    \\n        }\\n        \\n        return numOfOnes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        return __builtin_popcount(n);\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        \\n        counter = 0\\n    \\n        while n:\\n            \\n            # this will take out the right-most 1 of n    \\n            n = n & (n-1)\\n            \\n            # update counter\\n            counter += 1\\n        \\n        return counter\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int onesCount = 0;\\n        \\n        while( n != 0 ){\\n            \\n            // update counter when n is non-zero\\n            onesCount ++;\\n            \\n            // take out right most 1 of n\\n            n = n & (n-1);\\n            \\n        }\\n        \\n        return onesCount;\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\n\\nvar hammingWeight = function(n) {\\n    \\n    let count = 0;\\n    \\n    while( n ){\\n        \\n        // this will take out the right-most 1 of n    \\n        n = n & (n-1);\\n        \\n        // update counter\\n        count += 1\\n    }\\n    \\n    return count\\n};\\n```\n```\\nfunc hammingWeight(num uint32) int {\\n    \\n    num_of_1s := 0\\n    \\n    for  ;  num != 0;  {\\n        \\n        // this will take out the right-most 1 of n    \\n        num = num & (num - 1)\\n        \\n        // update counter\\n        num_of_1s += 1\\n    }\\n    \\n    return num_of_1s\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint32_t numOfOnes = 0;\\n        \\n        while( n ){\\n            \\n            // this will take out rightmost 1 in binary representation \\n            n = n & (n-1);\\n            \\n            numOfOnes++;\\n            \\n        }\\n        return numOfOnes;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55108,
                "title": "readable-simple-java-solution-o-1",
                "content": "In the following solution:\\n1. Iterate over 32 bits since its a 32-bit integer. This will be O(1) since it is in constant time\\n2. Left shift the number by i to get the LSB value\\n3. Do an AND of the number obtained from step 2 with 1. If the result of the AND is 1 then increment the count because the LSB value of that bit was 1.\\n\\n```\\n public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i=0; i<32; i++){\\n            count += (n >> i & 1) == 1 ? 1: 0;\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i=0; i<32; i++){\\n            count += (n >> i & 1) == 1 ? 1: 0;\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941048,
                "title": "one-line-of-code",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55194,
                "title": "use-n-n-n-1-trick-to-clear-the-least-bit",
                "content": "    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (;n!=0;n = n & (n-1))\\n            count++;\\n        return count;\\n    }\\n\\nn=n&(n-1) trick to clear the least significant bit",
                "solutionTags": [],
                "code": "    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (;n!=0;n = n & (n-1))\\n            count++;\\n        return count;\\n    }\\n\\nn=n&(n-1) trick to clear the least significant bit",
                "codeTag": "Unknown"
            },
            {
                "id": 3218849,
                "title": "191-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses a while loop to iterate over all bits of the given integer n and counts the number of \\'1\\' bits.\\n\\nHere\\'s how the solution works step-by-step:\\n\\n1. Initialize a counter variable count to 0.\\n2. Loop until n is 0.\\n3. Inside the loop, check if the last bit of n is 1 using the bitwise AND operator (&) with 1. If the result is 1, increment the counter count.\\n4. Shift n to the right by 1 bit using the right shift operator (>>).\\n5. Repeat steps 3-4 until all bits of n have been checked.\\n6. Return the counter count containing the number of \\'1\\' bits in the given integer n.\\n\\nFor example, let\\'s take the input n = 00000000000000000000000000001011.\\n\\n1. count = 0\\n2. Loop until n is 0.\\n3. n & 1 = 00000000000000000000000000000011 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 1.\\n4. n >> 1 = 00000000000000000000000000000101\\n5. n & 1 = 00000000000000000000000000000101 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 2.\\n6. n >> 1 = 00000000000000000000000000000010\\n7. n & 1 = 00000000000000000000000000000010 & 00000000000000000000000000000001 = 0. The last bit of n is 0, so do not increment count.\\n8. n >> 1 = 00000000000000000000000000000001\\n9. n & 1 = 00000000000000000000000000000001 & 00000000000000000000000000000001 = 1. The last bit of n is 1, so increment count to 3.\\n10. n >> 1 = 00000000000000000000000000000000\\n11. Loop terminates because n is now 0.\\n12. Return count = 3.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        # Initialize a counter variable to 0\\n        count = 0\\n        # Loop until n is 0\\n        while n != 0:\\n            # If the last bit of n is 1, increment the counter\\n            if n & 1 == 1:\\n                count += 1\\n            # Shift n to the right by 1 bit\\n            n = n >> 1\\n        # Return the counter\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        # Initialize a counter variable to 0\\n        count = 0\\n        # Loop until n is 0\\n        while n != 0:\\n            # If the last bit of n is 1, increment the counter\\n            if n & 1 == 1:\\n                count += 1\\n            # Shift n to the right by 1 bit\\n            n = n >> 1\\n        # Return the counter\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55434,
                "title": "concise-java-solution-x-x-1",
                "content": "x & (x-1) helps to remove right most 1 for x. For reference, see [Bit Hacks][1]\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            while(n != 0){\\n                n = n & (n-1);\\n                count++;\\n            }\\n            return count;\\n        }\\n    }\\n\\n  [1]: http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            while(n != 0){\\n                n = n & (n-1);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 427069,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    let sum = 0;\\n    \\n    while(n != 0) {\\n        sum += n & 1;\\n        n = n >>> 1;\\n    }\\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    let sum = 0;\\n    \\n    while(n != 0) {\\n        sum += n & 1;\\n        n = n >>> 1;\\n    }\\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045330,
                "title": "solution-to-follow-up-question",
                "content": "**A try to solve the follow-up to this question:**\\n*(Please review it)*\\n\\nIn case the call to this function is huge, it is worth precomputing some stuff so that we can achieve O(1) time complexity of this function.\\n\\nNumbers are 32-bits long, so we can split it in two (first 16-bits and second 16-bits)\\n\\nKeep an array for answers of 16-bit numbers.\\n\\n```\\nconst int len = 1 << 16;\\nint f[len]; // this will store answers for 16-bit numbers\\n\\nvoid precompute() {\\n\\tf[0] = 0;\\n\\tfor(int i = 1; i < len; i++) {\\n\\t\\tf[i] = f[i>>1] + (i&1);\\n\\t}\\n}\\n\\nint hammingWeight(uint32_t n) {\\n\\treturn f[n/len] + f[n%len]; // O(1) call\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst int len = 1 << 16;\\nint f[len]; // this will store answers for 16-bit numbers\\n\\nvoid precompute() {\\n\\tf[0] = 0;\\n\\tfor(int i = 1; i < len; i++) {\\n\\t\\tf[i] = f[i>>1] + (i&1);\\n\\t}\\n}\\n\\nint hammingWeight(uint32_t n) {\\n\\treturn f[n/len] + f[n%len]; // O(1) call\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074152,
                "title": "easy-o-1-space-python-c",
                "content": "***Please upvote if you find it useful***\\n\\n\\n---\\n1. #### Loop and find set bit\\n\\nThe main idea is to find the number of set bits using the masking operator. \\neg: For a binary number` 00000000000000000000000010000000`, we can check if a bit is set at a specific position by doing the following:\\n```\\n(00000000000000000000000010000000 & (1<<7))!=0\\n\\n(1<<7) acts as a mask to find the set bit at the 7th bit position\\n```\\n\\n\\n\\n**Python3**\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int: \\n        return sum((n & (1<<i))!=0 for i in range(32))\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;         \\n        for (int i = 0; i < 32; i++)\\n\\t\\t{ \\t\\t\\t\\n            if((n & (1<<i))!=0)\\n                cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n---\\n\\n2. #### Bit Manipulation\\n\\nThis is a little faster. The max number of iterations in this algorithm is the number of set bits in the input `n`.\\n\\n**Python3**\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        cnt = 0\\n        while n :\\n            cnt+=1\\n            n = n & (n-1)\\n        return cnt\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;         \\n        while(n!=0)\\n\\t\\t{ \\n\\t\\t\\tcnt++;     \\n            n&=(n-1); \\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Time - O(1)** - The max number of bits in input `n` is bounded to 32 bits. \\n**Space - O(1)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(00000000000000000000000010000000 & (1<<7))!=0\\n\\n(1<<7) acts as a mask to find the set bit at the 7th bit position\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int: \\n        return sum((n & (1<<i))!=0 for i in range(32))\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;         \\n        for (int i = 0; i < 32; i++)\\n\\t\\t{ \\t\\t\\t\\n            if((n & (1<<i))!=0)\\n                cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        cnt = 0\\n        while n :\\n            cnt+=1\\n            n = n & (n-1)\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;         \\n        while(n!=0)\\n\\t\\t{ \\n\\t\\t\\tcnt++;     \\n            n&=(n-1); \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55211,
                "title": "0-ms-c-solution",
                "content": "    int hammingWeight(uint32_t n) {\\n        int count = n ? 1 : 0;\\n        while(n &= (n-1)) count++;\\n        return count;\\n    }\\n\\nEdit: Updated code to make it more readable. Still 0 ms.",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int count = n ? 1 : 0;\\n        while(n &= (n-1)) count++;\\n        return count;\\n    }\\n\\nEdit: Updated code to make it more readable. Still 0 ms.",
                "codeTag": "Unknown"
            },
            {
                "id": 2075970,
                "title": "three-easy-solutions-linq-no-linq-and-a-system-library",
                "content": "LINQ:\\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> Convert.ToString(n, 2).Count(x => x == \\'1\\');\\n```\\n\\nNo LINQ:\\n```csharp\\npublic int HammingWeight(uint n)\\n{\\n\\tuint c = 0;\\n\\n\\twhile(n > 0)\\n\\t{\\n\\t\\tc += n & 1; // or: c += n % 2;\\n\\t\\tn >>= 1;    // or: n /= 2;\\n\\t}\\n\\n\\treturn (int) c;\\n}\\n```\\n\\nSystem library (the proper real-world solution of this problem):\\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> System.Numerics.BitOperations.PopCount(n);\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic int HammingWeight(uint n)\\n\\t=> Convert.ToString(n, 2).Count(x => x == \\'1\\');\\n```\n```csharp\\npublic int HammingWeight(uint n)\\n{\\n\\tuint c = 0;\\n\\n\\twhile(n > 0)\\n\\t{\\n\\t\\tc += n & 1; // or: c += n % 2;\\n\\t\\tn >>= 1;    // or: n /= 2;\\n\\t}\\n\\n\\treturn (int) c;\\n}\\n```\n```csharp\\npublic int HammingWeight(uint n)\\n\\t=> System.Numerics.BitOperations.PopCount(n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55402,
                "title": "java-solution-no-need-to-iterate-all-32-bits-all-the-time",
                "content": "No need to iterate all 32 bits all the time, for the example provided, only 4 iterations required.\\n\\n    public int hammingWeight(int n) {\\n            int result = 0;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    result++;\\n                }\\n                n >>>= 1;\\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "No need to iterate all 32 bits all the time, for the example provided, only 4 iterations required.\\n\\n    public int hammingWeight(int n) {\\n            int result = 0;\\n            while (n != 0) {\\n                if ((n & 1) == 1) {\\n                    result++;\\n                }\\n                n >>>= 1;\\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 975887,
                "title": "javascript-dropping-the-least-significant-bit-lsb",
                "content": "Counting the number of 1 bits is the same as dropping the least significant bit until we find that n is now zero instead of whatever it was before.\\n\\nHere\\'s an example of how LSB works\\n\\nn = 5 --> `101`\\n\\nn = n & (n - 1) (**dropping LSB**)\\nn = 101 & (100) = 100\\n\\nAs you can see, we dropped the LSB by doing n - 1, and ANDing it with the n we had before the subtraction. \\n\\nTime Complexity: O(number of bits)\\n\\n```\\nconst hammingWeight = (n) => {\\n\\tlet count = 0;\\n\\n\\twhile (n !== 0) {\\n\\t\\tcount++;\\n\\t\\tn = n & (n - 1);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst hammingWeight = (n) => {\\n\\tlet count = 0;\\n\\n\\twhile (n !== 0) {\\n\\t\\tcount++;\\n\\t\\tn = n & (n - 1);\\n\\t}\\n\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974845,
                "title": "java-solution-and-best-approach-with-time-complexity-o-set-bits-and-extra-useful-knowledge",
                "content": "**For java coders, a special note given below must read:**\\n\\nUnsigned int means => only +ve numbers in int range (0 to 2147483647)\\nSigned int means =>  +ve and -ve numbers both in int range (-2147483648 to 2147483647)\\n\\nIn Java language, the maximum integer is 2147483647. int type in Java is signed means (-2147483648 to 2147483647) and there is no unsigned int means there you will not get only +ve numbers like (0 to 2147483647) . \\nSo the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means Integer.MAX_VALUE+1==Integer.MIN_VALUE).\\nThis force us to use\\n```\\nn!=0\\n```\\n\\nin the while condition and we cannot use\\n```\\nn>0\\n```\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.  Because -2147483648 is less than 0.\\n\\n# First Approach\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n\\n        // TC => O(n) , where n is a binary string of length 32.\\n        while(n!=0){\\n            if((n&1)==1){\\n                ans++;\\n            }\\n            //n = n>>1;  //if use this you will get TLE Error \\n\\t\\t\\tn = n>>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Note:**\\nJava supports two types of right shift operators. The >> operator is a signed right shift operator and >>> is an unsigned right shift operator. The left operands value is moved right by the number of bits specified by the right operand.\\n\\n```\\nn = n>>1; //for Signed right shift\\n```\\n```\\nn = n>>>1; //for Unsigned right shift\\n```\\n\\n\\n# Second Approach:\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n        //TC => O(k), where k is total number of set bits. set bit is 1. unset bit is 0.\\n         while(n!=0){\\n             n = n & (n-1);\\n            ans++;\\n        }\\n \\n        return ans;\\n    }\\n}\\n```\\n\\n## ***Please Upvote Guys, it motivates me to write such article for you guys Please Upvote, God Will help you If you help others.***\\n\\n![image](https://assets.leetcode.com/users/images/60a806ee-c927-42a9-8ed6-f68434fc5d8a_1693457375.858137.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nn!=0\\n```\n```\\nn>0\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n\\n        // TC => O(n) , where n is a binary string of length 32.\\n        while(n!=0){\\n            if((n&1)==1){\\n                ans++;\\n            }\\n            //n = n>>1;  //if use this you will get TLE Error \\n\\t\\t\\tn = n>>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nn = n>>1; //for Signed right shift\\n```\n```\\nn = n>>>1; //for Unsigned right shift\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int ans=0;\\n        //TC => O(k), where k is total number of set bits. set bit is 1. unset bit is 0.\\n         while(n!=0){\\n             n = n & (n-1);\\n            ans++;\\n        }\\n \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55097,
                "title": "javascript-1-line",
                "content": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};",
                "solutionTags": [],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return n.toString(2).split(\"0\").join(\"\").length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1629020,
                "title": "java-c-simple-o-1-time-faster-than-100-detailed-explanation",
                "content": "# **Please Upvote if you find the solution helpful :)**\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, maximum number of possible signed bits in int type are 32, so O(32) ~ O(1)\\n* **Space: O(1)**, in-place\\n\\n<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **00000000000000000000000000010110** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# **Please Upvote if you find the solution helpful :)**\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u>**COMPLEXITY**</u>\\n* **Time: O(1)**, maximum number of possible signed bits in int type are 32, so O(32) ~ O(1)\\n* **Space: O(1)**, in-place\\n\\n<u>**BASIC IDEA**</u>\\n\\n* Using **Brian Kernighan Algorithm,** we will **not check/compare** or loop through all the 32 bits present but **only count the set bits** which is way better than checking all the 32 bits\\n* Suppose we have a number **00000000000000000000000000010110** (32 bits), now using this algorithm we will skip the 0\\'s bit and **directly jump to set bit(1\\'s bit)** and we don\\'t have to go through each bit to count set bits i.e. the loop will be executed **only for 3 times** for the mentioned example and **not for 32 times.**\\n\\n**<u>NOTE</u>: C++ CODE fluctates a lot from 0ms - 4ms**\\n<iframe src=\"https://leetcode.com/playground/TctjyQah/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nAssume we are working for 8 bits for better understanding, but the same logic apply for 32 bits\\nSo, we will take a number having 3 set bits.\\n   `n   = 00010110`\\n`n - 1 = 00010101`(by substracting 1 from the number, all the bits gets flipped/toggled after the **rightmost set bit including the rightmost set bit itself. **\\nAfter applying &(bitwise AND) operator on n and n - 1 i.e. (n & n - 1), the **righmost set bit will be turned off/toggled/flipped**\\n\\nLet\\'s understand step by step\\n\\n* **1st Iteration**\\n&nbsp;&nbsp;&nbsp;`00010110` --> (22(n) in decimal)\\n&&nbsp;<u>`00010101`</u> --> (21(n - 1) in decimal i.e. **flipping all the bits** of n(22) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\n`n = 00010100` (20 in decimal)\\nand **increase the count**\\nbitCount++ (Initial bitCount = 0. By incrementing it, the bitCount = 1)\\n<hr>\\n\\n* **2nd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010100` --> (20(n) in decimal)\\n&&nbsp;<u>`00010011`</u> --> (19(n - 1) in decimal i.e. **flipping all the bits** of n(20) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00010000` (16 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 1. By incrementing it, the bitCount = 2)\\n<hr>\\n\\n* **3rd Iteration**\\n&nbsp;&nbsp;&nbsp;`00010000` --> (16(n) in decimal)\\n&&nbsp;<u>`00001111`</u> --> (15(n - 1) in decimal i.e. **flipping all the bits** of n(16) **after rightmost set bit including the rightmost set bit itself** )\\n&nbsp;&nbsp;&nbsp;`00000000` --> (0(n & n - 1) in decimal i.e **after applying bitwise AND(&), the rightmost set bit will be turned off** )<br>\\nAfter **applying bitwise AND(&)** ,assign this number to n i.e. `n = n & n - 1`\\nn = `00000000` (0 in decimal)\\nand **increase the count**\\nbitCount++ (previous bitCount = 2. By incrementing it, the bitCount = 3)\\n\\nNow, since the `n = 0`, there will be no furthur iteration as the condition becomes false, so it will come out of the loop and **return bitCount which is 3 which is desired output.**\\n\\n<hr>\\n\\n**Refer to the following github repsitory for more leetcode solutions**\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find the solution helpful :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 55140,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar hammingWeight = function(n) {\\n    // remove 0s from base2 representation of the number\\n    return n.toString(2).replace(/0/g, '').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hammingWeight = function(n) {\\n    // remove 0s from base2 representation of the number\\n    return n.toString(2).replace(/0/g, '').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55217,
                "title": "4ms-1-line-c-solution",
                "content": "     int hammingWeight(uint32_t n) {\\n        return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n    }",
                "solutionTags": [],
                "code": "     int hammingWeight(uint32_t n) {\\n        return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2074228,
                "title": "c-one-line-of-code",
                "content": "```\\n__builtin_popcount(n): returns number of set bits in n.\\n```\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n__builtin_popcount(n): returns number of set bits in n.\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412923,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint8_t count = 0;\\n        for(uint8_t i = 0; i<32; ++i)\\n        {\\n            uint8_t bit = (n >> i) & 1;\\n            if(bit)\\n                count++;\\n        }\\n\\n        return (int)count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        \\n        uint8_t count = 0;\\n        for(uint8_t i = 0; i<32; ++i)\\n        {\\n            uint8_t bit = (n >> i) & 1;\\n            if(bit)\\n                count++;\\n        }\\n\\n        return (int)count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55319,
                "title": "the-fastest-c-solution-o-log-n-time-o-1-space",
                "content": "    int hammingWeight(uint32_t n) {\\n        int res =0;\\n        while (n!=0)\\n        {\\n            n = n & (n-1);\\n            res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int res =0;\\n        while (n!=0)\\n        {\\n            n = n & (n-1);\\n            res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2482831,
                "title": "python-easy-solution",
                "content": "```\\ndef hammingWeight(self, n: int) -> int: # n = 00000000000000000000000000001011\\n        return bin(n).count(\"1\")    # bin(n) = 0b1011\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int: # n = 00000000000000000000000000001011\\n        return bin(n).count(\"1\")    # bin(n) = 0b1011\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377550,
                "title": "python-multiple-solutions-including-o-1",
                "content": "# Using masking\\nThe idea here is that you use masking to count number of bits in every 2 bits, then in every 4 bits and so on.\\n\\n## Example\\n\\nLets say we want to compute the number of bits in a 4 bit number to simplify things\\n```python\\nmask_sum_2bit = 0x5 => 0101\\nx = 0b1010\\n\\n# Count number of bits in every consecutive 2 bits\\n\\nx                           =>  1010\\nx & mask_sum_2bit           =>  0000\\nx >> 1                      =>  0101\\nx >> 1 & mask_sum_2bit      =>  0101\\nx = (x & mask_sum_2bit) + (x >> 1 & mask_sum_2bit ) =>  0101 # Result of computing the number of bits in every consecutive 2 bits\\n\\nmask_sum_4bit = 0x3 => 0011\\n\\nx                      => 0101\\nx & mask_sum_4bit      => 0001\\nx >> 2                 => 0001\\nx >> 2 & mask_sum_4bit => 0001\\nx = (x & mask_sum_4bit) + (x >> 2 & mask_sum_4bit) => 0010 # Result of computing the number of bits in every consecutive 4 bits\\n```\\n\\n\\n## Implementation\\n\\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\t\\n        mask_sum_2bit = 0x55555555\\n        mask_sum_4bit = 0x33333333\\n        mask_sum_8bit = 0x0F0F0F0F\\n        mask_sum_16bit = 0x00FF00FF\\n        mask_sum_32bit = 0x0000FFFF\\n        \\n        n = (n & mask_sum_2bit) + ((n >> 1) & mask_sum_2bit)\\n        n = (n & mask_sum_4bit) + ((n >> 2) & mask_sum_4bit)\\n        n = (n & mask_sum_8bit) + ((n >> 4) & mask_sum_8bit)\\n        n = (n & mask_sum_16bit) + ((n >> 8) & mask_sum_16bit)\\n        n = (n & mask_sum_32bit) + ((n >> 16) & mask_sum_32bit)\\n        \\n        return n\\n```\\n\\n# Kernighan way\\n\\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        \\n        return count\\n```\\n\\nThis exploits the fact that `n` and `n - 1` have the the same bits up to the lower order bit set in `n`. This leads `n & (n - 1)` to unset the lower order bit set in `n`.\\n\\nIf you are still confused lets take an example:\\n\\n```python\\nx = 0b1100 => 12\\ncount = 0\\n\\n# First iteration\\nx           => 1100\\nx - 1       => 1011\\nx & (x - 1) => 1000\\ncount += 1\\n\\n# Second iteration\\nx           => 1000\\nx - 1       => 0111\\nx & (x - 1) => 0000\\ncount += 1\\n\\n# We stop here as x is now 0\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nmask_sum_2bit = 0x5 => 0101\\nx = 0b1010\\n\\n# Count number of bits in every consecutive 2 bits\\n\\nx                           =>  1010\\nx & mask_sum_2bit           =>  0000\\nx >> 1                      =>  0101\\nx >> 1 & mask_sum_2bit      =>  0101\\nx = (x & mask_sum_2bit) + (x >> 1 & mask_sum_2bit ) =>  0101 # Result of computing the number of bits in every consecutive 2 bits\\n\\nmask_sum_4bit = 0x3 => 0011\\n\\nx                      => 0101\\nx & mask_sum_4bit      => 0001\\nx >> 2                 => 0001\\nx >> 2 & mask_sum_4bit => 0001\\nx = (x & mask_sum_4bit) + (x >> 2 & mask_sum_4bit) => 0010 # Result of computing the number of bits in every consecutive 4 bits\\n```\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\t\\n        mask_sum_2bit = 0x55555555\\n        mask_sum_4bit = 0x33333333\\n        mask_sum_8bit = 0x0F0F0F0F\\n        mask_sum_16bit = 0x00FF00FF\\n        mask_sum_32bit = 0x0000FFFF\\n        \\n        n = (n & mask_sum_2bit) + ((n >> 1) & mask_sum_2bit)\\n        n = (n & mask_sum_4bit) + ((n >> 2) & mask_sum_4bit)\\n        n = (n & mask_sum_8bit) + ((n >> 4) & mask_sum_8bit)\\n        n = (n & mask_sum_16bit) + ((n >> 8) & mask_sum_16bit)\\n        n = (n & mask_sum_32bit) + ((n >> 16) & mask_sum_32bit)\\n        \\n        return n\\n```\n```python\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        \\n        return count\\n```\n```python\\nx = 0b1100 => 12\\ncount = 0\\n\\n# First iteration\\nx           => 1100\\nx - 1       => 1011\\nx & (x - 1) => 1000\\ncount += 1\\n\\n# Second iteration\\nx           => 1000\\nx - 1       => 0111\\nx & (x - 1) => 0000\\ncount += 1\\n\\n# We stop here as x is now 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55112,
                "title": "python-one-line-solution",
                "content": "    def hammingWeight(self, n): \\n           return str(bin(n)).count('1')",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def hammingWeight(self, n): \\n           return str(bin(n)).count('1')",
                "codeTag": "Python3"
            },
            {
                "id": 1972706,
                "title": "sss-swift-simple-solutions-4-different-approaches",
                "content": "**Binary Arithmetic Approach**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n % 2\\n\\t\\tn /= 2\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Binary Shift Approach**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n & 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Magic way**\\n\\nhttps://stackoverflow.com/questions/4678333/n-n-1-what-does-this-expression-do\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += 1\\n\\t\\tn &= n - 1 // NOTE: look at https://stackoverflow.com/questions/4678333/\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Cheater way**\\n\\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tn.nonzeroBitCount\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n % 2\\n\\t\\tn /= 2\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += n & 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tvar n = n, result = 0\\n\\twhile n != 0 {\\n\\t\\tresult += 1\\n\\t\\tn &= n - 1 // NOTE: look at https://stackoverflow.com/questions/4678333/\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nfunc hammingWeight(_ n: Int) -> Int {\\n\\tn.nonzeroBitCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55394,
                "title": "my-10ms-c-solution-using-bit-operation",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int ans = 0;\\n            while (n) {\\n                n &= (n-1);\\n                ans++;\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int ans = 0;\\n            while (n) {\\n                n &= (n-1);\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2417856,
                "title": "java-simple-solution-bit-shifting",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n != 0) {\\n        count += (n & 1);\\n        n = n >>> 1;\\n      }\\n      return count;\\n    }\\n}\\n```\\n\\nAn Integer in Java has 32 bits, e.g. 00101000011110010100001000011010.\\nTo count the 1s in the Integer representation we put the input int\\nn in bit AND with 1 (that is represented as\\n00000000000000000000000000000001, and if this operation result is 1,\\nthat means that the last bit of the input integer is 1. Thus we add it to the 1s count.\\nones = ones + (n & 1);\\n\\nThen we shift the input Integer by one on the right, to check for the\\nnext bit.\\nn = n>>>1;\\n\\nWe need to use bit shifting unsigned operation >>> (while >> depends on sign extension)\\n\\nWe keep doing this until the input Integer is 0.\\nIn Java we need to put attention on the fact that the maximum integer is 2147483647. Integer type in Java is signed and there is no unsigned int. So the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, that means Integer.MAX_VALUE+1==Integer.MIN_VALUE).\\nThis force us to use\\n\\nn!=0\\n\\nin the while condition and we cannot use\\n\\nn>0\\n\\nbecause the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 for n=2147483648.\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n != 0) {\\n        count += (n & 1);\\n        n = n >>> 1;\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881242,
                "title": "java-2ms-o-n-easy-and-simple-solution",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String num = Integer.toBinaryString(n); //build in function in java to convert Integer to Binary String \\n        int count=0;\\n        for(char ch:num.toCharArray()){\\n            if(ch==\\'1\\')\\n                count++; //just counting the number of 1\\'s\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo Upvote if it helped !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String num = Integer.toBinaryString(n); //build in function in java to convert Integer to Binary String \\n        int count=0;\\n        for(char ch:num.toCharArray()){\\n            if(ch==\\'1\\')\\n                count++; //just counting the number of 1\\'s\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186879,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the integer**, we can achive this result by using **Bitwise and Bitshift** operators [i.e. & and >>>] (*Look the note section for other technique*). These operators are faster, give you a precise control over individual bits of a number and are kinda cute when you understand them :D \\n\\n*At each iteration* we have to do Three operations:\\n1) If the **number is odd** there is a \\'1\\' in the last right position, we have to count it;\\n2) **Shift the number** right by one position, it will remove the most right \\'1\\' and add a \\'0\\' at the most left position;\\n3) If the **number is zero** this mean I have no other one to fint.\\n\\n**Note:** Is possible to solve the problem using a **simpler approach** such as `n % 2 == 0` to check if the last bit is zero or one and using `n = n / 2` to make the shift.\\n \\n**Bitwise AND (&):** It returns bit by bit AND of input values [i.e. if both bits are 1, it gives 1, else it shows 0].\\n**Unsigned Right shift operator (>>>):** Is used to shift the bits of a number right, thereby dividing the number by two. (From left add zeros)\\n\\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 94.18%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int count = 0;\\n\\n        while (n != 0) {\\n            \\n            // Check if the number is odd\\n            if ((n & 1) == 1)\\n                count++;\\n            \\n            n = n >>> 1;\\n        }\\n            \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        \\n        int count = 0;\\n\\n        while (n != 0) {\\n            \\n            // Check if the number is odd\\n            if ((n & 1) == 1)\\n                count++;\\n            \\n            n = n >>> 1;\\n        }\\n            \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648157,
                "title": "rust-one-liner-popcnt-solution",
                "content": "This problem is equivelent to the famous popcnt instruction, e.g count the number of ones in a binary number. This is a realitivley foundamental operation and has hardware support on (most modern) cpus.\\n\\nThe promissed one line solution comes as a standard function for i32 \\n\\n```rust\\npub fn hammingWeight (n: u32) -> i32 {\\n        n.count_ones() as i32\\n}\\n```\\n\\nIf we look at the diassembly we see that this is acutally only rellying on a single popcnt instruction and some movs.  This is assembly taken from this [godbolt](https://godbolt.org/z/WfYE8aYnv) session with the rust 1.57 compiler targetting haswell cpus.\\n\\n```asm\\nexample::hammingWeight:\\n        push    rax\\n        popcnt  eax, edi ; HERE is the main show\\n        mov     dword ptr [rsp + 4], eax\\n        mov     eax, dword ptr [rsp + 4]\\n        mov     dword ptr [rsp], eax\\n        mov     eax, dword ptr [rsp]\\n        pop     rcx\\n        ret\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn hammingWeight (n: u32) -> i32 {\\n        n.count_ones() as i32\\n}\\n```\n```asm\\nexample::hammingWeight:\\n        push    rax\\n        popcnt  eax, edi ; HERE is the main show\\n        mov     dword ptr [rsp + 4], eax\\n        mov     eax, dword ptr [rsp + 4]\\n        mov     dword ptr [rsp], eax\\n        mov     eax, dword ptr [rsp]\\n        pop     rcx\\n        ret\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044847,
                "title": "python-simple-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hammingWeight(self, n: int) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tans += n % 2\\n\\t\\t\\t\\tn = n >> 1\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef hammingWeight(self, n: int) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tans += n % 2\\n\\t\\t\\t\\tn = n >> 1\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 542786,
                "title": "python-very-simple-12ms-beats-99-98",
                "content": "**Code:**\\n```\\ndef hammingWeight(self, n: int) -> int:\\n        return sum((n>>i&1 for i in range(32)))\\n```\\n\\n**Explanation:**\\nUse bitwise operations:\\n- `&1` returns 1 if the last bit of the result of `n>>i` == 1, else 0\\n- By using `n>>i`, we shift the bits to the right by i places\\n- this way, every bit of n is the  \\'last bit\\' of `n>>i` at one point\\n- sum up the number of 1s that we found that way",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int:\\n        return sum((n>>i&1 for i in range(32)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2792326,
                "title": "java-4-solutions-bit-manipulation-string-easy",
                "content": "### **Please Upvote** :D\\n##### *Bit Manipulation approaches:*\\n##### Approach 1:\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### Approach 2:\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### Approach 3:\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\\n##### *Converting Binary input to String:*\\nWe remove all 0s from the string and return the length of the remaining string which would contain only 1s.\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n).replaceAll(\"0\", \"\");\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(N * logN) => O(32 * log32) => O(1\\n// N -> number of bits\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>>= 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(1)\\n```\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n).replaceAll(\"0\", \"\");\\n        return s.length();\\n    }\\n}\\n\\n// TC: O(N * logN) => O(32 * log32) => O(1\\n// N -> number of bits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716328,
                "title": "a-simple-solution-in-java-0-ms",
                "content": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650429,
                "title": "100-faster-without-bit-manipulation-optimal",
                "content": "![image](https://assets.leetcode.com/users/images/2d9ebd17-0471-4798-9da4-93e3d7b8c1d4_1664704138.696063.png)\\n![image](https://assets.leetcode.com/users/images/b5c67aad-9a56-4b6e-b398-779b3b4511ce_1664704208.2583528.gif)\\n\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n%2==1)ans++;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578463,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef hammingWeight(self, n: int) -> int:\\n\\treturn bin(n).count(\\'1\\')\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef hammingWeight(self, n: int) -> int:\\n\\treturn bin(n).count(\\'1\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1127507,
                "title": "recursive-one-liner-with-bits",
                "content": "TC/SC-O(1) Constant\\n```const hammingWeight = n => (n === 0) ? 0 : 1 + hammingWeight(n &= n - 1);```\\n\\n**Notes**\\nCheckout my follow up post [338. Counting Bits](https://leetcode.com/problems/counting-bits/discuss/1127579/Bits-One-liner-w-Recursive-helper-func) Medium problem that utilizes this one liner.\\nBit Manipulation utilizing the [Brian Kernighan\\'s Algorithm](https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/) and refactored to use recursion.  \\n\\nBase case: ```if (n === 0) return 0;```\\nRecusive case:  ```1 + hammingWeight(n &= n - 1);```\\nUnset rightmost set bit aka flip ```1``` to ```0```: ```n &= n - 1``` aka ```n = n & (n - 1)```\\nEasier to understand, non-one liner: \\n```\\nvar hammingWeight = function(n) {\\n  if (n === 0) return 0;\\n  return 1 + hammingWeight(n &= n - 1);\\n};\\n```\\n\\n**Happy LeetCoding!**\\n*Please upvote this post\\n*Comments welcomed \\n*Positivity encouraged \\n*You\\'ve got this!",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```const hammingWeight = n => (n === 0) ? 0 : 1 + hammingWeight(n &= n - 1);```\n```if (n === 0) return 0;```\n```1 + hammingWeight(n &= n - 1);```\n```1```\n```0```\n```n &= n - 1```\n```n = n & (n - 1)```\n```\\nvar hammingWeight = function(n) {\\n  if (n === 0) return 0;\\n  return 1 + hammingWeight(n &= n - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55233,
                "title": "2-ms-java-solution-5-lines-of-code",
                "content": "    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int i = 0;\\n            while(n!=0) {\\n                n&= n-1;\\n                i++;\\n            }\\n            return i;\\n        } \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int i = 0;\\n            while(n!=0) {\\n                n&= n-1;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3762297,
                "title": "solution-with-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            if n%2==1:\\n                count+=1\\n            n=n//2\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            if n%2==1:\\n                count+=1\\n            n=n//2\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762293,
                "title": "solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        def bit(n,count):\\n            if n==0:\\n                return count \\n            if n%2==0:\\n                return bit(n//2,count)\\n            else:\\n                return bit(n//2,count+1)\\n\\n        return bit(n,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        def bit(n,count):\\n            if n==0:\\n                return count \\n            if n%2==0:\\n                return bit(n//2,count)\\n            else:\\n                return bit(n//2,count+1)\\n\\n        return bit(n,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074440,
                "title": "c-1-line-vs-5-lines-o-1",
                "content": "**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        return __builtin_popcount(n); // built-in function to count the number of 1s in a 32-bit integer\\n\\t}\\n};\\n```\\n**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        // bitset<32>() is a class that can be used to convert an integer to a bitset of 32 bits \\n        // bitset<32>().count() is a function that counts the number of 1s in a bitset \\n        return bitset<32>(n).count(); \\n\\t}\\n};\\n```\\n**Time Complexity : O(1)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        int count=0; // initialize count to 0\\n        while(n){ // while n is not 0\\n            n=n&(n-1); // set the least significant bit to 0\\n            count++; // increment count\\n        }\\n        return count; // return count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        return __builtin_popcount(n); // built-in function to count the number of 1s in a 32-bit integer\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tpublic:\\n\\tint hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        // bitset<32>() is a class that can be used to convert an integer to a bitset of 32 bits \\n        // bitset<32>().count() is a function that counts the number of 1s in a bitset \\n        return bitset<32>(n).count(); \\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) { // function to count the number of 1s in a 32-bit integer\\n        int count=0; // initialize count to 0\\n        while(n){ // while n is not 0\\n            n=n&(n-1); // set the least significant bit to 0\\n            count++; // increment count\\n        }\\n        return count; // return count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045263,
                "title": "number-of-1-bits-explanation-of-3-increasingly-faster-solutions-generalization",
                "content": "Simple problem of counting the number of bits in a 32-bit integer. For people interested in different ways to achieve this there is a lot of information in [Bit Twiddling Hacks by Sean Eron Anderson](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetNaive).\\n\\nI tried Three Solutions:\\n1. Brute force, test each bit if a 1 or a 0. O(#bits) time O(1) space\\n2. Kernighan approach, count lowest set bit each time. O(#set bits) time O(1) space\\n3. Lookup approach, create a lookup table for segments of the input. O(#segements) time O(segment size) space\\n\\nThe solutions with code are at the bottom of this post.\\n\\nThe problem explicitly states it is a 32-bit number so technically  all the solutions are constant bounded so O(1) for both time and space.\\nHowever I do think it is worth considering how to solve the problem in the face of potentially changing requirements. For example what happens if number of bits is now 64, how does that effect time taken? In this case stating a complexity in terms of bits is helpful, particularly as the second solution is O(#bits set) while the first solution is O(bits).\\nTo conclude, strictly speaking this is O(1) solution, but when considering possible extensions to the problem then giving complexity in terms of number of bits is worthwhile, particularly if it gets extended to counting bits in a PKI solution with 2,048 bit keys for example.\\n\\n**Solution 1 - Brute Force**\\nThis always takes constant time based on the number of bits (for the problem 32).\\n* For each bit\\n\\t* make it the first bit in the integer by shifting it right.\\n\\t* And it with 1 and add result to count\\n* Return count\\n\\n**Time is O(#bits)**\\n```\\n// Brute Force\\n// O(32 >= # Set Bits) = O(1)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<32; i++)\\n\\t\\tcount += (n>>i) & 1;\\n\\treturn count;\\n}\\n```\\n\\n**Solution 2 - Kernighan Approach**\\nThis uses a method attributed to Brian Kernighan of C fame. Basically it relies on the fact that if you subtract 1 from a binary number you flip the least significant set bit from 0 to 1 and set all the bits lower to 1. When we and the result of this operation with the original number we have removed the lowest set bit from the number.\\nThis takes time dependent on the number of set bits in a number.\\n* While number is not zero\\n\\t* Increment count\\n\\t* remove lowest set bit by subtracting 1 from number and anding it with the original number.\\n* Return count\\n\\n**Time is O(#set bits)**\\n```\\n// Kernighan Algorithm\\n// O(# Set Bits)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile (n != 0) {\\n\\t\\tcount++;\\n\\t\\tn = n&(n-1);\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Solution 3 - Lookup Table**\\nWe could speed things up more by having a lookup table that maps the number directly to the number of bits. Obviously it is not practical to store all 2^32 possible values so we store smaller segments. The example below uses 8-bit chunks.\\nThis takes time dependent on the number of segments so we can trade off pace for time, larger segment is more space but faster.\\nThe algorithm has two parts, a pre-compute run once to generate the lookup table, and a per-request loop to calculate the number of bits.\\n* Pre-Compute Run Once\\n\\t* Iterate over all values in a segement (0..2^(segement_bits-1))\\n\\t\\t* count for value = lowest bit (and with 0x01) + count for value / 2\\n* Calculate Number 1 Bits\\n\\t* Iterate over number in segement sizes\\n\\t\\t* Add lookup of number of bits to count\\n\\t* Return count\\n\\n**Time is O(bits/segment size in bits) Space is O(2<<segment size in bits)**\\n```\\n// Lookup Approach\\n// O(32/LOOKUP_SIZE_BITS)\\nstatic final int LOOKUP_SIZE_BITS = 8;\\nstatic final int LOOKUP_TABLE_SIZE = 1<<LOOKUP_SIZE_BITS;\\nstatic final int LOOKUP_MASK = LOOKUP_TABLE_SIZE-1;\\nstatic final int LOOKUP_LOOPS = 32/LOOKUP_SIZE_BITS;\\nstatic int[] lookup = new int[LOOKUP_TABLE_SIZE];\\nstatic {\\n\\tfor (int i=0; i<LOOKUP_TABLE_SIZE; i++)\\n\\t\\tlookup[i] = (i&1) + lookup[i/2];\\n}\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<LOOKUP_LOOPS; i++) {\\n\\t\\tcount += lookup[n&LOOKUP_MASK];\\n\\t\\tn = n>>LOOKUP_SIZE_BITS;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Brute Force\\n// O(32 >= # Set Bits) = O(1)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<32; i++)\\n\\t\\tcount += (n>>i) & 1;\\n\\treturn count;\\n}\\n```\n```\\n// Kernighan Algorithm\\n// O(# Set Bits)\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile (n != 0) {\\n\\t\\tcount++;\\n\\t\\tn = n&(n-1);\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\n// Lookup Approach\\n// O(32/LOOKUP_SIZE_BITS)\\nstatic final int LOOKUP_SIZE_BITS = 8;\\nstatic final int LOOKUP_TABLE_SIZE = 1<<LOOKUP_SIZE_BITS;\\nstatic final int LOOKUP_MASK = LOOKUP_TABLE_SIZE-1;\\nstatic final int LOOKUP_LOOPS = 32/LOOKUP_SIZE_BITS;\\nstatic int[] lookup = new int[LOOKUP_TABLE_SIZE];\\nstatic {\\n\\tfor (int i=0; i<LOOKUP_TABLE_SIZE; i++)\\n\\t\\tlookup[i] = (i&1) + lookup[i/2];\\n}\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\tfor (int i=0; i<LOOKUP_LOOPS; i++) {\\n\\t\\tcount += lookup[n&LOOKUP_MASK];\\n\\t\\tn = n>>LOOKUP_SIZE_BITS;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55162,
                "title": "one-line-c",
                "content": "```\\npublic int HammingWeight(uint n) {\\n        return Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int HammingWeight(uint n) {\\n        return Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55254,
                "title": "right-bit-shift-in-place-simple-java-solution",
                "content": "    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i = 0; i < 32; i++){  \\n                if ((n & 1) == 1) count++;\\n                n >>= 1;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i = 0; i < 32; i++){  \\n                if ((n & 1) == 1) count++;\\n                n >>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55265,
                "title": "bit-shifting-solution-using-java",
                "content": "I start by looking at each of the 32 bits for the int value and use `1 << i` to check each bit for 1.\\n\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(((1 << i) & n) != 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "I start by looking at each of the 32 bits for the int value and use `1 << i` to check each bit for 1.\\n\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if(((1 << i) & n) != 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55393,
                "title": "one-line-and-clearly-solution-java",
                "content": "Each time n & (n - 1) reduce an '1', here is the code:\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3267115,
                "title": "c-easy-solution-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing **Right Shift & And operator**\\nAnd operator checks the first bit from the right, \\nRight Shift shifts one bit to the right.\\n> These are bitwise operators they don\\'t operate on entire numbers, these work bit-by-bit. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        \\n        int count = 0 ;\\n        while (n != 0)\\n        {\\n            if(n & 1)\\n            {\\n                count ++ ;\\n            }\\n            n = n >> 1 ;\\n        }        \\n        return count ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4820e9ad-f033-4fb6-995b-06ce0be9517f_1678166340.7738085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        \\n        int count = 0 ;\\n        while (n != 0)\\n        {\\n            if(n & 1)\\n            {\\n                count ++ ;\\n            }\\n            n = n >> 1 ;\\n        }        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618943,
                "title": "java-solution-in-o-n-simple-bit-shifting",
                "content": "```\\n\\t\\tint count  = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int mask = (1 << i);\\n            if((n & mask) != 0) count++;\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tint count  = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int mask = (1 << i);\\n            if((n & mask) != 0) count++;\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074207,
                "title": "c-solution-from-brute-force-to-inbuilt",
                "content": "**C++ Solution From Brute Force to Optimized and Inbuilt**\\n* First :-> Brute force:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {int ans=0;\\n        for(int i=0;i<=31;i++){\\n            if(n%2)ans++;n/=2;\\n        }return ans;\\n    }\\n};\\n```\\n* Second :-> Optimized:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n){\\n            n&=n-1;\\n            ans++;\\n        }                           \\n       return ans;\\n    }\\n};\\n```\\n* Third :-> Inbuilt Function:\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\\n**Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {int ans=0;\\n        for(int i=0;i<=31;i++){\\n            if(n%2)ans++;n/=2;\\n        }return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n){\\n            n&=n-1;\\n            ans++;\\n        }                           \\n       return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956599,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "**Explanation**\\n\\n* Set the count to zero.\\n* If n is greater than 0, it means it enters the while loop.\\n* It uses the bitwise And operator(&) to check if n ==1.\\n* If it is true, it means increaments count value.\\n* Shifts the n value to the right extent using the right shift operator.\\n* Finally, return the counted value.\\n\\n***Diagrammatic representation***\\n\\t![image](https://assets.leetcode.com/users/images/0add3b48-7733-4aa9-88c6-901a40a912df_1650185867.5690596.png)\\n \\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n>0){\\n            if(n&1)\\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n>0){\\n            if(n&1)\\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921847,
                "title": "four-js-solutions",
                "content": "\\n1) A more JavaScripty approach with `match`\\n```\\n   return n.toString(2).match(/1/g)?.length ?? 0; \\n```\\n2) A more JavaScripty approach with `replace`\\n```\\n   return n.toString(2).replace(/0/g, \\'\\').length; \\n```\\n3) Bit left shift\\n```\\n  let res = 0;\\n  let cur = 1;\\n  for (let i = 0; i < 32; i++) {\\n    if ((n & cur) !== 0) {\\n      res++;\\n    }\\n    cur = cur << 1;\\n  }\\n  return res;\\n```\\n4) Bit trick with n & n - 1\\n```    \\n    let sum = 0;\\n    while (n) {\\n        sum++;\\n        n &= (n - 1);\\n    }\\n    return sum;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n   return n.toString(2).match(/1/g)?.length ?? 0; \\n```\n```\\n   return n.toString(2).replace(/0/g, \\'\\').length; \\n```\n```\\n  let res = 0;\\n  let cur = 1;\\n  for (let i = 0; i < 32; i++) {\\n    if ((n & cur) !== 0) {\\n      res++;\\n    }\\n    cur = cur << 1;\\n  }\\n  return res;\\n```\n```    \\n    let sum = 0;\\n    while (n) {\\n        sum++;\\n        n &= (n - 1);\\n    }\\n    return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736862,
                "title": "swift-using-nonzerobitcount-property",
                "content": "May not be in the spirit of this challenge, but for those unaware.\\n```\\n    func hammingWeight(_ n: Int) -> Int {\\n        return n.nonzeroBitCount\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func hammingWeight(_ n: Int) -> Int {\\n        return n.nonzeroBitCount\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285270,
                "title": "golang-faster-than-100",
                "content": "```\\nfunc hammingWeight(num uint32) int {\\n    val := 0\\n    for num > 0 {\\n        val += int(num & 1)\\n        num = num >> 1\\n    }\\n    return val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    val := 0\\n    for num > 0 {\\n        val += int(num & 1)\\n        num = num >> 1\\n    }\\n    return val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168853,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        while n > 0:\\n            n, r = divmod(n,2)\\n            if r == 1:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        while n > 0:\\n            n, r = divmod(n,2)\\n            if r == 1:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55227,
                "title": "easy-java-solution",
                "content": "The trick is you check the last bit of n by performing ```n & 1 ``` and add it to result. Then perform unsigned right shift ```>>>``` until n becomes 0.\\n\\n    public int hammingWeight(int n) {\\n       int result = 0;\\n       while(n != 0) { \\n          result += (n & 1);\\n          n >>>= 1;\\n       }\\n       return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n & 1 ```\n```>>>```",
                "codeTag": "Unknown"
            },
            {
                "id": 55266,
                "title": "3-line-java-solution",
                "content": "\\n    public int hammingWeight(int n) {\\n        String integer = Integer.toBinaryString(n);\\n        integer = integer.replaceAll(\"0\",\"\");\\n        return integer.length();\\n    }",
                "solutionTags": [],
                "code": "\\n    public int hammingWeight(int n) {\\n        String integer = Integer.toBinaryString(n);\\n        integer = integer.replaceAll(\"0\",\"\");\\n        return integer.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55298,
                "title": "java-3-liner-only-iterates-for-1-bits",
                "content": "    public int hammingWeight(int n) {\\n        int i;\\n        for(i=0;n!=0;i++, n&=(n-1));\\n        return i;\\n    }\\n\\n\\nn &=(n-1)\\nremoves the smallest 1 bit in n.",
                "solutionTags": [],
                "code": "    public int hammingWeight(int n) {\\n        int i;\\n        for(i=0;n!=0;i++, n&=(n-1));\\n        return i;\\n    }\\n\\n\\nn &=(n-1)\\nremoves the smallest 1 bit in n.",
                "codeTag": "Unknown"
            },
            {
                "id": 55376,
                "title": "my-simple-solution-in-java",
                "content": "the argument n is regarded as unsigned by us but signed by computer, so using \"n % 2 == 1\" to check if the lowest bit is 1 is wrong  because it doesn't concern the highest bit indicate negative value. So we use \"&\" operation instead to check the lowest bit, and we use \">>>\" (not \">>\") to do logical shift right.\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int counter = 0;\\n            while(n != 0) {\\n                if((n & 1) == 1) {\\n                    counter += 1;\\n                }\\n                n >>>= 1;\\n            }\\n            return counter;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int counter = 0;\\n            while(n != 0) {\\n                if((n & 1) == 1) {\\n                    counter += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3358563,
                "title": "solution-in-c",
                "content": "# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint hammingWeight(uint32_t n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    int count = 0;\\n\\n    while (n) {\\n        if (n & 1) {\\n            count++;\\n        }\\n        \\n        n >>= 1;\\n    }\\n\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingWeight(uint32_t n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n\\n    int count = 0;\\n\\n    while (n) {\\n        if (n & 1) {\\n            count++;\\n        }\\n        \\n        n >>= 1;\\n    }\\n\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955087,
                "title": "beats-95-o-1-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= n-1\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= n-1\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215997,
                "title": "python3-simple-solution-do-n-n-1",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        result = 0\\n        while n:\\n            n = n & (n-1)\\n            result+=1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        result = 0\\n        while n:\\n            n = n & (n-1)\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019630,
                "title": "using-brian-kernighan-s-algorithm-another-approach",
                "content": "We can use Brian Kernighan\\u2019s algorithm to improve the above naive algorithm\\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\\n\\nThe expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\\n\\nFor example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\\n\\n1st iteration of the loop: n = 52\\n \\n00110100    &               (n)\\n00110011                    (n-1)\\n~~~~~~~~\\n00110000\\n \\n \\n2nd iteration of the loop: n = 48\\n \\n00110000    &               (n)\\n00101111                    (n-1)\\n~~~~~~~~\\n00100000\\n \\n \\n3rd iteration of the loop: n = 32\\n \\n00100000    &               (n)\\n00011111                    (n-1)\\n~~~~~~~~\\n00000000                    (n = 0)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        //Using Brian Kernighan\\u2019s algorithm\\n        int count=0;\\n        while(n)\\n        {\\n            //something unique acquisition\\n            n = n & (n-1);\\n            count++;\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) \\n    {\\n        //Using Brian Kernighan\\u2019s algorithm\\n        int count=0;\\n        while(n)\\n        {\\n            //something unique acquisition\\n            n = n & (n-1);\\n            count++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1973916,
                "title": "python-one-line-solution",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n````\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n````\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")",
                "codeTag": "Java"
            },
            {
                "id": 1905512,
                "title": "python-recursive-follow-up-explained",
                "content": "We want to answer the follow up question: *If this function is called many times, how would you optimize it?*\\n# BEFORE FOLLOW UP DISCUSSION\\nLet\\'s see first a recursive solution to the original problem.\\n\\nWe will use the following property:\\n* if *n* is even, it has exactly the same number of `1` bits as *n / 2*\\n* if *n* is odd, it has exactly one more `1` bit than the number of `1` bits of *floor(n / 2)*\\n\\nThis follows from the fact that a number `n` is odd if and only if its last bit is `1`, that is, if and only if `n & 1 == 1`. Thus we can define `hammingWeight` recursively as follows:\\n```\\n    def hammingWeight(self, n: int) -> int:\\n        return self.hammingWeight(n >> 1) + (n & 1)\\n```\\n\\n# FOLLOW UP\\nIf we are going to call this function several times, we could save previous calls in cache. With a recursive approach, if we call `hammingWeight(n)` we would have calculated `hammingWeight(m)` for *every* `m` between `0` and `n` anyways, so this would be one possible solution to the follow-up question.\\n\\nAssuming we are going to call it so may times that almost every value will need to be calculated at some point, we might as well **precalculate every possible answer**, thus giving us an answer in **O(1)** time. \\n```\\n```\\nThe problem states that the inputs will be *32*-bit numbers, so we will precalculate the answers to `hammingWeight(n)` for every `n` from `0` to `(1 << 32) - 1`, using the recursive definition we discussed before, and save them in a list `memo`. The solution would look something like this:\\n```\\nclass Solution:\\n    \\n\\t# create an array of size 2 ** 32\\n    memo = [0] * (1 << 32)\\n    for i in range(1, 1 << 32):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n\\t    # ask memo for the precalculated answer\\n        return self.memo[n]\\n```\\n**There is a problem, though \\uD83D\\uDE2D.** Either *I was wrong* with assuming Python can handle **very big** integers and huge arrays with no issues, or there is a memory limitation that was exceeded on Leetcode with this approach, as running this solution results in `MemoryError`.\\n\\n# **THIS CAN BE FIXED** \\uD83D\\uDE2C\\nWe can precalculate half the answers and still be successful \\uD83E\\uDD73.\\n\\nEvery *32*-bit integer is the concatenation of *two* *16*-bit integers. We can calculate `hammingWeight` of the first *16* bits and add that to `hammingWeight` of the last *16* bits. The first *16* bits of `n` are `n >> 16` and the last *16* are `n % (1 << 16)`, thus our full (accepted) solution looks like:\\n```\\nclass Solution:\\n    \\n    memo = [0] * (1 << 16)\\n    for i in range(1, 1 << 16):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n        return self.memo[n >> 16] + self.memo[n % (1 << 16)]\\n```\\n&#8718;",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n    def hammingWeight(self, n: int) -> int:\\n        return self.hammingWeight(n >> 1) + (n & 1)\\n```\n```\\n```\n```\\nclass Solution:\\n    \\n\\t# create an array of size 2 ** 32\\n    memo = [0] * (1 << 32)\\n    for i in range(1, 1 << 32):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n\\t    # ask memo for the precalculated answer\\n        return self.memo[n]\\n```\n```\\nclass Solution:\\n    \\n    memo = [0] * (1 << 16)\\n    for i in range(1, 1 << 16):\\n        memo[i] = memo[i >> 1] + (i & 1)\\n    \\n    def hammingWeight(self, n: int) -> int:\\n        return self.memo[n >> 16] + self.memo[n % (1 << 16)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050113,
                "title": "follow-up-java",
                "content": "To use the function repeatedly, we will make an 8 bit look-up table and pass it with the input. The 32-bit unsigned integer will be split into 4 equal parts and each part will be looked up in O(1) time.\\n\\nThe look-up table can be easily built as:\\n\\n\\tint[] lookup = new int[256];\\n\\tfor(int i = 0; i <= 255; i++){\\n\\t\\tlookup[i] = (i & 1) + lookup[i / 2];\\n\\t}\\n\\nThe function can be modified as :\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n, int[] lookup) {\\n        int count = lookup[n & 0xff] + lookup[(n >> 8) & 0xff] + \\n            lookup[(n >> 16) & 0xff] + lookup[(n >> 24) & 0xff];\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n, int[] lookup) {\\n        int count = lookup[n & 0xff] + lookup[(n >> 8) & 0xff] + \\n            lookup[(n >> 16) & 0xff] + lookup[(n >> 24) & 0xff];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044806,
                "title": "c-bitwise-solution-explained-100-time",
                "content": "Basic interview problem, of the kind you are supposed to crack on the spot in most settings - of course without using built-in functions and hopefully without expensive conversions (like turning the input into a string).\\n\\nTo solve this problem, we will first of all declare an accumulator variable `res`, preset to `0`.\\n\\nWe will then loop until `n` is `!= 0`, which, provided we do not need to keep the original value of `n`, is much faster than checking all the bits individually for each number, since we need one less variable and it requires much fewer iterations for lower numbers.\\n\\nInside the loop, we will just:\\n* update `res`, increasing it when the last bit (found with `n & 1`) is `1`;\\n* update `n`, shifting it left by one bit (the one we just checked) at each iteration.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\t\\t// support variables\\n        int res = 0;\\n        while (n) {\\n            // updating res\\n\\t\\t\\tres += n & 1;\\n\\t\\t\\t// reducing n\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCuriosly, my original submissions from years ago seems to require more memory, I would guess probably because of the unoptimised (by the compiler) modulo or division inside it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n % 2) count++;\\n            n /= 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\t\\t// support variables\\n        int res = 0;\\n        while (n) {\\n            // updating res\\n\\t\\t\\tres += n & 1;\\n\\t\\t\\t// reducing n\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n % 2) count++;\\n            n /= 2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407836,
                "title": "python-one-liner",
                "content": "Here is a one line version of the common Python solution.\\n\\n```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n    \\n        return bin(n).count(\\'1\\')\\n```\\n\\nNot much better, but I didn\\'t see anyone post this option. (Maybe considered more pythonic? idk.)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n    \\n        return bin(n).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55262,
                "title": "c-solution-of-brian-kernighan-u2019s-algorithm",
                "content": "    // Brian Kernighan\\u2019s Algorithm\\n    // http://www.geeksforgeeks.org/count-set-bits-in-an-integer/\\n    int hammingWeight(uint32_t n) {\\n        int count  = 0;\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    // Brian Kernighan\\u2019s Algorithm\\n    // http://www.geeksforgeeks.org/count-set-bits-in-an-integer/\\n    int hammingWeight(uint32_t n) {\\n        int count  = 0;\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55276,
                "title": "sharing-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int count = 0;\\n            unsigned int temp;\\n            for(int i=0; i<32; i++)\\n            {\\n                temp = n & (1<<i);\\n                if(temp > 0)\\n                    count++;\\n            }\\n            \\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int count = 0;\\n            unsigned int temp;\\n            for(int i=0; i<32; i++)\\n            {\\n                temp = n & (1<<i);\\n                if(temp > 0)\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55405,
                "title": "my-simple-python-and-java-solution-for-share",
                "content": "    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n >>>= 1)\\n            count += 1 & n;\\n        \\n        return count;\\n    }\\n    }\\n\\nBit Hack\\n\\n    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n &= n-1){\\n            count++;\\n        }\\n        return count;\\n    }\\n    }\\n\\nPython one line\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def hammingWeight(self, n):\\n        return bin(n).count('1')",
                "solutionTags": [],
                "code": "class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for (; n != 0; n >>>= 1)\\n            count += 1 & n;\\n        \\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 55427,
                "title": "c-solution-only-need-1ms",
                "content": "<pre><code>\\nint hammingWeight(uint32_t n) {\\n    \\n    int ret = 0;\\n    while (n) {\\n        if (n & 0x01)\\n            ret++;\\n        n >>= 1;\\n    }\\n    return ret;\\n}\\n</code></pre>",
                "solutionTags": [],
                "code": "<pre><code>\\nint hammingWeight(uint32_t n) {\\n    \\n    int ret = 0;\\n    while (n) {\\n        if (n & 0x01)\\n            ret++;\\n        n >>= 1;\\n    }\\n    return ret;\\n}\\n</code></pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 3357523,
                "title": "go-solution-with-bitwise-operators",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc hammingWeight(num uint32) int {\\n    res := 0\\n    for num > 0 {\\n        if num & 1 == 0 {\\n            num >>= 1\\n        } else {\\n            num &^= 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    res := 0\\n    for num > 0 {\\n        if num & 1 == 0 {\\n            num >>= 1\\n        } else {\\n            num &^= 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095697,
                "title": "python-3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830302,
                "title": "100-fastest-easy-c-solution-o-1-0ms-with-complexity",
                "content": "Here is My C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ones=0;\\n        for (int i=0; i<32; i++){\\n            if (n&1){\\n                ones++;\\n            }\\n            n= n>>1;\\n        }\\n        return ones;\\n    }\\n};\\n```\\n\\nIt is 100 % fast solution. 100% fastest and 0ms runtime.\\n\\n**Time Complexity : O(1)\\nSpace Complexity: O(1)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ones=0;\\n        for (int i=0; i<32; i++){\\n            if (n&1){\\n                ones++;\\n            }\\n            n= n>>1;\\n        }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812013,
                "title": "golang-bit-manipulation",
                "content": "# Approach\\nLet\\'s consider ***num = 5*** which in binary notation will look like **101**. \\n\\nEvery step we do the following:\\n1. binary AND operation with 1\\n    10**1** & 00**1** = 00**1** - since the last bit of 5 is 1 we add 1 to the final result.\\n2. binary shift 1 bit to the right:\\n    101 >> 1 = 010\\n\\nRepeat until the original number is 0. \\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(logN)$$\\nWhere ***N*** is the number of bits in the binary representation of ***num***\\n\\n# Code\\n```\\nfunc hammingWeight(num uint32) int {\\n    var res uint32\\n\\n    for num != 0 {\\n        res += num & 1 \\n        num >>= 1\\n    }\\n\\n    return int(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hammingWeight(num uint32) int {\\n    var res uint32\\n\\n    for num != 0 {\\n        res += num & 1 \\n        num >>= 1\\n    }\\n\\n    return int(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791463,
                "title": "java",
                "content": "```\\n\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369836,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        return Integer.bitCount(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323567,
                "title": "c-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n!=0){\\n            n=n&n-1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n        while(n!=0){\\n            n=n&n-1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173193,
                "title": "the-dumbest-solution-java-dumb-coder",
                "content": "```\\n\\t\\t//convert to string remove 0\\'s and just return the length of the string EZY PZY\\n        return Integer.toBinaryString(n).replaceAll(\"0\",\"\").length();\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t//convert to string remove 0\\'s and just return the length of the string EZY PZY\\n        return Integer.toBinaryString(n).replaceAll(\"0\",\"\").length();\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075153,
                "title": "c-easy-to-understand-bit-manipulation-3-approaches",
                "content": "**Approach 1:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\\n**Approach 2:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      return bitset<32>(n).count();\\n    }\\n};\\n```\\n**Approach 3:-**\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;\\n      while(n>0){\\n          n=n&(n-1);\\n          cnt++;\\n      }\\n      return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      return bitset<32>(n).count();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n      int cnt=0;\\n      while(n>0){\\n          n=n&(n-1);\\n          cnt++;\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074858,
                "title": "java-solution-with-dry-run",
                "content": "// dry run of this approach is \\n for example = n= 1 0 1 1 1 (binary representation of number )\\n     k  =    10111 - 1 =  10110     (-1  will flip digits till it encounter 1 from right to left  )  \\n\\t\\t n = 10111 & k = 10110\\n\\t\\t // 2nd iteration\\n\\t\\t k = 10110-1 = 10101       (flip digits till 2nd last position )\\n\\t\\t n =  10110  & k = 10100\\n\\t\\t // 3rd iteration \\n\\t\\t k = 10100 - 1 = 10011       (flip digits till 3nd last position )\\n\\t\\t n = 10100  & 10011 = 10000\\n\\t\\t // 4th \\n\\t\\t k = 10000 - 1 = 01111      (flip digit till it encounter 1  from right to left)\\n\\t\\t n = 10000  & 01111 = 00000    , 4 iteration so 4 is the answer \\n```\\n public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n!=0){\\n          n = n & (n - 1);\\n          count++;\\n      }\\n        \\n      return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int hammingWeight(int n) {\\n      int count = 0;\\n      while(n!=0){\\n          n = n & (n - 1);\\n          count++;\\n      }\\n        \\n      return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935570,
                "title": "java-multiple-approaches",
                "content": "# Brute Force Approach\\n```\\npublic int hammingWeight(int n) {\\n\\n        String num = Integer.toBinaryString(n);// convert Integer to Binary String \\n        int count = 0;\\n        for(char ch : num.toCharArray()){\\n            if(ch == \\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\\n\\n# Using BitMasking\\n```\\npublic int hammingWeight(int n) {\\n//         using bit masking\\n        int count = 0, i = 0;\\n        while(i < 32){\\n            int mask = (1 << i++);\\n            if((n & mask) != 0) count++;\\n        }\\n        return count;\\n    }\\n```\\n\\n# Right Shift Operation\\n```\\npublic int hammingWeight(int n) {\\n        int count = 0;\\n        while(n != 0){\\n            if((n & 1) != 0) count++;\\n            n >>>= 1;\\n        }\\n        return count;\\n    }\\n```\\n# Using hamming distance method\\n*  Do & operation of that number with n-1 till num != 0\\n*  eg -\\n\\t\\tnum = 123\\n\\t\\tnum = num&(num-1) = 123 & 122 => 122\\n\\t\\tnum = num&(num-1) = 122 & 121 => 120\\n\\t\\tnum = num&(num-1) = 120 & 119 => 112\\n\\t\\tnum = num&(num-1) = 112 & 111 => 96\\n\\t\\tnum = num&(num-1) = 96 & 95 => 64\\n\\t\\tnum = num&(num-1) = 64 & 63 => 0\\n```\\npublic int hammingWeight(int n) {\\n//         using hamming distance method\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n = (n & (n-1));\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\n        String num = Integer.toBinaryString(n);// convert Integer to Binary String \\n        int count = 0;\\n        for(char ch : num.toCharArray()){\\n            if(ch == \\'1\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n//         using bit masking\\n        int count = 0, i = 0;\\n        while(i < 32){\\n            int mask = (1 << i++);\\n            if((n & mask) != 0) count++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n        int count = 0;\\n        while(n != 0){\\n            if((n & 1) != 0) count++;\\n            n >>>= 1;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hammingWeight(int n) {\\n//         using hamming distance method\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n = (n & (n-1));\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808386,
                "title": "java-1-liner-explained",
                "content": "**Method 1:** Check each of the 32 bits if it\\'s set or not\\n>**T/S:** O(1)/O(1)\\n```\\npublic int hammingWeight(int n) {\\n\\tvar popCount = 0;\\n\\tfor (var i = 0; i < 32; i++, n >>= 1)\\n\\t\\tpopCount += n & 1;\\n\\treturn popCount;\\n}\\n```\\n**Method 2:** Use `bitCount` method\\n```\\npublic int hammingWeight(int n) {\\n\\treturn Integer.bitCount(n);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\tvar popCount = 0;\\n\\tfor (var i = 0; i < 32; i++, n >>= 1)\\n\\t\\tpopCount += n & 1;\\n\\treturn popCount;\\n}\\n```\n```\\npublic int hammingWeight(int n) {\\n\\treturn Integer.bitCount(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795287,
                "title": "c-solution-brian-kernighan-s-algorithm-0ms",
                "content": "```\\nint hammingWeight(uint32_t n) {\\n       uint32_t cnt=0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hammingWeight(uint32_t n) {\\n       uint32_t cnt=0;\\n        while(n)\\n        {\\n            n&=(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1733197,
                "title": "python-very-simple-iterative-solution-using-bitwise-operators",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        # while there are no more zeros left in our number (000000 == 0)\\n        while n:\\n\\t\\t\\t# & operator returns a binary number that has 1 in every position where both numbers contain a 1. If we use the\\n\\t\\t\\t# & operator with our number and one, it will check if the the first digit is a 1 or a 0. \\n            if n & 1:\\n\\t\\t\\t\\t# if a one exists in the first digit of our current number, increment count\\n                count += 1\\n\\t\\t\\t# shift n to the right one bit to \"iterate\" over the number\\n            n = n >> 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        # while there are no more zeros left in our number (000000 == 0)\\n        while n:\\n\\t\\t\\t# & operator returns a binary number that has 1 in every position where both numbers contain a 1. If we use the\\n\\t\\t\\t# & operator with our number and one, it will check if the the first digit is a 1 or a 0. \\n            if n & 1:\\n\\t\\t\\t\\t# if a one exists in the first digit of our current number, increment count\\n                count += 1\\n\\t\\t\\t# shift n to the right one bit to \"iterate\" over the number\\n            n = n >> 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708083,
                "title": "javascript-functional-programming-approach-o-n-time-o-n-space",
                "content": "```\\nvar hammingWeight = function(n) {\\n    return Array.from(n.toString(2)).reduce((acc, n) => acc += Number(n), 0)\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nvar hammingWeight = function(n) {\\n    return Array.from(n.toString(2)).reduce((acc, n) => acc += Number(n), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461232,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Check 32 bits**\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        for i in range(32):\\n            if (n >> i) & 1:\\n                ans += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(32)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Clear the rightmost bit one by one**\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= (n-1)  # Clear the rightmost bit\\n            ans += 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(32)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        for i in range(32):\\n            if (n >> i) & 1:\\n                ans += 1\\n        return ans\\n```\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            n &= (n-1)  # Clear the rightmost bit\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304131,
                "title": "easy-python-solution-95-81",
                "content": "Runtime: 24 ms, faster than 95.81% of Python3 online submissions for Number of 1 Bits.\\nMemory Usage: 14.3 MB, less than 35.35% of Python3 online submissions for Number of 1 Bits.\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        c=0\\n        while n:\\n            if(n&1):\\n                c+=1\\n            n=n>>1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 95.81% of Python3 online submissions for Number of 1 Bits.\\nMemory Usage: 14.3 MB, less than 35.35% of Python3 online submissions for Number of 1 Bits.\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        c=0\\n        while n:\\n            if(n&1):\\n                c+=1\\n            n=n>>1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 1044767,
                "title": "c-super-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            count += n % 2;\\n            n = n >> 1;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            count += n % 2;\\n            n = n >> 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988345,
                "title": "javascript-one-liner",
                "content": "```\\nconst hammingWeight = n => \\n  n.toString(2).match(/1/g)?.length ?? 0; \\n  ```\\n  See the optional chaining operator `?.`:\\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#Relationship_with_the_optional_chaining_operator_",
                "solutionTags": [],
                "code": "```\\nconst hammingWeight = n => \\n  n.toString(2).match(/1/g)?.length ?? 0; \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 965267,
                "title": "python-bit-manipulation-trick",
                "content": "From Elements of Programming Interviews in Python, `n &= n - 1` deletes the last `1` bit in `n`. For example, `n = 0b1010`, then\\n\\n`0b1010 & 0b1010 - 0b0001 =`\\n`0b1010 & 0b1001 =`\\n`0b1000`\\n\\nAnd you repeat this until there are no ones left. Time complexity is `O(k)` where `k` is the number of ones in the binary representation.\\n\\n```python\\ndef hammingWeight(self, n: int) -> int:\\n        count = 0\\n        while n:\\n            count += 1\\n            n &= n - 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\ndef hammingWeight(self, n: int) -> int:\\n        count = 0\\n        while n:\\n            count += 1\\n            n &= n - 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890389,
                "title": "python-simple-solution-using-bit-operations",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res += n & 1\\n            n >>= 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res += n & 1\\n            n >>= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722156,
                "title": "c-3-approaches-inbuilt-2-manually",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 6.1 MB, less than 38.02% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 5.9 MB, less than 90.40% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\\n***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Number of 1 Bits.\\nMemory Usage: 6.1 MB, less than 37.16% of C++ online submissions for Number of 1 Bits.***\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while(n){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return __builtin_popcount(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        return bitset<32>(n).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470633,
                "title": "ruby-recursive-iterative-and-with-language-tools",
                "content": "**With language tools:**\\nThe integer is converted to a string, passing in 2 as the base, ensuring we get a string version of the binary number. Then we count the number of \\'1\\' characters in the string.\\n\\n```\\ndef hamming_weight(n)\\n  n.to_s(2).count(\\'1\\')\\nend\\n```\\n\\n**Iterative with mod/division:**\\nBecause binary is base 2, we can learn what the last digit of the number is by using mod 2 and can then remove it by dividing the number by 2. One by one we remove the last number until there are no numbers left. By adding them all individually we can learn how many ones there are.\\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += n%2\\n    n /= 2\\n  end\\n  sum\\nend\\n```\\n\\n**Iterative with bit shifting:**\\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += (n & 1)\\n    n >>= 1\\n  end\\n  sum\\nend\\n```\\n\\n**Recursive with mod/division:**\\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n % 2) + hamming_weight(n/2) \\nend\\n```\\n\\n**Recursive with bit shifting:**\\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n & 1) + hamming_weight(n>>1) \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef hamming_weight(n)\\n  n.to_s(2).count(\\'1\\')\\nend\\n```\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += n%2\\n    n /= 2\\n  end\\n  sum\\nend\\n```\n```\\ndef hamming_weight(n)\\n  sum = 0\\n  while n > 0\\n    sum += (n & 1)\\n    n >>= 1\\n  end\\n  sum\\nend\\n```\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n % 2) + hamming_weight(n/2) \\nend\\n```\n```\\ndef hamming_weight(n)\\n  n.zero? ? 0 : (n & 1) + hamming_weight(n>>1) \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 390985,
                "title": "c-cheat-solution",
                "content": "The GCC compiler (which LeetCode appears to use) provides a builtin function `__builtin_popcount` that computes the Hamming weight. Some processors can even do this in a single instruction, and `__builtin_popcount` will use that instruction if available.\\n\\n```c\\nint hammingWeight(uint32_t n) {\\n    return __builtin_popcount(n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nint hammingWeight(uint32_t n) {\\n    return __builtin_popcount(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55380,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int res=0;\\n            while (n!=0) {\\n                res += n&1;\\n                n = n >> 1;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hammingWeight(uint32_t n) {\\n            int res=0;\\n            while (n!=0) {\\n                res += n&1;\\n                n = n >> 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55431,
                "title": "simple-java-solution",
                "content": "Iterate over each bit starting from the rightmost bit and working our way left.\\n\\n    public class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i=0; i < 32; i++) {\\n                if((n & (1 << i)) != 0) count++;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        // you need to treat n as an unsigned value\\n        public int hammingWeight(int n) {\\n            int count = 0;\\n            for(int i=0; i < 32; i++) {\\n                if((n & (1 << i)) != 0) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3762803,
                "title": "done-through-recurrsion-beginner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- recurrsion approach -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(log(n)) -->\\n\\n- Space complexity:\\n<!-- 15 mb -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return self.binary(n,0)\\n    def binary(self,n,count):\\n        if n==0: return count\\n        elif n%2==0: return self.binary(n//2,count)\\n        else: return self.binary(n//2,count+1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return self.binary(n,0)\\n    def binary(self,n,count):\\n        if n==0: return count\\n        elif n%2==0: return self.binary(n//2,count)\\n        else: return self.binary(n//2,count+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534668,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nUsing Right Shift\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460892,
                "title": "beats-49-2-25-145-top-interview-question",
                "content": "# Intuition\\n*right shift and left shift, Bit manipulation*\\n\\n# Approach\\nThis is a Python class method called `hammingWeight`, which takes an integer `n` as input and returns the number of 1-bits in its binary representation. Here\\'s a step-by-step breakdown of how the method works:\\n\\n1. Initialize a counter variable `count` to 0.\\n2. Loop 32 times, since integers in Python are represented using 32 bits.\\n3. Check if the least significant bit of `n` is 1 by using the modulo operator (`%`) to check if `n` is odd.\\n4. If the least significant bit is 1, increment the counter `count` by 1.\\n5. Right shift the binary representation of `n` by 1 bit (using the `>>` operator) to remove the least significant bit.\\n6. Repeat steps 3-5 for the remaining 31 bits of `n`.\\n7. Return the final count of 1-bits.\\n\\n`Note:`  that this implementation assumes that `n` is a non-negative integer. If `n` is negative, the method will return the number of 1-bits in its two\\'s complement representation (which may be more than 32 bits).\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\nThe `time complexity` of the `hammingWeight` method is `O(1)` since it always loops through a fixed number of iterations (32). Therefore, the time taken to execute the method does not depend on the size of the input.\\n\\nThe `space complexity` of the method is also `O(1)` since it only uses a fixed amount of memory to store the `count` variable and the loop counter. Regardless of the size of the input integer `n`, the method uses the same amount of memory to store these variables.\\n\\nIn summary, the `hammingWeight` method has a `constant time complexity of O(1)` and a `constant space complexity of O(1)`.\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        for _ in range(32):\\n            if n%2 == 1:\\n                count +=1\\n            n = n >> 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count = 0\\n        for _ in range(32):\\n            if n%2 == 1:\\n                count +=1\\n            n = n >> 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436437,
                "title": "c-simple-clean-code-bit-manipulation-beats-100",
                "content": "# Complexity\\n- Time complexity: O(32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        \\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232958,
                "title": "one-line-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:99% -----> please upvote me\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)-----> it would encourage me\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].zfill(32).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        return bin(n)[2:].zfill(32).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200312,
                "title": "counting-the-number-of-1-bits-in-an-unsigned-integer-using-binary-representation-and-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to count the number of \\'1\\' bits in the binary representation of an unsigned integer. One possible approach is to convert the integer to binary and count the number of \\'1\\' bits in the resulting string.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solve this problem is to convert the input integer to binary using the built-in `bin` function in Python. Then, we can count the number of \\'1\\' bits in the resulting binary string using the `count` method. To optimize the function for repeated calls, we can use memoization to cache the results for each integer that we have already processed.\\n# Complexity\\n- Time complexity: The time complexity of the `hammingWeight` method is $$O(log n)$$, where n is the input integer, since the `bin` function has a time complexity of $$O(log n)$$, and the `count` method has a time complexity of $$O(m)$$, where m is the length of the binary string.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the `hammingWeight` method is $$O(log n)$$, since we need to store the binary string of the input integer, which has a length of $$O(log n)$$. In addition, we use a cache to store the results of previously processed integers, which could take up additional space.\\n\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import Dict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def hammingWeight(self, n: int) -> int:\\n        if n in self.cache:\\n            return self.cache[n]\\n        else:\\n            count = bin(n).count(\\'1\\')\\n            self.cache[n] = count\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom typing import Dict\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def hammingWeight(self, n: int) -> int:\\n        if n in self.cache:\\n            return self.cache[n]\\n        else:\\n            count = bin(n).count(\\'1\\')\\n            self.cache[n] = count\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172788,
                "title": "100-beats-with-0ms-fast-solution-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int k=0;\\n        while(n>0)\\n        {\\n            n=n&n-1;\\n            k++;\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int k=0;\\n        while(n>0)\\n        {\\n            n=n&n-1;\\n            k++;\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834893,
                "title": "easy-and-fast-sol-java-time-o-1-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nand the the no with left shift 1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking 1 and shifting left side while checking with number n by and opration \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        int a=1;\\n        for (int i=0;i<32;++i){\\n            if( (n & a)!=0)count++;\\n            a<<=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        int a=1;\\n        for (int i=0;i<32;++i){\\n            if( (n & a)!=0)count++;\\n            a<<=1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818712,
                "title": "c-simple-solution",
                "content": "\\tint hammingWeight(uint32_t n) {\\n    uint32_t b = n;\\n    int count = 0;\\n    while(b>0){\\n        if (b%2==1){\\n            count++;\\n        }\\n        b/=2;\\n    }\\n    return count;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint hammingWeight(uint32_t n) {\\n    uint32_t b = n;\\n    int count = 0;\\n    while(b>0){\\n        if (b%2==1){\\n            count++;\\n        }\\n        b/=2;\\n    }\\n    return count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2813242,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        return bin(n).count(\\'1\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n):\\n        return bin(n).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790226,
                "title": "java-easy-solution-bit-shifting",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll check if we have bit \"1\" at the first position of given ```n``` (i.e. first position from right side) and will keep on shifting ```n``` towards right by 1\\n**NOTE -> Bitwise Zero Fill Right Shift Operator has to be used here.**\\n\\n```>>``` - *Bitwise Right Shift Operator* preserves the sign bit.\\n```>>>``` - *Bitwise Zero Fill Right Shift* Operator **do not** preserves the sign bit.\\n\\n# Complexity\\n- Time complexity: **O(logn)** \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution... :)$$\\n# Code\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while(n != 0) {\\n            count += (n & 1);\\n            n = n >>> 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```n```\n```n```\n```>>```\n```>>>```\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n\\n        while(n != 0) {\\n            count += (n & 1);\\n            n = n >>> 1;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696605,
                "title": "best-easy-3-methods",
                "content": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n1st method\\n        c = 0\\n        b = bin(n)[2:]\\n        for i in b:\\n            if i == \\'1\\':\\n                c = c + 1\\n        return c\\n    \\n2nd method\\n\\n        res = 0\\n        for i in range(32):\\n            res += n & 1\\n            n = n >> 1\\n        \\n        return res        \\n        \\n3rd method\\n        \\n        res = 0\\n        while n:\\n            n = n & (n-1)\\n            res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n1st method\\n        c = 0\\n        b = bin(n)[2:]\\n        for i in b:\\n            if i == \\'1\\':\\n                c = c + 1\\n        return c\\n    \\n2nd method\\n\\n        res = 0\\n        for i in range(32):\\n            res += n & 1\\n            n = n >> 1\\n        \\n        return res        \\n        \\n3rd method\\n        \\n        res = 0\\n        while n:\\n            n = n & (n-1)\\n            res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429512,
                "title": "no-of-1-bits-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n)\\n    {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1) \\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n)\\n    {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1) \\n                count++;\\n            n=n>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206668,
                "title": "c-solution-3-lines",
                "content": "Use a simple for-loop to check each bit and increment answer. My first post so please upvote me!\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) if(n &(1 << i)) ans++;\\n        return ans;\\n    }\\n};\\n\\n// Time Complexity O(1)\\n// Space Complexity O(1)\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) if(n &(1 << i)) ans++;\\n        return ans;\\n    }\\n};\\n\\n// Time Complexity O(1)\\n// Space Complexity O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724179,
                "title": "php-use-bit-manipulation-beat-96-55",
                "content": "```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function hammingWeight($n) {\\n        $count = 0;\\n        while ($n != 0) {\\n            if ($n & 1 == 1) {\\n                $count++;\\n            }\\n            $n = $n >> 1;\\n        }\\n        return $count;\\n    }\\n}",
                "solutionTags": [
                    "PHP",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function hammingWeight($n) {\\n        $count = 0;\\n        while ($n != 0) {\\n            if ($n & 1 == 1) {\\n                $count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1639862,
                "title": "easy-to-understand-in-c-bit-manipulation",
                "content": "class Solution {\\npublic:\\n\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n!=0){\\n            if(n & 1){\\n                ans+=1;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int hammingWeight(uint32_t n) {\\n        int ans=0;\\n        while(n!=0){\\n            if(n & 1){\\n                ans+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283125,
                "title": "java-easy-implementation-of-kernighan-s-algorithm-with-explanation-faster-then-100",
                "content": "\\nThe Solution is Based on **Brian Kernighan\\u2019s Algorithm:**  \\nThe Kernighan\\u2019s Algorithm jumps on only selective bits which are set (1).\\nWhat we are generally Doing here is finding out the right most set bit which is set i.e.  is 1 \\n    which is calculated using \"n & -n\" and then we subtract this from rsb so that the set bit will become non set now following by counting the set bit.\\n    And we count till all the bits become 0 and at the end we return the counted set bits.\\n\\t\\n\\t```\\n\\tpublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count =0;\\n        while(n != 0){\\n            long rsb = n & -n;\\n            n -= rsb;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n\\nP.S. upvote is appericiated",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hammingWeight(int n) {\\n        int count =0;\\n        while(n != 0){\\n            long rsb = n & -n;\\n            n -= rsb;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237413,
                "title": "java-100-faster-brian-kernighan-s-algo-full-explaination",
                "content": "**Brian Kernighan\\u2019s Algorithm:**\\nSubtracting 1 from a decimal number flips all the bits after the rightmost set bit(which is 1) including the rightmost set bit. So if we subtract a number by 1 and do bitwise & with itself (n & (n-1)), we unset the rightmost set bit. \\nfor example : \\n10 in binary is 00001010 \\n9 in binary is 00001001 \\n8 in binary is 00001000 \\n7 in binary is 00000111 \\nSo if we subtract a number by 1 and do it bitwise & with itself (n & (n-1)), we unset the rightmost set bit. If we do n & (n-1) in a loop and count the number of times the loop executes, we get the set bit count. \\nThe beauty of this solution is the number of times it loops is equal to the number of set bits in a given integer. \\n\\n\\t   1  Initialize count: = 0\\n\\t   2  If integer n is not zero\\n\\t\\t  (a) Do bitwise & with (n-1) and assign the value back to n\\n\\t\\t\\t  n: = n&(n-1)\\n\\t\\t  (b) Increment count by 1\\n\\t\\t  (c) go to step 2\\n\\t   3  Else return count\\n\\n```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044884,
                "title": "simple-java-solution-with-explaination-using-bit-shift",
                "content": "1.Input is given a integer example 12. We need to return number of 1\\'s in its binary form.\\n2.Idea is to iterate loop keep counting last digit in binary form and remove last digit for next iteration. break the loop if n becomes 0.\\n3.now trick is how to count 1 in binary form without converting n to binary string. for that we will use bitwise operator. If we perform bitwise & operator of any number with 1 we will get result as 1 if last digit is 1 else 0 result. why? \\nfor e.g.-> n=5. 5&1 will give 101 & 001 = 001. in decimal it is 1.\\nn=4, 4&1 will give 100 &001=000 . which is 0.\\n4. now we know how to check last digit. so just add result of above & operator with counter.\\n5. after that we need to remove last digit in binary form. so that above operator will check the correct digit. for that we can use right shift operator. as right shift by 1 will remove rightmost bit from number.\\n6. Once loop finishes counter will have desired 1\\'s count.\\nNote ->\\nsince it is mentioned in a question to treat number as unsigned.but in java every number is signed. and in java range is also cyclic INTEGER.MAX_VALUE+1=INTEGER.MIN_VALUE. so we will use right shift unsigned operator >>> instead of >>. and while loop(n!=0) as our number might go negative also if input passed is Max_VALUE.\\n```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0) {\\n            count+=(n&1);\\n            n=n>>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count=0;\\n        while(n!=0) {\\n            count+=(n&1);\\n            n=n>>>1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546593,
                "title": "python-solution-using-modulus-beating-98-in-time-and-100-in-memory",
                "content": "cnt = 0\\n        while n:\\n            cnt += n % 2\\n            n = n // 2\\n        return cnt",
                "solutionTags": [],
                "code": "cnt = 0\\n        while n:\\n            cnt += n % 2\\n            n = n // 2\\n        return cnt",
                "codeTag": "Unknown"
            },
            {
                "id": 432785,
                "title": "java-and-with-right-shift-zero-fill",
                "content": "```\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile(n!=0) {\\n\\t\\tcount += (n&1);\\n\\t\\tn>>>=1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hammingWeight(int n) {\\n\\tint count = 0;\\n\\twhile(n!=0) {\\n\\t\\tcount += (n&1);\\n\\t\\tn>>>=1;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293899,
                "title": "c-bit",
                "content": "```\\npublic class Solution {\\n    public int HammingWeight(uint n) {\\n        var count = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if ((n >> i & 1) == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int HammingWeight(uint n) {\\n        var count = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if ((n >> i & 1) == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213229,
                "title": "multiple-python-solutions",
                "content": "```\\ndef hammingWeight(self, n):\\n\\treturn bin(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\treturn \"{0:b}\".format(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\tcount = 0\\n\\twhile n > 0:\\n\\t\\tif n % 2 == 1:\\n\\t\\t\\tcount += 1\\n\\t\\tn //= 2\\n\\treturn count\\n\\ndef hammingWeight(self, n):\\n\\tif n == 0:\\n\\t\\treturn 0\\n\\treturn self.hammingWeight(n // 2) + n % 2\\n\\ndef hammingWeight(self, n):\\n\\treturn sum(1 for i in range(32) if n & (1 << i))\\n```",
                "solutionTags": [],
                "code": "```\\ndef hammingWeight(self, n):\\n\\treturn bin(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\treturn \"{0:b}\".format(n).count(\\'1\\')\\n\\ndef hammingWeight(self, n):\\n\\tcount = 0\\n\\twhile n > 0:\\n\\t\\tif n % 2 == 1:\\n\\t\\t\\tcount += 1\\n\\t\\tn //= 2\\n\\treturn count\\n\\ndef hammingWeight(self, n):\\n\\tif n == 0:\\n\\t\\treturn 0\\n\\treturn self.hammingWeight(n // 2) + n % 2\\n\\ndef hammingWeight(self, n):\\n\\treturn sum(1 for i in range(32) if n & (1 << i))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 55121,
                "title": "javascript-brian-kernighan-u2019s-algorithm",
                "content": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    var count = 0;\\n    while (n) {\\n      n &= (n-1) ;\\n      count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n    var count = 0;\\n    while (n) {\\n      n &= (n-1) ;\\n      count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55123,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func hammingWeight(_ n: Int) -> Int {\\n        var count = 0\\n        var n = n\\n        \\n        while n > 0 {\\n            n &= n - 1\\n            count += 1\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func hammingWeight(_ n: Int) -> Int {\\n        var count = 0\\n        var n = n\\n        \\n        while n > 0 {\\n            n &= n - 1\\n            count += 1\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55216,
                "title": "java-2ms-solution",
                "content": "    public int hammingWeight(int n) {\\n    \\t\\tint sum = 0;\\n    \\t\\twhile(n != 0) {\\n    \\t\\t\\tif ((n & 1) == 1) {\\n    \\t\\t\\t\\tsum++;\\n    \\t\\t\\t}\\n    \\t\\t\\tn = n >>> 1;\\n    \\t\\t}\\n    \\t\\treturn sum;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int hammingWeight(int n) {\\n    \\t\\tint sum = 0;\\n    \\t\\twhile(n != 0) {\\n    \\t\\t\\tif ((n & 1) == 1) {\\n    \\t\\t\\t\\tsum++;\\n    \\t\\t\\t}\\n    \\t\\t\\tn = n >>> 1;\\n    \\t\\t}\\n    \\t\\treturn sum;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 55246,
                "title": "my-simple-naive-c-solution",
                "content": "It's another way of asking for a number's binary sequence.\\n\\n    public class Solution {\\n        public int HammingWeight(uint n) {\\n            int count =0;\\n            while(n>0)\\n            {\\n                uint mode = n%2;\\n                if(mode == 1)\\n                    count++;\\n                n=n/2;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int HammingWeight(uint n) {\\n            int count =0;\\n            while(n>0)\\n            {\\n                uint mode = n%2;\\n                if(mode == 1)\\n                    count++;\\n                n=n/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 55296,
                "title": "my-simple-c-solution-in-o-the-number-of-ones",
                "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\n        int count=0;\\n        while (n){\\n            count++;   \\n            n&=n-1;\\n            \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n\\n        int count=0;\\n        while (n){\\n            count++;   \\n            n&=n-1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55304,
                "title": "solution-using-java-operator",
                "content": "    public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if((n & 1) == 1) count++;\\n            n = n >>> 1;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n        for(int i = 0; i < 32; i++) {\\n            if((n & 1) == 1) count++;\\n            n = n >>> 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55328,
                "title": "a-python-solution-with-some-speed-tricks",
                "content": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n    \\tdef hammingWeight(self, n):\\n    \\t\\tbitsMap = [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]\\n    \\t\\ti = 0\\n    \\t\\tresult = 0\\n    \\t\\twhile i < 32:\\n    \\t\\t\\tresult += bitsMap[(n>>i) & 15]\\n    \\t\\t\\ti += 4\\n    \\t\\treturn result\\n\\nI map a number in [0,15] to its number of  '1' bits, and the 'while' cope with 4 bits rather than 1 bits at a time, which means it will be faster.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param n, an integer\\n        # @return an integer\\n    \\tdef hammingWeight(self, n):\\n    \\t\\tbitsMap = [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]\\n    \\t\\ti = 0\\n    \\t\\tresult = 0\\n    \\t\\twhile i < 32:\\n    \\t\\t\\tresult += bitsMap[(n>>i) & 15]\\n    \\t\\t\\ti += 4\\n    \\t\\treturn result\\n\\nI map a number in [0,15] to its number of  '1' bits, and the 'while' cope with 4 bits rather than 1 bits at a time, which means it will be faster.",
                "codeTag": "Java"
            },
            {
                "id": 55372,
                "title": "a-max-value-of-int-in-java-is-2147483647-but-the-test-case-include-the-value-of-2147483648-is-the-system-wrong",
                "content": "I Try to solve this problem using java and not in a bit view. I do like this:\\n                 int num=0;\\n\\t\\t int m;\\n\\t\\t while(n!=0){\\n\\t\\t\\t m=n%2;\\n\\t\\t\\t n=n/2;\\n\\t\\t\\t if(m==1){\\n\\t\\t\\t\\t num++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return num;\\n\\nIn actually,It is a  mathematic way.it goes right in most situation,but the test case includes 2147483648,it is out of range in java.so the answer is wrong.\\nI want to know is there any way to solve this problem without using bit-operation (like &)?",
                "solutionTags": [
                    "Java"
                ],
                "code": "I Try to solve this problem using java and not in a bit view. I do like this:\\n                 int num=0;\\n\\t\\t int m;\\n\\t\\t while(n!=0){\\n\\t\\t\\t m=n%2;\\n\\t\\t\\t n=n/2;\\n\\t\\t\\t if(m==1){\\n\\t\\t\\t\\t num++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return num;\\n\\nIn actually,It is a  mathematic way.it goes right in most situation,but the test case includes 2147483648,it is out of range in java.so the answer is wrong.\\nI want to know is there any way to solve this problem without using bit-operation (like &)?",
                "codeTag": "Unknown"
            },
            {
                "id": 55370,
                "title": "a-3ms-solution-in-c",
                "content": "My first solution (6ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n > 0) {\\n            uint32_t m = n - 1;\\n            n = m & n;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nUsing register variable to improve the first solution (4ms):\\n\\n    register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            a &= (a - 1);\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nfinally, get a good balance between time complexity and space complexity (3ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int map[] = {0, 1,  1, 2,   1, 2, 2, 3,   1, 2, 2, 3, 2, 3, 3, 4};\\n        register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            count += map[0xf & a];\\n            a >>= 4;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "My first solution (6ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n > 0) {\\n            uint32_t m = n - 1;\\n            n = m & n;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nUsing register variable to improve the first solution (4ms):\\n\\n    register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            a &= (a - 1);\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\nfinally, get a good balance between time complexity and space complexity (3ms):\\n\\n    int hammingWeight(uint32_t n) {\\n        int map[] = {0, 1,  1, 2,   1, 2, 2, 3,   1, 2, 2, 3, 2, 3, 3, 4};\\n        register int count = 0;\\n        register uint32_t a = n;\\n        while (a > 0) {\\n            count += map[0xf & a];\\n            a >>= 4;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55437,
                "title": "c-solution-o-m-time-1ms",
                "content": "    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while( n )\\n        {\\n            n &= n - 1;\\n            res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while( n )\\n        {\\n            n &= n - 1;\\n            res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3985816,
                "title": "in-javascript-use-the-operator-instead-of-the-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n   let count = 0\\n   while(n!== 0){\\n   if(n&1){\\n      count++\\n   }\\n   n = n>>>1\\n//IMPORTANT NOTE:-when we are use >> operator  at that time it will not work for 11111111111111111111111111111101 this test case so we can use >>> operator because Use unsigned right shift to handle large positive numbers\\n   }\\n   return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function(n) {\\n   let count = 0\\n   while(n!== 0){\\n   if(n&1){\\n      count++\\n   }\\n   n = n>>>1\\n//IMPORTANT NOTE:-when we are use >> operator  at that time it will not work for 11111111111111111111111111111101 this test case so we can use >>> operator because Use unsigned right shift to handle large positive numbers\\n   }\\n   return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939808,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while( n > 0){\\n            ans +=  n%2;\\n            n = n/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ans = 0;\\n        while( n > 0){\\n            ans +=  n%2;\\n            n = n/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886181,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\nInitialization: Initialize an integer variable cnt to keep track of the count of set bits. This variable is initially set to 0.\\n\\nBit Traversal: Enter a loop that continues as long as n is greater than 0. This loop iterates through the bits of the binary representation of n.\\n\\nBit Parity Check: Inside the loop, perform a bitwise AND operation between n and the binary value 1 (n & 1). This operation checks whether the rightmost bit of n is set (equal to 1).\\n\\nCount Increment: If the result of the bitwise AND operation is greater than 0, it means the rightmost bit of n is set. In this case, increment the cnt variable to count this set bit.\\n\\nBit Shift: After checking the rightmost bit, right-shift n by one position (n = n >> 1), effectively moving to the next bit from right to left.\\n\\nLoop Continuation: Continue the loop until all bits of n have been traversed. When all bits are shifted out (i.e., n becomes zero), the loop will terminate.\\n\\nReturn Count: After the loop ends, the cnt variable will hold the count of set bits in the binary representation of the input n. Return this count as the final result.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;  // count of set bit\\n        while(n>0){  // iterate until all bits are traversed\\n            if((n&1)>0) // check the parity of first bit from right\\n                ++cnt;\\n            n=n>>1; //n=n/2, shift one bit to right\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632319,
                "title": "simplest",
                "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n&1) count++;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n) {\\n            if (n&1) count++;\\n            n >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532993,
                "title": "o-1-number-of-1-bits-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) -> since the length of the binary representation of the number is fixed at 32 bits.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int i, count=0;\\n        while(n>0)\\n        {\\n            i = n%2;\\n            n /= 2;\\n            if(i==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/234f529c-cadf-4728-b1b9-37b3905b47e0_1684297332.3629935.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int i, count=0;\\n        while(n>0)\\n        {\\n            i = n%2;\\n            n /= 2;\\n            if(i==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569428,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566245,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1576483,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1574925,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566224,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568785,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568380,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1739152,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1570753,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569676,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569428,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566245,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1576483,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1574925,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1566224,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568785,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1568380,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1739152,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1570753,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569676,
                "content": [
                    {
                        "username": "Redrox",
                        "content": "I don\\'t get how the input is given to the code, is it in int format or strign format? I am working on Python and when I run the program on my local machine giving the input 0000101 as input, it throws error as leading 0s is not expected. But in this question, input is int and it contains leading 0s! \\nCan someone explain please."
                    },
                    {
                        "username": "rlazimi",
                        "content": "The more important takeaway here (assuming you\\'re preparing for interviews) is that the goal of this question is for you to work with the bitwise operators (eg `<<`, `>>`, `&`).\\n\\nAs much as you may disagree that knowing those operators is useful, I suggest learning them anyway since there\\'s only a few of them. Check out this article that you can spend 5 minutes on that will help you get through these questions more easily: https://cp-algorithms.com/algebra/bit-manipulation.html."
                    },
                    {
                        "username": "shalldon",
                        "content": "instead of  n = \\'00000000000000000000000000001011\\' in STDIN you receive n = 11\\nint(\\'1011\\', 2) == 11\\n\\nto convert int to bin just use bin(n)"
                    },
                    {
                        "username": "debayon",
                        "content": "Input is just an integer and not a string of 1s and 0s."
                    },
                    {
                        "username": "yenlinhuang43",
                        "content": "The input converts the string to an integer in decimal representation (essentially ignoring the leading 0s as they don\\'t matter for the solution).\\n\\nYou\\'ll have to convert it into a binary string "
                    },
                    {
                        "username": "ait",
                        "content": "They use non-negative integers as the input because the binary representations is assumed to be unsigned."
                    },
                    {
                        "username": "kabirfaridi763",
                        "content": "no they are giving input in integers only\\n"
                    },
                    {
                        "username": "zahid2022skipq",
                        "content": "console.log(n)\\nor\\nreturn n\\n\\nfor 1st time to get idea about input"
                    },
                    {
                        "username": "areshand",
                        "content": "The signature of the function takes an integer as input. But the description says it takes an unsigned int as input. The test case also includes 1x10^32."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Tralex",
                        "content": "![image](https://assets.leetcode.com/users/images/a73f4d11-0fdc-4f73-af62-a36fc30dc6ca_1646585963.8005898.png)\\n\\n\\n\\tint hammingWeight(uint32_t n) {\\n\\t\\treturn n == 0 ? 0 : (n & 1) + hammingWeight(n >> 1);\\n\\t}\\n"
                    },
                    {
                        "username": "osamaadam",
                        "content": "Disgusting, love it."
                    },
                    {
                        "username": "shuchi1919",
                        "content": "Please explain me the signature, constraint : The input must be a binary string of length 32\\ndoesn\\'t it mean that we have to pass String to the method?\\nif method argument is int, won\\'t the example 3 etc exceeds maximum value of integer?\\n"
                    },
                    {
                        "username": "Django3",
                        "content": "If a number is negative, that is, if it has a minus sign, that number is signed."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-1-bits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Loop and Flip\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "yash17129",
                        "content": "return __builtin_popcount(n);"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess we are supposed to implement this ourselves... which doesn\\'t really make sense, because\\n1) The algorithm is widely available (e.g. in JDK and other language runtimes, and hundreds of publications).\\n2) The measurement works in such a way that difference between a naive loop doing 31 shifts, 31 ands and 31 additions, and a 6 times faster algorithm is insignificant compared to random factors influencing the measurement.\\n3) The hardware instruction is the \"proper\" way of solving it simply because it\\'s faster and requires less memory. And such instruction exists in every modern CPU.\\nAs for C++, I\\'ve done it via bitset<32>, and it executed in 0ms. I don\\'t even know whether it maps to a hardware instruction or uses a divide-and-conquer software implementation. I saw naive loops executing in 0 ms either."
                    },
                    {
                        "username": "stridemann",
                        "content": "for C#:\\nreturn (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(n);\\nDoesn\\'t looks like super fast, but do the job"
                    },
                    {
                        "username": "ak302",
                        "content": "Any idea how we can optimize the solution ( having time complexity O(no. of 1 bits) )  for follow up  part?"
                    },
                    {
                        "username": "august23",
                        "content": "This seems like a common misinterpretation of the follow up question. It doesn\\'t specify the optimization should be O(no. of 1 bits). It\\'s an open ended question of how would you optimize. \\n\\nAnswer: Since the input is bound to 32 bits, one way to do is by having a hashmap of <value: numbits> for all the combinations for say 4 bits. Then you\\'d reduce the execution time by 75%. In an actual interview it\\'d be good to ask to clarify the question. "
                    },
                    {
                        "username": "divyaraj-5935",
                        "content": "Yeah, every time you do n = n&(n-1), the last '1' bit get removed from n. So, by iterating this method and keeping the count, you can compute in the given time complexity O(no of 1 bits). Hope this helps."
                    },
                    {
                        "username": "Ronit_16",
                        "content": "I am trying to convert the int into string and then checking at each char that if it contains 1.... then incrementing the count by 1 ...why this approach is not working ?\\n"
                    },
                    {
                        "username": "Sushumna_singh",
                        "content": "I was also doing the same, but it was not working because turning into str is changing the value of n itself."
                    },
                    {
                        "username": "j3m3l",
                        "content": "I am not a Computer Scientist, so I couldn\\'t tell you the specifics as to why this occurs, but it seems that when you deal with n in the function, it is converted to base 10. For example, if you take case 1 (n = 00000000000000000000000000001011), it will output the number 11. Then, when you convert the integer to string, traverse the string, and increment with your counter, it will count 2 instead of 3 as \\'1\\' occurs in the string \\'11\\' only two times. I hope this helped."
                    },
                    {
                        "username": "akashkswarnkar",
                        "content": "[@monicalrnt_](/monicalrnt_) Even same for me. \\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toString(n);\\n        int count=0;\\n        for(int i =0; i<s.length();i++)\\n        {\\n            char ch= s.charAt(i);\\n            if(ch != \\'0\\')\\n            {\\n                //System.out.println(ch);\\n                count++;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "monicalrnt_",
                        "content": "same idea. not sure why its not working\\n"
                    },
                    {
                        "username": "brend3n",
                        "content": "return len(str(bin(n)).replace(\"0\",\"\").replace(\"b\",\"\"))\\n\\t\\t\\n\\n"
                    },
                    {
                        "username": "javohirmx",
                        "content": "return bin(n).count(\\'1\\')"
                    },
                    {
                        "username": "AnujPancholi",
                        "content": "![image](https://assets.leetcode.com/users/anujpancholi/image_1572922296.png)\\nIs the input that I\\'m getting wrong?"
                    },
                    {
                        "username": "svpka2z",
                        "content": "[@FadiZaarouri](/FadiZaarouri) Needed explanation"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "you need to use the Integer.toBinaryString() Method instead:\\n\\nSystem.out.println(Integer.toBinaryString(n));\\n\\nBut this is only for debugging or on your local machine"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "user4976IJ",
                        "content": "You are printing the value on standard output (i.e. System.out.println) but the program result will only be correct if you only return the value through the function."
                    }
                ]
            },
            {
                "id": 1569837,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1701191,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1570740,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1574934,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1573946,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1571405,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1569009,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1920451,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1898935,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1889447,
                "content": [
                    {
                        "username": "nikhilranjan7",
                        "content": "Hi, Can anyone answer the followup question ?\\n**If this function is called many times, how would you optimize it?**"
                    },
                    {
                        "username": "fangxianguk",
                        "content": "sure, we can optimize run time, and still make the memory complexity to be O(1), e.g. if you do bit shifting you may loop 32 times with n=n>>1, but you can optimize it by looping 16, 8, or 4 times. code is:\\n    for(byte i=0; i<16; i++){\\n        if(0==(n&3)){\\n        }else if(3==(n&3)){\\n            count+=2;\\n        }else{\\n            count++;\\n        }\\n        n = n>>2;\\n    }"
                    },
                    {
                        "username": "narayan_95",
                        "content": " `class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n     int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int a=n%10;\\n            if(a==1)\\n                count++;\\n                n=n/10;\\n        }\\n        return count;\\n    }`\\ncan someone pls tell me why output is wrong with this?"
                    },
                    {
                        "username": "siddhanth2305",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why should it be n=n/2 please explain"
                    },
                    {
                        "username": "dorsey_utd",
                        "content": "if you took remainder divided by 10 it would result in the wrong number of countings of number of 1 bits in the input .Try finding the remainder and dividing by 2....... correct it in this way=>\\nint a=n%2; if(a==1) count++; n/=2;"
                    },
                    {
                        "username": "TanishaShrivas",
                        "content": "[@huangqianchen2021](/huangqianchen2021) why? can you please elaborate?"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "Yes, of course, you should %2, instead of %10, same for this, n = n/2, hope my answer will help you."
                    },
                    {
                        "username": "kashif09",
                        "content": "return sum([int(x) for x in bin(n)[2:]])"
                    },
                    {
                        "username": "hunu",
                        "content": "its already in binary, why use `bin` ?"
                    },
                    {
                        "username": "alexand312z",
                        "content": "![image](https://assets.leetcode.com/users/images/4c0bf9a5-2bea-4d49-a447-129cf3009e6d_1612775993.4326098.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for solution in C++/Java/Python using the Brian Kernighan\\'s Algorithm\\nhttps://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/\\n"
                    },
                    {
                        "username": "holten",
                        "content": "int count = (n == 0) ? 0 : 1;\\n\\nwhile ((n = n & (n - 1)) != 0) count++;\\n\\nreturn count;"
                    },
                    {
                        "username": "user1504Hz",
                        "content": "Can you give a step wise description on this solution?I am just confused why its giving correct answer when n is not changing?"
                    },
                    {
                        "username": "Climax777",
                        "content": "    __builtin_popcount\\n\\nEnough said..."
                    },
                    {
                        "username": "TemurElizbarashvili",
                        "content": "Hello I\\'m writing in C# and can some1 explain me why this code does not work? \\n```\\nreturn n.ToString().Where(n => n == \\'1\\').Count();\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code snippet you provided attempts to convert an integer `n` to a string, filter out the characters that are \\'1\\', and then count the number of \\'1\\' characters.\\n\\nThe issue is that you\\'re using `n` as the parameter name in your lambda expression, which is shadowing the original `n` variable. This can lead to confusion and potential runtime errors. \\n\\nTo fix this, you should use a different variable name for the lambda parameter. Here\\'s the corrected code:\\n\\n```csharp\\nreturn n.ToString().Where(c => c == \\'1\\').Count();\\n```\\n\\nIn this corrected code, `c` is used as the variable name in the lambda expression. This `c` represents each character in the string representation of `n`. The `Where` method filters the characters, keeping only those that are \\'1\\'. The `Count` method then counts the number of \\'1\\' characters."
                    },
                    {
                        "username": "leolao",
                        "content": "\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n       n = str(n)\n       count = 0\n       for i in n:\n           if i == \"1\":\n              count += 1\n       return count\n        \n\nWhy is this not working\n\n\n\n\n\n        "
                    },
                    {
                        "username": "fhossain27",
                        "content": "[@bparanj](/bparanj) Great explanation - thank you!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is counting the number of \"1\"s in the decimal representation of `n`, not its binary representation. The Hamming weight of a number refers to the number of \"1\"s in its binary representation.\\n\\nTo correctly calculate the Hamming weight, you should first convert `n` to its binary representation using the `bin` function. Here is the corrected code:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)  # Convert to binary representation\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nIn this corrected code, `bin(n)` converts `n` to a binary string. The binary string starts with \\'0b\\', so you could further improve your code by slicing off the first two characters:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        count = 0\\n        for i in n:\\n            if i == \"1\":\\n                count += 1\\n        return count\\n```\\n\\nThis will correctly calculate the Hamming weight of `n`."
                    },
                    {
                        "username": "user1533lE",
                        "content": "why this code is not working ? but its working in other platforms\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = str(n).replace(\"0\",\"\")\\n        return(len(n))\\n       "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you posted is converting the integer `n` to a string, replacing all \"0\"s with an empty string, and then returning the length of the resulting string. However, this will not give you the Hamming weight of `n`, which is the number of \"1\"s in the binary representation of `n`.\\n\\nThe code might be working on other platforms if the input `n` is already a binary string representation of a number. But in the function signature, `n` is expected to be an integer, not a binary string. \\n\\nIf `n` is an integer, the code you posted would effectively be counting the number of non-zero digits in the decimal representation of `n`, which is not the same as the Hamming weight.\\n\\nHere is the corrected code that correctly computes the Hamming weight:\\n\\n```python\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        n = bin(n)[2:]  # Convert to binary representation and remove the \\'0b\\' prefix\\n        n = n.replace(\"0\", \"\")  # Remove all \"0\"s\\n        return len(n)  # Return the number of \"1\"s\\n```\\n\\nIn this corrected code, `bin(n)[2:]` is used to convert `n` to its binary representation (as a string), and the \\'0b\\' prefix is removed. The rest of the code then works as intended, removing all \"0\"s and returning the number of \"1\"s."
                    }
                ]
            },
            {
                "id": 1801736,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1787751,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1712882,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1571406,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1576142,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1572084,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 1571404,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2075841,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2062216,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2042195,
                "content": [
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int c=0;\\n        while(n!=0){\\n            if(n&1){\\n                c++;\\n            }\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "int count = 0;\\n        while(n!=0)\\n        {\\n            int digit = n%10;\\n            if((digit^0)==1)\\n            {\\n                count++;\\n            }\\n            n = n>>1;\\n        }\\n        return count;\\n\\ncan someone please explain what is the problem with this code, i\\'m getting 2 instead of 3 for 1011."
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution { // UPVOTE :)\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int cnt=0;\\n        while(n!=0){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "kunal4",
                        "content": "I roamed through all the answers. I am wondering whether there is any other way than bitwise operations?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, there are various ways to count the number of \\'1\\'s in the binary representation of an integer that don\\'t involve bitwise operations. Here are a few alternatives:\\n\\n1. **Using the `bin` function and `count` method in Python:**\\n\\n   You can convert the integer to its binary representation using the `bin` function and then count the number of \\'1\\'s using the `count` method:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return bin(n).count(\\'1\\')\\n   ```\\n\\n2. **Using a while loop and integer division:**\\n\\n   You can repeatedly divide the integer by 2 until it becomes 0, and count the number of times the remainder is 1:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           count = 0\\n           while n:\\n               count += n % 2\\n               n //= 2\\n           return count\\n   ```\\n\\n3. **Using built-in `format` function:**\\n\\n   You can use the `format` function to convert the integer to its binary representation and then count the number of \\'1\\'s:\\n\\n   ```python\\n   class Solution:\\n       def hammingWeight(self, n: int) -> int:\\n           return format(n, \\'b\\').count(\\'1\\')\\n   ```\\n\\nAll of these approaches avoid bitwise operations and directly count the number of \\'1\\'s in the binary representation of the integer."
                    },
                    {
                        "username": "simeonbauman",
                        "content": "return(sum(map(lambda x : 1 if \\'1\\' in x else 0, str(bin(n)))))\\n"
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift as a choice for submitting code in the editor for this challenge. \\nThank you!"
                    },
                    {
                        "username": "nouby",
                        "content": "The solution gives thes same running time for the loop ansower given in the editorial but only one line of code:\\n\\n<code>return Integer.bitCount(n);</code>"
                    },
                    {
                        "username": "66A0",
                        "content": "why should we convert the given into binary though it is already in binary?"
                    },
                    {
                        "username": "ad6mi5",
                        "content": "what is wrong when we use bitwise or operater in place of and with zero means(n|0)\\nwhen n contain 1 then only condition is true then value of count is increased.\\n"
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "In C++ there's a built in function `__builtin_popcountll(Variable)` , it counts the number of bits in set of numbers(1s), you may use it directly in the return function as it'll give you and int value! It has Time Complexity:O(1) and Auxiliary Space: O(1).\n\nThis function is used to count the number of set bits in an unsigned integer."
                    }
                ]
            },
            {
                "id": 2012595,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1963616,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1957542,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1950474,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1950207,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1924338,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1854409,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1833934,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1827149,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1799578,
                "content": [
                    {
                        "username": "neeldoshii",
                        "content": "Can someone explain me here Why we cant use here map or unordered map?"
                    },
                    {
                        "username": "danek1313",
                        "content": "In Javascript, why does `4294967293 >> 1` result in -2? This is making Test Case 3 fail. I\\'m very confused."
                    },
                    {
                        "username": "danek1313",
                        "content": "[@bparanj](/bparanj) That makes sense. Yeah Javascript isn\\'t usually the best language option for a lot of these problems. Thank you for the explanation."
                    },
                    {
                        "username": "bparanj",
                        "content": "JavaScript uses 32-bit signed numbers for bitwise operations. This means that when you perform a bitwise operation, JavaScript first converts the number to a 32-bit signed number, then performs the operation.\\n\\nThe number 4294967293 is represented in binary as `10000000000000000000000000000000101`. When JavaScript converts this to a 32-bit signed number, it only keeps the last 32 bits, which are `00000000000000000000000000000001`. This is the binary representation of -2 in two\\'s complement, which is how negative numbers are represented in binary.\\n\\nTherefore, when you perform the operation `4294967293 >> 1` in JavaScript, it first converts the number to `-2`, and then right shifts it by 1. The result of right shifting `-2` by 1 is still `-2`, because right shifting a negative number in two\\'s complement always rounds towards negative infinity.\\n\\nIf you want to perform bitwise operations on larger numbers in JavaScript, you\\'ll need to use a BigInt or a library that supports larger integers. \\n"
                    },
                    {
                        "username": "Nanna95604",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        string s=to_string(n);\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}; what\\'s wrong with this solution? I am getting wrong Output against this code? Please Help"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your current approach is that `to_string(n)` is converting `n` to a string representation of the decimal value, not the binary value. Thus, when you\\'re counting \\'1\\'s, you\\'re counting in the decimal representation, not the binary.\\n\\nIn C++, you can get the binary representation of a number using bitwise operations, or by using bitset from the standard library.\\n\\nHere\\'s how you might modify your code to correctly count the number of \\'1\\'s in the binary representation of `n` using bitset:\\n\\n```cpp\\n#include <bitset>\\n\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        std::bitset<32> bits(n);\\n        return bits.count();\\n    }\\n};\\n```\\n\\nThis code first converts `n` into a 32-bit binary representation using `std::bitset<32>`, and then uses the `count` method of `std::bitset` to count the number of \\'1\\'s."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Isn\\'t the input in example #1 = 11 and not binary representation of 11 ie. 00000000000000000000000000001011? It is confusing. "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of Hamming Weight, the input integer is typically understood to be in binary format. For example, if the input is 11, it\\'s understood to represent the binary number \\\\(1011_2\\\\) (which is \\\\(11_{10}\\\\) in decimal), and the Hamming Weight would be 3, because there are three \\'1\\'s in the binary representation.\\n\\nHowever, the way the question is posed or the input is provided might sometimes lead to confusion. It\\'s important to read the problem statement carefully. If the problem states that the input is a decimal number and asks for the count of \\'1\\'s in its binary representation, then you should first convert the decimal number to binary and then count the \\'1\\'s.\\n\\nIf you\\'re dealing with a programming problem or a piece of code and you\\'re unsure about the format of the input, it might be helpful to print the input or use a debugger to check its actual value."
                    },
                    {
                        "username": "Arya_Verma_",
                        "content": "Please anyone explain that whether we are taking unsigned integer as input or its binary  representation as when i am using statement cout<<n i am getting decimal number but input in test case section is in binary representation."
                    },
                    {
                        "username": "bparanj",
                        "content": "When you\\'re dealing with integers in most programming languages, including C++ and Python, you\\'re usually working with decimal integers by default. When you print an integer variable with a statement like `cout << n`, it will output the decimal representation of the integer.\\n\\nHowever, when a problem involves binary operations or refers to bits, it often means that you need to consider the binary representation of the integer. The integer is still stored in memory as a binary number, but when you work with it in your code or print it out, it\\'s normally treated as a decimal number.\\n\\nFor example, if you have an integer `n` with a value of `11`, that\\'s `11` in decimal and `1011` in binary. The binary representation is what\\'s relevant for calculating the Hamming weight (the number of \\'1\\' bits), but if you just print `n`, you\\'ll see `11`, not `1011`.\\n\\nIf you\\'re given an integer in a problem and it\\'s not clear whether it\\'s supposed to be a binary or decimal number, you should check the problem statement. The statement should specify the format of the number. In many problems that involve binary operations, the input might be given as a decimal number, but you\\'re supposed to consider its binary representation for the problem."
                    },
                    {
                        "username": "mjcoder79",
                        "content": "if we are giving input in form of integer .....then if we use n&1....won\\'t it consider the input n as  a decimal and change such a big number into a binary one ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In programming, the number you\\'re working with is stored in binary format, whether it\\'s an integer, float, or another type. When you write a number in your code or input it into your program, you\\'re usually writing it in decimal form (unless specified otherwise), but it\\'s stored in memory in binary form. This is true whether the number is small or large.\\n\\nWhen you perform a bitwise operation like `n & 1`, it operates on the binary representation of `n`. The operation `n & 1` will return the least significant bit of `n` \\u2014 that is, it will tell you whether `n` is odd (if the result is 1) or even (if the result is 0). This is because the least significant bit in the binary representation of an integer determines its parity.\\n\\nSo, to answer your question, yes, the bitwise operation `n & 1` considers `n` in binary, but it doesn\\'t \"change\" `n` into binary \\u2014 `n` is already stored in binary in the computer\\'s memory. The operation doesn\\'t change the way `n` is stored or represented; it just uses the binary representation to calculate the result."
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Can I ask why string.count() does not give the correct result?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The input is given as an integer converted from binary, i.e. 011 would equals 3"
                    },
                    {
                        "username": "Almazino",
                        "content": "var hammingWeight = function(n) {\\n    return n\\n};why i get 4294967293 and not 1111111111111111111111111111101"
                    },
                    {
                        "username": "sinhaapurva25",
                        "content": "Local IDE and LeetCode Playground gives the same result but over here in submission it\\'s different.\\n"
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "I don\\'t mean to complain but leetcode used the phrase string and integer interchangingly to an extend that I was totally confused what type of input am working with."
                    }
                ]
            },
            {
                "id": 1799302,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1797770,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1787787,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1787103,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1780731,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1769522,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1768529,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1766175,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1758034,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1749304,
                "content": [
                    {
                        "username": "Frances1",
                        "content": "A problem with Java input!\nI use common solution with bit shifting but for testcase with \"11111111111111111111111111111101\" it return error.\nIn IDE compiler also return error:\n`error: integer number too large`\n`hammingWeight(1111111111111111111111111111101)`\n`______________^`\nDoes anyone know what's wrong with input?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error you\\'re seeing is because the number you\\'ve written is being interpreted as a decimal number, and it\\'s larger than the maximum value that can be represented by an `int` in Java.\\n\\nIf you want to write a binary literal in your code in Java, you should prefix it with `0b` or `0B`. So if you want to represent the binary number `11111111111111111111111111111101`, you should write it as `0b11111111111111111111111111111101`.\\n\\nHowever, there\\'s another issue. Java uses signed integers, and the sign bit is the leftmost bit. If it\\'s 1, the number is negative, and if it\\'s 0, the number is positive. When you write `0b11111111111111111111111111111101`, the sign bit is 1, so Java interprets this as a negative number.\\n\\nTo represent large binary numbers that have their sign bit set, you can use a long and suffix it with `L`:\\n\\n```java\\nlong num = 0b11111111111111111111111111111101L;\\n```\\n\\nBut keep in mind that the problem statement specifies the function should take an unsigned integer. In Java 8 and later, you can use `Integer.parseUnsignedInt` with radix 2 to get the unsigned integer value of a binary string:\\n\\n```java\\nint num = Integer.parseUnsignedInt(\"11111111111111111111111111111101\", 2);\\n```\\n\\nThis will correctly interpret the binary string as an unsigned integer, so you can perform bitwise operations on it and calculate the Hamming weight."
                    },
                    {
                        "username": "Syed_Sohail_26",
                        "content": "I just tried a method to count the number of ones in the integer by converting it to string but the code runs and only one test case passed. Please help me out\n \n`public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) \n    {\n        String s = Integer.toString(n);\n        int c=0;\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='1')\n            {\n                ++c;\n            }\n        }\n        return c;\n        \n    }\n}`\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code is that the `Integer.toString(n)` function is converting `n` to a decimal string, not a binary string. When you\\'re counting \\'1\\'s, you\\'re counting them in the decimal representation, not the binary representation, which is why the code is not working as expected. \\n\\nTo convert `n` to a binary string in Java, you should use the `Integer.toBinaryString(n)` function. Here\\'s how you can modify your code to correctly count the number of \\'1\\'s in the binary representation of `n`:\\n\\n```java\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int c = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nThis code first converts `n` into a binary string. It then iterates over each character in the string, incrementing the counter `c` each time it encounters a \\'1\\'. The function then returns the count of \\'1\\'s in the binary representation of `n`."
                    },
                    {
                        "username": "longlostcerebralsystem",
                        "content": "why is 0000000000000000000000000000101%10 a 5 and 101%10 a 1 ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation `%` is the modulus operator, which gives the remainder when the first number is divided by the second. \\n\\nWhen you perform `0000000000000000000000000000101 % 10`, the number `0000000000000000000000000000101` is a binary number, and in decimal format, it is `101`. So, `101 % 10` gives a remainder of `1`, not `5`.\\n\\nHowever, if you are treating `0000000000000000000000000000101` as a decimal number (not binary), then it is indeed equal to `101`. In that case, `101 % 10` would give a remainder of `1`.\\n\\nIn the case of `101 % 10`, if `101` is a binary number, its decimal equivalent is `5`, and `5 % 10` gives `5`.\\n\\nSo, it depends on whether you\\'re treating `101` as a binary number or a decimal number. In binary, `101` is `5` in decimal, and in decimal, `101` is `101`. Therefore, `101 % 10` is `1` if `101` is treated as a decimal number, and `5` if it\\'s treated as a binary number. \\n\\nRemember that in most programming languages, numbers are interpreted as decimal by default unless specified otherwise. If you want to interpret a number as binary in your code, you\\'ll need to use the appropriate function or method to do so."
                    },
                    {
                        "username": "ashokbabug",
                        "content": "        int count=0;\\n        int val=n;\\n        System.out.println(val);\\n        while(val!=0) {\\n            count+=(val&1);\\n            val = val>>1;\\n            System.out.println(val);\\n        }\\nwhy the baove code is not stopping at 0.val becoming 0 but its not getting out of while loop?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve posted should indeed exit the `while` loop once `val` reaches 0. The `while(val!=0)` condition ensures that the loop continues as long as `val` is not equal to 0. When `val` becomes 0, the condition evaluates to `false`, and the loop should exit.\\n\\nIf you\\'re finding that the loop doesn\\'t exit even when `val` appears to be 0, one possibility is that `val` is not exactly zero, but a very small number close to zero, due to some kind of rounding or precision error. This can happen in some circumstances when working with floating-point numbers, but it shouldn\\'t happen with integer values, as in your code.\\n\\nAnother possibility is that `val` is a negative number. If `val` is negative and you\\'re right shifting using `>>`, the result is implementation-defined in some languages, and it could result in a negative value. In Java, `>>` is a signed right shift operator, so if `val` is negative, it will remain negative after the shift, and the loop will continue indefinitely.\\n\\nTo diagnose the problem, you could try printing out `val` at each iteration of the loop to see its exact value. If it\\'s a very small number close to zero or a negative number, that could explain why the loop isn\\'t exiting.\\n\\nIf `val` is indeed becoming negative due to the right shift, and if `n` is supposed to be an unsigned value, you could use `>>>` instead of `>>` for the right shift. The `>>>` operator in Java is an unsigned right shift operator, which will not preserve the sign bit and will not result in a negative value."
                    },
                    {
                        "username": "Hsiao-Chien-Ti",
                        "content": "For the for loop here, it runs as many iterations as the log of the input. Is the time complexity of my code O(n) or, O(log n). I somehow remember I learned that the time complexity should be analysis in with number of bits of the input instead of the value of the input somewhere.\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        if(n==0)\\n            return 0;\\n        int k=log2(n);\\n        int cnt=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            cnt+=n&1;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "urmichm",
                        "content": "it\\'s int32, your loop has at most 32 iterations. The problem is O(1)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is \\\\(O(\\\\log n)\\\\), not \\\\(O(n)\\\\), because the number of iterations of your loop depends on the number of bits in `n`, which is proportional to the logarithm of `n`, not `n` itself.\\n\\nHere\\'s why: In binary representation, a number `n` needs approximately \\\\(\\\\log_2 n\\\\) bits. The `log2(n)` function returns the base-2 logarithm of `n`, which is approximately the number of bits needed to represent `n` in binary.\\n\\nIn your code, you\\'re looping from `i = 0` to `i = k`, where `k = log2(n)`. This means you\\'re performing one iteration for each bit in `n`. So, the number of iterations, and thus the time complexity, is proportional to the number of bits in `n`, which is \\\\(O(\\\\log n)\\\\).\\n\\nRemember that in time complexity analysis, `n` is the size of the input. In many problems, `n` is the number of elements in an input list or array, but in problems involving binary operations, `n` is often the number of bits in the input number. In this case, your input is a single number, and the size of the input is the number of bits in that number. Therefore, a loop that runs once for each bit in the input has a time complexity of \\\\(O(n)\\\\) when `n` is the number of bits, or \\\\(O(\\\\log n)\\\\) when `n` is the value of the input number."
                    },
                    {
                        "username": "abhi070301",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while(n != 0){\\n            if(n&1)\\n            count++;\\n            n = n>>1;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "flappygoat",
                        "content": "```\nfunction hammingWeight(n: number): number {\n    let count = 0;\n    while (n !== 0) {\n        if ((n >> 1) >>> 0 >= n) {\n            count++;\n        }\n        n = (n << 1) >>> 0;\n    }\n    return count;\n};\n```\nI'm shifting left every iteration (n = n << 1), because i'm essentially checking the most significant bit value. I do an arithmetic right shift (n >> 1), which inserts 1 if the most significant bit was 1, which means the number got bigger (or the same if all bits where 1's) or inserts 0 if the most significant bit was 0, which means the number got smaller. That is how I check if the bit was 1 or 0. For this to work the numbers must be treated as unsigned. In javascript we do this by adding >>> 0 after every bit-wise operation."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/191_Number_of_1_Bits.cpp"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count=0;\\n\\n        while(n!=0){\\n            if(n&1)\\n            {\\n                count++;\\n\\n            }\\n           n=n>>1;\\n        }\\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "sandeepkv233",
                        "content": "There are 3 Approaches we can use to solve it..\\n`\\nint hammingWeight(uint32_t n) {\\n       // FIRST Approach\\n        int count = 0;\\n        uint32_t mask = 1;\\n        for(int i=0; i<32; i++) {\\n            if((n & mask) != 0)\\n                count++;\\n            mask = mask << 1;\\n        }\\n        return count;\\n\\n       // SECOND Approach\\n        int count = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n        //THIRD Approach\\n        if(n == 0 || n == 1)\\n        return n;\\n\\n        return hammingWeight(n&(n-1)) + 1;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1746563,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1744317,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1741274,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1739391,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1725101,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1721352,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1717349,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716397,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716153,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713318,
                "content": [
                    {
                        "username": "punithnayak098",
                        "content": " `class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n!=0:\\n            rightmostsignificantbit=n & (~n+1)\\n            n=n-rightmostsignificantbit\\n            count+=1\\n        return count`"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "We can achieve it just manipulate the bits!.\n`let count = 0; while(n !== 0){ const compare = n & 1; if(compare == 1) {count+=1;} n>>>=1; } return count;`"
                    },
                    {
                        "username": "RameezRaja045",
                        "content": "# java solution\\npublic class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int count = 0;\\n            for(int j=0; j<=31; j++){\\n                int bit = (n>>j)&1;\\n                if(bit==1){\\n                    count = count+1;\\n                }\\n            }\\n            return count;       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Why this is working with `n%2` and not with `n% 10 `? Can anybody please explain. Thanks\\n`int count = 0;\\n    while(n != 0){\\n        uint digit = n % 2;\\n        if(digit == 1){\\n         count++;\\n        }\\n        n = n/2;\\n    }\\n    return count;`"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code is calculating the Hamming weight of a number, which is the number of \\'1\\'s in its binary representation. It does this by repeatedly dividing `n` by 2 and checking if the remainder is 1. If the remainder is 1, that means the least significant bit (rightmost bit) in the binary representation of `n` is 1, so it increments the counter. \\n\\nWhen you use `n % 2`, you\\'re getting the remainder when `n` is divided by 2, which is equivalent to the least significant bit in the binary representation of `n`. \\n\\nHowever, when you use `n % 10`, you\\'re getting the remainder when `n` is divided by 10, which is not relevant to the binary representation of `n`. In the decimal number system, `n % 10` would give you the last digit of `n`, but in the binary number system, every digit is either 0 or 1, so getting the last digit of `n` in the decimal system doesn\\'t tell you anything about the number of \\'1\\'s in the binary representation.\\n\\nThat\\'s why the code works with `n % 2` and not with `n % 10`. `n % 2` is a way to get the least significant bit of `n` in binary, which is what you need to calculate the Hamming weight."
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "think about it, if n = 7? with n%10, it\\'s for decimal"
                    },
                    {
                        "username": "Tanjid470",
                        "content": "n>>>1 what does it means??? \\n"
                    },
                    {
                        "username": "anil_52026",
                        "content": "n>>1 , it is right shift operator"
                    },
                    {
                        "username": "iamrajveer25",
                        "content": "n=int(input())\\n\\nc=0\\nwhile(n>0):\\n  if(n%10==1):\\n    c=c+1\\n  n=n//10\\nprint(c)\\n\\nThe same code I try to run in leetcode it\\'s showing Wrong answer.\\nBut when i run on my local machine it satsify all test cases giving n as user input.\\n\\nCan some one give me suggestion why it\\'s like that ??"
                    },
                    {
                        "username": "saumay31",
                        "content": "var count=0;\\n    for(var i=0;i<=31;i++){\\n    \\n    if(((n>>i)&1)==1){\\n        count++;\\n    }\\n    }\\n    return count;"
                    },
                    {
                        "username": "prince_511",
                        "content": " int hammingWeight(uint32_t n) {\\n       return __builtin_popcount(n); \\n    }"
                    },
                    {
                        "username": "gauravpatil97886",
                        "content": "# Code\\n```\\n\\n// 1st approach\\nclass Solution {\\npublic:\\n//     int hammingWeight(uint32_t n) {\\n// int count=0;\\n// while(n!=0)\\n// {    if(n&1)\\n//     {\\n//     count++;\\n//     }\\n//     n=n>>1;\\n// }\\n//     return count;\\n\\n//     }\\n\\n// 2nd approach\\n    int hammingWeight(uint32_t n) { return bitset<32>(n).count(); }\\n\\n};"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "public class Solution \\n{\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) \\n    {\\n        int count = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            if ((n & mask) != 0)\\n            {\\n                count++;\\n            }\\n            mask = mask << 1;\\n        }     \\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713066,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1711122,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1708440,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1699462,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1694674,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1687363,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1686110,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1680312,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1676216,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            },
            {
                "id": 1673535,
                "content": [
                    {
                        "username": "pozitron",
                        "content": "example 1:\\n`Input: n = 00000000000000000000000000001011\\nOutput: 3\\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three \\'1\\' bits.`\\n\\nhmm, wat ?\\nI assume 3 should be 00000000000000000000000000000011\\njava\\'s Integer.toBinaryString confirms that."
                    },
                    {
                        "username": "Soykot_podder",
                        "content": "code...`\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        count=0\\n        while n:\\n            n=n&(n-1)\\n            count+=1\\n            \\n        return count"
                    },
                    {
                        "username": "vanchung1995",
                        "content": "unsign integer but testcase contains -3 ???"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int res = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ColdFront",
                        "content": "This solution works in my IDE (Pycharm, Python 3.9/3.10), but won\\'t work in here:\\n`class Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        number = str(n).replace(\"0\", \"\")\\n        if not number.startswith(\"1\"):\\n            number = bin(n).replace(\"0\", \"\")\\n        return number.count(\"1\")\\n\\nsolution = Solution()\\nn = 0o0000000000000000000000000001011\\nn2 = 11111111111111111111111111111101\\nn3 = 0o0000000000000000000000010000000\\nn4 = 0o000000000000100000000000000000`\\n\\nI just don\\'t understand this =/"
                    },
                    {
                        "username": "rishabh_1112",
                        "content": "// THIS METHOD WILL RUN ONLY IF USER WILL ENTER INPUT IN BINARY FORM\\n     int n;   int digit=0; int sum=0;\\n         while (n!=0)\\n           {\\n                digit=n%10;\\n                if (digit==1)\\n                 {\\n                     sum++;\\n                 }\\n                 n=n/10;\\n           }\\n           return sum;\\n\\nkindly  check this method \\nthe method is running successfully but the one issue i faced if i enter input of more than 18\\ndigit  in binary form \\ngive me the solution of this if anybody have"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you\\'ve written is intended to calculate the number of \\'1\\'s in a binary number, assuming that the binary number is input as a decimal. For example, the binary number 101 would be input as the decimal number 101, not the decimal number 5.\\n\\nHowever, this method has a limitation related to the maximum value that can be stored in an `int` in most programming languages. In many languages including Java, C, and C++, an `int` is 32 bits and can store values up to about 2 billion (2^31 - 1 for positive numbers). If you try to input a binary number with more than 18 digits, it will exceed this limit when it\\'s interpreted as a decimal number, and you\\'ll get an overflow.\\n\\nTo handle binary numbers with more than 18 digits, you can accept the input as a string instead of an integer. Then you can iterate over the characters in the string, counting the number of \\'1\\'s. This will allow you to handle binary numbers of any length, limited only by the maximum length of a string in your programming language.\\n\\nHere is an example of how you might modify your code to accept a string input:\\n\\n```java\\nString n;\\nint sum = 0;\\n\\nfor (int i = 0; i < n.length(); i++) {\\n    char digit = n.charAt(i);\\n    if (digit == \\'1\\') {\\n        sum++;\\n    }\\n}\\n\\nreturn sum;\\n```\\n\\nIn this code, `n` is a string, and `n.charAt(i)` gets the `i`-th digit of the binary number. The comparison `digit == \\'1\\'` checks whether this digit is \\'1\\', and if so, increments `sum`. The code then returns `sum`, which is the count of \\'1\\'s in the binary number."
                    },
                    {
                        "username": "Loop4aWhile",
                        "content": "So short, so cheaty\n\n `\n    def hammingWeight(self, n: int) -> int: return str(bin(n)).count(\"1\")\n`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# O(set bits) | One Liner Optimized\\uD83E\\uDDE8 FAANG CODE\\nhttps://leetcode.com/problems/number-of-1-bits/solutions/2221186/o-set-bits-one-liner-optimized-faang-code/"
                    },
                    {
                        "username": "Asmali",
                        "content": "I don\\'t understand why my code isn\\'t running correctly. I tried it in VS code and it passed all the test cases, but it failed in leet code?\\n ` public int hammingWeight(int n) {\\n        String copy=String.valueOf(n);\\n        int count=0;\\n        for (int i = 0; i < copy.length(); i++) {\\n            if (copy.charAt(i) == \\'1\\') {\\n                count += 1;\\n            }\\n        }\\n\\n        return count;\\n    }"
                    },
                    {
                        "username": "k_lalit",
                        "content": "python:\\n\\nreturn str(bin(n)).count(\\'1\\')"
                    }
                ]
            }
        ]
    }
]