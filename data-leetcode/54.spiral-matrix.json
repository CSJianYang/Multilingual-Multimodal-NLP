[
    {
        "title": "Spiral Matrix",
        "question_content": "Given an m x n matrix, return all elements of the matrix in spiral order.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 10\n\t-100 <= matrix[i][j] <= 100",
        "solutions": [
            {
                "id": 20571,
                "title": "1-liner-in-python-ruby",
                "content": "Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions.\\n\\nPython:\\n\\n    def spiralOrder(self, matrix):\\n        return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n\\nPython 3:\\n\\n    def spiralOrder(self, matrix):\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n\\nRuby:\\n```\\ndef spiral_order(matrix)\\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\\nor\\n```\\ndef spiral_order(matrix)\\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\\n\\n### Visualization\\n\\nHere's how the matrix changes by always extracting the first row and rotating the remaining matrix counter-clockwise:\\n\\n        |1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n        |4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n        |7 8 9|      |4 7|\\n\\nNow look at the first rows we extracted:\\n\\n        |1 2 3|      |6 9|      |8 7|      |4|      |5|\\n\\nThose concatenated are the desired result.\\n\\n### Another visualization\\n```\\n  spiral_order([[1, 2, 3],\\n                [4, 5, 6],\\n                [7, 8, 9]])\\n\\n= [1, 2, 3] + spiral_order([[6, 9],\\n                            [5, 8],\\n                            [4, 7]])\\n\\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\\n                                     [5, 4]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\\n                                              [5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\\n\\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef spiral_order(matrix)\\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\n```\\ndef spiral_order(matrix)\\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\n```\\n  spiral_order([[1, 2, 3],\\n                [4, 5, 6],\\n                [7, 8, 9]])\\n\\n= [1, 2, 3] + spiral_order([[6, 9],\\n                            [5, 8],\\n                            [4, 7]])\\n\\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\\n                                     [5, 4]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\\n                                              [5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\\n\\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20599,
                "title": "super-simple-and-easy-to-understand-solution",
                "content": "This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin.\\n\\nThe only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know!\\n\\nAny comments greatly appreciated.\\n\\n    public class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            \\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if (matrix.length == 0) {\\n                return res;\\n            }\\n            \\n            int rowBegin = 0;\\n            int rowEnd = matrix.length-1;\\n            int colBegin = 0;\\n            int colEnd = matrix[0].length - 1;\\n            \\n            while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n                // Traverse Right\\n                for (int j = colBegin; j <= colEnd; j ++) {\\n                    res.add(matrix[rowBegin][j]);\\n                }\\n                rowBegin++;\\n                \\n                // Traverse Down\\n                for (int j = rowBegin; j <= rowEnd; j ++) {\\n                    res.add(matrix[j][colEnd]);\\n                }\\n                colEnd--;\\n                \\n                if (rowBegin <= rowEnd) {\\n                    // Traverse Left\\n                    for (int j = colEnd; j >= colBegin; j --) {\\n                        res.add(matrix[rowEnd][j]);\\n                    }\\n                }\\n                rowEnd--;\\n                \\n                if (colBegin <= colEnd) {\\n                    // Traver Up\\n                    for (int j = rowEnd; j >= rowBegin; j --) {\\n                        res.add(matrix[j][colBegin]);\\n                    }\\n                }\\n                colBegin ++;\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            \\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if (matrix.length == 0) {\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20573,
                "title": "a-concise-c-implementation-based-on-directions",
                "content": "When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n\\n0  1   2   3   4   5\\n    6   7   8   9   10\\n   11 12 13 14 15\\n\\nImagine a cursor starts off at (0, -1), i.e. the position at '0', then we can achieve the spiral order by doing the following:\\n\\n1. Go right 5 times \\n2. Go down 2 times\\n3. Go left 4 times\\n4. Go up 1 times.\\n5. Go right 3 times\\n6. Go down 0 times -> quit\\n  \\nNotice that the directions we choose always follow the order 'right->down->left->up', and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. \\n\\nThus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four.\\n\\nAnother good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched.\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<vector<int> > dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<int> res;\\n        int nr = matrix.size();     if (nr == 0) return res;\\n        int nc = matrix[0].size();  if (nc == 0) return res;\\n        \\n        vector<int> nSteps{nc, nr-1};\\n        \\n        int iDir = 0;   // index of direction.\\n        int ir = 0, ic = -1;    // initial position\\n        while (nSteps[iDir%2]) {\\n            for (int i = 0; i < nSteps[iDir%2]; ++i) {\\n                ir += dirs[iDir][0]; ic += dirs[iDir][1];\\n                res.push_back(matrix[ir][ic]);\\n            }\\n            nSteps[iDir%2]--;\\n            iDir = (iDir + 1) % 4;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n\\n0  1   2   3   4   5\\n    6   7   8   9   10\\n   11 12 13 14 15\\n\\nImagine a cursor starts off at (0, -1), i.e. the position at '0', then we can achieve the spiral order by doing the following:\\n\\n1. Go right 5 times \\n2. Go down 2 times\\n3. Go left 4 times\\n4. Go up 1 times.\\n5. Go right 3 times\\n6. Go down 0 times -> quit\\n  \\nNotice that the directions we choose always follow the order 'right->down->left->up', and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. \\n\\nThus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four.\\n\\nAnother good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched.\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<vector<int> > dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<int> res;\\n        int nr = matrix.size();     if (nr == 0) return res;\\n        int nc = matrix[0].size();  if (nc == 0) return res;\\n        \\n        vector<int> nSteps{nc, nr-1};\\n        \\n        int iDir = 0;   // index of direction.\\n        int ir = 0, ic = -1;    // initial position\\n        while (nSteps[iDir%2]) {\\n            for (int i = 0; i < nSteps[iDir%2]; ++i) {\\n                ir += dirs[iDir][0]; ic += dirs[iDir][1];\\n                res.push_back(matrix[ir][ic]);\\n            }\\n            nSteps[iDir%2]--;\\n            iDir = (iDir + 1) % 4;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20570,
                "title": "clean-java-readable-human-friendly-code",
                "content": "    public class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(matrix.length == 0 || matrix[0].length == 0) return res;\\n            \\n            int top = 0;\\n            int bottom = matrix.length-1;\\n            int left = 0;\\n            int right = matrix[0].length-1;\\n            \\n            while(true){\\n                for(int i = left; i <= right; i++) res.add(matrix[top][i]);\\n                top++;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = top; i <= bottom; i++) res.add(matrix[i][right]);\\n                right--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = right; i >= left; i--) res.add(matrix[bottom][i]);\\n                bottom--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = bottom; i >= top; i--) res.add(matrix[i][left]);\\n                left++;\\n                if(left > right || top > bottom) break;\\n            }\\n            \\n            return res;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(matrix.length == 0 || matrix[0].length == 0) return res;\\n            \\n            int top = 0;\\n            int bottom = matrix.length-1;\\n            int left = 0;\\n            int right = matrix[0].length-1;\\n            \\n            while(true){\\n                for(int i = left; i <= right; i++) res.add(matrix[top][i]);\\n                top++;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = top; i <= bottom; i++) res.add(matrix[i][right]);\\n                right--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = right; i >= left; i--) res.add(matrix[bottom][i]);\\n                bottom--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = bottom; i >= top; i--) res.add(matrix[i][left]);\\n                left++;\\n                if(left > right || top > bottom) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 978853,
                "title": "c-0ms-faster-than-100-easy-solution-with-proper-explanation",
                "content": "**Algorithm:**\\n*  First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).\\n*  Then we will iterate from **new top** to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).\\n*  Then we will iterate in bottom row from **right** to **left** and pushback all the elements from **new right** to left. After iterating, we change the bottom to second last row (bottom--).\\n*  Then we will iterate from **new bottom** to **new top** and push back only left most element. After iterating, we change the left to second column (left++).\\n*  Repeat all these steps until left = right **and** top = bottom.\\n\\n![image](https://assets.leetcode.com/users/images/03da4de5-eae8-4dd5-b82d-b33ab1f1eefc_1608447882.2876782.png)\\n\\nTake look at image for better understanding\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int left=0,right=m-1,bottom=n-1,top=0;\\n        int direction=1;\\n        vector<int> v;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction==1)\\n            {\\n                for(int i=left;i<=right;i++) v.push_back(matrix[top][i]);\\n                direction=2;\\n                top++;\\n            }\\n            \\n            else if(direction==2)\\n            {\\n                for(int i=top;i<=bottom;i++) v.push_back(matrix[i][right]);\\n                direction=3;\\n                right--;\\n            }\\n            \\n            else if(direction==3)\\n            {\\n                for(int i=right;i>=left;i--) v.push_back(matrix[bottom][i]);\\n                direction=4;\\n                bottom--;\\n            }\\n            \\n            else if(direction==4)\\n            {\\n                for(int i=bottom;i>=top;i--) v.push_back(matrix[i][left]);\\n                direction=1;\\n                left++;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n**Upvote it** if you liked it!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int left=0,right=m-1,bottom=n-1,top=0;\\n        int direction=1;\\n        vector<int> v;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction==1)\\n            {\\n                for(int i=left;i<=right;i++) v.push_back(matrix[top][i]);\\n                direction=2;\\n                top++;\\n            }\\n            \\n            else if(direction==2)\\n            {\\n                for(int i=top;i<=bottom;i++) v.push_back(matrix[i][right]);\\n                direction=3;\\n                right--;\\n            }\\n            \\n            else if(direction==3)\\n            {\\n                for(int i=right;i>=left;i--) v.push_back(matrix[bottom][i]);\\n                direction=4;\\n                bottom--;\\n            }\\n            \\n            else if(direction==4)\\n            {\\n                for(int i=bottom;i>=top;i--) v.push_back(matrix[i][left]);\\n                direction=1;\\n                left++;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394774,
                "title": "python-3-solution-for-spiral-matrix-one-of-the-most-easiest-you-will-never-forget",
                "content": "# UPVOTE \\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if len(matrix) == 0:\\n            return res\\n        row_begin = 0\\n        col_begin = 0\\n        row_end = len(matrix)-1 \\n        col_end = len(matrix[0])-1\\n        while (row_begin <= row_end and col_begin <= col_end):\\n            for i in range(col_begin,col_end+1):\\n                res.append(matrix[row_begin][i])\\n            row_begin += 1\\n            for i in range(row_begin,row_end+1):\\n                res.append(matrix[i][col_end])\\n            col_end -= 1\\n            if (row_begin <= row_end):\\n                for i in range(col_end,col_begin-1,-1):\\n                    res.append(matrix[row_end][i])\\n                row_end -= 1\\n            if (col_begin <= col_end):\\n                for i in range(row_end,row_begin-1,-1):\\n                    res.append(matrix[i][col_begin])\\n                col_begin += 1\\n        return res\\n    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if len(matrix) == 0:\\n            return res\\n        row_begin = 0\\n        col_begin = 0\\n        row_end = len(matrix)-1 \\n        col_end = len(matrix[0])-1\\n        while (row_begin <= row_end and col_begin <= col_end):\\n            for i in range(col_begin,col_end+1):\\n                res.append(matrix[row_begin][i])\\n            row_begin += 1\\n            for i in range(row_begin,row_end+1):\\n                res.append(matrix[i][col_end])\\n            col_end -= 1\\n            if (row_begin <= row_end):\\n                for i in range(col_end,col_begin-1,-1):\\n                    res.append(matrix[row_end][i])\\n                row_end -= 1\\n            if (col_begin <= col_end):\\n                for i in range(row_end,row_begin-1,-1):\\n                    res.append(matrix[i][col_begin])\\n                col_begin += 1\\n        return res\\n    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20719,
                "title": "c-spiral-traverse",
                "content": "Traverse the matrix in the spiral order by keeping four variables: `u` for the uppermost row, `d` for the downmost row, `l` for the leftmost column and `r` for the rightmost column.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, u = 0, d = m - 1, l = 0, r = n - 1, p = 0;\\n        vector<int> order(m * n);\\n        while (u <= d && l <= r) {\\n            for (int col = l; col <= r; col++) {\\n                order[p++] = matrix[u][col];\\n            }\\n            if (++u > d) {\\n                break;\\n            }\\n            for (int row = u; row <= d; row++) {\\n                order[p++] = matrix[row][r];\\n            }\\n            if (--r < l) {\\n                break;\\n            }\\n            for (int col = r; col >= l; col--) {\\n                order[p++] = matrix[d][col];\\n            }\\n            if (--d < u) {\\n                break;\\n            }\\n            for (int row = d; row >= u; row--) {\\n                order[p++] = matrix[row][l];\\n            }\\n            if (l++ > r) {\\n                break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, u = 0, d = m - 1, l = 0, r = n - 1, p = 0;\\n        vector<int> order(m * n);\\n        while (u <= d && l <= r) {\\n            for (int col = l; col <= r; col++) {\\n                order[p++] = matrix[u][col];\\n            }\\n            if (++u > d) {\\n                break;\\n            }\\n            for (int row = u; row <= d; row++) {\\n                order[p++] = matrix[row][r];\\n            }\\n            if (--r < l) {\\n                break;\\n            }\\n            for (int col = r; col >= l; col--) {\\n                order[p++] = matrix[d][col];\\n            }\\n            if (--d < u) {\\n                break;\\n            }\\n            for (int row = d; row >= u; row--) {\\n                order[p++] = matrix[row][l];\\n            }\\n            if (l++ > r) {\\n                break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502600,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution \\n\\n# Search \\uD83D\\uDC49 `Spiral Matrix by Tech Wired `\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- We will use a while loop to traverse the matrix in a clockwise spiral order.\\n- We will define four variables: left, right, top, bottom to represent the four boundaries of the current spiral.\\n- We will use four for loops to traverse each edge of the current spiral in clockwise order and add the elements to the result list.\\n- We will update the boundaries of the current spiral and continue the process until all elements have been traversed.\\n\\n# Intuition:\\n\\n- We start with the outermost layer of the matrix and traverse it in a clockwise spiral order, adding the elements to the result list.\\n- Then we move on to the next inner layer of the matrix and repeat the process until we have traversed all layers.\\n- To traverse each layer, we need to keep track of the four boundaries of the current spiral.\\n- We start at the top-left corner of the current spiral and move right until we hit the top-right corner.\\n- Then we move down to the bottom-right corner and move left until we hit the bottom-left corner.\\n- Finally, we move up to the top-left corner of the next spiral and repeat the process until we have traversed all elements in the matrix.\\n\\n\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        rows, cols = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, rows-1, 0, cols-1\\n        result = []\\n        \\n        while len(result) < rows * cols:\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        \\n        return result\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.length, cols = matrix[0].length;\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if (matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        rows, cols = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, rows-1, 0, cols-1\\n        result = []\\n        \\n        while len(result) < rows * cols:\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        \\n        return result\\n\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.length, cols = matrix[0].length;\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if (matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999388,
                "title": "95-41-faster-solution",
                "content": "1 - pop the first row and store it in result\\n2 - rotate the remaining matrix\\n3 - jump to 1st step.\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)\\n            matrix = (list(zip(*matrix)))[::-1]\\n        return result\\n```\\n\\nfor beginners who does not know the workings of zip here is explaination:\\n```\\nl = [1,2,3]\\nl2 = [4,5,6]\\nprint(list(zip(l,l2)))\\n#it will print [(1,4),(2,5),(3,6)]\\n```\\n\\nFor * (Star expression) here\\'s an example to understand\\n```\\ndef add(a,b):\\n\\treturn a+b\\nl = (2,3)\\nprint(add(*l))\\n```\\nIt basically unpacks the tuple and puts them as positional arguments in the function call.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)\\n            matrix = (list(zip(*matrix)))[::-1]\\n        return result\\n```\n```\\nl = [1,2,3]\\nl2 = [4,5,6]\\nprint(list(zip(l,l2)))\\n#it will print [(1,4),(2,5),(3,6)]\\n```\n```\\ndef add(a,b):\\n\\treturn a+b\\nl = (2,3)\\nprint(add(*l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466413,
                "title": "python-simulate-process-explained",
                "content": "Let us use coordinate `(x, y)` and direction of movement `(dx, dy)`. Each time when we reach point outside matrix we rotate. How we can rotate? We can either create array of rotations in advance or we can use the trick `dx, dy = -dy, dx`. Also how we understand it is time to rotate? We will write already visited elements with `*`, so when we see `*` or we go outside the grid, it is time to rotate.\\n\\n#### Complexity\\nIt is `O(mn)` both for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        n, m = len(matrix[0]), len(matrix)\\n        x, y, dx, dy = 0, 0, 1, 0\\n        ans = []\\n        for _ in range(m*n):\\n            if not 0 <= x+dx < n or not 0 <= y+dy < m or matrix[y+dy][x+dx] == \"*\":\\n                dx, dy = -dy, dx\\n                \\n            ans.append(matrix[y][x])\\n            matrix[y][x] = \"*\"\\n            x, y = x + dx, y + dy\\n        \\n        return ans\\n``` \\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        n, m = len(matrix[0]), len(matrix)\\n        x, y, dx, dy = 0, 0, 1, 0\\n        ans = []\\n        for _ in range(m*n):\\n            if not 0 <= x+dx < n or not 0 <= y+dy < m or matrix[y+dy][x+dx] == \"*\":\\n                dx, dy = -dy, dx\\n                \\n            ans.append(matrix[y][x])\\n            matrix[y][x] = \"*\"\\n            x, y = x + dx, y + dy\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20579,
                "title": "simple-python-solution-by-mutating-the-matrix",
                "content": "The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage.\\n\\n      \\n    def spiralOrder(self, matrix):\\n        ret = []\\n        while matrix:\\n            ret += matrix.pop(0)\\n            if matrix and matrix[0]:\\n                for row in matrix:\\n                    ret.append(row.pop())\\n            if matrix:\\n                ret += matrix.pop()[::-1]\\n            if matrix and matrix[0]:\\n                for row in matrix[::-1]:\\n                    ret.append(row.pop(0))\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage.\\n\\n      \\n    def spiralOrder(self, matrix):\\n        ret = []\\n        while matrix:\\n            ret += matrix.pop(0)\\n            if matrix and matrix[0]:\\n                for row in matrix:\\n                    ret.append(row.pop())\\n            if matrix:\\n                ret += matrix.pop()[::-1]\\n            if matrix and matrix[0]:\\n                for row in matrix[::-1]:\\n                    ret.append(row.pop(0))\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3503000,
                "title": "day-404-brute-better-optimal-1-liner-0ms-100-python-java-c-explained",
                "content": "\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![image.png](https://assets.leetcode.com/users/images/e0fa2719-73a2-4974-975c-bd971f7b11b4_1683602842.914548.png)\\n\\n# BRUTE\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force Approach:\\n\\nUse a stack and a 2D array to traverse the matrix in spiral order. It starts at the top-left corner of the matrix and pushes the coordinates onto the stack. It then pops the coordinates from the stack and checks if they are within the boundaries of the matrix and if they have been visited before. If they have not been visited, the value at that coordinate is added to the answer list and the coordinate is marked as visited. The program then checks the next coordinate in the direction of traversal (which is determined by the direction array) and pushes it onto the stack. If the next coordinate is out of bounds or has been visited before, the direction of traversal is changed by incrementing the index of the direction array. The program continues to pop coordinates from the stack until it is empty, at which point it returns the answer list.\\n\\n```java []\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length;\\n    int n = matrix[0].length;\\n    List<Integer> answer = new ArrayList<>();\\n    int[][] direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    int[][] visited = new int[m][n];\\n    for(int i = 0; i < m; i++) {\\n        Arrays.fill(visited[i], 0);\\n    }\\n    Consumer<int[]> traverse = (coord) -> {\\n        int index = 3;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(coord);\\n        while(!stack.isEmpty()) {\\n            coord = stack.pop();\\n            if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n                continue;\\n            }\\n            answer.add(matrix[coord[0]][coord[1]]);\\n            visited[coord[0]][coord[1]] = 1;\\n            int[] coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n                index = (index + 1) % 4;\\n            }\\n            coord2 = new int[]{coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            stack.push(coord2);\\n        }\\n    };\\n    traverse.accept(new int[]{0,0});\\n    return answer;\\n}\\n```\\n```c++ []\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int m = matrix.size();\\n    int n = matrix[0].size();\\n    vector<int> answer;\\n    vector<vector<int>> direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    vector<vector<int>> visited(m, vector<int>(n, 0));\\n    function<void(vector<int>, int)> traverse = [&](vector<int> coord, int index) {\\n        if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n            return;\\n        }\\n        answer.push_back(matrix[coord[0]][coord[1]]);\\n        visited[coord[0]][coord[1]] = 1;\\n        vector<int> coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n            index = (index + 1) % 4;\\n        }\\n        coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        traverse(coord2, index);\\n    };\\n    traverse({0,0}, 3);\\n    return answer;\\n}\\n```\\n```python []\\ndef spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# BETTER \\n\\nBetter Approach:\\n\\nThis approach uses four variables to keep track of the boundaries of the matrix and a variable to keep track of the direction of traversal. It starts at the top-left corner of the matrix and adds the value at that coordinate to the result list. It then checks the direction of traversal and increments or decrements the row or column index accordingly. If the index reaches a boundary, the boundary is updated and the direction of traversal is changed. The program continues to add values to the result list until it has added all the values in the matrix. Finally, it returns the result list. This approach is similar to the previous approaches, but it uses boundary variables and a character variable to keep track of the direction of traversal instead of a 2D array.\\n\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int nrow = matrix.length;\\n        int ncol = matrix[0].length;\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        List<Integer> result = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.add(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        vector<int> result;\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.push_back(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        nrow, ncol = len(matrix), len(matrix[0])\\n        l_wall, r_wall = -1, ncol\\n        u_wall, d_wall = 0, nrow\\n        direction = \\'r\\'\\n        result = []\\n        i, j = 0, 0\\n        while len(result) < nrow * ncol:\\n            result.append(matrix[i][j])\\n            if direction == \\'r\\':\\n                j += 1\\n                if j == r_wall:\\n                    r_wall -= 1\\n                    j = r_wall\\n                    direction = \\'d\\'\\n                    i += 1\\n            elif direction == \\'d\\':\\n                i += 1\\n                if i == d_wall:\\n                    d_wall -= 1\\n                    i = d_wall\\n                    direction = \\'l\\'\\n                    j -= 1\\n            elif direction == \\'l\\':\\n                j -= 1\\n                if j == l_wall:\\n                    l_wall += 1\\n                    j = l_wall\\n                    direction = \\'u\\'\\n                    i -= 1\\n            elif direction == \\'u\\':\\n                i -= 1\\n                if i == u_wall:\\n                    u_wall += 1\\n                    i = u_wall\\n                    direction = \\'r\\'\\n                    j += 1\\n        return result\\n```\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Optimal\\n\\nOptimal Approach:\\n\\nWe can further optimize the above approach by using a single loop to traverse the matrix in a spiral order. We start by initializing the top, bottom, left, and right pointers to the edges of the matrix. We then use a single loop to traverse the matrix in a spiral order by moving the pointers inward after each traversal. We continue this process until we have visited all elements of the matrix.\\n\\n\\n```JAVA []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if(matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        if not matrix or not matrix[0]:\\n            return result\\n        m, n = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, m - 1, 0, n - 1\\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right + 1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            # Traverse down\\n            for i in range(top, bottom + 1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        return result\\n```\\n\\n# ONE LINER \\n```PYTHON []\\ndef spiralOrder(self, matrix):\\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n```\\n```PYTHON3 []\\ndef spiralOrder(self, matrix):\\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\\n```py []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)  # pop the first row each time\\n            matrix = list(zip(*matrix))[::-1]  # left rotate matrix 90 degree each time\\n        return result\\n```\\n# how it works step by step.\\n\\nThe first line of the code checks if the matrix is not empty. If the matrix is empty, it returns an empty list. If the matrix is not empty, it proceeds with the traversal.\\n\\n##### \\u2022return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\nThe second line of the code uses a list comprehension to extract the first row of the matrix and add it to the result list. It then uses the pop() method to remove the first row from the matrix.\\n\\n##### \\u2022[*matrix.pop(0)]\\nThe third line of the code uses the zip() function to transpose the matrix and then reverses the order of the rows using slicing. This creates a new matrix that can be traversed in the next recursive call.\\n\\n##### \\u2022[*zip(*matrix)][::-1]\\nThe fourth line of the code uses recursion to traverse the new matrix in a spiral order. The result of the recursive call is added to the result list using the + operator.\\n\\n##### \\u2022self.spiralOrder([*zip(*matrix)][::-1])\\nFinally, the result list is returned.\\n\\n##### \\u2022return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\nusing recursive approach to traverse the matrix in a spiral order. It extracts the first row of the matrix, removes it from the matrix, transposes the matrix, and then reverses the order of the rows to create a new matrix that can be traversed in the next recursive call. The process continues until all elements of the matrix have been added to the result list.\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# DRY RUN\\n\\n\\n##### \\u2022\\tExample 1:\\n![image.png](https://assets.leetcode.com/users/images/38c304d2-83e3-4e4b-a5cb-23c57ff432fb_1683603361.7566543.png)\\n##### \\u2022\\tInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\\n##### \\u2022\\tOutput: [1,2,3,6,9,8,7,4,5]\\n##### \\u2022\\tStep-by-Step Explanation:\\n##### \\u2022\\tInitialize the result list as an empty list.\\n##### \\u2022\\tSet the top, bottom, left, and right pointers to the edges of the matrix. top = 0, bottom = 2, left = 0, right = 2.\\n##### \\u2022\\tTraverse the first row from left to right and add the elements to the result list. result = [1, 2, 3]. Increment the top pointer to 1.\\n##### \\u2022\\tTraverse the last column from top to bottom and add the elements to the result list. result = [1, 2, 3, 6, 9]. Decrement the right pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is true, traverse the last row from right to left and add the elements to the result list. result = [1, 2, 3, 6, 9, 8, 7]. Decrement the bottom pointer to 1.\\n##### \\u2022\\tCheck if left <= right. Since it is true, traverse the first column from bottom to top and add the elements to the result list. result = [1, 2, 3, 6, 9, 8, 7, 4, 5]. Increment the left pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is false, the traversal is complete. Return the result list.\\n##### \\u2022\\tExample 2:\\n![image.png](https://assets.leetcode.com/users/images/6d7fe5a8-721d-4475-b379-59bcb7e423ab_1683603351.6500404.png)\\n##### \\u2022\\tInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\\n##### \\u2022\\tOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\\n##### \\u2022\\tStep-by-Step Explanation:\\n##### \\u2022\\tInitialize the result list as an empty list.\\n##### \\u2022\\tSet the top, bottom, left, and right pointers to the edges of the matrix. top = 0, bottom = 2, left = 0, right = 3.\\n##### \\u2022\\tTraverse the first row from left to right and add the elements to the result list. result = [1, 2, 3, 4]. Increment the top pointer to 1.\\n##### \\u2022\\tTraverse the last column from top to bottom and add the elements to the result list. result = [1, 2, 3, 4, 8, 12]. Decrement the right pointer to 2.\\n##### \\u2022\\tCheck if top <= bottom. Since it is true, traverse the last row from right to left and add the elements to the result list. result = [1, 2, 3, 4, 8, 12, 11, 10, 9]. Decrement the bottom pointer to 1.\\n##### \\u2022\\tCheck if left <= right. Since it is true, traverse the first column from bottom to top and add the elements to the result list. result = [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]. Increment the left pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is false, the traversal is complete. Return the result list.\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length;\\n    int n = matrix[0].length;\\n    List<Integer> answer = new ArrayList<>();\\n    int[][] direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    int[][] visited = new int[m][n];\\n    for(int i = 0; i < m; i++) {\\n        Arrays.fill(visited[i], 0);\\n    }\\n    Consumer<int[]> traverse = (coord) -> {\\n        int index = 3;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(coord);\\n        while(!stack.isEmpty()) {\\n            coord = stack.pop();\\n            if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n                continue;\\n            }\\n            answer.add(matrix[coord[0]][coord[1]]);\\n            visited[coord[0]][coord[1]] = 1;\\n            int[] coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n                index = (index + 1) % 4;\\n            }\\n            coord2 = new int[]{coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            stack.push(coord2);\\n        }\\n    };\\n    traverse.accept(new int[]{0,0});\\n    return answer;\\n}\\n```\n```c++ []\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int m = matrix.size();\\n    int n = matrix[0].size();\\n    vector<int> answer;\\n    vector<vector<int>> direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    vector<vector<int>> visited(m, vector<int>(n, 0));\\n    function<void(vector<int>, int)> traverse = [&](vector<int> coord, int index) {\\n        if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n            return;\\n        }\\n        answer.push_back(matrix[coord[0]][coord[1]]);\\n        visited[coord[0]][coord[1]] = 1;\\n        vector<int> coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n            index = (index + 1) % 4;\\n        }\\n        coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        traverse(coord2, index);\\n    };\\n    traverse({0,0}, 3);\\n    return answer;\\n}\\n```\n```python []\\ndef spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\n```java  []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int nrow = matrix.length;\\n        int ncol = matrix[0].length;\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        List<Integer> result = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.add(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        vector<int> result;\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.push_back(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        nrow, ncol = len(matrix), len(matrix[0])\\n        l_wall, r_wall = -1, ncol\\n        u_wall, d_wall = 0, nrow\\n        direction = \\'r\\'\\n        result = []\\n        i, j = 0, 0\\n        while len(result) < nrow * ncol:\\n            result.append(matrix[i][j])\\n            if direction == \\'r\\':\\n                j += 1\\n                if j == r_wall:\\n                    r_wall -= 1\\n                    j = r_wall\\n                    direction = \\'d\\'\\n                    i += 1\\n            elif direction == \\'d\\':\\n                i += 1\\n                if i == d_wall:\\n                    d_wall -= 1\\n                    i = d_wall\\n                    direction = \\'l\\'\\n                    j -= 1\\n            elif direction == \\'l\\':\\n                j -= 1\\n                if j == l_wall:\\n                    l_wall += 1\\n                    j = l_wall\\n                    direction = \\'u\\'\\n                    i -= 1\\n            elif direction == \\'u\\':\\n                i -= 1\\n                if i == u_wall:\\n                    u_wall += 1\\n                    i = u_wall\\n                    direction = \\'r\\'\\n                    j += 1\\n        return result\\n```\n```JAVA []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if(matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        if not matrix or not matrix[0]:\\n            return result\\n        m, n = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, m - 1, 0, n - 1\\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right + 1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            # Traverse down\\n            for i in range(top, bottom + 1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        return result\\n```\n```PYTHON []\\ndef spiralOrder(self, matrix):\\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n```\n```PYTHON3 []\\ndef spiralOrder(self, matrix):\\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\n```py []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)  # pop the first row each time\\n            matrix = list(zip(*matrix))[::-1]  # left rotate matrix 90 degree each time\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039684,
                "title": "python-solution-explained-step-by-step-with-illustrations",
                "content": "### \\u2705 Upvote if it helps! \\n\\n# Code :\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0) # 1\\n\\n            if matrix and matrix[0]: # 2 \\n                for line in matrix:\\n                    result.append(line.pop())\\n\\n            if matrix: # 3\\n                result += matrix.pop()[::-1]\\n\\n            if matrix and matrix[0]: # 4\\n                for line in matrix[::-1]:\\n                    result.append(line.pop(0))\\n        return result\\n```\\n\\n\\n# Step by step :\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s explain what\\'s inside the loop step by step with an example:\\n\\n\\n- **Initial state**:\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7e17f951-0d27-4031-bd19-3cd94990a3df_1673513448.4431794.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n- **Step 1**:\\n```\\nresult += matrix.pop(0)\\n```\\nWe add the first line to the result and delete it from the initial matrix.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/8e873cf6-0239-4ef2-b4c9-6373a546757d_1673513580.3806927.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n- **Step 2**:\\n```\\nfor line in matrix:\\n    result.append(line.pop())\\n```\\nWe iterate over the lines *(in green)* and we are popping the ***last*** item of each line (in red).\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/4c9c8a98-27c6-42ad-82fa-da8e309199ab_1673513719.533255.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\n- **Step 3**:\\n```\\nresult += matrix.pop()[::-1]\\n```\\nWe add the last line in a reverse order.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/4319c5be-0d19-41cf-9f51-3a1236c760fd_1673513818.7995842.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\n\\n- **Step 4**:\\n```\\nfor line in matrix[::-1]:\\n    result.append(line.pop(0))\\n```\\nWe iterate over the lines and we are popping the ***first*** item of each line (in red).\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/ec967a82-1e5e-45cb-bba1-d3d70e7872e5_1673513878.5658035.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\nWhen we escape the loop, it means that the matrix is empty and that we explored all cells.\\nWe cans then return the result.\\n\\n# **Upvote if it helps!** \\uD83D\\uDE00\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0) # 1\\n\\n            if matrix and matrix[0]: # 2 \\n                for line in matrix:\\n                    result.append(line.pop())\\n\\n            if matrix: # 3\\n                result += matrix.pop()[::-1]\\n\\n            if matrix and matrix[0]: # 4\\n                for line in matrix[::-1]:\\n                    result.append(line.pop(0))\\n        return result\\n```\n```\\nresult += matrix.pop(0)\\n```\n```\\nfor line in matrix:\\n    result.append(line.pop())\\n```\n```\\nresult += matrix.pop()[::-1]\\n```\n```\\nfor line in matrix[::-1]:\\n    result.append(line.pop(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20656,
                "title": "ac-python-32ms-solution",
                "content": "    def spiralOrder(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        m, n = len(matrix), len(matrix[0])\\n        u, d, l, r = 0, m - 1, 0, n - 1\\n        while l < r and u < d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r)])\\n            ans.extend([matrix[i][r] for i in xrange(u, d)])\\n            ans.extend([matrix[d][j] for j in xrange(r, l, -1)])\\n            ans.extend([matrix[i][l] for i in xrange(d, u, -1)])\\n            u, d, l, r = u + 1, d - 1, l + 1, r - 1\\n        if l == r:\\n            ans.extend([matrix[i][r] for i in xrange(u, d + 1)])\\n        elif u == d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r + 1)])\\n        return ans\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 100%",
                "solutionTags": [],
                "code": "    def spiralOrder(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        m, n = len(matrix), len(matrix[0])\\n        u, d, l, r = 0, m - 1, 0, n - 1\\n        while l < r and u < d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r)])\\n            ans.extend([matrix[i][r] for i in xrange(u, d)])\\n            ans.extend([matrix[d][j] for j in xrange(r, l, -1)])\\n            ans.extend([matrix[i][l] for i in xrange(d, u, -1)])\\n            u, d, l, r = u + 1, d - 1, l + 1, r - 1\\n        if l == r:\\n            ans.extend([matrix[i][r] for i in xrange(u, d + 1)])\\n        elif u == d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r + 1)])\\n        return ans\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 100%",
                "codeTag": "Python3"
            },
            {
                "id": 651503,
                "title": "javascript-simple-and-clean",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n  const res = []\\n  while(matrix.length){\\n    const first = matrix.shift()\\n    res.push(...first)\\n    for(const m of matrix){\\n      let val = m.pop()\\n      if(val)\\n        res.push(val)\\n        m.reverse()   \\n    }\\n    matrix.reverse()\\n  }\\n  return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n  const res = []\\n  while(matrix.length){\\n    const first = matrix.shift()\\n    res.push(...first)\\n    for(const m of matrix){\\n      let val = m.pop()\\n      if(val)\\n        res.push(val)\\n        m.reverse()   \\n    }\\n    matrix.reverse()\\n  }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468151,
                "title": "python-smart-simulate-by-marking-as-visited-clean-concise",
                "content": "**Idea**\\n- Initially, we move by the RIGHT direction.\\n- If we meet the boundary or we meet visited cell then we change to the next direction.\\n- Directions are in order [RIGHT, DOWN, LEFT, TOP].\\n- We iterate `m*n` times to add `m*n` cells to our anser.\\n- This problem **[59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)** is exactly the same, try to solve it yourself.\\n\\n![image](https://assets.leetcode.com/users/images/9d38605b-ab50-4a07-af35-d5aaa183a494_1631859060.3834043.png)\\n\\n\\n```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        m, n, VISITED = len(matrix), len(matrix[0]), 200\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c, d = 0, 0, 0\\n        ans = []\\n        for _ in range(m * n):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < m or not 0 <= nc < n or matrix[nr][nc] == VISITED:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n\\n            ans.append(matrix[r][c])\\n            matrix[r][c] = VISITED  # Mark as visited\\n            r, c = nr, nc\\n\\n        return ans\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 10` is number of rows, `N <= 10` is number of columns in the matrix.\\n- Extra space (without counting output as space): `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        m, n, VISITED = len(matrix), len(matrix[0]), 200\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c, d = 0, 0, 0\\n        ans = []\\n        for _ in range(m * n):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < m or not 0 <= nc < n or matrix[nr][nc] == VISITED:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n\\n            ans.append(matrix[r][c])\\n            matrix[r][c] = VISITED  # Mark as visited\\n            r, c = nr, nc\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447082,
                "title": "python-96-simple-solution-w-explanation",
                "content": "# Intuition:\\nWe can think about the matrix as an onion. We will first spiral around the outermost layer, adding it to the result, then \"discard\" the outer layer. This leaves us with a new outermost layer which we haven\\'t examined yet, on which we repeat the process.\\n\\n# Algorithm:\\n- Keep track of **four pointers**: a left, right, up, and down pointer. This tells us which portion of the matrix we should be adding, since with every successive spiral it shrinks. We will **update these pointers to tell us which part of the array we haven\\'t looked at yet** (the box formed by these pointers). \\n- We will build our solution from four distinct movements: scanning **left -> right on the topmost row** we haven\\'t looked at, scanning **top -> bottom on the rightmost column**, scanning **right -> left on the bottommost row,** and **bottom -> top on the leftmost column.**\\n- First scan from **left to right.** The pointers are as follows:\\n```\\nL     R\\n|     |\\nv     v\\nx x x x <- T\\nx x x x\\nx x x x <- B\\n```\\nAfter adding the whole first row, **we move the top pointer down one row** to indicate that the first row has been examined.\\n- Next scan from top to bottom. The pointers are as follows:\\n```\\nL     R\\n|     |\\nv     v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\\nWe want to include all members of the R column between T and B (inclusive). Note that the **topmost member of the R column was already added** when scanning left -> right, so we don\\'t want a duplicate. After scanning this column, we **move the right pointer left one column** to indicate the R column was just added.\\n- Next scan from right to left. The pointers are as follows:\\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\\nWe want **all members of the B row between R and L inclusive**, since we already previously added the rightmost member. After adding this row, we **shift B up by one**.\\n- Lastly, scan from bottom to top. The pointers are as follows:\\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n```\\n\\nWe want **all members of the L column between T and B inclusive**. We then **move L right by one column** after adding.\\n- **Repeat these four steps**. Here are what the pointers look like over the next few iterations:\\n\\n```\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- B\\nx x x x <- T\\n```\\n\\nAt this point, the top pointer is below the bottom pointer. This means we\\'ve spiraled through the whole matrix, there\\'s nothing left to examine, and we should stop repeating these steps. Note that we should be **checking before performing any one of these four steps that none of our pointers are overlapping** (i.e. L is bigger than R, or T is greater than B). In the code below, I check which direction we should be scanning by using **pattern matching**.\\n\\n# Final code solution:\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        l, r = 0, len(matrix[0]) - 1\\n        u, d = 0, len(matrix) - 1\\n        res = []\\n        step = 0\\n        while l <= r and u <= d:\\n            match (step % 4):\\n                case 0:\\n                    for i in range(l, r+1):\\n                        res.append(matrix[u][i])\\n                    u += 1\\n                case 1:\\n                    for i in range(u, d+1):\\n                        res.append(matrix[i][r])\\n                    r -= 1\\n                case 2:\\n                    for i in range(r, l-1, -1):\\n                        res.append(matrix[d][i])\\n                    d -= 1\\n                case 3:\\n                    for i in range(d, u-1, -1):\\n                        res.append(matrix[i][l])\\n                    l += 1\\n            step += 1\\n        return res\\n```\\n\\nI hope this was helpful! A +1 would be most appreciated if you liked my solution + explanation :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nL     R\\n|     |\\nv     v\\nx x x x <- T\\nx x x x\\nx x x x <- B\\n```\n```\\nL     R\\n|     |\\nv     v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n```\n```\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- B\\nx x x x <- T\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        l, r = 0, len(matrix[0]) - 1\\n        u, d = 0, len(matrix) - 1\\n        res = []\\n        step = 0\\n        while l <= r and u <= d:\\n            match (step % 4):\\n                case 0:\\n                    for i in range(l, r+1):\\n                        res.append(matrix[u][i])\\n                    u += 1\\n                case 1:\\n                    for i in range(u, d+1):\\n                        res.append(matrix[i][r])\\n                    r -= 1\\n                case 2:\\n                    for i in range(r, l-1, -1):\\n                        res.append(matrix[d][i])\\n                    d -= 1\\n                case 3:\\n                    for i in range(d, u-1, -1):\\n                        res.append(matrix[i][l])\\n                    l += 1\\n            step += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20782,
                "title": "40-ms-python-solution-top-right-bottom-left-peeling-off-layers",
                "content": "    class Solution(object):\\n        def spiralOrder(self, matrix):\\n\\n            if matrix == []:\\n              return matrix\\n    \\n            l = 0\\n            r = len(matrix[0]) - 1\\n            t = 0\\n            b = len(matrix) - 1\\n    \\n            ret = []\\n            while l < r and t < b:\\n            \\t# top\\n            \\tfor i in range(l, r):\\n            \\t\\tret.append(matrix[t][i])\\n            \\t# right\\n            \\tfor i in range(t, b):\\n            \\t\\tret.append(matrix[i][r])\\n            \\t# bottom\\n            \\tfor i in range(r, l, -1):\\n            \\t\\tret.append(matrix[b][i])\\n            \\t# left\\n            \\tfor i in range(b, t, -1):\\n            \\t\\tret.append(matrix[i][l])\\n    \\n    \\t        l += 1\\n    \\t        r -= 1 \\n    \\t        t += 1\\n    \\t        b -= 1\\n    \\n    \\t    # single square\\n            if l == r and t == b:\\n            \\tret.append(matrix[t][l])\\n            # vertical line\\n           \\telif l == r:\\n           \\t\\tfor i in range(t, b + 1):\\n           \\t\\t\\tret.append(matrix[i][l])\\n           \\t# horizontal line\\n           \\telif t == b:\\n           \\t\\tfor i in range(l, r + 1):\\n           \\t\\t\\tret.append(matrix[t][i])\\n           \\treturn ret\\n\\nAny crits appreciated. Wondering about reducing the edge case checks at the end.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def spiralOrder(self, matrix):\\n\\n            if matrix == []:\\n              return matrix\\n    \\n            l = 0\\n            r = len(matrix[0]) - 1\\n            t = 0\\n            b = len(matrix) - 1\\n    \\n            ret = []\\n            while l < r and t < b:\\n            \\t# top\\n            \\tfor i in range(l, r):\\n            \\t\\tret.append(matrix[t][i])\\n            \\t# right\\n            \\tfor i in range(t, b):\\n            \\t\\tret.append(matrix[i][r])\\n            \\t# bottom\\n            \\tfor i in range(r, l, -1):\\n            \\t\\tret.append(matrix[b][i])\\n            \\t# left\\n            \\tfor i in range(b, t, -1):\\n            \\t\\tret.append(matrix[i][l])\\n    \\n    \\t        l += 1\\n    \\t        r -= 1 \\n    \\t        t += 1\\n    \\t        b -= 1\\n    \\n    \\t    # single square\\n            if l == r and t == b:\\n            \\tret.append(matrix[t][l])\\n            # vertical line\\n           \\telif l == r:\\n           \\t\\tfor i in range(t, b + 1):\\n           \\t\\t\\tret.append(matrix[i][l])\\n           \\t# horizontal line\\n           \\telif t == b:\\n           \\t\\tfor i in range(l, r + 1):\\n           \\t\\t\\tret.append(matrix[t][i])\\n           \\treturn ret\\n\\nAny crits appreciated. Wondering about reducing the edge case checks at the end.",
                "codeTag": "Java"
            },
            {
                "id": 3502674,
                "title": "c-java-optimal-solution-step-by-step-solution-beats-100-easy-to-understand",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nConsider the following 4x4 matrix as an example:\\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\\nThe goal of the algorithm is to visit each element in the matrix in a clockwise spiral order, starting from the top-left corner and moving towards the center of the matrix.\\n\\nWe can visualize the spiral order traversal of the matrix as follows:\\n\\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\\nIn the first step, we traverse the top row of the matrix from left to right:\\n```\\n1  2  3  4\\n   --------\\n```\\nIn the second step, we traverse the rightmost column of the matrix from top to bottom:\\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  | \\n```\\nIn the third step, we traverse the bottom row of the matrix from right to left:\\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  --------\\n```\\nIn the fourth step, we traverse the leftmost column of the matrix from bottom to top:\\n```\\n    2   3\\n    |   8\\n    |  12\\n1 --   16\\n    |\\n```\\nIn the fifth step, we traverse the second row of the matrix from left to right:\\n```\\n    2   3\\n    |   8\\n    |  12\\n---------   \\n1  5   6  7\\n```\\nIn the sixth step, we traverse the second-to-last column of the matrix from top to bottom:\\n```\\n    2 |  3\\n    | | 12\\n    | |   \\n---- | --   \\n1  5 | 6  7\\n    | |\\n```\\nIn the seventh step, we traverse the bottom row of the matrix from left to right:\\n\\n```\\n    2 |  3\\n    | | 12\\n---- | ----   \\n1  5  9 10 11\\n       |\\n```\\nIn the eighth step, we traverse the second-to-last column of the matrix from bottom to top:\\n```\\n    2 |    \\n---- | ----   \\n1  5 | 9 10 11\\n    | | 12\\n    | |\\n```\\nIn the ninth and final step, we traverse the third row of the matrix from right to left:\\n```\\n    --    \\n1  5  9  6 \\n    | |    \\n    | | 12 \\n    --    \\n```\\nAt this point, we have visited all the elements in the matrix in spiral order, and the traversal is complet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# -----------------------------------------------------\\n# PLEASE UPVOTE IF IT HELPS YOU\\n# -----------------------------------------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col =matrix[0].size();\\n        int count =0;\\n        int total =row*col;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=row-1;\\n        int endingcol=col-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                ans.push_back(matrix[startingrow][i]);\\n                count++;\\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n                ans.push_back(matrix[i][endingcol]);\\n                count++;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                ans.push_back(matrix[endingrow][i]);\\n                count++;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                ans.push_back(matrix[i][startingcol]);\\n                count++;\\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n# java code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int count = 0;\\n        int total = m * n;\\n        int startingRow = 0;\\n        int endingRow = m - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count < total) {\\n            // Traverse top row from left to right\\n            for (int i = startingCol; count < total && i <= endingCol; i++) {\\n                ans.add(matrix[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Traverse right column from top to bottom\\n            for (int i = startingRow; count < total && i <= endingRow; i++) {\\n                ans.add(matrix[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // Traverse bottom row from right to left\\n            for (int i = endingCol; count < total && i >= startingCol; i--) {\\n                ans.add(matrix[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // Traverse left column from bottom to top\\n            for (int i = endingRow; count < total && i >= startingRow; i--) {\\n                ans.add(matrix[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\n```\\n1  2  3  4\\n   --------\\n```\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  | \\n```\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  --------\\n```\n```\\n    2   3\\n    |   8\\n    |  12\\n1 --   16\\n    |\\n```\n```\\n    2   3\\n    |   8\\n    |  12\\n---------   \\n1  5   6  7\\n```\n```\\n    2 |  3\\n    | | 12\\n    | |   \\n---- | --   \\n1  5 | 6  7\\n    | |\\n```\n```\\n    2 |  3\\n    | | 12\\n---- | ----   \\n1  5  9 10 11\\n       |\\n```\n```\\n    2 |    \\n---- | ----   \\n1  5 | 9 10 11\\n    | | 12\\n    | |\\n```\n```\\n    --    \\n1  5  9  6 \\n    | |    \\n    | | 12 \\n    --    \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col =matrix[0].size();\\n        int count =0;\\n        int total =row*col;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=row-1;\\n        int endingcol=col-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                ans.push_back(matrix[startingrow][i]);\\n                count++;\\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n                ans.push_back(matrix[i][endingcol]);\\n                count++;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                ans.push_back(matrix[endingrow][i]);\\n                count++;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                ans.push_back(matrix[i][startingcol]);\\n                count++;\\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int count = 0;\\n        int total = m * n;\\n        int startingRow = 0;\\n        int endingRow = m - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count < total) {\\n            // Traverse top row from left to right\\n            for (int i = startingCol; count < total && i <= endingCol; i++) {\\n                ans.add(matrix[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Traverse right column from top to bottom\\n            for (int i = startingRow; count < total && i <= endingRow; i++) {\\n                ans.add(matrix[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // Traverse bottom row from right to left\\n            for (int i = endingCol; count < total && i >= startingCol; i--) {\\n                ans.add(matrix[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // Traverse left column from bottom to top\\n            for (int i = endingRow; count < total && i >= startingRow; i--) {\\n                ans.add(matrix[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20606,
                "title": "very-easy-to-understand-python-solution",
                "content": "    def spiralOrder(self, matrix):\\n        res = []\\n        if not matrix:\\n            return []\\n        i,j,di,dj = 0,0,0,1\\n        m, n = len(matrix),len(matrix[0])\\n        for v in xrange(m * n):\\n            res.append(matrix[i][j])\\n            matrix[i][j] = ''\\n            if matrix[(i+di)%m][(j+dj)%n] == '':\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def spiralOrder(self, matrix):\\n        res = []\\n        if not matrix:\\n            return []\\n        i,j,di,dj = 0,0,0,1\\n        m, n = len(matrix),len(matrix[0])\\n        for v in xrange(m * n):\\n            res.append(matrix[i][j])\\n            matrix[i][j] = ''\\n            if matrix[(i+di)%m][(j+dj)%n] == '':\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1511476,
                "title": "java-tc-o-m-n-sc-o-1-optimized-solution-using-switch-case",
                "content": "**Using Switch-Case**\\n\\n```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Right\\n                    for (int i = left; i <= right; i++) {\\n                        result.add(matrix[top][i]);\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result.add(matrix[i][right]);\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Left\\n                    for (int i = right; i >= left; i--) {\\n                        result.add(matrix[bottom][i]);\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Top\\n                    for (int i = bottom; i >= top; i--) {\\n                        result.add(matrix[i][left]);\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Without using Switch-Case**\\n\\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/discuss/1511479/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Multiple-optimized-ways-to-solve-this-question)\\n- [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/discuss/1511489/Java-or-TC:-O(max(R-C)2)-or-SC:-O(1)-or-Simulating-a-Spiral-Walk)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Right\\n                    for (int i = left; i <= right; i++) {\\n                        result.add(matrix[top][i]);\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result.add(matrix[i][right]);\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Left\\n                    for (int i = right; i >= left; i--) {\\n                        result.add(matrix[bottom][i]);\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Top\\n                    for (int i = bottom; i >= top; i--) {\\n                        result.add(matrix[i][left]);\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20778,
                "title": "0ms-c-solution-take-turns-to-move-in-4-directions",
                "content": "    class Solution {\\n    public:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> res;        \\n        int rowSize = matrix.size();\\n        if (rowSize==0) return res;\\n        int colSize = matrix[0].size();\\n        int lb=0,rb=colSize-1,ub=0,db=rowSize-1;// left bound, right bound, up bound, down bound;\\n        int direction = 0;\\n        int col=0,row=0;\\n        while (lb<=rb && ub<=db){\\n            res.push_back(matrix[row][col]);\\n            switch (direction){\\n                case 0:  //  right\\n                    if (col>=rb) {direction = 1;row=row+1;ub++;} else col=col+1;\\n                    break;\\n                case 1: // down\\n                    if (row>=db) {direction = 2;col=col-1;rb--;} else row=row+1;\\n                    break;\\n                case 2: // left\\n                    if (col<=lb) {direction = 3;row=row-1;db--;} else col=col-1;\\n                    break;\\n                default:  // up\\n                    if (row<=ub) {direction = 0;col=col+1;lb++;} else row=row-1;\\n            }\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> res;        \\n        int rowSize = matrix.size();\\n        if (rowSize==0) return res;\\n        int colSize = matrix[0].size();\\n        int lb=0,rb=colSize-1,ub=0,db=rowSize-1;// left bound, right bound, up bound, down bound;\\n        int direction = 0;\\n        int col=0,row=0;\\n        while (lb<=rb && ub<=db){\\n            res.push_back(matrix[row][col]);\\n            switch (direction){\\n                case 0:  //  right\\n                    if (col>=rb) {direction = 1;row=row+1;ub++;}",
                "codeTag": "Java"
            },
            {
                "id": 1333700,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int right = matrix[0].size()-1;\\n        int top = 0;\\n        int bottom = matrix.size()-1;\\n        vector<int> res;\\n        int i;\\n        while(left <= right and top <= bottom) {\\n            // traverse from left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                res.push_back(matrix[top][i]);\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            // traverse from top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n                res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left > right || top > bottom) break;\\n            // traverse from right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n                res.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            // // traverse from bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int right = matrix[0].size()-1;\\n        int top = 0;\\n        int bottom = matrix.size()-1;\\n        vector<int> res;\\n        int i;\\n        while(left <= right and top <= bottom) {\\n            // traverse from left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                res.push_back(matrix[top][i]);\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            // traverse from top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n                res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left > right || top > bottom) break;\\n            // traverse from right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n                res.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            // // traverse from bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20821,
                "title": "an-iterative-python-solution",
                "content": "The idea is to peel the the matrix layer by layer.\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of integers\\n        # 9:27\\n        def spiralOrder(self, matrix):\\n            result = []\\n            \\n            while matrix and matrix[0]:\\n                if matrix[0]:\\n                    result += matrix.pop(0)\\n                \\n                if matrix and matrix[0]:\\n                    for row in matrix:\\n                        result.append(row.pop())\\n                \\n                if matrix and matrix[-1]:\\n                    result += matrix.pop()[::-1]\\n    \\n                if matrix and matrix[0]:\\n                    for row in matrix[::-1]:\\n                        result.append(row.pop(0))\\n            \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is to peel the the matrix layer by layer.\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of integers\\n        # 9:27\\n        def spiralOrder(self, matrix):\\n            result = []\\n            \\n            while matrix and matrix[0]:\\n                if matrix[0]:\\n                    result += matrix.pop(0)\\n                \\n                if matrix and matrix[0]:\\n                    for row in matrix:\\n                        result.append(row.pop())\\n                \\n                if matrix and matrix[-1]:\\n                    result += matrix.pop()[::-1]\\n    \\n                if matrix and matrix[0]:\\n                    for row in matrix[::-1]:\\n                        result.append(row.pop(0))\\n            \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 2689004,
                "title": "simple-4-pointers-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Time taken to cover row * column elements is O(row * column) = O(N).\\nSpace Complexity - Since we do not use any extra space, space taken is O(1).\\nExplanation - We fix four pointers - left, right, top, bottom which we use to traverse the matrix.\\nAfter moving in one direction, we change our direction to traverse cyclically.\\nOn traversing the top row, we increment top. On traversing the right row, we decrement right.\\nOn traversing the bottom row, we decrement bottom. On traversing the left row, we increment left.\\ndirection 1 - left to right\\ndirection 2 - top to bottom\\ndirection 3 - right to left\\ndirection 4 - bottom to top\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix){\\n        int row = matrix.size(), col = matrix[0].size(), left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1, direction = 1;\\n        vector<int> order;\\n        \\n        while(order.size() < row * col)\\n        {\\n            switch(direction){\\n                case 1:\\n                    for(int i = left; i <= right; i++) order.push_back(matrix[top][i]);\\n                    direction = 2;\\n                    top++;\\n                    break;\\n                    \\n                case 2:\\n                    for(int i = top; i <= bottom; i++) order.push_back(matrix[i][right]);\\n                    direction = 3;\\n                    right--;\\n                    break;\\n                    \\n                case 3:\\n                    for(int i = right;i >= left; i--) order.push_back(matrix[bottom][i]);\\n                    direction = 4;\\n                    bottom--;\\n                    break;\\n                    \\n                case 4:\\n                    for(int i = bottom; i >= top; i--) order.push_back(matrix[i][left]);\\n                    direction = 1;\\n                    left++;\\n                    break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix){\\n        int row = matrix.size(), col = matrix[0].size(), left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1, direction = 1;\\n        vector<int> order;\\n        \\n        while(order.size() < row * col)\\n        {\\n            switch(direction){\\n                case 1:\\n                    for(int i = left; i <= right; i++) order.push_back(matrix[top][i]);\\n                    direction = 2;\\n                    top++;\\n                    break;\\n                    \\n                case 2:\\n                    for(int i = top; i <= bottom; i++) order.push_back(matrix[i][right]);\\n                    direction = 3;\\n                    right--;\\n                    break;\\n                    \\n                case 3:\\n                    for(int i = right;i >= left; i--) order.push_back(matrix[bottom][i]);\\n                    direction = 4;\\n                    bottom--;\\n                    break;\\n                    \\n                case 4:\\n                    for(int i = bottom; i >= top; i--) order.push_back(matrix[i][left]);\\n                    direction = 1;\\n                    left++;\\n                    break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20773,
                "title": "elegant-and-fast-java-solution-240ms",
                "content": "        public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> spiralList = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) return spiralList;\\n        \\n        // declare indices\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        \\n        while(true){\\n            // 1. print top row\\n            for(int j=left; j <=right;j++){\\n                spiralList.add(matrix[top][j]);\\n            }\\n            top++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n            \\n            // 2. print rightmost column\\n            for(int i=top; i <= bottom; i++){\\n                spiralList.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n                \\n            // 3. print bottom row\\n            for(int j=right; j >=left; j--){\\n                spiralList.add(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n                \\n            // 4. print leftmost column\\n            for(int i=bottom; i >= top; i--){\\n                spiralList.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n        }// end while true\\n        \\n        return spiralList;\\n    }\\n    \\n    private boolean boundriesCrossed(int left,int right,int bottom,int top){\\n        if(left>right || bottom<top)\\n            return true;\\n        else\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "        public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> spiralList = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) return spiralList;\\n        \\n        // declare indices\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        \\n        while(true){\\n            // 1. print top row\\n            for(int j=left; j <=right;j++){\\n                spiralList.add(matrix[top][j]);\\n            }\\n            top++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n            \\n            // 2. print rightmost column\\n            for(int i=top; i <= bottom; i++){\\n                spiralList.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n                \\n            // 3. print bottom row\\n            for(int j=right; j >=left; j--){\\n                spiralList.add(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n                \\n            // 4. print leftmost column\\n            for(int i=bottom; i >= top; i--){\\n                spiralList.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n        }// end while true\\n        \\n        return spiralList;\\n    }\\n    \\n    private boolean boundriesCrossed(int left,int right,int bottom,int top){\\n        if(left>right || bottom<top)\\n            return true;\\n        else\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721823,
                "title": "python-dfs-recursion-faster-than-90",
                "content": "This is a simple python recursive code. We use the helper function to recurse through the matrix and append the elements onto the matrix.\\n\\nThe helper has one base conditions - If the row or columns are outside the boundary, or if value = \\'#\\'\\n\\nThen we append the element onto the matrix and set the matrix value to #. We do this to avoid revisiting the nodes.\\n\\nThe if statement controls when the cursor needs to start going right. Else it will recurse in the wrong direction as shown in the image below.\\n\\nFinally, the four recursive statements basically goes all the way right, all the way down, all the way left and all the way up. Given that we are at (row, col), where row is the row index, and col is the column index.\\n\\tmove right: (row, col + 1)\\n\\tmove downwards: (row + 1, col)\\n\\tmove left: (row, col - 1)\\n\\tmove upwards: (row - 1, col)\\n\\n![image](https://assets.leetcode.com/users/images/c41afd0f-2473-4269-9319-4f56c84713af_1643212545.6249688.jpeg)\\n\\nPS: Please go easy on me, I just started problem solving coding a month back. I might be inefficient.\\n\\n\\n```\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = [] \\n        self.helper(matrix,0,0,res)\\n        return res\\n        \\n        \\n    def helper(self,matrix,i,j,res):\\n        if i < 0 or i >= len(matrix) or j < 0 or j>=len(matrix[0]) or matrix[i][j] == \\'#\\':  return\\n        \\n        res.append(matrix[i][j])\\n        matrix[i][j] = \\'#\\'\\n        \\n        #are we going up? - yes? then go till one value greater than i\\n\\t\\t#example -> when we are in the outer boundary of the matrix, i = 0\\n\\t\\t# so go up (use this loop to increment j) until we reach (0,1) or (i, i+1)\\n        if j+1>=i:\\n            self.helper(matrix,i,j+1,res)\\n        self.helper(matrix,i+1,j,res)\\n        self.helper(matrix,i,j-1,res)\\n        self.helper(matrix,i-1,j,res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This is a simple python recursive code. We use the helper function to recurse through the matrix and append the elements onto the matrix.\\n\\nThe helper has one base conditions - If the row or columns are outside the boundary, or if value = \\'#\\'\\n\\nThen we append the element onto the matrix and set the matrix value to #. We do this to avoid revisiting the nodes.\\n\\nThe if statement controls when the cursor needs to start going right. Else it will recurse in the wrong direction as shown in the image below.\\n\\nFinally, the four recursive statements basically goes all the way right, all the way down, all the way left and all the way up. Given that we are at (row, col), where row is the row index, and col is the column index.\\n\\tmove right: (row, col + 1)\\n\\tmove downwards: (row + 1, col)\\n\\tmove left: (row, col - 1)\\n\\tmove upwards: (row - 1, col)\\n\\n![image](https://assets.leetcode.com/users/images/c41afd0f-2473-4269-9319-4f56c84713af_1643212545.6249688.jpeg)\\n\\nPS: Please go easy on me, I just started problem solving coding a month back. I might be inefficient.\\n\\n\\n```\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = [] \\n        self.helper(matrix,0,0,res)\\n        return res\\n        \\n        \\n    def helper(self,matrix,i,j,res):\\n        if i < 0 or i >= len(matrix) or j < 0 or j>=len(matrix[0]) or matrix[i][j] == \\'#\\':  return\\n        \\n        res.append(matrix[i][j])\\n        matrix[i][j] = \\'#\\'\\n        \\n        #are we going up? - yes? then go till one value greater than i\\n\\t\\t#example -> when we are in the outer boundary of the matrix, i = 0\\n\\t\\t# so go up (use this loop to increment j) until we reach (0,1) or (i, i+1)\\n        if j+1>=i:\\n            self.helper(matrix,i,j+1,res)\\n        self.helper(matrix,i+1,j,res)\\n        self.helper(matrix,i,j-1,res)\\n        self.helper(matrix,i-1,j,res)",
                "codeTag": "Python3"
            },
            {
                "id": 3438545,
                "title": "the-most-difficult-solution",
                "content": "# Approach\\nThis is an obfuscated recursive solution, the essence of the challenge was not to use letters and numbers when solving.I spent about 2 hours to solve the problem.\\n> Not all of the code written is required to complete the task, I forgot to remove the capital letters.\\n\\n# Complexity\\n- Time complexity:\\n> Beats ~35% of users in execution speed\\n\\n- Space complexity:\\n> This is very strange, but in terms of memory costs, this solution is better than the solutions of ~93% of users.\\n\\n# Code\\n```\\n_=[\\n    (![]+[])[-~[]],\\n    ({}+[])[-~[]+-~[]],\\n    ({}+[])[-~[]<<-~[]<<-~[]|-~[]],\\n    ([][[]]+[])[-~[]<<-~[]],\\n    ([][[]]+[])[-~[]<<-~[]|-~[]],\\n    (![]+[])[+[]],,,\\n    (-~[]/+[]+[])[-~[]<<-~[]|-~[]],\\n    ({}+[])[-~[]<<-~[]|-~[]],,\\n    (![]+[])[-~[]+-~[]],,\\n    ([][[]]+[])[-~[]],\\n    ({}+[])[-~[]],,,\\n    (!![]+[])[-~[]],\\n    (![]+[])[-~[]<<-~[]|-~[]],\\n    (!![]+[])[+[]],\\n    ([][[]]+[])[+[]],,,,\\n    (-~[]/+[]+[])[(-~[]<<-~[]<<-~[]<<-~[])+~[]]\\n];\\n\\n$_= _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+[]+ +[]]+\\n    _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[-~[]+-~[]+[]+(-~[])] = (\"\"[$_]+[])[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])];\\n\\n_[-~[]+[]+(-~[]+-~[])] = ((+[])[$_]+[])[-~[]+[]+-~[]];\\n\\n_$= _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[+[]]+\\n    _[-~[]+[]+(-~[]+-~[])]+\\n    _[-~[]<<-~[]<<-~[]];\\n\\n\\n_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])] = / /[$_][_$][-~[]+-~[]];\\n_[-~[]+-~[]+[]+(-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]];\\n_[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[(-~[]<<-~[]<<-~[]<<-~[])+~[]] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[])\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]));\\n\\n_[-~[]<<-~[]<<-~[]<<-~[]<<-~[]] = (+(-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))))\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n\\n_[-~[]+-~[]+[]+(-~[]+-~[])] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[])\\n                              [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                              (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n         \\n_[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = (+(-~[]+-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])))\\n                                          [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                          (+(-~[]+-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))));\\n\\n_[-~[]+[]+ +[]] = (+(-~[]+-~[]+[]+(+[])))\\n                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                  (+(-~[]+-~[]+[]+(-~[])));\\n\\n[][$_][$_](\"_$_=_=>\"+\\n    _[-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[+[]]+\"(_)\"\\n)();\\n\\n[][$_][$_](\"$__=_=>\"+/ /[$_][_$]+\"(\\\\\"[^\"+[][$_][_$][+[]]+\"-\"+_$_(_[-~[]+-~[]+-~[]])[+[]]+\"]+\\\\\",\\\\\"\"+_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\"\\\\\")\")();\\n\\n[][$_][$_](\"__$=($_,_$)=>$_+_$_(_$+_$+_$)\")();\\n\\n__$ = [\\n        _[+[]],\\n        _[-~[]],\\n        _[-~[]+-~[]],\\n        _[-~[]+-~[]+-~[]],\\n        _[-~[]<<-~[]<<-~[]],\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])],\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]],\\n        -~[]+[],\\n        (-~[]+-~[])+[],\\n        (-~[]<<-~[]<<-~[])+[],\\n        (-~[]<<-~[]<<-~[]|-~[])+[],\\n        (-~[]<<-~[]<<-~[]<<-~[])+[],\\n        \".\",\"+\",\"-\",\"(\",\"?\"\\n    ][\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+-~[]]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ](__$,\"\");\\n\\n__$=__$[\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+[]+-~[]]+\\n        _[+[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ]($__(),\"\");\\n\\n[][$_][$_](\"$__=_=>\"+\\n    [][$_][_$]+\"[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]+-~[])]\\n    +\"\\\\\"](\"+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[]+-~[])]+\" \"+\\n        \"\"[$_][_$][+[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\"(\\\\\"\"+\\n        __$+[][$_][_$][+[]]\\n    +\"\\\\\"))[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]\\n    +\"\\\\\"]()\"\\n)();\\n\\n__ = $__();\\n\\n[][$_][$_](\"_$_=_=>_[\\\\\"\"+ \\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]+-~[]+[]+(-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n\"\\\\\"]()\")();\\n\\n[][$_][$_](\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[+[]]+\\n    _[-~[]+[]+-~[]]+\\n    {}[$_][_$][+[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    \"=_=($_,_$=[])=>$_[\\\\\"\"+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"]?(_$[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"](...$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"]()),$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](\"+\\n        \"$__$=_=>_$[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+-~[]+[]+ +[]]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n            _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        \"\\\\\"](_[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        \"\\\\\"]())\"\\n    +\"),$_[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n    \"\\\\\"]()[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](_$_), _($_,_$)): _$[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\"\\\\\"]((_)=>_!==\"+[][[]]+\")\"\\n)()\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n_=[\\n    (![]+[])[-~[]],\\n    ({}+[])[-~[]+-~[]],\\n    ({}+[])[-~[]<<-~[]<<-~[]|-~[]],\\n    ([][[]]+[])[-~[]<<-~[]],\\n    ([][[]]+[])[-~[]<<-~[]|-~[]],\\n    (![]+[])[+[]],,,\\n    (-~[]/+[]+[])[-~[]<<-~[]|-~[]],\\n    ({}+[])[-~[]<<-~[]|-~[]],,\\n    (![]+[])[-~[]+-~[]],,\\n    ([][[]]+[])[-~[]],\\n    ({}+[])[-~[]],,,\\n    (!![]+[])[-~[]],\\n    (![]+[])[-~[]<<-~[]|-~[]],\\n    (!![]+[])[+[]],\\n    ([][[]]+[])[+[]],,,,\\n    (-~[]/+[]+[])[(-~[]<<-~[]<<-~[]<<-~[])+~[]]\\n];\\n\\n$_= _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+[]+ +[]]+\\n    _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[-~[]+-~[]+[]+(-~[])] = (\"\"[$_]+[])[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])];\\n\\n_[-~[]+[]+(-~[]+-~[])] = ((+[])[$_]+[])[-~[]+[]+-~[]];\\n\\n_$= _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[+[]]+\\n    _[-~[]+[]+(-~[]+-~[])]+\\n    _[-~[]<<-~[]<<-~[]];\\n\\n\\n_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])] = / /[$_][_$][-~[]+-~[]];\\n_[-~[]+-~[]+[]+(-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]];\\n_[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[(-~[]<<-~[]<<-~[]<<-~[])+~[]] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[])\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]));\\n\\n_[-~[]<<-~[]<<-~[]<<-~[]<<-~[]] = (+(-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))))\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n\\n_[-~[]+-~[]+[]+(-~[]+-~[])] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[])\\n                              [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                              (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n         \\n_[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = (+(-~[]+-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])))\\n                                          [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                          (+(-~[]+-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))));\\n\\n_[-~[]+[]+ +[]] = (+(-~[]+-~[]+[]+(+[])))\\n                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                  (+(-~[]+-~[]+[]+(-~[])));\\n\\n[][$_][$_](\"_$_=_=>\"+\\n    _[-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[+[]]+\"(_)\"\\n)();\\n\\n[][$_][$_](\"$__=_=>\"+/ /[$_][_$]+\"(\\\\\"[^\"+[][$_][_$][+[]]+\"-\"+_$_(_[-~[]+-~[]+-~[]])[+[]]+\"]+\\\\\",\\\\\"\"+_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\"\\\\\")\")();\\n\\n[][$_][$_](\"__$=($_,_$)=>$_+_$_(_$+_$+_$)\")();\\n\\n__$ = [\\n        _[+[]],\\n        _[-~[]],\\n        _[-~[]+-~[]],\\n        _[-~[]+-~[]+-~[]],\\n        _[-~[]<<-~[]<<-~[]],\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])],\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]],\\n        -~[]+[],\\n        (-~[]+-~[])+[],\\n        (-~[]<<-~[]<<-~[])+[],\\n        (-~[]<<-~[]<<-~[]|-~[])+[],\\n        (-~[]<<-~[]<<-~[]<<-~[])+[],\\n        \".\",\"+\",\"-\",\"(\",\"?\"\\n    ][\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+-~[]]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ](__$,\"\");\\n\\n__$=__$[\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+[]+-~[]]+\\n        _[+[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ]($__(),\"\");\\n\\n[][$_][$_](\"$__=_=>\"+\\n    [][$_][_$]+\"[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]+-~[])]\\n    +\"\\\\\"](\"+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[]+-~[])]+\" \"+\\n        \"\"[$_][_$][+[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\"(\\\\\"\"+\\n        __$+[][$_][_$][+[]]\\n    +\"\\\\\"))[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]\\n    +\"\\\\\"]()\"\\n)();\\n\\n__ = $__();\\n\\n[][$_][$_](\"_$_=_=>_[\\\\\"\"+ \\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]+-~[]+[]+(-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n\"\\\\\"]()\")();\\n\\n[][$_][$_](\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[+[]]+\\n    _[-~[]+[]+-~[]]+\\n    {}[$_][_$][+[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    \"=_=($_,_$=[])=>$_[\\\\\"\"+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"]?(_$[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"](...$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"]()),$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](\"+\\n        \"$__$=_=>_$[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+-~[]+[]+ +[]]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n            _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        \"\\\\\"](_[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        \"\\\\\"]())\"\\n    +\"),$_[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n    \"\\\\\"]()[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](_$_), _($_,_$)): _$[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\"\\\\\"]((_)=>_!==\"+[][[]]+\")\"\\n)()\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 716854,
                "title": "c-best-solution-easy-and-short-logic-100-3",
                "content": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL); \\n         vector<int>ret;\\n        int m=matrix.size();   \\n          if(m==0)\\n            return ret;\\n        int n=matrix[0].size();  \\n        vector<int>res(m*n);  \\n        int r=0,c=0,cnt=0; \\n        while(r<m && c<n)\\n        {\\n            for(int i=c;i<n;i++)\\n                res[cnt++]=matrix[r][i];\\n            r++;\\n            for(int j=r;j<m;j++)\\n                res[cnt++]=matrix[j][n-1]; \\n            n--; \\n            if(r<m)\\n            {\\n                for(int i=n-1;i>=c;i--)\\n                    res[cnt++]=matrix[m-1][i];\\n                m--; \\n            }\\n              if(c<n)\\n              {\\n                  for(int j=m-1;j>=r;j--)\\n                      res[cnt++]=matrix[j][c]; \\n                  c++;\\n              }\\n        } \\n        return res;\\n    } \\n\\t``` \\n\\tIf you like my solution please Upvote.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL); \\n         vector<int>ret;\\n        int m=matrix.size();   \\n          if(m==0)\\n            return ret;\\n        int n=matrix[0].size();  \\n        vector<int>res(m*n);  \\n        int r=0,c=0,cnt=0; \\n        while(r<m && c<n)\\n        {\\n            for(int i=c;i<n;i++)\\n                res[cnt++]=matrix[r][i];\\n            r++;\\n            for(int j=r;j<m;j++)\\n                res[cnt++]=matrix[j][n-1]; \\n            n--; \\n            if(r<m)\\n            {\\n                for(int i=n-1;i>=c;i--)\\n                    res[cnt++]=matrix[m-1][i];\\n                m--; \\n            }\\n              if(c<n)\\n              {\\n                  for(int j=m-1;j>=r;j--)\\n                      res[cnt++]=matrix[j][c]; \\n                  c++;\\n              }\\n        } \\n        return res;\\n    } \\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 517536,
                "title": "simple-java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    List<Integer> res;\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return new ArrayList<>();\\n        \\n        visited = new boolean[matrix.length][matrix[0].length];\\n        res = new ArrayList<>();\\n        dfs(0, 0, matrix, false);\\n        return res;\\n    }\\n    \\n    public void dfs(int y, int x, int[][] matrix, boolean goingUp) {\\n        if(y < 0 || y >= matrix.length || x < 0 || x >= matrix[y].length || visited[y][x]) return;\\n        res.add(matrix[y][x]);\\n        visited[y][x] = true;\\n        \\n        if(goingUp) {\\n            dfs(y - 1, x, matrix, true);\\n        }\\n        \\n        dfs(y, x + 1, matrix, false);\\n        dfs(y + 1, x, matrix, false);\\n        dfs(y, x - 1, matrix, false);\\n        dfs(y - 1, x, matrix, true);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    List<Integer> res;\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return new ArrayList<>();\\n        \\n        visited = new boolean[matrix.length][matrix[0].length];\\n        res = new ArrayList<>();\\n        dfs(0, 0, matrix, false);\\n        return res;\\n    }\\n    \\n    public void dfs(int y, int x, int[][] matrix, boolean goingUp) {\\n        if(y < 0 || y >= matrix.length || x < 0 || x >= matrix[y].length || visited[y][x]) return;\\n        res.add(matrix[y][x]);\\n        visited[y][x] = true;\\n        \\n        if(goingUp) {\\n            dfs(y - 1, x, matrix, true);\\n        }\\n        \\n        dfs(y, x + 1, matrix, false);\\n        dfs(y + 1, x, matrix, false);\\n        dfs(y, x - 1, matrix, false);\\n        dfs(y - 1, x, matrix, true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502927,
                "title": "c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn",
                "content": "> Note: These solutions are different from other brute force with 4 for loops. I have tried to do it in single for loop without modifying the input marking visited. Follow the images to understand.\\n\\n# Intuition\\n\\n## Hint 1\\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\\nIt\\'s all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\\n\\n## Hint 2\\n![image.png](https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png)\\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\\n\\n## Hint 3\\nLet $[r,c]$ be the current cell and the next cell is given as $[r\\',c\\'] = [r + dr, c + dc]$.\\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\\n| Index | Direction | $dr$ | $dc$ |\\n| :-- | :-- | :--: | :--: |\\n| 0 | Right | 0 | 1 |\\n| 1 | Down | 1 | 0 |\\n| 2 | Left | 0 | -1 |\\n| 3 | Up | -1 | 0 |\\n\\nChange in direction of traversal is $Right \\\\rightarrow Down \\\\rightarrow Left \\\\rightarrow Up \\\\rightarrow ...$\\n\\n## Hint 4\\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - I (Recursion) [Accepted]***\\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \\n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\\n\\n`total` is the area of one spiral, `total = area of outer rectangle - area of inner rectangle (if it exists)`.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    vector<int> result;\\n\\n    void spiral(vector<vector<int>>& matrix, int r1, int r2, int c1, int c2) {\\n        int r12 = r2 - r1 + 1, c12 = c2 - c1 + 1;\\n        if (r12 <= 0 || c12 <= 0) {\\n            return;\\n        }\\n        int total = r12 * c12, dir = 0;\\n        if (r12 > 2 && c12 > 2) { // if inner rectangle exists\\n            total -= (r12 - 2) * (c12 - 2);\\n        }\\n        vector<int> curr = {r1, c1}; // curr = {r, c}\\n        vector<vector<int>> limit = {{r1, c2}, {r2, c2}, {r2, c1}, {r1 + 1, c1}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // dcurr = {dr, dc}\\n        for (int j = 0; j < total; j++) {\\n            result.push_back(matrix[curr[0]][curr[1]]);\\n            if (curr == limit[dir]) { // change direction\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]}; // next cell\\n        }\\n        spiral(matrix, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        spiral(matrix, 0, matrix.size() - 1, 0, matrix[0].size() - 1);\\n        return result;\\n    }\\n};\\n```\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - II (Iteration) [Accepted]***\\nWell, if you don\\'t want to use recursion, everything was alright for one spiral above. But for next spiral, boundaries will change. Can we calculate how will they change?\\n\\nTake the matrix from Hint 4\\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\\n\\nThe new sub-matrix and next spiral\\'s boundaries will be\\n![image.png](https://assets.leetcode.com/users/images/e054d689-e8fc-424a-8272-62876a53e5fa_1683605169.4419448.png)\\n\\nNotice how the boundaries changed?\\n![image.png](https://assets.leetcode.com/users/images/1a51b53c-f22b-4a83-b86e-810e927bd4dd_1683605580.8317032.png)\\n\\nBoundaries change as\\n\\n| Index | Direction | Boundary | Change | New Boundary |\\n| :-- | :-- | :-- | :-- | :-- |\\n| 0 | Right | $[0,n-1]$ | $[1,-1]$ | $[1,n-2]$ |\\n| 1 | Down | $[m-1,n-1]$ | $[-1,-1]$ | $[m-2,n-2]$ |\\n| 2 | Left | $[m-1,0]$ | $[-1,1]$ | $[m-2,1]$ |\\n| 3 | Up | $[1,0]$ | $[1,1]$ | $[2,1]$ |\\n\\nNow these changes are constant. That is why it is a spiral.\\n![image.png](https://assets.leetcode.com/users/images/63891d0f-cedd-44df-9366-04e1b9c7812c_1683607300.7183905.png)\\n\\nBoundaries change by $[[1,-1], [-1,-1], [-1,1], [1,1]]$\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), dir = 0; // direction\\n        vector<int> result(m * n), curr = {0, 0}; // {r, c}\\n        vector<vector<int>> limit = {{0, n - 1}, {m - 1, n - 1}, {m - 1, 0}, {1, 0}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, // {dr, dc}\\n        dLimit = {{1, -1}, {-1, -1}, {-1, 1}, {1, 1}}; // change in boundaries\\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[curr[0]][curr[1]];\\n            if (curr == limit[dir]) { // change direction\\n                limit[dir] = {limit[dir][0] + dLimit[dir][0], limit[dir][1] + dLimit[dir][1]}; // change boundary\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]};\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n---\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n---\\n\\nFor any mistakes / suggestions / questions, please do comment below \\uD83D\\uDC47\\nUpvote if helps!",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> result;\\n\\n    void spiral(vector<vector<int>>& matrix, int r1, int r2, int c1, int c2) {\\n        int r12 = r2 - r1 + 1, c12 = c2 - c1 + 1;\\n        if (r12 <= 0 || c12 <= 0) {\\n            return;\\n        }\\n        int total = r12 * c12, dir = 0;\\n        if (r12 > 2 && c12 > 2) { // if inner rectangle exists\\n            total -= (r12 - 2) * (c12 - 2);\\n        }\\n        vector<int> curr = {r1, c1}; // curr = {r, c}\\n        vector<vector<int>> limit = {{r1, c2}, {r2, c2}, {r2, c1}, {r1 + 1, c1}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // dcurr = {dr, dc}\\n        for (int j = 0; j < total; j++) {\\n            result.push_back(matrix[curr[0]][curr[1]]);\\n            if (curr == limit[dir]) { // change direction\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]}; // next cell\\n        }\\n        spiral(matrix, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        spiral(matrix, 0, matrix.size() - 1, 0, matrix[0].size() - 1);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), dir = 0; // direction\\n        vector<int> result(m * n), curr = {0, 0}; // {r, c}\\n        vector<vector<int>> limit = {{0, n - 1}, {m - 1, n - 1}, {m - 1, 0}, {1, 0}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, // {dr, dc}\\n        dLimit = {{1, -1}, {-1, -1}, {-1, 1}, {1, 1}}; // change in boundaries\\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[curr[0]][curr[1]];\\n            if (curr == limit[dir]) { // change direction\\n                limit[dir] = {limit[dir][0] + dLimit[dir][0], limit[dir][1] + dLimit[dir][1]}; // change boundary\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]};\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226384,
                "title": "1-approach-for-your-interview",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    \\n         \\n    let r = matrix.length, c=matrix[0].length;\\n    let [left, right, top, bottom] = [0, c-1, 0, r-1];\\n\\n    let arr = [];\\n\\n    while(left<=right && top <= bottom){\\n        for(let i=left; i<=right; i++) arr.push(matrix[top][i])\\n        top++;\\n\\n\\n        for(let i=top; i<=bottom; i++) arr.push(matrix[i][right])\\n        right--;\\n\\n\\n        if(top<=bottom){               // condition 1\\n            for(let i=right; i>=left; i--) arr.push(matrix[bottom][i])\\n            bottom--;\\n        }\\n      \\n\\n        if(left<=right){               // condition 2\\n            for(let i=bottom; i>=top; i--) arr.push(matrix[i][left])\\n            left++;\\n        }\\n      \\n        \\n\\n    }\\n\\n\\n    return arr\\n\\n};\\n```\\n\\n\\ncondition 1 and condition2 will look suspecious/confusing to you, if you dont dry run.\\ndo dry run, and understand !",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    \\n         \\n    let r = matrix.length, c=matrix[0].length;\\n    let [left, right, top, bottom] = [0, c-1, 0, r-1];\\n\\n    let arr = [];\\n\\n    while(left<=right && top <= bottom){\\n        for(let i=left; i<=right; i++) arr.push(matrix[top][i])\\n        top++;\\n\\n\\n        for(let i=top; i<=bottom; i++) arr.push(matrix[i][right])\\n        right--;\\n\\n\\n        if(top<=bottom){               // condition 1\\n            for(let i=right; i>=left; i--) arr.push(matrix[bottom][i])\\n            bottom--;\\n        }\\n      \\n\\n        if(left<=right){               // condition 2\\n            for(let i=bottom; i>=top; i--) arr.push(matrix[i][left])\\n            left++;\\n        }\\n      \\n        \\n\\n    }\\n\\n\\n    return arr\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20793,
                "title": "7-lines-recursive-python-solution-5-lines-solution-w-o-recursion",
                "content": "(1). Initial\\n\\n>1, 2, 3\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(2). The first row, [1, 2, 3], is used\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(3). Rotate the rest into:\\n\\n>6, 9\\n\\n>5, 8\\n\\n> 4, 7\\n\\n(4). Use the first row after rotation. Got [1, 2, 3, 6, 9, ... ] and just keep going !\\n\\n    def spiralOrder(self, matrix):\\n\\n        result = []\\n\\n        def helper(mat):\\n            if mat:\\n                result.extend(mat[0])\\n                helper(self.rotate_counter(mat[1:]))\\n\\n        helper(matrix)\\n        return result\\n\\n    def rotate_counter(self, mat):\\n        return zip(*mat)[::-1]\\n\\np.s. I isolate the rotation function for readability.                 \\np.s. fixed the redundancy & added a while-loop version under the suggestion of StefanPochmann\\n\\n    def spiralOrder(self, matrix):    #a while-loop version\\n\\n        result = []\\n\\n        while matrix:\\n            result.extend(matrix.pop(0))\\n            matrix = zip(*matrix)[::-1]    #rotate the remaining matrix counter-clockwise\\n            \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "(1). Initial\\n\\n>1, 2, 3\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(2). The first row, [1, 2, 3], is used\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(3). Rotate the rest into:\\n\\n>6, 9\\n\\n>5, 8\\n\\n> 4, 7\\n\\n(4). Use the first row after rotation. Got [1, 2, 3, 6, 9, ... ] and just keep going !\\n\\n    def spiralOrder(self, matrix):\\n\\n        result = []\\n\\n        def helper(mat):\\n            if mat:\\n                result.extend(mat[0])\\n                helper(self.rotate_counter(mat[1:]))\\n\\n        helper(matrix)\\n        return result\\n\\n    def rotate_counter(self, mat):\\n        return zip(*mat)[::-1]\\n\\np.s. I isolate the rotation function for readability.                 \\np.s. fixed the redundancy & added a while-loop version under the suggestion of StefanPochmann\\n\\n    def spiralOrder(self, matrix):    #a while-loop version\\n\\n        result = []\\n\\n        while matrix:\\n            result.extend(matrix.pop(0))\\n            matrix = zip(*matrix)[::-1]    #rotate the remaining matrix counter-clockwise\\n            \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3173516,
                "title": "best-c-solution-ever-matrix-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simply solve this question using matrix. We will traverse the whole matrix spirally and store the output and return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are visiting every element of the matrix ones which creates the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are\\n    visiting every element of the matrix ones which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, \\n    however the output does not count towards the space complexity.\\n\\n    Solved using Matrix.    \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int numberOfRows = matrix.size();\\n        int numberOfColumns = matrix[0].size();\\n        int totalElements = numberOfRows * numberOfColumns;\\n        int rowStart = 0;\\n        int colStart = 0;\\n        int rowEnd = numberOfRows-1;\\n        int colEnd = numberOfColumns-1;\\n        vector<int> ans;\\n        int count = 0;\\n        while(count < totalElements){\\n            for(int i=colStart; i<=colEnd && count < totalElements; i++){\\n                ans.push_back(matrix[rowStart][i]);\\n                count++;\\n            }\\n            rowStart++; \\n            for(int i=rowStart; i<=rowEnd && count < totalElements; i++){\\n                ans.push_back(matrix[i][colEnd]);\\n                count++;\\n            }\\n            colEnd--;\\n            for(int i=colEnd; i>=colStart && count < totalElements; i--){\\n                ans.push_back(matrix[rowEnd][i]);\\n                count++;\\n            }\\n            rowEnd--;\\n            for(int i=rowEnd; i>=rowStart && count < totalElements; i--){\\n                ans.push_back(matrix[i][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n###### ***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are\\n    visiting every element of the matrix ones which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, \\n    however the output does not count towards the space complexity.\\n\\n    Solved using Matrix.    \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int numberOfRows = matrix.size();\\n        int numberOfColumns = matrix[0].size();\\n        int totalElements = numberOfRows * numberOfColumns;\\n        int rowStart = 0;\\n        int colStart = 0;\\n        int rowEnd = numberOfRows-1;\\n        int colEnd = numberOfColumns-1;\\n        vector<int> ans;\\n        int count = 0;\\n        while(count < totalElements){\\n            for(int i=colStart; i<=colEnd && count < totalElements; i++){\\n                ans.push_back(matrix[rowStart][i]);\\n                count++;\\n            }\\n            rowStart++; \\n            for(int i=rowStart; i<=rowEnd && count < totalElements; i++){\\n                ans.push_back(matrix[i][colEnd]);\\n                count++;\\n            }\\n            colEnd--;\\n            for(int i=colEnd; i>=colStart && count < totalElements; i--){\\n                ans.push_back(matrix[rowEnd][i]);\\n                count++;\\n            }\\n            rowEnd--;\\n            for(int i=rowEnd; i>=rowStart && count < totalElements; i--){\\n                ans.push_back(matrix[i][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930808,
                "title": "easiest-programmer-friendly-code-with-comments-intution-and-complexity-analysis",
                "content": "**Intution:**\\n->Create an empty list to store the answer.\\n->Remove **Top Row** from matrix and insert into answer list.\\n->Remove **Rightmost Column** from matrix and insert into answer list.\\n->Remove **Bottom Row** from matrix and insert into answer list (in reverse order as sprial is expected to go from right to left in bottom-most row).\\n->Remove **Leftmost Column** from matrix and insert into answers list (In reverse order, as the spiral is expected to go from bottom to top in left-most row).\\n->Repeat this process unless the length of matrix becomes 0.\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n x m)\\nSpace complexity:\\nO( n x m)\\n\\n(*where m is number of rows and n is number of columns*)\\n\\n**Code:**\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ans=[]\\n        while len(matrix): #Process would be repeated unless the length of matrix becomes zero.\\n            try: # Exception handling, in case the pop operation on empty matrix is performed.\\n                ans+=matrix.pop(0) #Removing Top Row from matrix and inserting into answer list.\\n                ans+=[i.pop() for i in matrix] #Removing Rightmost Column from matrix and inserting into answer list.\\n                ans+=matrix.pop()[::-1] #Removing Bottom Row from matrix and inserting into answer list in reverse order.\\n                ans+=[i.pop(0) for i in matrix][::-1] #Removing Leftmost Column from matrix and inserting into answers list in reverse order.\\n            except:\\n                break\\n        return ans\\n```\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ans=[]\\n        while len(matrix): #Process would be repeated unless the length of matrix becomes zero.\\n            try: # Exception handling, in case the pop operation on empty matrix is performed.\\n                ans+=matrix.pop(0) #Removing Top Row from matrix and inserting into answer list.\\n                ans+=[i.pop() for i in matrix] #Removing Rightmost Column from matrix and inserting into answer list.\\n                ans+=matrix.pop()[::-1] #Removing Bottom Row from matrix and inserting into answer list in reverse order.\\n                ans+=[i.pop(0) for i in matrix][::-1] #Removing Leftmost Column from matrix and inserting into answers list in reverse order.\\n            except:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672856,
                "title": "c-solution-using-4-pointers-with-explanations-time-complexity-o-n-2",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we have to do 4 types of traversal to get the spiral matrix.\\n    1. First row from left to right.\\n    2. Last column from top to down.\\n    3. Last row from right to left.\\n    4. First column from down to top.\\n- We will take 4 pointers: ***top, down, left, right*** & 1 counter ***count*** to select the traversal type.\\n    - If ***count=0,*** we will traverse a row from left to right & increase count value.\\n    - If ***count=1,*** we will traverse a column from top to down & increase count value.\\n    - If ***count=2,*** we will traverse a row from right to left & increase count value.\\n    - If ***count=3,*** we will traverse a column from down to top & will make ***count=0*** to repeat the traversal again.\\n- We\\u2019ll repeat the process until ***top<=down && left<=right.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int n= matrix[0].size(), m= matrix.size();\\n        \\n        int top=0,down=m-1,left=0,right=n-1, count=0;\\n        \\n        while(top<=down && left<=right){\\n            if(count==0){\\n                for(int i=left; i<=right; i++)\\n                    ans.push_back(matrix[top][i]);\\n                top++; count++;\\n            }\\n            else if(count==1){\\n                for(int i=top; i<=down; i++)\\n                    ans.push_back(matrix[i][right]);\\n                right--; count++;\\n            }\\n            else if(count==2){\\n                for(int i=right; i>=left; i--)\\n                    ans.push_back(matrix[down][i]);\\n                down--; count++;\\n            }\\n            else if(count==3){\\n                for(int i=down; i>=top; i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++; count=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int n= matrix[0].size(), m= matrix.size();\\n        \\n        int top=0,down=m-1,left=0,right=n-1, count=0;\\n        \\n        while(top<=down && left<=right){\\n            if(count==0){\\n                for(int i=left; i<=right; i++)\\n                    ans.push_back(matrix[top][i]);\\n                top++; count++;\\n            }\\n            else if(count==1){\\n                for(int i=top; i<=down; i++)\\n                    ans.push_back(matrix[i][right]);\\n                right--; count++;\\n            }\\n            else if(count==2){\\n                for(int i=right; i>=left; i--)\\n                    ans.push_back(matrix[down][i]);\\n                down--; count++;\\n            }\\n            else if(count==3){\\n                for(int i=down; i>=top; i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++; count=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271889,
                "title": "c-four-pointer-solution-o-n-easy-to-understand",
                "content": "Using \\n1) Four variables : top, bottom, right, and left.\\n2) Direction : 0,1, 2, 3\\n\\t0 -  left to right\\n\\t1 - top to bottom\\n\\t2 - right to left\\n\\t3 - bottom to top\\n\\n![image](https://assets.leetcode.com/users/images/d537f740-bab3-4274-b94f-9efbe33798c6_1623671124.918477.png)\\n\\nTime Complexity : O(n)\\n\\n\\n```\\n\\n     vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> spiral; // to store the resulting array\\n\\t\\t\\n\\t\\t//initializing top, bottom, left and right\\n        int top = 0;\\n        int bottom = matrix.size() - 1;\\n        int left = 0;\\n        int right = matrix[0].size() - 1;\\n\\t\\t\\n\\t\\t//initializing direction\\n        int direction = 0; \\n\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(direction == 0){\\n\\t\\t\\t\\t//left -> right\\n                for(int i = left; i <= right; i++){\\n                    spiral.push_back(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            else if(direction == 1){\\n\\t\\t\\t\\t//top -> bottom\\n                for(int i = top; i <= bottom; i++){\\n                    spiral.push_back(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            else if(direction == 2){\\n\\t\\t\\t\\t//right -> left\\n                for(int i = right; i >= left; i--){\\n                    spiral.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            else if(direction == 3){\\n\\t\\t\\t\\t//bottom -> top\\n                for(int i = bottom; i >= top; i--){\\n                    spiral.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//increment the value of direction\\n            direction = (direction + 1) % 4;\\n\\n\\n        }\\n\\n        return spiral;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n\\n     vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> spiral; // to store the resulting array\\n\\t\\t\\n\\t\\t//initializing top, bottom, left and right\\n        int top = 0;\\n        int bottom = matrix.size() - 1;\\n        int left = 0;\\n        int right = matrix[0].size() - 1;\\n\\t\\t\\n\\t\\t//initializing direction\\n        int direction = 0; \\n\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(direction == 0){\\n\\t\\t\\t\\t//left -> right\\n                for(int i = left; i <= right; i++){\\n                    spiral.push_back(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            else if(direction == 1){\\n\\t\\t\\t\\t//top -> bottom\\n                for(int i = top; i <= bottom; i++){\\n                    spiral.push_back(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            else if(direction == 2){\\n\\t\\t\\t\\t//right -> left\\n                for(int i = right; i >= left; i--){\\n                    spiral.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            else if(direction == 3){\\n\\t\\t\\t\\t//bottom -> top\\n                for(int i = bottom; i >= top; i--){\\n                    spiral.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//increment the value of direction\\n            direction = (direction + 1) % 4;\\n\\n\\n        }\\n\\n        return spiral;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329836,
                "title": "go-solution-tc-o-m-n",
                "content": "```go\\nfunc spiralOrder(matrix [][]int) []int {\\n\\tif matrix == nil || len(matrix) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tresult := make([]int, 0)\\n\\ttop, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1\\n\\n\\tfor {\\n\\t\\t// right\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tresult = append(result, matrix[top][i])\\n\\t\\t}\\n\\t\\ttop++\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// down\\n\\t\\tfor i := top; i <= bottom; i++ {\\n\\t\\t\\tresult = append(result, matrix[i][right])\\n\\t\\t}\\n\\t\\tright--\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// left\\n\\t\\tfor i := right; i >= left; i-- {\\n\\t\\t\\tresult = append(result, matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom--\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// up\\n\\t\\tfor i := bottom; i >= top; i-- {\\n\\t\\t\\tresult = append(result, matrix[i][left])\\n\\t\\t}\\n\\t\\tleft++\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go",
                    "Matrix"
                ],
                "code": "```go\\nfunc spiralOrder(matrix [][]int) []int {\\n\\tif matrix == nil || len(matrix) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tresult := make([]int, 0)\\n\\ttop, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1\\n\\n\\tfor {\\n\\t\\t// right\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tresult = append(result, matrix[top][i])\\n\\t\\t}\\n\\t\\ttop++\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// down\\n\\t\\tfor i := top; i <= bottom; i++ {\\n\\t\\t\\tresult = append(result, matrix[i][right])\\n\\t\\t}\\n\\t\\tright--\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// left\\n\\t\\tfor i := right; i >= left; i-- {\\n\\t\\t\\tresult = append(result, matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom--\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// up\\n\\t\\tfor i := bottom; i >= top; i-- {\\n\\t\\t\\tresult = append(result, matrix[i][left])\\n\\t\\t}\\n\\t\\tleft++\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146248,
                "title": "javascript-solution",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    var spiralArray = [];\\n    if (matrix.length === 0) {\\n        return spiralArray;\\n    }\\n    var rowBegin = 0;\\n    var rowEnd = matrix.length - 1;\\n    var colBegin = 0;\\n    var colEnd = matrix[0].length - 1;\\n    \\n    while (colBegin <= colEnd && rowBegin <= rowEnd) {\\n        for (var i = colBegin; i <= colEnd; i++) {\\n            spiralArray.push(matrix[rowBegin][i]);\\n        }\\n        rowBegin++;\\n        for (var i = rowBegin; i <= rowEnd; i++) {\\n            spiralArray.push(matrix[i][colEnd]);\\n        }\\n        colEnd--;\\n        if (rowBegin <= rowEnd) {\\n            for (var i = colEnd; i >= colBegin; i --) {\\n                spiralArray.push(matrix[rowEnd][i]);\\n            }\\n        }\\n        rowEnd--;\\n        if (colBegin <= colEnd) {\\n            for (var i = rowEnd; i >= rowBegin; i--) {\\n                spiralArray.push(matrix[i][colBegin]);\\n            }\\n        }\\n        colBegin++;\\n    }\\n    return spiralArray;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    var spiralArray = [];\\n    if (matrix.length === 0) {\\n        return spiralArray;\\n    }\\n    var rowBegin = 0;\\n    var rowEnd = matrix.length - 1;\\n    var colBegin = 0;\\n    var colEnd = matrix[0].length - 1;\\n    \\n    while (colBegin <= colEnd && rowBegin <= rowEnd) {\\n        for (var i = colBegin; i <= colEnd; i++) {\\n            spiralArray.push(matrix[rowBegin][i]);\\n        }\\n        rowBegin++;\\n        for (var i = rowBegin; i <= rowEnd; i++) {\\n            spiralArray.push(matrix[i][colEnd]);\\n        }\\n        colEnd--;\\n        if (rowBegin <= rowEnd) {\\n            for (var i = colEnd; i >= colBegin; i --) {\\n                spiralArray.push(matrix[rowEnd][i]);\\n            }\\n        }\\n        rowEnd--;\\n        if (colBegin <= colEnd) {\\n            for (var i = rowEnd; i >= rowBegin; i--) {\\n                spiralArray.push(matrix[i][colBegin]);\\n            }\\n        }\\n        colBegin++;\\n    }\\n    return spiralArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20874,
                "title": "an-easy-to-understand-solution",
                "content": "This solution use a most left up point and a most right bottom point to act as limiters, and traverse around directly. I think it's quite easy to understand.\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        if (matrix == null) return list;\\n        int m = matrix.length;\\n        if (m == 0) return list;\\n        int n = matrix[0].length;\\n        int x0 = 0, y0 = 0; // most left up point\\n        int x1 = m-1, y1 = n-1; // most right bottom point\\n        int x = 0, y = 0;\\n        while(x0 < x1 && y0 < y1) {\\n            x = x0; // after one loop, (x, y) goes back to original position, must set them 'forward'\\n            y = y0;\\n            // traverse around\\n            while (y < y1) list.add(matrix[x][y++]);\\n            while (x < x1) list.add(matrix[x++][y]);\\n            while (y > y0) list.add(matrix[x][y--]);\\n            while (x > x0) list.add(matrix[x--][y]);\\n            // move limiters to center\\n            x0++; \\n            y0++;\\n            x1--;\\n            y1--;\\n        }\\n        x = x0;\\n        y = y0;\\n        // deal with one row or col left case\\n        if (x0 == x1 && y0 <= y1) {\\n            while (y <= y1) list.add(matrix[x][y++]);\\n        } else if (y0 == y1 && x0 <= x1) {\\n            while (x <= x1) list.add(matrix[x++][y]);\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "This solution use a most left up point and a most right bottom point to act as limiters, and traverse around directly. I think it's quite easy to understand.\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        if (matrix == null) return list;\\n        int m = matrix.length;\\n        if (m == 0) return list;\\n        int n = matrix[0].length;\\n        int x0 = 0, y0 = 0; // most left up point\\n        int x1 = m-1, y1 = n-1; // most right bottom point\\n        int x = 0, y = 0;\\n        while(x0 < x1 && y0 < y1) {\\n            x = x0; // after one loop, (x, y) goes back to original position, must set them 'forward'\\n            y = y0;\\n            // traverse around\\n            while (y < y1) list.add(matrix[x][y++]);\\n            while (x < x1) list.add(matrix[x++][y]);\\n            while (y > y0) list.add(matrix[x][y--]);\\n            while (x > x0) list.add(matrix[x--][y]);\\n            // move limiters to center\\n            x0++; \\n            y0++;\\n            x1--;\\n            y1--;\\n        }\\n        x = x0;\\n        y = y0;\\n        // deal with one row or col left case\\n        if (x0 == x1 && y0 <= y1) {\\n            while (y <= y1) list.add(matrix[x][y++]);\\n        } else if (y0 == y1 && x0 <= x1) {\\n            while (x <= x1) list.add(matrix[x++][y]);\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3502677,
                "title": "explained-with-images-simple-traversal",
                "content": "![image](https://assets.leetcode.com/users/images/f9e648a8-69ec-46c2-9915-559359fb3ab1_1683593610.2674944.jpeg)\\n![image](https://assets.leetcode.com/users/images/11ff19f5-dd6c-42d9-b8a4-77dbfcd5b17a_1683593602.4515886.jpeg)\\n\\n## CODE\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int lowRow = 0, highRow = m - 1;\\n        int lowCol = 0, highCol = n - 1;\\n        int i, j;\\n        vector<int>ans;\\n        while(lowRow <= highRow && lowCol <= highCol)\\n        {\\n            //===================================================================\\n            //TOP-LEFT to TOP-RIGHT\\n            i = lowRow; j = lowCol;\\n            while(j <= highCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j++;\\n            }\\n            lowRow++; //increment the lowRow, we will not use it now\\n            //===================================================================\\n            //TOP-RIGHT to BOTTOM-RIGHT\\n            j = highCol; i = lowRow;\\n            while(i <= highRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i++;\\n            }\\n            highCol--; //decrement the highCol, we will not use it now\\n            //====================================================================\\n            //BOTTOM-RIGHT to BOTTOM-LEFT\\n            //WE COULD EVEN VANISH THE MATRIX IN MIDWAY\\n            if (lowRow > highRow || lowCol > highCol) break;  //***IMPORTANT*****\\n            i = highRow; j = highCol;\\n            while(j >= lowCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j--;\\n            }\\n            highRow--; //decrement the highRow, we will not use it now\\n            //=====================================================================\\n            //BOTTOM-LEFT to TOP-LEFT\\n            j = lowCol; i = highRow;\\n            while(i >= lowRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i--;\\n            }\\n            lowCol++; //decrement the lowCol, we will not use it now\\n            //=========================================================================\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int lowRow = 0, highRow = m - 1;\\n        int lowCol = 0, highCol = n - 1;\\n        int i, j;\\n        vector<int>ans;\\n        while(lowRow <= highRow && lowCol <= highCol)\\n        {\\n            //===================================================================\\n            //TOP-LEFT to TOP-RIGHT\\n            i = lowRow; j = lowCol;\\n            while(j <= highCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j++;\\n            }\\n            lowRow++; //increment the lowRow, we will not use it now\\n            //===================================================================\\n            //TOP-RIGHT to BOTTOM-RIGHT\\n            j = highCol; i = lowRow;\\n            while(i <= highRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i++;\\n            }\\n            highCol--; //decrement the highCol, we will not use it now\\n            //====================================================================\\n            //BOTTOM-RIGHT to BOTTOM-LEFT\\n            //WE COULD EVEN VANISH THE MATRIX IN MIDWAY\\n            if (lowRow > highRow || lowCol > highCol) break;  //***IMPORTANT*****\\n            i = highRow; j = highCol;\\n            while(j >= lowCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j--;\\n            }\\n            highRow--; //decrement the highRow, we will not use it now\\n            //=====================================================================\\n            //BOTTOM-LEFT to TOP-LEFT\\n            j = lowCol; i = highRow;\\n            while(i >= lowRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i--;\\n            }\\n            lowCol++; //decrement the lowCol, we will not use it now\\n            //=========================================================================\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738729,
                "title": "solution-swift-spiral-matrix-test-cases",
                "content": "```swift\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        guard !(matrix.isEmpty) else { return [] }\\n        \\n        var result: [Int] = []\\n        var rBegin = 0, rEnd = matrix.count - 1\\n        var cBegin = 0, cEnd = matrix[0].count - 1\\n        \\n        while rBegin <= rEnd && cBegin <= cEnd {\\n            // Traverse right\\n            for i in stride(from: cBegin, to: cEnd + 1, by: 1) {\\n                result.append(matrix[rBegin][i])\\n            }\\n            rBegin += 1\\n            \\n            // Traverse down\\n            for i in stride(from: rBegin, to: rEnd + 1, by: 1) {\\n                result.append(matrix[i][cEnd])\\n            }\\n            cEnd -= 1\\n            \\n            // Traverse left\\n            if rBegin <= rEnd {\\n                for i in stride(from: cEnd, to: cBegin - 1, by: -1) {\\n                    result.append(matrix[rEnd][i])\\n                }\\n            }\\n            rEnd -= 1\\n            \\n            // Traverse up\\n            if cBegin <= cEnd {\\n                for i in stride(from: rEnd, to: rBegin - 1, by: -1) {\\n                    result.append(matrix[i][cBegin])\\n                }\\n            }\\n            cBegin += 1\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(value, [1,2,3,6,9,8,7,4,5])\\n    }\\n    \\n    func test1() {\\n        let value = solution.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\\n        XCTAssertEqual(value, [1,2,3,4,8,12,11,10,9,5,6,7])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        guard !(matrix.isEmpty) else { return [] }\\n        \\n        var result: [Int] = []\\n        var rBegin = 0, rEnd = matrix.count - 1\\n        var cBegin = 0, cEnd = matrix[0].count - 1\\n        \\n        while rBegin <= rEnd && cBegin <= cEnd {\\n            // Traverse right\\n            for i in stride(from: cBegin, to: cEnd + 1, by: 1) {\\n                result.append(matrix[rBegin][i])\\n            }\\n            rBegin += 1\\n            \\n            // Traverse down\\n            for i in stride(from: rBegin, to: rEnd + 1, by: 1) {\\n                result.append(matrix[i][cEnd])\\n            }\\n            cEnd -= 1\\n            \\n            // Traverse left\\n            if rBegin <= rEnd {\\n                for i in stride(from: cEnd, to: cBegin - 1, by: -1) {\\n                    result.append(matrix[rEnd][i])\\n                }\\n            }\\n            rEnd -= 1\\n            \\n            // Traverse up\\n            if cBegin <= cEnd {\\n                for i in stride(from: rEnd, to: rBegin - 1, by: -1) {\\n                    result.append(matrix[i][cBegin])\\n                }\\n            }\\n            cBegin += 1\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(value, [1,2,3,6,9,8,7,4,5])\\n    }\\n    \\n    func test1() {\\n        let value = solution.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\\n        XCTAssertEqual(value, [1,2,3,4,8,12,11,10,9,5,6,7])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801834,
                "title": "python-o-m-n-by-simulation-w-visualization",
                "content": "**Hint**:\\n\\nSpiral path can be view as combination of four kinds of traversal, \\nincluding go right \\u2192, go down \\u2193, go left \\u2190, and go up \\u2191.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/78685e35-1ec7-4561-b689-a7e6db013dfd_1597909617.491446.png)\\n\\n---\\n\\n**Implementation** by iteration:\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix or not matrix[0]:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        left, right = 0, len(matrix[0])-1\\n        top, bottom = 0, len(matrix)-1\\n        \\n        spiral_path = []\\n        \\n        # Go with spiral shape and record the path\\n        while True:\\n            \\n            # Top side and go right \\u2192\\n            spiral_path.extend( matrix[top][x] for x in range(left, right+1) )\\n            top += 1\\n            \\n            if top > bottom: break \\n            \\n            # Right side and go down \\u2193\\n            spiral_path.extend( matrix[y][right] for y in range(top, bottom+1) )\\n            right -= 1\\n            \\n            if left > right: break \\n            \\n            # Bottom side and go left \\u2190\\n            spiral_path.extend( matrix[bottom][x] for x in range(right, left-1, -1) )\\n            bottom -= 1\\n            \\n            if top > bottom: break \\n            \\n            # Left side and go up \\u2191\\n            spiral_path.extend( matrix[y][left] for y in range(bottom, top-1, -1) )\\n            left += 1\\n            \\n            if left > right: break\\n        \\n        return spiral_path\\n```\\n\\n---\\n\\nShare another interesting implementation by matrix transpose with python built-in zip( ... ) function.\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        spiral_path = []\\n        \\n        while matrix:\\n            \\n            # pop the top-most row\\n            spiral_path.extend( matrix.pop(0) )\\n            \\n            # get the upside-down of matrix transpose\\n            matrix = [ *zip(*matrix) ][::-1]\\n        \\n        return spiral_path\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official doscs about zip( ... )](https://docs.python.org/3/library/functions.html#zip)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix or not matrix[0]:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        left, right = 0, len(matrix[0])-1\\n        top, bottom = 0, len(matrix)-1\\n        \\n        spiral_path = []\\n        \\n        # Go with spiral shape and record the path\\n        while True:\\n            \\n            # Top side and go right \\u2192\\n            spiral_path.extend( matrix[top][x] for x in range(left, right+1) )\\n            top += 1\\n            \\n            if top > bottom: break \\n            \\n            # Right side and go down \\u2193\\n            spiral_path.extend( matrix[y][right] for y in range(top, bottom+1) )\\n            right -= 1\\n            \\n            if left > right: break \\n            \\n            # Bottom side and go left \\u2190\\n            spiral_path.extend( matrix[bottom][x] for x in range(right, left-1, -1) )\\n            bottom -= 1\\n            \\n            if top > bottom: break \\n            \\n            # Left side and go up \\u2191\\n            spiral_path.extend( matrix[y][left] for y in range(bottom, top-1, -1) )\\n            left += 1\\n            \\n            if left > right: break\\n        \\n        return spiral_path\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        spiral_path = []\\n        \\n        while matrix:\\n            \\n            # pop the top-most row\\n            spiral_path.extend( matrix.pop(0) )\\n            \\n            # get the upside-down of matrix transpose\\n            matrix = [ *zip(*matrix) ][::-1]\\n        \\n        return spiral_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388871,
                "title": "simple-recursion-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        // Check for edge cases for the matrix\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return new ArrayList<Integer>();\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n        // Run our recursion starting with the first and last eligible rows and the first and last eligible columns\\n        spiralOut(res, matrix, 0, matrix.length - 1, 0, matrix[0].length - 1);\\n        return res;\\n    }\\n    \\n    private void spiralOut(List<Integer> res, int[][] m, int r1, int r2, int c1, int c2){\\n        // Return if we\\'ve exhausted all values to the point of invalid indices\\n        if(r1 > r2 || c1 > c2) return;\\n        \\n        // TOP ROW: left to right\\n        for(int c = c1; c <= c2; c++) res.add(m[r1][c]);\\n        \\n        // RIGHT COLUMN: top to bottom\\n        for(int r = r1 + 1; r <= r2; r++) res.add(m[r][c2]);\\n        \\n        // Return if we\\'ve processed the last row/column because we\\'d otherwise repeat values\\n        if(r1 == r2 || c1 == c2) return;\\n        \\n        // BOTTOM ROW: right to left\\n        for(int c = c2 - 1; c >= c1; c--) res.add(m[r2][c]);\\n        \\n        // LEFT COLUMN: bottom to top\\n        for(int r = r2 - 1; r >= r1 + 1; r--) res.add(m[r][c1]);\\n        \\n        // Recursion through the inner matrix\\n        spiralOut(res, m, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n}\\n```\\n\\nIf you imagine a spiral traversal of a matrix, the traversal of the inner matrix once you peel back the outmost 1 layer of the matrix is the same regardless of that outermost layer. Therefore, we can break the problem down to traversing the outermost layer, recording it, and then doing the same thing for the inner matrix. When we traverse the outermost layer, we have to be careful not the repeat the very last value from the last row/column as the first value in our current row/column.\\n\\nNote that if there are an odd number of rows or columns for the last matrix/layer, you must be careful not to double-count.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        // Check for edge cases for the matrix\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return new ArrayList<Integer>();\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n        // Run our recursion starting with the first and last eligible rows and the first and last eligible columns\\n        spiralOut(res, matrix, 0, matrix.length - 1, 0, matrix[0].length - 1);\\n        return res;\\n    }\\n    \\n    private void spiralOut(List<Integer> res, int[][] m, int r1, int r2, int c1, int c2){\\n        // Return if we\\'ve exhausted all values to the point of invalid indices\\n        if(r1 > r2 || c1 > c2) return;\\n        \\n        // TOP ROW: left to right\\n        for(int c = c1; c <= c2; c++) res.add(m[r1][c]);\\n        \\n        // RIGHT COLUMN: top to bottom\\n        for(int r = r1 + 1; r <= r2; r++) res.add(m[r][c2]);\\n        \\n        // Return if we\\'ve processed the last row/column because we\\'d otherwise repeat values\\n        if(r1 == r2 || c1 == c2) return;\\n        \\n        // BOTTOM ROW: right to left\\n        for(int c = c2 - 1; c >= c1; c--) res.add(m[r2][c]);\\n        \\n        // LEFT COLUMN: bottom to top\\n        for(int r = r2 - 1; r >= r1 + 1; r--) res.add(m[r][c1]);\\n        \\n        // Recursion through the inner matrix\\n        spiralOut(res, m, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20820,
                "title": "python-easy-to-understand-solution-left-right-top-down",
                "content": "        \\n    def spiralOrder(self, matrix):\\n        if not matrix:\\n            return []\\n        left, right, top, down, res = 0, len(matrix[0])-1, 0, len(matrix)-1, []\\n        while left <= right and top <= down:\\n            res.extend(matrix[top][left:right+1]) # left to right\\n            top += 1 \\n            for i in xrange(top, down+1): # top to down\\n                res.append(matrix[i][right])\\n            right -= 1\\n            if top <= down:\\n                res.extend(matrix[down][left:right+1][::-1]) # right to left\\n                down -= 1\\n            if left <= right:\\n                for i in xrange(down, top-1, -1): # bottom to up\\n                    res.append(matrix[i][left])\\n                left += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def spiralOrder(self, matrix):\\n        if not matrix:\\n            return []\\n        left, right, top, down, res = 0, len(matrix[0])-1, 0, len(matrix)-1, []\\n        while left <= right and top <= down:\\n            res.extend(matrix[top][left:right+1]) # left to right\\n            top += 1 \\n            for i in xrange(top, down+1): # top to down\\n                res.append(matrix[i][right])\\n            right -= 1\\n            if top <= down:\\n                res.extend(matrix[down][left:right+1][::-1]) # right to left\\n                down -= 1\\n            if left <= right:\\n                for i in xrange(down, top-1, -1): # bottom to up\\n                    res.append(matrix[i][left])\\n                left += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3503965,
                "title": "beats-99-with-s-complexity",
                "content": "![image.png](https://assets.leetcode.com/users/images/6f9a92fd-ef1f-4b6a-bb86-2cda2c03d332_1683620171.7653453.png)\\n\\n# Institution\\n\\nStoring each element of `matrix` to the `bag` in spiral order.\\n> Seeker of Miracle\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/0c451fb0-afab-4115-b88c-0361d9a34db1_1683619789.227738.png)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(X*Y) - where X is Length of X axis in matrix field, Y is Length of Y axis in matrix field\\n\\n- Space complexity:O(X*Y) - where X is Length of X axis in matrix field, Y is Length of Y axis in matrix field\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n   \\n    const yLength = matrix.length, xLength = matrix[0].length;\\n    let y=0, x=0, count=0, area= xLength * yLength, bag=[];\\n\\n    while(count<area)\\n    {\\n        for(let i=x; count<area && i<xLength-x; i++)\\n        {\\n            bag.push(matrix[y][i])\\n            count++;\\n        }\\n        y++;\\n        for(let i=y; count<area && i<yLength-y+1; i++)\\n        {\\n            bag.push(matrix[i][(xLength-1) - x])\\n            count++;\\n        }\\n        x++;\\n\\n        for(let i= (xLength-1) - x; count<area && i>=x-1; i--)\\n        {\\n            bag.push(matrix[(yLength-1) - (y-1)][i])\\n            count++;\\n        }\\n\\n        for(let i= (yLength-1) - y; count<area && i>=y; i--)\\n        {\\n            bag.push(matrix[i][x-1])\\n            count++;\\n        }\\n\\n    }\\n    return bag\\n};\\n```\\n*I am happy if you leave your comments below as advise in order to improve my code*",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n   \\n    const yLength = matrix.length, xLength = matrix[0].length;\\n    let y=0, x=0, count=0, area= xLength * yLength, bag=[];\\n\\n    while(count<area)\\n    {\\n        for(let i=x; count<area && i<xLength-x; i++)\\n        {\\n            bag.push(matrix[y][i])\\n            count++;\\n        }\\n        y++;\\n        for(let i=y; count<area && i<yLength-y+1; i++)\\n        {\\n            bag.push(matrix[i][(xLength-1) - x])\\n            count++;\\n        }\\n        x++;\\n\\n        for(let i= (xLength-1) - x; count<area && i>=x-1; i--)\\n        {\\n            bag.push(matrix[(yLength-1) - (y-1)][i])\\n            count++;\\n        }\\n\\n        for(let i= (yLength-1) - y; count<area && i>=y; i--)\\n        {\\n            bag.push(matrix[i][x-1])\\n            count++;\\n        }\\n\\n    }\\n    return bag\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779082,
                "title": "100-beats-0ms-c-fastest",
                "content": "\\n# Approach\\nTraverse the matrix in the spiral order by keeping four variables: rs for the first row, re for the last row, cs for the first column and ce for the last column.\\n# Complexity\\n- Time complexity: 0(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(matrix.size() == 0) \\n        return res;\\n        int rs = 0, re = matrix.size() - 1, cs = 0, ce = matrix[0].size() - 1;\\n        while(rs <= re && cs <= ce)\\n        {\\n            for(int i = cs; i <= ce; i++) \\n             res.push_back(matrix[rs][i]);\\n            rs++;\\n            for(int i = rs; i <= re; i++) \\n             res.push_back(matrix[i][ce]);\\n            ce--;\\n            for(int i = ce; i >= cs && rs <= re; i--) \\n             res.push_back(matrix[re][i]);\\n            re--;\\n            for(int i = re; i >= rs && cs <= ce; i--) \\n             res.push_back(matrix[i][cs]);\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(matrix.size() == 0) \\n        return res;\\n        int rs = 0, re = matrix.size() - 1, cs = 0, ce = matrix[0].size() - 1;\\n        while(rs <= re && cs <= ce)\\n        {\\n            for(int i = cs; i <= ce; i++) \\n             res.push_back(matrix[rs][i]);\\n            rs++;\\n            for(int i = rs; i <= re; i++) \\n             res.push_back(matrix[i][ce]);\\n            ce--;\\n            for(int i = ce; i >= cs && rs <= re; i--) \\n             res.push_back(matrix[re][i]);\\n            re--;\\n            for(int i = re; i >= rs && cs <= ce; i--) \\n             res.push_back(matrix[i][cs]);\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692290,
                "title": "fully-detailed-concise-and-clear-python-solution",
                "content": "Note: for each part that I\\'m explaining I\\'ll be referencing the relevant line in the code [*Line k*]. The code snippet is enumerated.\\n\\nMy solution approaches this problem one step at a time - simulating a walk over a spiral path. \\n\\n#### **Simulation details:**\\nThere are only 4 movement directions: \\n1. Right or `(row, col) + (0, 1)`: moving across the same row to the *next* column\\n2. Down or `(row, col) + (1, 0)`: moving across the same column to the *next* row\\n3. Left or `(row, col) + (0, -1)`: moving across the same row to the *previous* column\\n4. Up or `(row, col) + (-1, 0)`: moving across the same column to the *previous* row\\n\\nWe start at cell `(0,0)` and move to right with step pattern `(0,1)` [*Lines 5-6*], and we add each cell we visit to the `path` list [*Line 9*]. However, when we encounter a border or a visited cell, we need to change direction. Whenever we change direction we keep walking in that direction until again we encounter any of the obstacles (broder or visited cell).\\n\\n**Visited:** I indicate that a cell has been visited by changing its value to `120` [*Line 10*](but this could be any number not in the range of possible values `-100 <= num <= 100`. You can also achieve this by maintaining a set or anything data structure of your choice. But my method avoids using up extra space. [*Line 13 third conditional*]\\n\\n**Border:** This is rather intuitive, you should have to check if the new row and new col fall within the boundaries of the matrix. [*Lines 12, Line 13 first two conditionals*]\\n\\t\\n**Changing directions:** This follows a fixed pattern (at a right angle and clockwise). So we can follow the order above (from 1 to 4 and back to 1 in a loop). Achieving this in code can simply be done by recognizing the mathematical pattern. If you have a (simple) background in linear algebra, this can be understood as finding the transformation matrix for a clockwise 90 degrees rotation. But you don\\'t really need linear algebra. Notice that in transitioning from one step pattern to the next we do:\\n     `(x, y) => (y, -x)`\\n\\t  `(0,1)  => (1,0) => (0,-1) => (-1,0) => (0,1) => . . .`\\n\\t\\nThus, we change the pattern everytime the conditions at Line 13 aren\\'t satisfied. And we use our pattern above to change direction and move to the next cell according to the new pattern. [*Lines 15-18*]\\n\\n**Terminate the loop:** we already know what the final length of the path is - the number of cells in the matrix [*Line 3*]. So we terminate the loop when `len(path)` becomes equal to this size. [*Line 8*]\\n\\n\\n```\\n1. class Solution:\\n2.     def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n3.         size = len(matrix) * len(matrix[0])\\n4.         path = []\\n5.         cell = [0,0]\\n6.         step = [0,1]\\n7.         \\n8.         while len(path) < size:\\n9.             path.append(matrix[cell[0]][cell[1]])\\n10.            matrix[cell[0]][cell[1]] = 120\\n11.            # next cell\\n12.            nrow, ncol = cell[0]+step[0], cell[1]+step[1]\\n13.            if (0 <= nrow < len(matrix)) and (0 <= ncol < len(matrix[0])) and (matrix[nrow][ncol]) != 120:\\n14.                cell[0], cell[1] = nrow, ncol\\n15.            else:\\n16.                 # change direction (90 degrees clockwise)\\n17.                 step[0], step[1] = step[1], -step[0]\\n18.                 cell[0], cell[1] = cell[0]+step[0], cell[1]+step[1]\\n19.                \\n20.        return path\\n```\\n\\n\\nBelow I use `n` to indicate the size of the input rather than the number of rows (you could replace `n` with `nxm`).\\n\\n***Time complexity:*** O(n) \\nSince this is a simulation we only visit each cell once, and for each cell we perform a constant number of operations, and there are `n` cells.\\n\\n***Space complexity:*** O(n)\\nBecause we populate the `path` array with all n cell values.\\n\\n\\n**Notes:**\\n1. We can improve performance by initializing the `path` array to its final size (since we already know that it will contain `n` values). This way we can help Python avoid the continuous reallocation of the entire array after every few appends. ([Read more here](http://https://rednafi.github.io/reflections/pre-allocated-lists-in-python.html)). We would also have to keep a counter to keep track of the last inserted index.\\n2. Please suggest any performance or implementation improvements that you can think of.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n1. class Solution:\\n2.     def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n3.         size = len(matrix) * len(matrix[0])\\n4.         path = []\\n5.         cell = [0,0]\\n6.         step = [0,1]\\n7.         \\n8.         while len(path) < size:\\n9.             path.append(matrix[cell[0]][cell[1]])\\n10.            matrix[cell[0]][cell[1]] = 120\\n11.            # next cell\\n12.            nrow, ncol = cell[0]+step[0], cell[1]+step[1]\\n13.            if (0 <= nrow < len(matrix)) and (0 <= ncol < len(matrix[0])) and (matrix[nrow][ncol]) != 120:\\n14.                cell[0], cell[1] = nrow, ncol\\n15.            else:\\n16.                 # change direction (90 degrees clockwise)\\n17.                 step[0], step[1] = step[1], -step[0]\\n18.                 cell[0], cell[1] = cell[0]+step[0], cell[1]+step[1]\\n19.                \\n20.        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912519,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        let count = (matrix.count + 1) / 2 \\n        let row = matrix.count\\n        let col = matrix[0].count\\n        var res: [Int] = []\\n        \\n        for i in 0..<count {\\n            \\n            for j in i..<col - i - 1 {\\n                let x = i\\n                let y = j\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = j\\n                let y = col - i - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<col - i - 1 {\\n                let x = row - i - 1\\n                let y = col - j - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = row - j - 1\\n                let y = i\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            if res.count == row * col { break }\\n        }\\n        \\n        if res.count == row * col - 1 {\\n            res.append(matrix[row / 2][col / 2])\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        let count = (matrix.count + 1) / 2 \\n        let row = matrix.count\\n        let col = matrix[0].count\\n        var res: [Int] = []\\n        \\n        for i in 0..<count {\\n            \\n            for j in i..<col - i - 1 {\\n                let x = i\\n                let y = j\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = j\\n                let y = col - i - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<col - i - 1 {\\n                let x = row - i - 1\\n                let y = col - j - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = row - j - 1\\n                let y = i\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            if res.count == row * col { break }\\n        }\\n        \\n        if res.count == row * col - 1 {\\n            res.append(matrix[row / 2][col / 2])\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954443,
                "title": "python-dfs",
                "content": "It looked simple dfs traversal at first but it fails when matrix is greater than size 3. \\nThanx to https://leetcode.com/problems/spiral-matrix/discuss/517536/Simple-Java-DFS-Solution, I found the trick.\\n\\n```\\n        ans = []\\n        seen = set()\\n        def dfs(row,col, isUp):\\n            if row < len(matrix) and row >= 0 and col < len(matrix[0]) and col >= 0 and (row,col) not in seen:\\n                seen.add((row,col))\\n                ans.append(matrix[row][col])\\n                if isUp:\\n                    dfs(row-1,col,True)\\n                dfs(row,col+1,False)\\n                dfs(row+1,col,False)\\n                dfs(row,col-1,False)\\n                dfs(row-1,col,True)\\n        dfs(0,0, False)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n        ans = []\\n        seen = set()\\n        def dfs(row,col, isUp):\\n            if row < len(matrix) and row >= 0 and col < len(matrix[0]) and col >= 0 and (row,col) not in seen:\\n                seen.add((row,col))\\n                ans.append(matrix[row][col])\\n                if isUp:\\n                    dfs(row-1,col,True)\\n                dfs(row,col+1,False)\\n                dfs(row+1,col,False)\\n                dfs(row,col-1,False)\\n                dfs(row-1,col,True)\\n        dfs(0,0, False)\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 925789,
                "title": "easy-js-solution",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length == 0) return [];\\n    \\n    let res = [];\\n    let row1 = 0, col1 = 0, row2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\n    while (row1 <= row2 && col1 <= col2) {\\n        // upper perimeter\\n        for (let col = col1; col <= col2; col++) {\\n            res.push(matrix[row1][col]);    \\n        }\\n        // right perimeter\\n        for (let row = row1+1; row <= row2; row++) {\\n            res.push(matrix[row][col2]);\\n        }\\n        if (row1 < row2 && col1 < col2) {\\n            // bottom perimeter\\n            for (let col = col2-1; col >= col1; col--) {\\n                res.push(matrix[row2][col]);\\n            }\\n            // left perimeter\\n            for (let row = row2-1; row > row1; row--) {\\n                res.push(matrix[row][col1]);\\n            }    \\n        }\\n        \\n        row1++, col1++, row2--, col2--;\\n    }\\n    \\n    return res;\\n    \\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length == 0) return [];\\n    \\n    let res = [];\\n    let row1 = 0, col1 = 0, row2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\n    while (row1 <= row2 && col1 <= col2) {\\n        // upper perimeter\\n        for (let col = col1; col <= col2; col++) {\\n            res.push(matrix[row1][col]);    \\n        }\\n        // right perimeter\\n        for (let row = row1+1; row <= row2; row++) {\\n            res.push(matrix[row][col2]);\\n        }\\n        if (row1 < row2 && col1 < col2) {\\n            // bottom perimeter\\n            for (let col = col2-1; col >= col1; col--) {\\n                res.push(matrix[row2][col]);\\n            }\\n            // left perimeter\\n            for (let row = row2-1; row > row1; row--) {\\n                res.push(matrix[row][col1]);\\n            }    \\n        }\\n        \\n        row1++, col1++, row2--, col2--;\\n    }\\n    \\n    return res;\\n    \\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496148,
                "title": "python3-easy-to-understand-solution-with-comments",
                "content": "I was considering element by element operation at the beginning, but gave up after trying for 30 mins. If modifying the input matrix is OK, the code can be much easier by popping the elements in the right order and append. After some optimization, only the resulting array/list and a single variable is used. It seems to me that this is easy to remember/understand and come up in interviews. Please leave a comment or upvote if you find the post helpful :)\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        turn = 0\\n        \\n        while len(matrix) != 0 and len(matrix[0]) != 0:\\n            if turn % 4 == 0: # need to pop first row\\n                res += matrix.pop(0)\\n                \\n            if turn % 4 == 1: # need to pop last column\\n                for i in range(len(matrix)):\\n                    res.append(matrix[i].pop())\\n\\n            if turn % 4 == 2: # need to pop last row and reverse\\n                res += matrix.pop()[::-1]\\n                \\n            if turn % 4 == 3: # need to pop first column and reverse\\n                for i in range(len(matrix))[::-1]:\\n                    res.append(matrix[i].pop(0))\\n\\n            turn += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        turn = 0\\n        \\n        while len(matrix) != 0 and len(matrix[0]) != 0:\\n            if turn % 4 == 0: # need to pop first row\\n                res += matrix.pop(0)\\n                \\n            if turn % 4 == 1: # need to pop last column\\n                for i in range(len(matrix)):\\n                    res.append(matrix[i].pop())\\n\\n            if turn % 4 == 2: # need to pop last row and reverse\\n                res += matrix.pop()[::-1]\\n                \\n            if turn % 4 == 3: # need to pop first column and reverse\\n                for i in range(len(matrix))[::-1]:\\n                    res.append(matrix[i].pop(0))\\n\\n            turn += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316519,
                "title": "simple-javascript-solution-with-pop-shift-recursion-beat-86",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length === 0) return [];\\n    if (matrix[0].length === 0) return [];\\n    \\n    let result = [];\\n    // ADD FIRST ROW\\n    result = result.concat(matrix.shift());\\n    \\n    // ADD LAST COL\\n    for (let i=0; i<matrix.length-1; i++){\\n        result.push(matrix[i].pop());\\n    }\\n    \\n    // ADD LAST ROW\\n    const lastRow = matrix.pop();\\n    if (lastRow) result = result.concat(lastRow.reverse());\\n\\n    // ADD FIRST COL\\n    for (let i=matrix.length-1; i>=0; i--){\\n        if (matrix[i].length) result.push(matrix[i].shift());\\n    }\\n    \\n    return result.concat(spiralOrder(matrix));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length === 0) return [];\\n    if (matrix[0].length === 0) return [];\\n    \\n    let result = [];\\n    // ADD FIRST ROW\\n    result = result.concat(matrix.shift());\\n    \\n    // ADD LAST COL\\n    for (let i=0; i<matrix.length-1; i++){\\n        result.push(matrix[i].pop());\\n    }\\n    \\n    // ADD LAST ROW\\n    const lastRow = matrix.pop();\\n    if (lastRow) result = result.concat(lastRow.reverse());\\n\\n    // ADD FIRST COL\\n    for (let i=matrix.length-1; i>=0; i--){\\n        if (matrix[i].length) result.push(matrix[i].shift());\\n    }\\n    \\n    return result.concat(spiralOrder(matrix));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20811,
                "title": "23-line-clear-and-simple-c-solution",
                "content": "    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> res;\\n        if (matrix.empty()) return res;\\n        const int nx[] = {0, 1, 0, -1};\\n        const int ny[] = {1, 0, -1, 0};\\n        int x = 0, y = -1;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0;\\n        \\n        while (m > 0 && n>0) {\\n            int k;\\n            if (i%2 == 0) k = n, m--;\\n            else k = m, n--;\\n                \\n            while (k--) {\\n                x += nx[i]; y += ny[i];\\n                res.push_back(matrix[x][y]);\\n            }\\n            \\n            i = (i+1)%4; //direction\\n        }\\n        \\n        return res;\\n    }\\n\\nvariable i control the direction of next movement, nx and ny holds the offset of next step",
                "solutionTags": [],
                "code": "    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> res;\\n        if (matrix.empty()) return res;\\n        const int nx[] = {0, 1, 0, -1};\\n        const int ny[] = {1, 0, -1, 0};\\n        int x = 0, y = -1;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0;\\n        \\n        while (m > 0 && n>0) {\\n            int k;\\n            if (i%2 == 0) k = n, m--;\\n            else k = m, n--;\\n                \\n            while (k--) {\\n                x += nx[i]; y += ny[i];\\n                res.push_back(matrix[x][y]);\\n            }\\n            \\n            i = (i+1)%4; //direction\\n        }\\n        \\n        return res;\\n    }\\n\\nvariable i control the direction of next movement, nx and ny holds the offset of next step",
                "codeTag": "Unknown"
            },
            {
                "id": 3503174,
                "title": "100-beats-c-easy-to-undestand",
                "content": "sr : starting of row\\ner : end of row\\nsc : starting of row\\nec : end of columns\\n\\n{first traverse first row increment starting row by one\\nsecond traversal for insert last columns decrement last columns by 1\\nthird time insert last row decrement last row by one\\nfourth time insert first row increment 1st column by row}\\n    repeat these all four steps untill sr <= er && sc <= ec.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int sr = 0, sc = 0, er = mat.size()-1,ec = mat[0].size()-1,i;\\n        vector<int> v;\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v.push_back(mat[sr][i]);\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v.push_back(mat[i][ec]);\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v.push_back(mat[er][i]);\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v.push_back(mat[i][sc]);\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int sr = 0, sc = 0, er = mat.size()-1,ec = mat[0].size()-1,i;\\n        vector<int> v;\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v.push_back(mat[sr][i]);\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v.push_back(mat[i][ec]);\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v.push_back(mat[er][i]);\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v.push_back(mat[i][sc]);\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493023,
                "title": "super-logic-with-left-right-top-bottom-pointers-two-logics",
                "content": "# 1. Python3 Solution:\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==(len(matrix)*len(matrix[0])):\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```\\n\\n\\n# 2. Python3 Solution\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if left>right or top>bottom:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==(len(matrix)*len(matrix[0])):\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if left>right or top>bottom:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3337983,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing four pointers top , left , right , bottom\\nEach variable placed as their name suggest top = 0 , left = 0 , right = n-1 , bottom =m-1\\n- first we travels from left to right increasing top since top layer is already saved in our vector\\n- Then we travel from new top to bottom then decreasing right\\n- Then we travel from new right to left decreasing bottom \\n- Then we finally travel from bottom to top and increasing left\\n- this we have to do in while loop until our answer vector is not equal to original size of matrix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top = 0 , left = 0 ;\\n        int bot = matrix.size() - 1 , right = matrix[0].size()-1;\\n        int n = matrix.size() , m = matrix[0].size();\\n        vector<int>ans;\\n        int cnt = 0 ;\\n        while( ans.size() < n*m)\\n        {\\n            cnt++;\\n            if( left <= right)\\n            {\\n                for(int i = left ;i<= right ;i++ )\\n                {\\n                    ans.push_back( matrix[top][i]);\\n                }\\n                top++;\\n\\n            }\\n            if( top <= bot and ans.size() < n*m )\\n            {\\n                 for(int i = top ;i<=bot ;i++ )\\n                {\\n                    ans.push_back( matrix[i][right]);\\n                }\\n                right--;\\n\\n            }\\n\\n            if( right >= left and ans.size() < n*m ) \\n            {\\n                for(int i = right ;i>=left ;i-- )\\n                {\\n                    ans.push_back( matrix[bot][i]);\\n\\n                }\\n                bot--;\\n\\n            }\\n            if( bot >= top and ans.size() < n*m)\\n            {\\n                for(int i = bot ;i>= top ;i--)\\n                {\\n                    ans.push_back(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n            }\\n          \\n        }\\n        cout<<cnt;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top = 0 , left = 0 ;\\n        int bot = matrix.size() - 1 , right = matrix[0].size()-1;\\n        int n = matrix.size() , m = matrix[0].size();\\n        vector<int>ans;\\n        int cnt = 0 ;\\n        while( ans.size() < n*m)\\n        {\\n            cnt++;\\n            if( left <= right)\\n            {\\n                for(int i = left ;i<= right ;i++ )\\n                {\\n                    ans.push_back( matrix[top][i]);\\n                }\\n                top++;\\n\\n            }\\n            if( top <= bot and ans.size() < n*m )\\n            {\\n                 for(int i = top ;i<=bot ;i++ )\\n                {\\n                    ans.push_back( matrix[i][right]);\\n                }\\n                right--;\\n\\n            }\\n\\n            if( right >= left and ans.size() < n*m ) \\n            {\\n                for(int i = right ;i>=left ;i-- )\\n                {\\n                    ans.push_back( matrix[bot][i]);\\n\\n                }\\n                bot--;\\n\\n            }\\n            if( bot >= top and ans.size() < n*m)\\n            {\\n                for(int i = bot ;i>= top ;i--)\\n                {\\n                    ans.push_back(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n            }\\n          \\n        }\\n        cout<<cnt;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1774250,
                "title": "4-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        int row= matrix.size(),col = matrix[0].size();\\n        int top =0,right = col-1,left = 0,bottom = row-1;\\n        vector<int> ans;\\n        while(left<=right and top<=bottom){\\n            // trversing from left to right\\n            // increase the top\\n            for(int i=left;i<=right;i++)\\n                ans.push_back(matrix[top][i]);\\n            top++;\\n            //traversing from top to bottom\\n            // decremnt right\\n            for(int i=top;i<=bottom;i++)\\n                ans.push_back(matrix[i][right]);\\n            right--;\\n            // traversing  right to left\\n            // decremnt the bottom\\n            if(left<=right){\\n                for(int i=right;i>=left;i--)\\n                    ans.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            // traversing from bottom to top\\n            // incerament the left\\n            if(top<=bottom){\\n                for(int i =bottom;i>=top;i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        int row= matrix.size(),col = matrix[0].size();\\n        int top =0,right = col-1,left = 0,bottom = row-1;\\n        vector<int> ans;\\n        while(left<=right and top<=bottom){\\n            // trversing from left to right\\n            // increase the top\\n            for(int i=left;i<=right;i++)\\n                ans.push_back(matrix[top][i]);\\n            top++;\\n            //traversing from top to bottom\\n            // decremnt right\\n            for(int i=top;i<=bottom;i++)\\n                ans.push_back(matrix[i][right]);\\n            right--;\\n            // traversing  right to left\\n            // decremnt the bottom\\n            if(left<=right){\\n                for(int i=right;i>=left;i--)\\n                    ans.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            // traversing from bottom to top\\n            // incerament the left\\n            if(top<=bottom){\\n                for(int i =bottom;i>=top;i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188627,
                "title": "javascript-recursive",
                "content": "``` \\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix, result = []) {\\n     // Write your code here, and\\n      // return your final answer.\\n      if (matrix.length === 0) {\\n        return result\\n\\n      }\\n\\t\\n\\tfor (var i = 0; i < matrix.length; i++) {\\n\\t\\tvar current = matrix[i]\\n\\t \\tif (i === 0) {\\n\\t \\t\\tresult = result.concat(current);\\n\\t \\t} else {\\n\\t \\t  var last = current.pop();\\n\\t \\t\\tif (!last) {\\n\\t \\t\\t\\treturn result\\n\\t \\t\\t}\\n\\t \\t\\tresult.push(last)\\n\\t \\t\\tcurrent.reverse()\\n\\t \\t} \\n \\t}\\n\\t\\n\\tmatrix.shift()\\n \\treturn spiralOrder(matrix.reverse(), result)\\n};\\n\\n```",
                "solutionTags": [],
                "code": "``` \\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix, result = []) {\\n     // Write your code here, and\\n      // return your final answer.\\n      if (matrix.length === 0) {\\n        return result\\n\\n      }\\n\\t\\n\\tfor (var i = 0; i < matrix.length; i++) {\\n\\t\\tvar current = matrix[i]\\n\\t \\tif (i === 0) {\\n\\t \\t\\tresult = result.concat(current);\\n\\t \\t} else {\\n\\t \\t  var last = current.pop();\\n\\t \\t\\tif (!last) {\\n\\t \\t\\t\\treturn result\\n\\t \\t\\t}\\n\\t \\t\\tresult.push(last)\\n\\t \\t\\tcurrent.reverse()\\n\\t \\t} \\n \\t}\\n\\t\\n\\tmatrix.shift()\\n \\treturn spiralOrder(matrix.reverse(), result)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504302,
                "title": "c-fully-explained-easy-to-understand",
                "content": "# Intuition\\n**step1)** go from  left-top corner to right most cell of  row 0.\\n**step2)** go from right-top corner to right-bottom cell of **column n-1**\\n **step3)** go from right-bottom corner to left cell of column 0 .\\n**step4)** go left-bottom cell to up .\\nrepeate it untill   **c1<=c2 and r1<=r2** where **c1=0,c2=matrix[0].size()-1;**\\n             __________________________________________and  **r1=0,r2=matrix.size()-1;**\\n\\n# PLEASE upvote to motivate me more \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int c1=0,c2=matrix[0].size()-1;\\n        int r1=0,r2=matrix.size()-1;\\n\\n        while(c1<=c2 && r1<=r2){\\n            for(int c=c1;c<=c2;++c){ //from left to right\\n                ans.push_back(matrix[r1][c]);\\n            }\\n            for(int r=r1+1;r<=r2;++r){ // from right top to bottom\\n                ans.push_back(matrix[r][c2]);\\n            }\\n            if(r1<r2 && c1<c2){\\n              for(int c=c2-1;c>=c1;--c){ //from bottom right to bottom left\\n                  ans.push_back(matrix[r2][c]);\\n              }\\n              for(int r=r2-1;r>r1;--r){ //from left bottom to left up\\n                  ans.push_back(matrix[r][c1]);\\n              }\\n            }\\n\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Time Complexity :- O(m * n)\\n where m is the number of rows and n is the number of columns in the matrix. This is because the code iterates over each element in the matrix exactly once in the worst case.\\n\\n# Space Complexity :-O(m * n). \\nThis is because the code creates a vector of size m * n to store the output spiral order of the matrix.\\n\\n\\n![begging.jpg](https://assets.leetcode.com/users/images/b3a7e1db-c49f-4e61-ae82-e02eed7f4f46_1683626459.056374.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int c1=0,c2=matrix[0].size()-1;\\n        int r1=0,r2=matrix.size()-1;\\n\\n        while(c1<=c2 && r1<=r2){\\n            for(int c=c1;c<=c2;++c){ //from left to right\\n                ans.push_back(matrix[r1][c]);\\n            }\\n            for(int r=r1+1;r<=r2;++r){ // from right top to bottom\\n                ans.push_back(matrix[r][c2]);\\n            }\\n            if(r1<r2 && c1<c2){\\n              for(int c=c2-1;c>=c1;--c){ //from bottom right to bottom left\\n                  ans.push_back(matrix[r2][c]);\\n              }\\n              for(int r=r2-1;r>r1;--r){ //from left bottom to left up\\n                  ans.push_back(matrix[r][c1]);\\n              }\\n            }\\n\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998924,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(Row x Colums)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n         List<Integer> res = new ArrayList<Integer>();\\n        int startRow =0;\\n        int endRow = matrix.length-1;\\n        int startCol = 0;\\n        int endCol =  matrix[0].length-1;\\n\\n        while(startRow<=endRow && startCol <= endCol){\\n            //top\\n            for(int j=startCol; j<=endCol; j++){\\n                res.add(matrix[startRow][j]);\\n            }\\n            // right\\n            for(int i=startRow+1; i<=endRow; i++){\\n                res.add(matrix[i][endCol]);\\n            }\\n            // bottom\\n            for(int j= endCol-1; j>=startCol; j--){\\n                if(startRow==endRow){\\n                    break;\\n                }\\n                res.add(matrix[endRow][j]);\\n            }\\n            // left\\n            for(int i=endRow-1; i>=startRow+1; i--){\\n                if(startCol==endCol){\\n                    break;\\n                }\\n                res.add(matrix[i][startCol]);\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n         List<Integer> res = new ArrayList<Integer>();\\n        int startRow =0;\\n        int endRow = matrix.length-1;\\n        int startCol = 0;\\n        int endCol =  matrix[0].length-1;\\n\\n        while(startRow<=endRow && startCol <= endCol){\\n            //top\\n            for(int j=startCol; j<=endCol; j++){\\n                res.add(matrix[startRow][j]);\\n            }\\n            // right\\n            for(int i=startRow+1; i<=endRow; i++){\\n                res.add(matrix[i][endCol]);\\n            }\\n            // bottom\\n            for(int j= endCol-1; j>=startCol; j--){\\n                if(startRow==endRow){\\n                    break;\\n                }\\n                res.add(matrix[endRow][j]);\\n            }\\n            // left\\n            for(int i=endRow-1; i>=startRow+1; i--){\\n                if(startCol==endCol){\\n                    break;\\n                }\\n                res.add(matrix[i][startCol]);\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145118,
                "title": "swift-solution",
                "content": "```\\nfunc spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n\\tguard  !matrix.isEmpty else {\\n\\t\\treturn []\\n\\t}\\n\\tvar top = 0\\n\\tvar bottom = matrix.count - 1\\n\\tvar left = 0\\n\\tvar right = matrix[0].count - 1\\n\\tlet count = matrix.count * matrix[0].count\\n\\tvar arr = [Int]()\\n\\twhile arr.count < count {\\n\\n\\t\\tfor i in stride(from: left, to: right+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[top][i])\\n\\t\\t}\\n\\t\\ttop += 1\\n\\t\\tfor i in stride(from: top, to: bottom+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][right])\\n\\t\\t}\\n\\t\\tright -= 1\\n\\t\\tfor i in stride(from: right, to: left-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom -= 1\\n\\t\\tfor i in stride(from: bottom, to: top-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][left])\\n\\t\\t}\\n\\t\\tleft += 1\\n\\t}\\n\\treturn arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n\\tguard  !matrix.isEmpty else {\\n\\t\\treturn []\\n\\t}\\n\\tvar top = 0\\n\\tvar bottom = matrix.count - 1\\n\\tvar left = 0\\n\\tvar right = matrix[0].count - 1\\n\\tlet count = matrix.count * matrix[0].count\\n\\tvar arr = [Int]()\\n\\twhile arr.count < count {\\n\\n\\t\\tfor i in stride(from: left, to: right+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[top][i])\\n\\t\\t}\\n\\t\\ttop += 1\\n\\t\\tfor i in stride(from: top, to: bottom+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][right])\\n\\t\\t}\\n\\t\\tright -= 1\\n\\t\\tfor i in stride(from: right, to: left-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom -= 1\\n\\t\\tfor i in stride(from: bottom, to: top-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][left])\\n\\t\\t}\\n\\t\\tleft += 1\\n\\t}\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435612,
                "title": "python3-try-except",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:  \\n        ans = []\\n        while True:\\n            try: \\n                ans += matrix.pop(0) #take top row\\n                ans += [i.pop() for i in matrix] #take right col\\n                ans += matrix.pop()[::-1] #take bottom row,\\n                ans += [i.pop(0) for i in matrix][::-1] #take left col\\n            except IndexError: #when matrix is emptied mission is complete\\n                return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:  \\n        ans = []\\n        while True:\\n            try: \\n                ans += matrix.pop(0) #take top row\\n                ans += [i.pop() for i in matrix] #take right col\\n                ans += matrix.pop()[::-1] #take bottom row,\\n                ans += [i.pop(0) for i in matrix][::-1] #take left col\\n            except IndexError: #when matrix is emptied mission is complete\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055455,
                "title": "spiral-matrix-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks for a list of integers representing a spiral order traversal of a given 2D matrix. My intuition for this code is to simulate the spiral traversal pattern by moving through the matrix in four directions: right, down, left, and up, while updating the boundaries of the submatrix. In conlusion I move from the outermost boundary towards the center until there are no more elements left to traverse.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach for traversing a 2D matrix in a spiral order involves a systematic step-by-step process:\\n\\n1. Initialization: Start with key variables:\\nstart_row as 0 for the starting row.\\nend_row as n - 1 (n is the number of rows) for the ending row.\\nstart_col at 0 for the starting column.\\nend_col as m - 1 (m is the number of columns) for the ending column.\\nCreate an empty list called integerList to store spiral order elements.\\n2. Spiral Traversal Loop: Utilize a loop to visit all elements.\\n\\n3. Traverse Top Row (left to right): In the loop, move along the top row left to right:\\nUse a for loop with j from start_col to end_col.\\nAdd arr[start_row][j] to integerList.\\n\\n4. Traverse Right Column (top to bottom): Proceed to the rightmost column from top to bottom:\\n      Use a for loop with i from start_row + 1 to end_row.\\n      Add arr[i][end_col] to integerList.\\n\\n5. Traverse Bottom Row (right to left) if needed: If multiple rows are left (start_row < end_row), navigate the bottom row right to left:\\nEmploy a for loop with j from end_col - 1 to start_col.\\nAppend arr[end_row][j] to integerList.\\n\\n6. Traverse Left Column (bottom to top) if needed: If multiple columns are left (start_col < end_col), travel the leftmost column from bottom to top:\\nUse a for loop with i from end_row - 1 to start_row + 1.\\nAdd arr[i][start_col] to integerList.\\n\\n7. Update Boundaries: After one spiral loop, adjust start_col, start_row (inward movement), and end_col, end_row (boundary reduction).\\n\\n8. Repeat Steps 3-7: Continue these steps until all matrix elements are visited.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn terms of complexity, the time complexity is O(n * m) since each element is visited once, where \\'n\\' is the number of rows and \\'m\\' is the number of columns.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(n * m) because \\'integerList\\' stores all matrix elements in spiral order.\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> integerList = new ArrayList<>();\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int start_row = 0;\\n        int end_row = n - 1;\\n        int start_col = 0;\\n        int end_col = m - 1;\\n\\n        while (start_row <= end_row && start_col <= end_col) {\\n            // printing top elements\\n            for (int j = start_col; j <= end_col; j++) {\\n                integerList.add(arr[start_row][j]);\\n            }\\n\\n            // printing right elements\\n            for (int i = start_row + 1; i <= end_row; i++) {\\n                integerList.add(arr[i][end_col]);\\n            }\\n\\n            // printing bottom elements\\n            if (start_row < end_row) {\\n                for (int j = end_col - 1; j >= start_col; j--) {\\n                    integerList.add(arr[end_row][j]);\\n                }\\n            }\\n\\n            // printing left elements\\n            if (start_col < end_col) {\\n                for (int i = end_row - 1; i >= start_row + 1; i--) {\\n                    integerList.add(arr[i][start_col]);\\n                }\\n            }\\n\\n            start_col++;\\n            start_row++;\\n            end_col--;\\n            end_row--;\\n        }\\n\\n        return integerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> integerList = new ArrayList<>();\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int start_row = 0;\\n        int end_row = n - 1;\\n        int start_col = 0;\\n        int end_col = m - 1;\\n\\n        while (start_row <= end_row && start_col <= end_col) {\\n            // printing top elements\\n            for (int j = start_col; j <= end_col; j++) {\\n                integerList.add(arr[start_row][j]);\\n            }\\n\\n            // printing right elements\\n            for (int i = start_row + 1; i <= end_row; i++) {\\n                integerList.add(arr[i][end_col]);\\n            }\\n\\n            // printing bottom elements\\n            if (start_row < end_row) {\\n                for (int j = end_col - 1; j >= start_col; j--) {\\n                    integerList.add(arr[end_row][j]);\\n                }\\n            }\\n\\n            // printing left elements\\n            if (start_col < end_col) {\\n                for (int i = end_row - 1; i >= start_row + 1; i--) {\\n                    integerList.add(arr[i][start_col]);\\n                }\\n            }\\n\\n            start_col++;\\n            start_row++;\\n            end_col--;\\n            end_row--;\\n        }\\n\\n        return integerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502854,
                "title": "python-well-explained",
                "content": "# Approach\\n\\nThe optimized solution is a more efficient implementation of the same algorithm used in the original solution. Instead of using pop(0) to extract the first row of the matrix, we use four variables top, bottom, left, right to keep track of the boundaries of the matrix, and use loops to traverse the matrix in a spiral order.\\n\\nThe while loop iterates until top <= bottom and left <= right, which means that we have not yet traversed the entire matrix. Inside the loop, we use four for loops to traverse the matrix in a spiral order.\\n\\nThe first for loop traverses from left to right on the top row of the matrix, appending each element to the result list. Then, we increment top to exclude the top row from future iterations.\\n\\nThe second for loop traverses from top to bottom on the right column of the matrix, appending each element to the result list. Then, we decrement right to exclude the right column from future iterations.\\n\\nThe third for loop traverses from right to left on the bottom row of the matrix, appending each element to the result list. Then, we decrement bottom to exclude the bottom row from future iterations.\\n\\nThe fourth for loop traverses from bottom to top on the left column of the matrix, appending each element to the result list. Then, we increment left to exclude the left column from future iterations.\\n\\nWe continue this process until we have traversed the entire matrix.\\n\\n# Complexity\\n- Time complexity:\\n-\\nThe time complexity of the optimized solution is O(m * n) or O(n^2), where m and n are the number of rows and columns of the matrix, respectively. This is because we visit each element of the matrix once.\\n\\n- Space complexity:\\nThe space complexity of the optimized solution is O(1), since we only use constant extra space to store the result list and the boundary variables.\\n\\n#Algorithm\\n\\nWe can efficiently traverse the matrix in a spiral order by keeping track of the boundaries of the matrix using four variables top, bottom, left, right, and using loops to traverse the matrix in a spiral order. \\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        result = []\\n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\\n        \\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            # Traverse down\\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        result = []\\n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\\n        \\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            # Traverse down\\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557262,
                "title": "python-faster-than-97-short-and-simple-solution-with-comments",
                "content": "You have to do four operations to solve this:\\n- remove the top row\\n- remove the right row\\n- remove the bottom row\\n- remove the left row\\nand repeat until the matrix is empty.\\nwhen you remove a row, append all it\\'s element in a array and that\\'s the answer.\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = list()\\n        while len(matrix) > 0:\\n            try:\\n                result += matrix.pop(0) #remove the first nested list (top row)\\n                result += [x.pop(-1) for x in matrix] #remove every last element of the lists (right row)\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                result += matrix.pop(-1)[::-1] #remove last nested list in reverse order (bottom row)\\n                result += [x.pop(0) for x in matrix][::-1] #remove every last element of the lists (left row)\\n            except:\\n                break #if at any moment the matrix is empty, break the loop and return the result array\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = list()\\n        while len(matrix) > 0:\\n            try:\\n                result += matrix.pop(0) #remove the first nested list (top row)\\n                result += [x.pop(-1) for x in matrix] #remove every last element of the lists (right row)\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                result += matrix.pop(-1)[::-1] #remove last nested list in reverse order (bottom row)\\n                result += [x.pop(0) for x in matrix][::-1] #remove every last element of the lists (left row)\\n            except:\\n                break #if at any moment the matrix is empty, break the loop and return the result array\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600651,
                "title": "simple-java-solution-with-some-helpful-comments",
                "content": "\\n```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length==0) {\\n            return Collections.EMPTY_LIST;\\n        }\\n        List<Integer> cells = new ArrayList<>();\\n       int top = 0;\\n       int bottom =matrix.length-1;\\n        int left = 0;\\n        int right = matrix[0].length-1;\\n\\t\\t//loop while still in the matrix boundries \\n        while(top <= bottom && left <= right){\\n\\n           //move right\\n            for(int i = left; i<= right; i++){\\n                cells.add(matrix[top][i]);\\n            }\\n            \\n            //Set the top row pointer down to the next row\\n            top++;\\n            //\\n            //Move down\\n            for(int i = top; i<= bottom; i++){\\n                cells.add(matrix[i][right]);\\n            }\\n            //Move column pointer to left\\n            right--;\\n           \\n            //Move left\\n            if(top <= bottom){\\n                for(int i = right; i>= left; i--){\\n                    cells.add(matrix[bottom][i]);\\n                }\\n            }\\n            //Set bottom row pointer to next row up\\n            bottom--;\\n            //move up\\n            if(left <= right){\\n                for(int i = bottom; i>= top; i--){\\n                    cells.add(matrix[i][left]);\\n                }\\n            }\\n            //set left coulmn pointer to next column to the right\\n            left++;\\n        }\\n\\n        return cells;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length==0) {\\n            return Collections.EMPTY_LIST;\\n        }\\n        List<Integer> cells = new ArrayList<>();\\n       int top = 0;\\n       int bottom =matrix.length-1;\\n        int left = 0;\\n        int right = matrix[0].length-1;\\n\\t\\t//loop while still in the matrix boundries \\n        while(top <= bottom && left <= right){\\n\\n           //move right\\n            for(int i = left; i<= right; i++){\\n                cells.add(matrix[top][i]);\\n            }\\n            \\n            //Set the top row pointer down to the next row\\n            top++;\\n            //\\n            //Move down\\n            for(int i = top; i<= bottom; i++){\\n                cells.add(matrix[i][right]);\\n            }\\n            //Move column pointer to left\\n            right--;\\n           \\n            //Move left\\n            if(top <= bottom){\\n                for(int i = right; i>= left; i--){\\n                    cells.add(matrix[bottom][i]);\\n                }\\n            }\\n            //Set bottom row pointer to next row up\\n            bottom--;\\n            //move up\\n            if(left <= right){\\n                for(int i = bottom; i>= top; i--){\\n                    cells.add(matrix[i][left]);\\n                }\\n            }\\n            //set left coulmn pointer to next column to the right\\n            left++;\\n        }\\n\\n        return cells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20615,
                "title": "c-solutions-to-spiral-matrix-1-and-2-nearly-the-same",
                "content": "Here is Spiral Matrix 1 - build a list from the matrix\\n\\n```\\n    public IList<int> SpiralOrder(int[,] matrix) {\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        IList<int> list = new List<int>();\\n        int direction = 0;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++) list.Add(matrix[top, i]);\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++) list.Add(matrix[i, right]);\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--) list.Add(matrix[bottom, i]);\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--) list.Add(matrix[i, left]);\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return list;\\n    }\\n```\\n\\nHere is Spiral Matrix 2 - build the matrix from a list.  The only difference is that instead of capturing the matrix element you set the matrix element, the iteration is the same.\\n```\\n    public int[,] GenerateMatrix(int n) \\n    {\\n        int[,] matrix = new int[n,n];\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        int direction = 0;\\n        int num = 1;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++, num++) matrix[top, i] = num;\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++, num++) matrix[i, right] = num;\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--, num++) matrix[bottom, i] = num;\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--, num++) matrix[i, left] = num;\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return matrix;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> SpiralOrder(int[,] matrix) {\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        IList<int> list = new List<int>();\\n        int direction = 0;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++) list.Add(matrix[top, i]);\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++) list.Add(matrix[i, right]);\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--) list.Add(matrix[bottom, i]);\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--) list.Add(matrix[i, left]);\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return list;\\n    }\\n```\n```\\n    public int[,] GenerateMatrix(int n) \\n    {\\n        int[,] matrix = new int[n,n];\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        int direction = 0;\\n        int num = 1;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++, num++) matrix[top, i] = num;\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++, num++) matrix[i, right] = num;\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--, num++) matrix[bottom, i] = num;\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--, num++) matrix[i, left] = num;\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return matrix;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20791,
                "title": "c-concise-solution",
                "content": "        \\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return {};\\n        vector<int> res;\\n        int left, right, top, down, index;\\n        left = top = 0, down = matrix.size()-1, right = matrix[0].size()-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res.push_back(matrix[top][j]);\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res.push_back(matrix[i][right]);\\n            right--;\\n            if (top <= down) {\\n                for(int j = right; j >= left; j--)\\n                    res.push_back(matrix[down][j]);\\n                down--;\\n            }\\n            if (left <= right) {\\n                for (int i = down; i >= top; i--)\\n                    res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return {};\\n        vector<int> res;\\n        int left, right, top, down, index;\\n        left = top = 0, down = matrix.size()-1, right = matrix[0].size()-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res.push_back(matrix[top][j]);\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res.push_back(matrix[i][right]);\\n            right--;\\n            if (top <= down) {\\n                for(int j = right; j >= left; j--)\\n                    res.push_back(matrix[down][j]);\\n                down--;\\n            }\\n            if (left <= right) {\\n                for (int i = down; i >= top; i--)\\n                    res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3506264,
                "title": "java-spiral-matrix",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answ = new ArrayList<>();\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] != -200) {\\n                    answ.add(matrix[x][y]);\\n                    matrix[x][y] = -200;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answ = new ArrayList<>();\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] != -200) {\\n                    answ.add(matrix[x][y]);\\n                    matrix[x][y] = -200;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284606,
                "title": "3-the-most-efficient-python-solution-with-short-explanation",
                "content": "#   Sulution #1\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res.extend(matrix.pop(0))\\n            if matrix and matrix[0]:\\n                res.extend([row.pop() for row in matrix])\\n            if matrix:\\n                res.extend(matrix.pop()[::-1])\\n            if matrix and matrix[0]:\\n                res.extend([row.pop(0) for row in matrix][::-1])\\n        return res\\n```\\n- Create an empty list called res to store the result.\\n\\n- Enter a while loop that will continue as long as there are still rows in the matrix. This loop will iterate over the matrix in a clockwise spiral order, appending the elements to res.\\n\\n- Append the first row of the matrix to res using the extend method of lists. This removes the first row from the matrix using pop(0).\\n\\n- Check if the matrix is not empty and if the first row of the matrix is not empty. If this is true, then iterate over each row in the matrix and append the last element of each row to res using a list comprehension. This removes the last element from each row using pop().\\n\\n- Check if the matrix is not empty. If this is true, then append the last row of the matrix to res in reverse order using the extend method and a slice that reverses the order of the row ([::-1]). This removes the last row from the matrix using pop().\\n\\n- Check if the matrix is not empty and if the first row of the matrix is not empty. If this is true, then iterate over each row in the matrix in reverse order and append the first element of each row to res using a list comprehension. This removes the first element from each row using pop(0).\\n\\n- Return the res list containing all the elements of the matrix in a clockwise spiral order.\\n\\n\\n# Sulution #2\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res += matrix.pop(0)\\n            matrix = [*zip(*matrix)][::-1]\\n        return res\\n```\\n- res = []: Initialize an empty list called res to store the result.\\n\\n- while matrix:: Loop through the matrix while it is not empty.\\n\\n- res += matrix.pop(0): Append the first row of the matrix to res and remove it from the matrix.\\n\\n- matrix = [*zip(*matrix)][::-1]: Transpose the matrix (convert rows to columns and columns to rows), reverse the order of the rows, and assign it back to matrix. This effectively rotates the matrix counterclockwise by 90 degrees.\\n\\n- return res: Return the final result.\\n\\n\\n# Sulution #3\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\\n- If the matrix is empty or None, return an empty list.\\n\\n- Take the first row of the matrix using \"matrix.pop(0)\" and convert it to a list using [*] operator. This represents the top row of the spiral.\\n\\n- Transpose the remaining matrix using \"zip(*matrix)\" which effectively rotates the matrix clockwise by 90 degrees.\\n\\n- Reverse the order of the rows of the transposed matrix using [::-1] operator. This ensures that the next row to be traversed is the one adjacent to the bottom row of the original matrix.\\n\\n- Recursively call the \"spiralOrder\" method on the transposed and reversed matrix.\\n\\n- Concatenate the top row of the original matrix with the result of the recursive call to get the final spiral order traversal of the matrix.\\n\\n- Return the list of integers representing the spiral order traversal of the matrix.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res.extend(matrix.pop(0))\\n            if matrix and matrix[0]:\\n                res.extend([row.pop() for row in matrix])\\n            if matrix:\\n                res.extend(matrix.pop()[::-1])\\n            if matrix and matrix[0]:\\n                res.extend([row.pop(0) for row in matrix][::-1])\\n        return res\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res += matrix.pop(0)\\n            matrix = [*zip(*matrix)][::-1]\\n        return res\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466651,
                "title": "c-spiral-traverse-clean-concise",
                "content": "We just need to move right and increment rowBegin, then slide down and decrease colEnd, then traverse left and descend rowEnd, and finally sideways up and increase colBegin.\\n\\nWhen going left or up, must check if the row or column still exists or not to avoid duplication.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>> &matrix) {\\n        vector<int> result;\\n        int rowBegin, colBegin, rowEnd, colEnd;\\n        rowBegin = colBegin = 0, rowEnd = matrix.size() - 1, colEnd = matrix[0].size() - 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int j = colBegin; j <= colEnd; j++)  // Traverse Right\\n                result.push_back(matrix[rowBegin][j]);\\n            \\n            for (int i = ++rowBegin; i <= rowEnd; i++) // Traverse Down\\n                result.push_back(matrix[i][colEnd]);\\n            \\n            for (int j = --colEnd; rowBegin <= rowEnd && j >= colBegin; j--) // Traverse Left\\n                result.push_back(matrix[rowEnd][j]);\\n            \\n            for (int i = --rowEnd; colBegin <= colEnd && i >= rowBegin; i--) // Traver Up\\n                result.push_back(matrix[i][colBegin]);\\n            \\n            colBegin++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>> &matrix) {\\n        vector<int> result;\\n        int rowBegin, colBegin, rowEnd, colEnd;\\n        rowBegin = colBegin = 0, rowEnd = matrix.size() - 1, colEnd = matrix[0].size() - 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int j = colBegin; j <= colEnd; j++)  // Traverse Right\\n                result.push_back(matrix[rowBegin][j]);\\n            \\n            for (int i = ++rowBegin; i <= rowEnd; i++) // Traverse Down\\n                result.push_back(matrix[i][colEnd]);\\n            \\n            for (int j = --colEnd; rowBegin <= rowEnd && j >= colBegin; j--) // Traverse Left\\n                result.push_back(matrix[rowEnd][j]);\\n            \\n            for (int i = --rowEnd; colBegin <= colEnd && i >= rowBegin; i--) // Traver Up\\n                result.push_back(matrix[i][colBegin]);\\n            \\n            colBegin++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867810,
                "title": "python-code-easy-to-understand-with-comments",
                "content": "```\\n\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        res = []\\n\\n        h = len(matrix)\\n        if h < 1:\\n            return res\\n        w = len(matrix[0])\\n\\n        # pointers we will use to iterate round the matrix\\n        top = 0\\n        bottom = h - 1\\n        left = 0\\n        right = w - 1\\n\\n        while top <= bottom and left <= right:\\n\\n            # TOP section: left to right\\n            l = left\\n            while l <= right:  # and left <= right: <-- we will never reach that condition\\n                res.append(matrix[top][l])\\n                l += 1\\n            # move lower\\n            # because: added all from the top area\\n            top += 1\\n\\n            # RIGHT section: top to bottom\\n            t = top\\n            while t <= bottom:  # and top <= bottom: <-- we will never reach that condition\\n                res.append(matrix[t][right])\\n                t += 1\\n            # move pointer to the left\\n            # done with right-most section\\n            right -= 1\\n\\n            # BOTTOM section: right to left\\n            # on the last of the spiral, char: right = left, therefore, r = left\\n            # so the while loop might run again\\n            r = right\\n            while r >= left and top <= bottom:\\n                res.append(matrix[bottom][r])\\n                r -= 1\\n            bottom -= 1\\n\\n            # LEFT section: bottom to top\\n            # on the last of the spiral, char: bottom = top, therefore, b = top\\n            # so the while loop might run again\\n            # that\\'s why we have the extra condition\\n            b = bottom\\n            while b >= top and left <= right:\\n                res.append(matrix[b][left])\\n                b -= 1\\n            left += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        res = []\\n\\n        h = len(matrix)\\n        if h < 1:\\n            return res\\n        w = len(matrix[0])\\n\\n        # pointers we will use to iterate round the matrix\\n        top = 0\\n        bottom = h - 1\\n        left = 0\\n        right = w - 1\\n\\n        while top <= bottom and left <= right:\\n\\n            # TOP section: left to right\\n            l = left\\n            while l <= right:  # and left <= right: <-- we will never reach that condition\\n                res.append(matrix[top][l])\\n                l += 1\\n            # move lower\\n            # because: added all from the top area\\n            top += 1\\n\\n            # RIGHT section: top to bottom\\n            t = top\\n            while t <= bottom:  # and top <= bottom: <-- we will never reach that condition\\n                res.append(matrix[t][right])\\n                t += 1\\n            # move pointer to the left\\n            # done with right-most section\\n            right -= 1\\n\\n            # BOTTOM section: right to left\\n            # on the last of the spiral, char: right = left, therefore, r = left\\n            # so the while loop might run again\\n            r = right\\n            while r >= left and top <= bottom:\\n                res.append(matrix[bottom][r])\\n                r -= 1\\n            bottom -= 1\\n\\n            # LEFT section: bottom to top\\n            # on the last of the spiral, char: bottom = top, therefore, b = top\\n            # so the while loop might run again\\n            # that\\'s why we have the extra condition\\n            b = bottom\\n            while b >= top and left <= right:\\n                res.append(matrix[b][left])\\n                b -= 1\\n            left += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210241,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n     let res = [];\\n    \\n     if (matrix.length == 0) {\\n            return res;\\n        }  \\n    \\n    let rowBegin =0;\\n    let rowEnd = matrix.length -1;\\n    let colBegin =0;\\n    let colEnd = matrix[0].length -1;\\n    \\n    while(rowBegin <= rowEnd && colBegin <= colEnd) {\\n        //right\\n        for(let i=colBegin;i<=colEnd;i++){\\n            res.push(matrix[rowBegin][i])\\n        }\\n        ++rowBegin;\\n        //bottom\\n        for(let i=rowBegin ;i<=rowEnd;i++) {\\n            res.push(matrix[i][colEnd])\\n        }\\n        --colEnd;\\n        //scan bottom right to left\\n        if (rowBegin <= rowEnd) {\\n            for(let i=colEnd; i>=colBegin;i--) {\\n                res.push(matrix[rowEnd][i])\\n            }\\n        }\\n        --rowEnd;\\n        //scan left to top\\n        if(colBegin <= colEnd){\\n             for(let i=rowEnd;i>= rowBegin; i--){\\n                res.push(matrix[i][colBegin])\\n            }\\n        }   \\n        ++colBegin;\\n     }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n     let res = [];\\n    \\n     if (matrix.length == 0) {\\n            return res;\\n        }  \\n    \\n    let rowBegin =0;\\n    let rowEnd = matrix.length -1;\\n    let colBegin =0;\\n    let colEnd = matrix[0].length -1;\\n    \\n    while(rowBegin <= rowEnd && colBegin <= colEnd) {\\n        //right\\n        for(let i=colBegin;i<=colEnd;i++){\\n            res.push(matrix[rowBegin][i])\\n        }\\n        ++rowBegin;\\n        //bottom\\n        for(let i=rowBegin ;i<=rowEnd;i++) {\\n            res.push(matrix[i][colEnd])\\n        }\\n        --colEnd;\\n        //scan bottom right to left\\n        if (rowBegin <= rowEnd) {\\n            for(let i=colEnd; i>=colBegin;i--) {\\n                res.push(matrix[rowEnd][i])\\n            }\\n        }\\n        --rowEnd;\\n        //scan left to top\\n        if(colBegin <= colEnd){\\n             for(let i=rowEnd;i>= rowBegin; i--){\\n                res.push(matrix[i][colBegin])\\n            }\\n        }   \\n        ++colBegin;\\n     }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20877,
                "title": "concise-solution-in-java",
                "content": "After each iteration the scope of each for loop is reduced. The if condition before the two last loops is to avoid duplicates.\\n\\n\\n     public List<Integer> spiralOrder(int[][] mtx) {\\n        List<Integer> ret=new LinkedList<>();\\n        if(mtx.length==0)return ret;\\n        int m=mtx.length;\\n        int n=mtx[0].length;\\n        int min=Math.min(m,n);\\n        for(int b=0;b<Math.ceil(min/2.);b++){\\n            for(int a=b;a<n-b;a++)ret.add(mtx[b][a]);\\n            for(int a=b+1;a<m-b;a++)ret.add(mtx[a][n-b-1]);\\n            if(b!=m-b-1)for(int a=n-b-2;a>=b;a--)ret.add(mtx[m-b-1][a]);\\n            if(n-b-1!=b)for(int a=m-b-2;a>b;a--)ret.add(mtx[a][b]);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "After each iteration the scope of each for loop is reduced. The if condition before the two last loops is to avoid duplicates.\\n\\n\\n     public List<Integer> spiralOrder(int[][] mtx) {\\n        List<Integer> ret=new LinkedList<>();\\n        if(mtx.length==0)return ret;\\n        int m=mtx.length;\\n        int n=mtx[0].length;\\n        int min=Math.min(m,n);\\n        for(int b=0;b<Math.ceil(min/2.);b++){\\n            for(int a=b;a<n-b;a++)ret.add(mtx[b][a]);\\n            for(int a=b+1;a<m-b;a++)ret.add(mtx[a][n-b-1]);\\n            if(b!=m-b-1)for(int a=n-b-2;a>=b;a--)ret.add(mtx[m-b-1][a]);\\n            if(n-b-1!=b)for(int a=m-b-2;a>b;a--)ret.add(mtx[a][b]);\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3857175,
                "title": "iterative-c-approach",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION**\\n# Approach\\nInitialize variables:\\n\\nn is the number of rows in the matrix.\\nm is the number of columns in the matrix.\\nstartrow, startcol, endrow, and endcol are pointers to represent the boundaries of the current spiral.\\ntotal is the total number of elements in the matrix (n * m).\\ncount is used to keep track of the number of elements added to the result vector ans.\\nUse a while loop that runs as long as count is less than total, indicating that not all elements have been traversed yet.\\n\\nTraverse the matrix in four steps:\\na. Starting row: Traverse from left to right in the current startrow from startcol to endcol.\\nb. Ending column: Traverse from top to bottom in the current endcol from startrow to endrow.\\nc. Ending row: Traverse from right to left in the current endrow from endcol to startcol.\\nd. Starting column: Traverse from bottom to top in the current startcol from endrow to startrow.\\n\\nAfter each step, update the corresponding boundary (startrow, startcol, endrow, endcol) to move towards the center of the matrix. Also, increment the count by the number of elements traversed in that step.\\n\\nRepeat the above steps until all elements are traversed (count == total).\\n\\nReturn the ans vector containing the spiral order traversal of the matrix.\\n\\nNote: The code assumes that the input matrix is non-empty and a valid 2D matrix (i.e., all rows have the same number of elements). If the input matrix is empty or has different-sized rows, the code might encounter undefined behavior.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n         vector<int>ans;\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=n-1;\\n        int endcol=m-1;\\n        int total=n*m;\\n        int count =0;\\n        while(count<total)\\n        {\\n            // starting row \\n            for(int i = startcol; count<total && i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[startrow][i]);\\n                count++;\\n            }\\n            startrow++;\\n            // ending col\\n            for(int i = startrow; count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            // ending row\\n            for(int i = endcol; count<total && i>=startcol;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;\\n            }\\n            endrow--;\\n            // starting col\\n            for(int i = endrow; count<total && i>=startrow;i--)\\n            {\\n                ans.push_back(matrix[i][startcol]);\\n                count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n         vector<int>ans;\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=n-1;\\n        int endcol=m-1;\\n        int total=n*m;\\n        int count =0;\\n        while(count<total)\\n        {\\n            // starting row \\n            for(int i = startcol; count<total && i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[startrow][i]);\\n                count++;\\n            }\\n            startrow++;\\n            // ending col\\n            for(int i = startrow; count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            // ending row\\n            for(int i = endcol; count<total && i>=startcol;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;\\n            }\\n            endrow--;\\n            // starting col\\n            for(int i = endrow; count<total && i>=startrow;i--)\\n            {\\n                ans.push_back(matrix[i][startcol]);\\n                count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516257,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "![Screenshot 2023-05-12 at 18.46.26.png](https://assets.leetcode.com/users/images/16dbbe6b-5966-43be-ab4c-cc1dea8d1275_1683897410.5314755.png)\\n\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize four variables: l, r, t, b, representing the start and end indices of the rows and columns of the submatrix we are currently traversing.\\n2. Traverse the top row from left to right, incrementing the column index  at each step. When the traversal reaches the last column, update the t variable to move down to the next row.\\n3. Traverse the right column from top to bottom, decrementing the row index at each step. When the traversal reaches the last row, update the r variable to move to the next column.\\n4. Traverse the bottom row from right to left, decrementing the column index at each step. When the traversal reaches the first column, update the b variable to move up to the next row.\\n5. Traverse the left column from bottom to top, incrementing the row index at each step. When the traversal reaches the first row, update the l variable to move to the next column.\\n\\nRepeat steps 2-5 until all elements have been traversed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> res = new ArrayList<>();\\n        int b = arr.length, r = arr[0].length;\\n        int t = 0, l = 0, size = b*r;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                res.add(arr[t][i]);\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                res.add(arr[i][r-1]);\\n            }\\n            r--;\\n            if(res.size()>=size){\\n                break;\\n            }\\n            for (int i = r-1; i >= l; i--) {\\n                res.add(arr[b-1][i]);\\n            }\\n            b--;\\n            if(res.size()>=size)\\n                break;\\n            for (int i = b-1; i >= t; i--) {\\n                res.add(arr[i][l]);\\n            }\\n            l++;\\n            if(res.size()>=size)\\n                break;\\n\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> res = new ArrayList<>();\\n        int b = arr.length, r = arr[0].length;\\n        int t = 0, l = 0, size = b*r;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                res.add(arr[t][i]);\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                res.add(arr[i][r-1]);\\n            }\\n            r--;\\n            if(res.size()>=size){\\n                break;\\n            }\\n            for (int i = r-1; i >= l; i--) {\\n                res.add(arr[b-1][i]);\\n            }\\n            b--;\\n            if(res.size()>=size)\\n                break;\\n            for (int i = b-1; i >= t; i--) {\\n                res.add(arr[i][l]);\\n            }\\n            l++;\\n            if(res.size()>=size)\\n                break;\\n\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507927,
                "title": "easy-understandable-approach",
                "content": "# Easy understandable APPROACH:-\\n**T.C =O(N)**\\n# Approach:-\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int strow=0;\\n        int stcol=0;\\n        int endrow=row-1;\\n        int endcol=col-1;\\n        int total=row*col;\\n        int count =0;      // to count no. of elements \\n        \\n        while(count<total)\\n        {\\n\\t\\t   // for first traverse from top of matrix i.e. from left to right   \\n            for(int i=stcol;count<total &&  i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++;\\n            }\\n            strow++;   // once row gets traversed increased the startRow by 1 so that it could come to next index\\n\\t\\t\\t\\n\\t\\t\\t// for traversing last column to continue spiral rotation in a matrix i.e. from top to bottom\\n            for(int i=strow;count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;  // once the last column gets pushed in the ans vector decrement it by 1 so that it could point to just before wala column\\n\\t\\t\\t // for traversing from right to left in a last row\\n            for(int i=endcol;count<total && i>=stcol;i--)\\n            {\\n              ans.push_back(matrix[endrow][i]);\\n                  count++;\\n            }\\n            endrow--; // decreament endRow by 1 so that it could reach above wala row\\n            for(int i=endrow;count<total && i>=strow;i--)\\n            {\\n              ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;  //increament the startingcol by 1 \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c163df13-909e-4fed-8d68-49d19e1a2080_1683706705.6780376.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int strow=0;\\n        int stcol=0;\\n        int endrow=row-1;\\n        int endcol=col-1;\\n        int total=row*col;\\n        int count =0;      // to count no. of elements \\n        \\n        while(count<total)\\n        {\\n\\t\\t   // for first traverse from top of matrix i.e. from left to right   \\n            for(int i=stcol;count<total &&  i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++;\\n            }\\n            strow++;   // once row gets traversed increased the startRow by 1 so that it could come to next index\\n\\t\\t\\t\\n\\t\\t\\t// for traversing last column to continue spiral rotation in a matrix i.e. from top to bottom\\n            for(int i=strow;count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;  // once the last column gets pushed in the ans vector decrement it by 1 so that it could point to just before wala column\\n\\t\\t\\t // for traversing from right to left in a last row\\n            for(int i=endcol;count<total && i>=stcol;i--)\\n            {\\n              ans.push_back(matrix[endrow][i]);\\n                  count++;\\n            }\\n            endrow--; // decreament endRow by 1 so that it could reach above wala row\\n            for(int i=endrow;count<total && i>=strow;i--)\\n            {\\n              ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;  //increament the startingcol by 1 \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503815,
                "title": "beginner-friendly-simple-fastest-c-explanation-optimal-solution-beats-100",
                "content": "# Intuition\\nThe most optimal solution to this problem is the most simple and the most basic. We need to traverse the entire matrix in a spiral order. Starting from the top-left to the bottom-right and then the vice-versa.\\n\\n# Explanation\\n-> We need to iterate through the matrix until all the elements of the matrix are appended to the array. For this, we use the concept of nested loops.\\n1) The first loop traverses from the top-left corner to the top-right corner, incrementing the top at the end.\\n2) The second loop traverses from the top-right corner to the bottom-right corner, decrementing the right at the end.\\n3) The third loop traverses from the bottom-right corner to the bottom-left corner, decrementing the bottom at the end.\\n4) The last loop traverses from the bottom-left corner to the top-left corner, incrementing the left at the end.\\n\\n-> If at any instance, the size of the array is equal than the size of the matrix, we return the resultant array.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size(),top=0,left=0,right=m-1,\\n        bottom=n-1;\\n        vector<int> v;\\n        while(v.size()!=m*n){\\n            for(int i=left;v.size()!=m*n and i<=right;i++){\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            for(int i=top;v.size()!=m*n and i<=bottom;i++){\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int i=right;v.size()!=m*n and i>=left;i--){\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            for(int i=bottom;v.size()!=m*n and i>=top;i--){\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size(),top=0,left=0,right=m-1,\\n        bottom=n-1;\\n        vector<int> v;\\n        while(v.size()!=m*n){\\n            for(int i=left;v.size()!=m*n and i<=right;i++){\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            for(int i=top;v.size()!=m*n and i<=bottom;i++){\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int i=right;v.size()!=m*n and i>=left;i--){\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            for(int i=bottom;v.size()!=m*n and i>=top;i--){\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502615,
                "title": "short-easy-clean-solution-w-clear-explanation-bfs-o-nm-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo print the resulting matrix, we can simply simulate procedure for this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nEssentially, we want to switch to the next direction anytime that we can\\'t keep going in the existing direction. I.e: Going out of bounds or revisiting a cell. Therefore, we can run a BFS with preset direction orderings. Everytime, we attempt to go in our current direction, and if we can\\'t, we try the next directoin until we can continue in that new direction. The directions is ordered by Right, Down, Left, and Up to simulate the ordering the problem wants for the spiral matrix.\\n\\n# Complexity\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        Queue<Pos> q = new LinkedList<>();\\n        q.add(new Pos(0, 0, 0));\\n\\n        int[] dx = {0, 1, 0, -1};\\n        int[] dy = {1, 0, -1, 0};\\n        ans.add(matrix[0][0]);\\n        matrix[0][0] = 101;\\n        while (!q.isEmpty()) {\\n            Pos p = q.poll();\\n            int i = p.i;\\n            int j = p.j;\\n            \\n            for (int k = p.dir; k < p.dir + 4; k++) {\\n                int ix = k % 4;\\n                int ni = i + dx[ix];\\n                int nj = j + dy[ix];\\n                if (ni < 0 || ni >= matrix.length || nj < 0 || nj >= matrix[0].length) continue;\\n                if (matrix[ni][nj] == 101) continue;\\n                ans.add(matrix[ni][nj]);\\n                matrix[ni][nj] = 101;\\n                q.add(new Pos(ni, nj, ix));\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    class Pos {\\n        int i, j, dir;\\n        public Pos(int a, int b, int d) {\\n            i = a; j = b; dir = d;\\n        }\\n    }\\n}\\n```\\n\\n\\nPlease consider upvoting :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        Queue<Pos> q = new LinkedList<>();\\n        q.add(new Pos(0, 0, 0));\\n\\n        int[] dx = {0, 1, 0, -1};\\n        int[] dy = {1, 0, -1, 0};\\n        ans.add(matrix[0][0]);\\n        matrix[0][0] = 101;\\n        while (!q.isEmpty()) {\\n            Pos p = q.poll();\\n            int i = p.i;\\n            int j = p.j;\\n            \\n            for (int k = p.dir; k < p.dir + 4; k++) {\\n                int ix = k % 4;\\n                int ni = i + dx[ix];\\n                int nj = j + dy[ix];\\n                if (ni < 0 || ni >= matrix.length || nj < 0 || nj >= matrix[0].length) continue;\\n                if (matrix[ni][nj] == 101) continue;\\n                ans.add(matrix[ni][nj]);\\n                matrix[ni][nj] = 101;\\n                q.add(new Pos(ni, nj, ix));\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    class Pos {\\n        int i, j, dir;\\n        public Pos(int a, int b, int d) {\\n            i = a; j = b; dir = d;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284596,
                "title": "one-line-python-solution-beats-89-91-88-11",
                "content": "enjoy\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120847,
                "title": "97-fast-javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/WgYpGizBdUo\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let r = matrix.length;\\n    let c = matrix[0].length;\\n    let direction = 0;\\n    let left = 0;\\n    let right = c-1;\\n    let bottom = 0;\\n    let top = r-1;\\n\\n    while(arr.length<r*c){\\n        if(direction == 0){\\n            for(let i = left; i<=right; i++){\\n                arr.push(matrix[bottom][i])\\n            }\\n            bottom++\\n            direction++\\n        }\\n        else if(direction == 1){\\n            for(let i = bottom; i<=top; i++){\\n                arr.push(matrix[i][right])\\n            }\\n            right--\\n            direction++\\n        }\\n        else if(direction == 2){\\n            for(let i = right; i>=left;i--){\\n                arr.push(matrix[top][i])\\n            }\\n            top--\\n            direction++\\n        }\\n        else if(direction==3){\\n            for(let i =top; i>=bottom; i--){\\n                arr.push(matrix[i][left])\\n            }\\n            left++\\n            direction++\\n        }\\n        if(direction == 4) direction = 0;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let r = matrix.length;\\n    let c = matrix[0].length;\\n    let direction = 0;\\n    let left = 0;\\n    let right = c-1;\\n    let bottom = 0;\\n    let top = r-1;\\n\\n    while(arr.length<r*c){\\n        if(direction == 0){\\n            for(let i = left; i<=right; i++){\\n                arr.push(matrix[bottom][i])\\n            }\\n            bottom++\\n            direction++\\n        }\\n        else if(direction == 1){\\n            for(let i = bottom; i<=top; i++){\\n                arr.push(matrix[i][right])\\n            }\\n            right--\\n            direction++\\n        }\\n        else if(direction == 2){\\n            for(let i = right; i>=left;i--){\\n                arr.push(matrix[top][i])\\n            }\\n            top--\\n            direction++\\n        }\\n        else if(direction==3){\\n            for(let i =top; i>=bottom; i--){\\n                arr.push(matrix[i][left])\\n            }\\n            left++\\n            direction++\\n        }\\n        if(direction == 4) direction = 0;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046949,
                "title": "fastest-efficient-c-solution",
                "content": "**When you look at the title of the problem and visualise the test cases (and also come to know that this problem is asked in the interview rounds of many different fortune companies), it might look like ->**\\n\\n![spiral.png](https://assets.leetcode.com/users/images/1b952ff1-d211-447d-953f-f797c8dce488_1673638972.7788875.png)\\n\\n***Hypnotised right ? Don\\'t Worry, I got your back.***\\n# HAVE PATIENCE AND JUST PLAY WITH THE LOOPS FOR A WHILE WITH ME AND ITS DONE!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        //declared startrow,startcol and initialised them with 0\\n        int startrow=0;\\n        int startcol=0;\\n\\n        //declared end row and assigned it the size of the row of the matrix\\n        int endrow = matrix.size()-1;\\n\\n        //declared end column and assigned it the size of the column of the matrix\\n        int endcol = matrix[0].size()-1;\\n\\n        //declared a vector named ans of integer datatype\\n        vector<int> ans;\\n\\n        //now traverse the matrix spirally \\n        while(startrow<=endrow && startcol<=endcol){\\n            //from left to right\\n            for(int i=startcol;i<=endcol;++i){   \\n                ans.push_back(matrix[startrow][i]); \\n            }\\n            startrow++;\\n\\n            //from top to bottom\\n            for(int i=startrow;i<=endrow;++i){  \\n                ans.push_back(matrix[i][endcol]);\\n            }\\n            endcol--;\\n            \\n            ////if startrow is not less than or equal to endrow OR startcol is not less than or equal to endcol then break the loop and return (this could be easily visualised by taking different\\n            if((startrow>endrow) || (startcol>endcol)){\\n                break;\\n            }\\n\\n            //from right to left\\n            for(int i=endcol;i>=startcol;--i){ \\n                ans.push_back(matrix[endrow][i]);\\n            }\\n            endrow--;\\n\\n            //from bottom to top\\n            for(int i=endrow;i>=startrow;--i){ \\n                ans.push_back(matrix[i][startcol]);\\n            }\\n            startcol++;\\n\\n        }\\n\\n        //return the vector\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# HAPPY CODING!\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        //declared startrow,startcol and initialised them with 0\\n        int startrow=0;\\n        int startcol=0;\\n\\n        //declared end row and assigned it the size of the row of the matrix\\n        int endrow = matrix.size()-1;\\n\\n        //declared end column and assigned it the size of the column of the matrix\\n        int endcol = matrix[0].size()-1;\\n\\n        //declared a vector named ans of integer datatype\\n        vector<int> ans;\\n\\n        //now traverse the matrix spirally \\n        while(startrow<=endrow && startcol<=endcol){\\n            //from left to right\\n            for(int i=startcol;i<=endcol;++i){   \\n                ans.push_back(matrix[startrow][i]); \\n            }\\n            startrow++;\\n\\n            //from top to bottom\\n            for(int i=startrow;i<=endrow;++i){  \\n                ans.push_back(matrix[i][endcol]);\\n            }\\n            endcol--;\\n            \\n            ////if startrow is not less than or equal to endrow OR startcol is not less than or equal to endcol then break the loop and return (this could be easily visualised by taking different\\n            if((startrow>endrow) || (startcol>endcol)){\\n                break;\\n            }\\n\\n            //from right to left\\n            for(int i=endcol;i>=startcol;--i){ \\n                ans.push_back(matrix[endrow][i]);\\n            }\\n            endrow--;\\n\\n            //from bottom to top\\n            for(int i=endrow;i>=startrow;--i){ \\n                ans.push_back(matrix[i][startcol]);\\n            }\\n            startcol++;\\n\\n        }\\n\\n        //return the vector\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760215,
                "title": "java-100-faster-time-compexity-o-m-n",
                "content": "# Intuition\\nPlease upvote if you find it useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int i, k = 0, l = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length, n = matrix[0].length;\\n        /*  k - starting row index\\n        m - ending row index\\n        l - starting column index\\n        n - ending column index\\n        i - iterator\\n        */\\n \\n        while (k < m && l < n) {\\n            // Print the first row from the remaining rows\\n            for (i = l; i < n; ++i) {\\n                ans.add(matrix[k][i] );\\n            }\\n            k++;\\n \\n            // Print the last column from the remaining\\n            // columns\\n            for (i = k; i < m; ++i) {\\n                ans.add(matrix[i][n - 1] );\\n            }\\n            n--;\\n \\n            // Print the last row from the remaining rows */\\n            if (k < m) {\\n                for (i = n - 1; i >= l; --i) {\\n                    ans.add(matrix[m - 1][i]);\\n                }\\n                m--;\\n            }\\n \\n            // Print the first column from the remaining\\n            // columns */\\n            if (l < n) {\\n                for (i = m - 1; i >= k; --i) {\\n                    ans.add(matrix[i][l]);\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int i, k = 0, l = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length, n = matrix[0].length;\\n        /*  k - starting row index\\n        m - ending row index\\n        l - starting column index\\n        n - ending column index\\n        i - iterator\\n        */\\n \\n        while (k < m && l < n) {\\n            // Print the first row from the remaining rows\\n            for (i = l; i < n; ++i) {\\n                ans.add(matrix[k][i] );\\n            }\\n            k++;\\n \\n            // Print the last column from the remaining\\n            // columns\\n            for (i = k; i < m; ++i) {\\n                ans.add(matrix[i][n - 1] );\\n            }\\n            n--;\\n \\n            // Print the last row from the remaining rows */\\n            if (k < m) {\\n                for (i = n - 1; i >= l; --i) {\\n                    ans.add(matrix[m - 1][i]);\\n                }\\n                m--;\\n            }\\n \\n            // Print the first column from the remaining\\n            // columns */\\n            if (l < n) {\\n                for (i = m - 1; i >= k; --i) {\\n                    ans.add(matrix[i][l]);\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681064,
                "title": "java-100-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list=new ArrayList<>();\\n        int left=0,right=matrix[0].length;\\n        int top=0,bottom=matrix.length;\\n        while(left<right && top<bottom){\\n        for(int i=left;i<right;i++){\\n            list.add(matrix[top][i]);\\n        }\\n        top+=1;\\n        for(int i=top;i<bottom;i++){\\n            list.add(matrix[i][right-1]);\\n        }\\n        right-=1;\\n         if (!(left<right && top<bottom)){\\n                break;\\n            }\\n        for(int i=right-1;i>left;i--){\\n            list.add(matrix[bottom-1][i]);\\n        }\\n        bottom-=1;\\n        for(int i=bottom;i>=top;i--){\\n            list.add(matrix[i][left]);\\n        }\\n        left+=1;\\n    }\\n        return list;\\n    }\\n    \\n}\\n```\\n**Pls upvote if u like it**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list=new ArrayList<>();\\n        int left=0,right=matrix[0].length;\\n        int top=0,bottom=matrix.length;\\n        while(left<right && top<bottom){\\n        for(int i=left;i<right;i++){\\n            list.add(matrix[top][i]);\\n        }\\n        top+=1;\\n        for(int i=top;i<bottom;i++){\\n            list.add(matrix[i][right-1]);\\n        }\\n        right-=1;\\n         if (!(left<right && top<bottom)){\\n                break;\\n            }\\n        for(int i=right-1;i>left;i--){\\n            list.add(matrix[bottom-1][i]);\\n        }\\n        bottom-=1;\\n        for(int i=bottom;i>=top;i--){\\n            list.add(matrix[i][left]);\\n        }\\n        left+=1;\\n    }\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477682,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        int top = 0,left = 0,bottom = matrix.length -1,right = matrix[0].length -1;\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t//Top Row\\n            for(int i = left ; i <= right ; i++){\\n                al.add(matrix[top][i]);\\n            }\\n            top++;\\n\\t\\t\\t//Right Column\\n            for(int i = top ; i <= bottom; i++){\\n                al.add(matrix[i][right]);\\n            }\\n            right--;\\n\\t\\t\\t//Bottom Row\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    al.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\t\\t\\t//Left Column\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    al.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        int top = 0,left = 0,bottom = matrix.length -1,right = matrix[0].length -1;\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t//Top Row\\n            for(int i = left ; i <= right ; i++){\\n                al.add(matrix[top][i]);\\n            }\\n            top++;\\n\\t\\t\\t//Right Column\\n            for(int i = top ; i <= bottom; i++){\\n                al.add(matrix[i][right]);\\n            }\\n            right--;\\n\\t\\t\\t//Bottom Row\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    al.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\t\\t\\t//Left Column\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    al.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467152,
                "title": "c-simple-solution-using-for-loops-with-comments-for-understanding",
                "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> output;\\n        int l1=matrix.size();\\n        int l2=matrix[0].size();\\n        \\n        int top,bottom,left,right;\\n        // top and bottom are used to keep the count of rows.\\n        top = 0;\\n        bottom = l1-1;\\n        \\n        // left and right are used to keep count of the columns.\\n        left = 0;\\n        right = l2-1;\\n        \\n        //int length = matrix.size()*matrix[0].size(); //total no.of elements that needs to be present in the output\\n        \\n        while(top<=bottom && left<=right && output.size()<l1*l2)\\n        {\\n            for(int j=left; j<=right; j++) //traversal of top row\\n            { output.push_back(matrix[top][j]);}\\n            \\n            \\n            top++; //increment of top by 1\\n            \\n            for(int i=top; i<=bottom; i++) //traversal of last column\\n            { output.push_back(matrix[i][right]);}\\n            \\n             right--;//decrement of right by 1\\n            \\n            for(int j=right; top<=bottom && j>=left; j--) //traversal of last row\\n            {output.push_back(matrix[bottom][j]);}\\n            \\n             bottom--;//decrement of bottom by 1\\n            \\n            for(int i=bottom; left<=right && i>=top; i--) //traversal of first column\\n            {  output.push_back(matrix[i][left]);}\\n            \\n            left++; //increment of left by 1\\n            \\n            // after this the process again repeats..\\n        }\\n        \\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> output;\\n        int l1=matrix.size();\\n        int l2=matrix[0].size();\\n        \\n        int top,bottom,left,right;\\n        // top and bottom are used to keep the count of rows.\\n        top = 0;\\n        bottom = l1-1;\\n        \\n        // left and right are used to keep count of the columns.\\n        left = 0;\\n        right = l2-1;\\n        \\n        //int length = matrix.size()*matrix[0].size(); //total no.of elements that needs to be present in the output\\n        \\n        while(top<=bottom && left<=right && output.size()<l1*l2)\\n        {\\n            for(int j=left; j<=right; j++) //traversal of top row\\n            { output.push_back(matrix[top][j]);}",
                "codeTag": "Java"
            },
            {
                "id": 20830,
                "title": "simple-structed-java-solution-with-o-m-n-complexity",
                "content": "The idea is the same as the solution on [programcreek][1]. \\nCode is long, but the idea and structure is simple.\\nFeast yourself!\\n\\n    public class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if (matrix.length == 0) return list;\\n        \\n        int m = matrix.length; //width\\n        int n = matrix[0].length; //height\\n        int x = 0, y = 0;\\n        \\n        while (m > 0 && n > 0) {\\n            //If there is only one row or one column, then just put this row/column into the list\\n            if (m == 1) {\\n                for (int i = 0; i < n; i++) {\\n                    list.add(matrix[x][y++]);\\n                }\\n                break;\\n            } else if (n == 1) {\\n                for (int i = 0; i < m; i++) {\\n                    list.add(matrix[x++][y]);\\n                }\\n                break;\\n            }\\n            \\n            //left to right\\n            for (int i = 0; i < n - 1; i++) {\\n                list.add(matrix[x][y++]);\\n            } \\n            \\n            //up to down\\n            for (int i = 0; i < m - 1; i++) {\\n                list.add(matrix[x++][y]);\\n            }\\n            \\n            //right to left\\n            for (int i = 0; i < n - 1; i++) {\\n                list.add(matrix[x][y--]);\\n            } \\n            \\n            //down to up\\n            for (int i = 0; i < m - 1; i++) {\\n                list.add(matrix[x--][y]);\\n            }\\n            \\n            m = m - 2;\\n            n = n - 2;\\n            x++;\\n            y++;\\n        }\\n        return list;\\n    }\\n}\\n\\n\\n  [1]: http://www.programcreek.com/2013/01/leetcode-spiral-matrix-java/",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if (matrix.length == 0) return list;\\n        \\n        int m = matrix.length; //width\\n        int n = matrix[0].length; //height\\n        int x = 0, y = 0;\\n        \\n        while (m > 0 && n > 0) {\\n            //If there is only one row or one column, then just put this row/column into the list\\n            if (m == 1) {\\n                for (int i = 0; i < n; i++) {\\n                    list.add(matrix[x][y++]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4047753,
                "title": "intuitive-c-recursive-approach-for-beginners",
                "content": "# Intuition\\nIdentify the pattern, specifically when the change in direction will occur\\n\\nPLEASE UPVOTE IF YOU FIND THIS HELPFUL\\n\\n# Approach\\nUnderstand the factors to consider:\\n- Position of element\\n- Direction currently moved\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1) if global vector not considered\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x,y;\\n    vector<vector<int>> arr;\\n    vector<int> vec;\\n\\n    void solve(int i,int j,int dir){\\n        if(arr[i][j]==-101) return;\\n        vec.push_back(arr[i][j]);\\n        cout<<arr[i][j]<<endl;\\n        arr[i][j]=-101;\\n        if(j<y && ((dir==0 && arr[i][j+1]!=-101) || (dir==3 && (i==0 || arr[i-1][j]==-101)))) solve(i,j+1,0);\\n        else if(i<x && ((dir==1 && arr[i+1][j]!=-101) || (dir==0 && (j==y || arr[i][j+1]==-101)))) solve(i+1,j,1);\\n        else if(j>0 && ((dir==2 && arr[i][j-1]!=-101) || (dir==1 && (i==x || arr[i+1][j]==-101)))) solve(i,j-1,2);\\n        else if(i>0 && ((dir==3 && arr[i-1][j]!=-101) || (dir==2 && (j==0 || arr[i][j-1]==-101)))) solve(i-1,j,3);\\n    }\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        arr=matrix;\\n        x=arr.size()-1;\\n        y=arr[0].size()-1;\\n        solve(0,0,0);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x,y;\\n    vector<vector<int>> arr;\\n    vector<int> vec;\\n\\n    void solve(int i,int j,int dir){\\n        if(arr[i][j]==-101) return;\\n        vec.push_back(arr[i][j]);\\n        cout<<arr[i][j]<<endl;\\n        arr[i][j]=-101;\\n        if(j<y && ((dir==0 && arr[i][j+1]!=-101) || (dir==3 && (i==0 || arr[i-1][j]==-101)))) solve(i,j+1,0);\\n        else if(i<x && ((dir==1 && arr[i+1][j]!=-101) || (dir==0 && (j==y || arr[i][j+1]==-101)))) solve(i+1,j,1);\\n        else if(j>0 && ((dir==2 && arr[i][j-1]!=-101) || (dir==1 && (i==x || arr[i+1][j]==-101)))) solve(i,j-1,2);\\n        else if(i>0 && ((dir==3 && arr[i-1][j]!=-101) || (dir==2 && (j==0 || arr[i][j-1]==-101)))) solve(i-1,j,3);\\n    }\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        arr=matrix;\\n        x=arr.size()-1;\\n        y=arr[0].size()-1;\\n        solve(0,0,0);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3503991,
                "title": "100-fast-solution-of-spiral-matrix-problem-2-d-array",
                "content": "# Intuition\\n\\n\\n# Approach\\n. first of all initialise row, column and total [i.e, row*column]\\n. then intialise the indeces of starting row, starting column,     ending row and ending column.\\n\\n     1. Print the starting row\\n     2. Print the ending column\\n     3. Print the ending row\\n     4. Print the starting column\\n     \\n. After that push back the matrix[row][column] for all the above iterations by cheching count < total of the matrix and then simply increment the count value\\n\\n# Complexity\\n- Time complexity: O(nm) [i.e, n = row and m = column]\\n\\n\\n- Space complexity: O(nm)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int cnt = 0;\\n        int total = row*col;\\n        \\n        //index initialisation\\n        int sR = 0;  // starting row\\n        int sC = 0;  // starting column\\n        int eR = row -1;  // ending row\\n        int eC = col-1;   // ending column\\n\\n        while(cnt < total){\\n\\n            //printing starting row\\n            for(int index = sC; cnt < total && index <= eC; index++){\\n               ans.push_back(matrix[sR][index]);\\n               cnt++;\\n            }\\n            sR++;\\n\\n            //printing ending column\\n            for(int index = sR; cnt < total && index <= eR; index++){\\n               ans.push_back(matrix[index][eC]);\\n               cnt++;\\n            }\\n            eC--;\\n\\n            //printing ending row\\n            for(int index = eC; cnt < total && index >= sC; index--){\\n               ans.push_back(matrix[eR][index]);\\n               cnt++;\\n            }\\n            eR--;\\n\\n            //printing starting column\\n            for(int index = eR; cnt < total && index >= sR; index--){\\n               ans.push_back(matrix[index][sC]);\\n               cnt++;\\n            }\\n            sC++;\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int cnt = 0;\\n        int total = row*col;\\n        \\n        //index initialisation\\n        int sR = 0;  // starting row\\n        int sC = 0;  // starting column\\n        int eR = row -1;  // ending row\\n        int eC = col-1;   // ending column\\n\\n        while(cnt < total){\\n\\n            //printing starting row\\n            for(int index = sC; cnt < total && index <= eC; index++){\\n               ans.push_back(matrix[sR][index]);\\n               cnt++;\\n            }\\n            sR++;\\n\\n            //printing ending column\\n            for(int index = sR; cnt < total && index <= eR; index++){\\n               ans.push_back(matrix[index][eC]);\\n               cnt++;\\n            }\\n            eC--;\\n\\n            //printing ending row\\n            for(int index = eC; cnt < total && index >= sC; index--){\\n               ans.push_back(matrix[eR][index]);\\n               cnt++;\\n            }\\n            eR--;\\n\\n            //printing starting column\\n            for(int index = eR; cnt < total && index >= sR; index--){\\n               ans.push_back(matrix[index][sC]);\\n               cnt++;\\n            }\\n            sC++;\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503117,
                "title": "java-easy-solution-beginner-friendly-step-by-step-procees-concise-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart with the outermost layer of the matrix and then move inward towards the center. To traverse each layer in a spiral order, we make use of four pointers - top, bottom, left, and right. We start at the top-left corner of the matrix and move towards the right until we reach the top-right corner. Then, we move downwards towards the bottom-right corner, then towards the bottom-left corner, and finally towards the top-left corner. We repeat this process for each layer until we reach the center of the matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize four pointers - l (left), r (right), t (top), and b (bottom) to represent the boundaries of the current layer of the matrix being traversed.\\n- While the top and bottom boundaries do not cross each other and the left and right boundaries do not cross each other, do the following:\\na. Traverse the top boundary from left to right and add the elements to the result list.\\nb. Traverse the right boundary from top to bottom and add the elements to the result list.\\nc. Traverse the bottom boundary from right to left and add the elements to the result list.\\nd. Traverse the left boundary from bottom to top and add the elements to the result list.\\ne. Update the pointers to move to the next layer of the matrix.\\n- Return the result list.\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> l1 = new ArrayList<Integer>();\\n        //left\\n        int l=0,b=matrix.length-1,r=matrix[0].length-1,t=0;\\n        while(l<=r || t<=b){\\n                if(t<=b){\\n                    for(int i=l;i<=r;i++)\\n                    l1.add(matrix[t][i]);\\n                    t++;\\n                }\\n                if(l<=r){\\n                    for(int i=t;i<=b;i++)\\n                    l1.add(matrix[i][r]);\\n                    r--;\\n                }\\n                if(t<=b){\\n                    for(int i=r;i>=l;i--)\\n                    l1.add(matrix[b][i]);\\n                    b--;\\n                }\\n                if(l<=r){\\n                    for(int i=b;i>=t;i--)\\n                    l1.add(matrix[i][l]);\\n                    l++;\\n                }\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> l1 = new ArrayList<Integer>();\\n        //left\\n        int l=0,b=matrix.length-1,r=matrix[0].length-1,t=0;\\n        while(l<=r || t<=b){\\n                if(t<=b){\\n                    for(int i=l;i<=r;i++)\\n                    l1.add(matrix[t][i]);\\n                    t++;\\n                }\\n                if(l<=r){\\n                    for(int i=t;i<=b;i++)\\n                    l1.add(matrix[i][r]);\\n                    r--;\\n                }\\n                if(t<=b){\\n                    for(int i=r;i>=l;i--)\\n                    l1.add(matrix[b][i]);\\n                    b--;\\n                }\\n                if(l<=r){\\n                    for(int i=b;i>=t;i--)\\n                    l1.add(matrix[i][l]);\\n                    l++;\\n                }\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163347,
                "title": "c-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).\\n- Then we will iterate from new top to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).\\n- Then we will iterate in bottom row from right to left and pushback all the elements from new right to left. After iterating, we change the bottom to second last row (bottom--).\\n- Then we will iterate from new bottom to new top and push back only left most element. After iterating, we change the left to second column (left++).\\n- Repeat all these steps until left = right and top = bottom.\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top=0,bottom=matrix.size()-1,right=matrix[0].size()-1,left=0,direction=0;\\n        vector<int>res;\\n        while(top<=bottom and left<=right)\\n        {\\n            if(direction==0){\\n\\n                for(int i=left;i<=right;i++)\\n                res.push_back(matrix[top][i]);\\n                top++;\\n            }\\n            else if(direction==1){\\n\\n                for(int i=top;i<=bottom;i++)\\n                res.push_back(matrix[i][right]);\\n                right--;\\n            }\\n            else if(direction==2){\\n\\n                for(int i=right;i>=left;i--)\\n                res.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            else if(direction==3){\\n\\n                for(int i=bottom;i>=top;i--)\\n                res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n            direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top=0,bottom=matrix.size()-1,right=matrix[0].size()-1,left=0,direction=0;\\n        vector<int>res;\\n        while(top<=bottom and left<=right)\\n        {\\n            if(direction==0){\\n\\n                for(int i=left;i<=right;i++)\\n                res.push_back(matrix[top][i]);\\n                top++;\\n            }\\n            else if(direction==1){\\n\\n                for(int i=top;i<=bottom;i++)\\n                res.push_back(matrix[i][right]);\\n                right--;\\n            }\\n            else if(direction==2){\\n\\n                for(int i=right;i>=left;i--)\\n                res.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            else if(direction==3){\\n\\n                for(int i=bottom;i>=top;i--)\\n                res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n            direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161179,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].size() - 1;\\n        int bottom = matrix.size() - 1;\\n        \\n        vector<int> result;\\n        \\n        while (top <= bottom && left <= right) {\\n            for (int j = left; j <= right; j++) {\\n                result.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int j = right; j >= left; j--) {\\n                    result.push_back(matrix[bottom][j]);\\n                }\\n            }\\n            bottom--;\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = matrix[0]\\n        cur_i, cur_j = 0, len(matrix[0]) - 1\\n        dist_x, dist_y = -(len(matrix[0]) - 1), len(matrix) - 1\\n        step_x, step_y = -1, 1\\n        while True:\\n            if dist_y == 0:\\n                break\\n            else:\\n                for i in range(0, dist_y, step_y):\\n                    cur_i += step_y\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_y = -dist_y + step_y\\n                step_y *= -1\\n            if dist_x == 0:\\n                break\\n            else:\\n                for i in range(0, dist_x, step_x):\\n                    cur_j += step_x\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_x = -dist_x + step_x\\n                step_x *= -1\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rb = 0;\\n        int re = matrix.length - 1;\\n        int cb = 0;\\n        int ce = matrix[0].length - 1;\\n\\n        while (rb <= re && cb <= ce) {\\n            for (int j = cb; j <= ce; j++) {\\n                list.add(matrix[rb][j]);\\n            }\\n            rb++;\\n\\n            for (int i = rb; i <= re; i++) {\\n                list.add(matrix[i][ce]);\\n            }\\n            ce--;\\n\\n            if (rb <= re) {\\n                for (int j = ce; j >= cb; j--) {\\n                    list.add(matrix[re][j]);\\n                }\\n            }\\n            re--;\\n\\n            if (cb <= ce) {\\n                for (int i = re; i >= rb; i--) {\\n                    list.add(matrix[i][cb]);\\n                }\\n            }\\n            cb++;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].size() - 1;\\n        int bottom = matrix.size() - 1;\\n        \\n        vector<int> result;\\n        \\n        while (top <= bottom && left <= right) {\\n            for (int j = left; j <= right; j++) {\\n                result.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int j = right; j >= left; j--) {\\n                    result.push_back(matrix[bottom][j]);\\n                }\\n            }\\n            bottom--;\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = matrix[0]\\n        cur_i, cur_j = 0, len(matrix[0]) - 1\\n        dist_x, dist_y = -(len(matrix[0]) - 1), len(matrix) - 1\\n        step_x, step_y = -1, 1\\n        while True:\\n            if dist_y == 0:\\n                break\\n            else:\\n                for i in range(0, dist_y, step_y):\\n                    cur_i += step_y\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_y = -dist_y + step_y\\n                step_y *= -1\\n            if dist_x == 0:\\n                break\\n            else:\\n                for i in range(0, dist_x, step_x):\\n                    cur_j += step_x\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_x = -dist_x + step_x\\n                step_x *= -1\\n        return res\\n```\n```Java []\\nclass Solution {\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rb = 0;\\n        int re = matrix.length - 1;\\n        int cb = 0;\\n        int ce = matrix[0].length - 1;\\n\\n        while (rb <= re && cb <= ce) {\\n            for (int j = cb; j <= ce; j++) {\\n                list.add(matrix[rb][j]);\\n            }\\n            rb++;\\n\\n            for (int i = rb; i <= re; i++) {\\n                list.add(matrix[i][ce]);\\n            }\\n            ce--;\\n\\n            if (rb <= re) {\\n                for (int j = ce; j >= cb; j--) {\\n                    list.add(matrix[re][j]);\\n                }\\n            }\\n            re--;\\n\\n            if (cb <= ce) {\\n                for (int i = re; i >= rb; i--) {\\n                    list.add(matrix[i][cb]);\\n                }\\n            }\\n            cb++;\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108009,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<int> SpiralOrder(int[][] matrix) {\\n        var width = matrix[0].Length;\\n        var height = matrix.Length;\\n        var lenght = width * height;\\n\\n        var result = new List<int>(lenght);\\n        var x = 0;\\n        var y = 0;\\n        var dy = 1;\\n        var dx = 1;\\n\\n        while(result.Count < lenght)\\n        {\\n            result.Add(matrix[y][x]);\\n\\n            if (y == dy - 1 && x < width - dx)\\n            {\\n                x++;\\n            }\\n            else if (x == width - dx && y < height - dy)\\n            {\\n                y++;\\n            }\\n            else if (x > dx - 1)\\n            {\\n                x--;\\n            }\\n            else if (y > dy)\\n            {\\n                y--;\\n                if (y == dy && x == dx - 1)\\n                {\\n                    dx++;\\n                    dy++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> SpiralOrder(int[][] matrix) {\\n        var width = matrix[0].Length;\\n        var height = matrix.Length;\\n        var lenght = width * height;\\n\\n        var result = new List<int>(lenght);\\n        var x = 0;\\n        var y = 0;\\n        var dy = 1;\\n        var dx = 1;\\n\\n        while(result.Count < lenght)\\n        {\\n            result.Add(matrix[y][x]);\\n\\n            if (y == dy - 1 && x < width - dx)\\n            {\\n                x++;\\n            }\\n            else if (x == width - dx && y < height - dy)\\n            {\\n                y++;\\n            }\\n            else if (x > dx - 1)\\n            {\\n                x--;\\n            }\\n            else if (y > dy)\\n            {\\n                y--;\\n                if (y == dy && x == dx - 1)\\n                {\\n                    dx++;\\n                    dy++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100997,
                "title": "beats-100-o-n-n-each-approach-full-explained-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to print a pattern in spiral order, which means we have to make a circular round like a spiral.generally matrix problems are solved in n*n complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find the size of matrix and for column, find the length of any row.\\n2. declare variables like startingCol=0, endingCol= length -1, startingRow=0, endingRow= length-1.\\n3. first we will print first row, by moving from startingCol to endingcol. and increase startingrow by 1, so that we can print next row in second iteration.\\n4. then, we will print last column, by moving from startingrow to endingrow and decrease endingCol by 1 so that we can to next inner col.\\n5. then we will print last row, by moving from endingCol to startingcol. and decrease endingRow by 1, so that we can move to  next inner row in next iteration.\\n6. then  we will print first col, by moving from endingRow to startingrow, and increase startingCol by 1, so that we can move to next col in next iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& nums) {\\n        int row= nums.size();\\n        int col= nums[0].size();\\n        int end= row*col -1, count=0;\\n        vector<int>v;\\n        int startingRow=0, startingCol=0,endingRow= row-1, endingCol= col-1;\\n\\n        while(count<= end)\\n        {\\n            for first row\\n            for(int i= startingCol;count <= end && i<= endingCol;i++)\\n            {\\n                v.push_back(nums[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            //last column \\n            for(int i= startingRow;count <= end && i<= endingRow;i++)\\n            {\\n                v.push_back(nums[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // last row\\n            for(int i= endingCol;count <= end && i>=startingCol;i--)\\n            {\\n                v.push_back(nums[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            first column \\n            for(int i= endingRow;count <= end && i>= startingRow;i--)\\n            {\\n                v.push_back(nums[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& nums) {\\n        int row= nums.size();\\n        int col= nums[0].size();\\n        int end= row*col -1, count=0;\\n        vector<int>v;\\n        int startingRow=0, startingCol=0,endingRow= row-1, endingCol= col-1;\\n\\n        while(count<= end)\\n        {\\n            for first row\\n            for(int i= startingCol;count <= end && i<= endingCol;i++)\\n            {\\n                v.push_back(nums[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            //last column \\n            for(int i= startingRow;count <= end && i<= endingRow;i++)\\n            {\\n                v.push_back(nums[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // last row\\n            for(int i= endingCol;count <= end && i>=startingCol;i--)\\n            {\\n                v.push_back(nums[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            first column \\n            for(int i= endingRow;count <= end && i>= startingRow;i--)\\n            {\\n                v.push_back(nums[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094313,
                "title": "best-solution",
                "content": "#\\n\\n# Complexity\\n- Time complexity:\\n$$O(R*C)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> ans;\\n        int R = matrix.size(), C = matrix[0].size();\\n        int t = 0, r = C - 1, b = R - 1, l = 0;\\n        while (t <= b && l <= r) {\\n            for (int i = l; i <= r; i++) \\n                ans.push_back(matrix[t][i]);\\n            t++;\\n            for (int j = t; j <= b; j++) \\n                ans.push_back(matrix[j][r]);\\n            r--;\\n            if (t <= b) {\\n                for (int m = r; m >= l; m--) \\n                ans.push_back(matrix[b][m]);\\n            b--;\\n            }\\n            if (l <= r) {\\n                for (int n = b; n >= t; n--) \\n                ans.push_back(matrix[n][l]);\\n            l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> ans;\\n        int R = matrix.size(), C = matrix[0].size();\\n        int t = 0, r = C - 1, b = R - 1, l = 0;\\n        while (t <= b && l <= r) {\\n            for (int i = l; i <= r; i++) \\n                ans.push_back(matrix[t][i]);\\n            t++;\\n            for (int j = t; j <= b; j++) \\n                ans.push_back(matrix[j][r]);\\n            r--;\\n            if (t <= b) {\\n                for (int m = r; m >= l; m--) \\n                ans.push_back(matrix[b][m]);\\n            b--;\\n            }\\n            if (l <= r) {\\n                for (int n = b; n >= t; n--) \\n                ans.push_back(matrix[n][l]);\\n            l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785141,
                "title": "simple-java-solution-using-switch-case-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        \\n        List<Integer> res = new ArrayList<Integer>(); \\n        if (matrix.length == 0) {\\n            return res;\\n        }\\n        \\n        int rowStart = 0;\\n        int rowEnd = matrix.length-1;\\n        int colStart = 0;\\n        int colEnd = matrix[0].length - 1;\\n        int direction = 0;\\n    \\n    while(rowStart <= rowEnd && colStart <= colEnd) {\\n        switch(direction) {      \\n            case 0:   \\n                for(int j = colStart; j <= colEnd; j++)           //Right\\n                    res.add(matrix[rowStart][j]);\\n                rowStart++;\\n                break;\\n            case 1:                                              //Down\\n                for(int j = rowStart; j <=rowEnd; j++) \\n                    res.add(matrix[j][colEnd])    ;\\n                colEnd--;\\n                break;\\n            case 2:\\n                for(int j = colEnd; j >= colStart; j --)          //Left\\n                    res.add(matrix[rowEnd][j]);            \\n                rowEnd--;\\n                break;\\n            case 3:\\n                for(int j = rowEnd; j >= rowStart; j--)           //up\\n                    res.add(matrix[j][colStart]);\\n                colStart++;  \\n                break;\\n        }                                   \\n        direction = (direction+1)%4;                                                            \\n    }   \\n    return res;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        \\n        List<Integer> res = new ArrayList<Integer>(); \\n        if (matrix.length == 0) {\\n            return res;\\n        }\\n        \\n        int rowStart = 0;\\n        int rowEnd = matrix.length-1;\\n        int colStart = 0;\\n        int colEnd = matrix[0].length - 1;\\n        int direction = 0;\\n    \\n    while(rowStart <= rowEnd && colStart <= colEnd) {\\n        switch(direction) {      \\n            case 0:   \\n                for(int j = colStart; j <= colEnd; j++)           //Right\\n                    res.add(matrix[rowStart][j]);\\n                rowStart++;\\n                break;\\n            case 1:                                              //Down\\n                for(int j = rowStart; j <=rowEnd; j++) \\n                    res.add(matrix[j][colEnd])    ;\\n                colEnd--;\\n                break;\\n            case 2:\\n                for(int j = colEnd; j >= colStart; j --)          //Left\\n                    res.add(matrix[rowEnd][j]);            \\n                rowEnd--;\\n                break;\\n            case 3:\\n                for(int j = rowEnd; j >= rowStart; j--)           //up\\n                    res.add(matrix[j][colStart]);\\n                colStart++;  \\n                break;\\n        }                                   \\n        direction = (direction+1)%4;                                                            \\n    }   \\n    return res;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554377,
                "title": "spiral-matrix-easiest-approach",
                "content": "\\n\\n    class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans= new ArrayList<>();\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        int total = row * col;\\n        int count = 0;\\n\\n        // initialise the indexes;\\n\\t\\t\\n        int startRow = 0;\\n        int endCol = col - 1;\\n        int endRow = row - 1;\\n        int startCol = 0;\\n\\n        while(count < total){\\n\\n            //print startRow\\n            for(int idx = startCol; count < total && idx <= endCol; idx++){\\n                ans.add(matrix[startRow][idx]);\\n                count++;\\n            }\\n            startRow++;\\n\\n            // print lastCol\\n            for(int idx = startRow; count < total && idx <= endRow; idx++){\\n                ans.add(matrix[idx][endCol]);\\n                count++;\\n            }\\n            endCol--;\\n\\n            // print lastRow\\n\\n            for(int idx = endCol; count < total && idx >= startCol; idx--){\\n                ans.add(matrix[endRow][idx]);\\n                count++;\\n            }\\n            endRow--;\\n\\n            // print firstCol\\n\\n            for(int idx = endRow; count < total && idx >= startRow; idx--){\\n                ans.add(matrix[idx][startCol]);\\n                count++;\\n            }\\n            startCol++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans= new ArrayList<>();\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        int total = row * col;\\n        int count = 0;\\n\\n        // initialise the indexes;\\n\\t\\t\\n        int startRow = 0;\\n        int endCol = col - 1;\\n        int endRow = row - 1;\\n        int startCol = 0;\\n\\n        while(count < total){\\n\\n            //print startRow\\n            for(int idx = startCol; count < total && idx <= endCol; idx++){\\n                ans.add(matrix[startRow][idx]);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1970215,
                "title": "java-100-fasteest-with-best-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n           List<Integer> list= new ArrayList<>();\\n        if(matrix.length==0){\\n            return list;\\n        }\\n        int rowBegin=0;\\n        int rowEnd= matrix.length-1;\\n        int colBegin= 0;\\n        int colEnd= matrix[0].length-1;\\n        \\n        \\n       \\n        while(rowBegin<= rowEnd && colBegin<= colEnd){\\n         \\n            // printing 1,2,3\\n            for(int i= colBegin; i<=colEnd; i++){\\n                list.add(matrix[rowBegin][i]);\\n            }\\n            \\n            //moving downward\\n            rowBegin++;\\n            \\n            //printing last element of 1st row that is we are printing 6 and than travsing to downward\\n            for(int i= rowBegin; i<=rowEnd; i++){\\n                list.add(matrix[i][colEnd]);\\n            }\\n           \\n            //know for traversing towards left side\\n            colEnd--;\\n            \\n            //traversing towards left side of in last row\\n            if(rowBegin<=rowEnd){\\n                for(int i= colEnd; i>=colBegin; i--){\\n                    list.add(matrix[rowEnd][i]);\\n                } \\n            }\\n            \\n            //than traversing upward from last row\\n            rowEnd--;\\n            \\n            // traversing to right side again\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin; i--){\\n                    list.add(matrix[i][colBegin]);\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return list;\\n    }\\n}\\n```// if you feel that you understood please UPVOTE .  IT gives me motivation to do more",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n           List<Integer> list= new ArrayList<>();\\n        if(matrix.length==0){\\n            return list;\\n        }\\n        int rowBegin=0;\\n        int rowEnd= matrix.length-1;\\n        int colBegin= 0;\\n        int colEnd= matrix[0].length-1;\\n        \\n        \\n       \\n        while(rowBegin<= rowEnd && colBegin<= colEnd){\\n         \\n            // printing 1,2,3\\n            for(int i= colBegin; i<=colEnd; i++){\\n                list.add(matrix[rowBegin][i]);\\n            }\\n            \\n            //moving downward\\n            rowBegin++;\\n            \\n            //printing last element of 1st row that is we are printing 6 and than travsing to downward\\n            for(int i= rowBegin; i<=rowEnd; i++){\\n                list.add(matrix[i][colEnd]);\\n            }\\n           \\n            //know for traversing towards left side\\n            colEnd--;\\n            \\n            //traversing towards left side of in last row\\n            if(rowBegin<=rowEnd){\\n                for(int i= colEnd; i>=colBegin; i--){\\n                    list.add(matrix[rowEnd][i]);\\n                } \\n            }\\n            \\n            //than traversing upward from last row\\n            rowEnd--;\\n            \\n            // traversing to right side again\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin; i--){\\n                    list.add(matrix[i][colBegin]);\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941436,
                "title": "spiral-matrix-c-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        vector<int> res;\\n        \\n        int left=0;\\n        int right=n-1;\\n        int upper=0;\\n        int lower=m-1;\\n        \\n        while(left<=right && upper<=lower){\\n            for(int i=left;i<=right;i++){\\n                 res.push_back(matrix[upper][i]);\\n            }\\n            upper++;\\n            if(upper>lower)break;\\n            \\n            for(int i=upper;i<=lower;i++){\\n             res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left>right)break;\\n            \\n            for(int i=right;i>=left;i--){\\n                res.push_back(matrix[lower][i]);\\n            }\\n            lower--;\\n            if(upper>lower)break;\\n            \\n            for(int i=lower;i>=upper;i--){\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n            if(left>right)break;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        vector<int> res;\\n        \\n        int left=0;\\n        int right=n-1;\\n        int upper=0;\\n        int lower=m-1;\\n        \\n        while(left<=right && upper<=lower){\\n            for(int i=left;i<=right;i++){\\n                 res.push_back(matrix[upper][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1908016,
                "title": "c-naive-approach-a-very-basic-thinking",
                "content": "* The idea is to maintain **4 boolean variables right, down, left, up** which will tell us in which direction to move. \\n* There are **4 integer variables rowStart, rowEnd, colStart, colEnd** to specify constrains for moving in single direction. After moving in any direction update these variables to move in another direction.\\n* The **index** variable will be incremented at each time so that **r*c** matrix cells will be stored in linear array\\n* Adjust the constrains based upon direction of traversing n these values can be used in **while condition**\\n\\t* After traversing in horitanzal direction from left to right **rowStart** will increment by one\\n\\t* After  traversing in horitanzal direction from right to left **rowEnd** will decrement by one\\n\\t* After traversing in vertical direction from top to bottom **colEnd** will decrement by one\\n\\t* After traversing in vertical direction from bottom to top **colStart** will increment by one\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        vector<int> ans(r*c);\\n        \\n        int rows = 0, cols = 0, rowe = r-1, cole = c-1;\\n        \\n        int index = 0;\\n        bool right = true, down = false, left = false, up = false;\\n        while((rows<=rowe) && (cols<=cole)){\\n            \\n            if(right){\\n                for(int col=cols; col<=cole; col++){\\n                    ans[index++] = matrix[rows][col];\\n                }\\n                rows++; \\n                right = false, down = true;\\n            }\\n            else if(down){\\n                for(int ri=rows; ri<=rowe; ri++){\\n                    ans[index++] = matrix[ri][cole];\\n                }\\n                cole--; \\n                down = false, left = true;\\n            }\\n            else if(left){\\n                for(int ci=cole; ci>=cols; ci--){\\n                    ans[index++] = matrix[rowe][ci];\\n                }\\n                rowe--;\\n                left = false, up = true;\\n            }\\n            else if(up){\\n                for(int ri=rowe; ri>=rows; ri--){\\n                    ans[index++] = matrix[ri][cols];\\n                }\\n                cols++;\\n                up = false, right = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        vector<int> ans(r*c);\\n        \\n        int rows = 0, cols = 0, rowe = r-1, cole = c-1;\\n        \\n        int index = 0;\\n        bool right = true, down = false, left = false, up = false;\\n        while((rows<=rowe) && (cols<=cole)){\\n            \\n            if(right){\\n                for(int col=cols; col<=cole; col++){\\n                    ans[index++] = matrix[rows][col];\\n                }\\n                rows++; \\n                right = false, down = true;\\n            }\\n            else if(down){\\n                for(int ri=rows; ri<=rowe; ri++){\\n                    ans[index++] = matrix[ri][cole];\\n                }\\n                cole--; \\n                down = false, left = true;\\n            }\\n            else if(left){\\n                for(int ci=cole; ci>=cols; ci--){\\n                    ans[index++] = matrix[rowe][ci];\\n                }\\n                rowe--;\\n                left = false, up = true;\\n            }\\n            else if(up){\\n                for(int ri=rowe; ri>=rows; ri--){\\n                    ans[index++] = matrix[ri][cols];\\n                }\\n                cols++;\\n                up = false, right = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782596,
                "title": "java-solution-easy-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int tne=matrix.length*matrix[0].length;\\n        int rowmin=0, colmin=0, colmax=matrix[0].length-1, rowmax=matrix.length-1;\\n        int count=0;\\n        List<Integer> ans=new ArrayList<>();\\n        while(count<tne){\\n            //top wall\\n            for(int i=colmin; i<=colmax && count<tne; i++){\\n                ans.add(matrix[rowmin][i]);\\n                count++;\\n            }\\n            rowmin++;\\n            \\n            //right wall\\n              for(int i=rowmin; i<=rowmax && count<tne; i++){\\n                ans.add(matrix[i][colmax]);\\n                  count++;\\n            }\\n            colmax--;\\n            \\n            //bottom wall\\n            for(int i=colmax; i>=colmin && count<tne; i--){\\n                ans.add(matrix[rowmax][i]);\\n                count++;\\n                \\n            }\\n            rowmax--;\\n            \\n            //left wall\\n            for(int i=rowmax; i>=rowmin && count<tne;i--){\\n                ans.add(matrix[i][colmin]);\\n                count++;\\n            }\\n            colmin++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int tne=matrix.length*matrix[0].length;\\n        int rowmin=0, colmin=0, colmax=matrix[0].length-1, rowmax=matrix.length-1;\\n        int count=0;\\n        List<Integer> ans=new ArrayList<>();\\n        while(count<tne){\\n            //top wall\\n            for(int i=colmin; i<=colmax && count<tne; i++){\\n                ans.add(matrix[rowmin][i]);\\n                count++;\\n            }\\n            rowmin++;\\n            \\n            //right wall\\n              for(int i=rowmin; i<=rowmax && count<tne; i++){\\n                ans.add(matrix[i][colmax]);\\n                  count++;\\n            }\\n            colmax--;\\n            \\n            //bottom wall\\n            for(int i=colmax; i>=colmin && count<tne; i--){\\n                ans.add(matrix[rowmax][i]);\\n                count++;\\n                \\n            }\\n            rowmax--;\\n            \\n            //left wall\\n            for(int i=rowmax; i>=rowmin && count<tne;i--){\\n                ans.add(matrix[i][colmin]);\\n                count++;\\n            }\\n            colmin++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648434,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "\\n```java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1;\\n        int len = matrix.length*matrix[0].length;\\n        while(list.size() < len){\\n            for(int i=left; i<=right && list.size() < len; i++) list.add(matrix[top][i]);\\n            top++;\\n            for(int i=top; i<=bottom && list.size() < len; i++) list.add(matrix[i][right]);\\n            right--;\\n            for(int i=right; i>=left && list.size() < len; i--) list.add(matrix[bottom][i]);\\n            bottom--;\\n            for(int i=bottom; i>=top && list.size() < len; i--) list.add(matrix[i][left]);\\n            left++;\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1\\n    let len = matrix.length*matrix[0].length\\n    while(arr.length < len){\\n        for(let i=left; i<=right && arr.length < len; i++)  arr.push(matrix[top][i])\\n        top++  \\n        for(let i=top; i<=bottom && arr.length < len; i++) arr.push(matrix[i][right])\\n        right--\\n        for(let i=right; i>=left && arr.length < len; i--) arr.push(matrix[bottom][i])\\n        bottom--\\n        for(let i=bottom; i>=top && arr.length < len; i--) arr.push(matrix[i][left])\\n        left++\\n    }\\n    return arr\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        arr = []\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        n = len(matrix) * len(matrix[0])\\n        while len(arr) < n :\\n            for i in range(left, right+1):\\n                if len(arr) < n:\\n                    arr.append(matrix[top][i])\\n            top += 1\\n            for i in range(top, bottom+1): \\n                if len(arr) < n:\\n                    arr.append(matrix[i][right])\\n            right -= 1\\n            for i in reversed(range(left, right+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[bottom][i])\\n            bottom -= 1\\n            for i in reversed(range(top, bottom+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[i][left])\\n            left += 1\\n        return arr\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1;\\n        int len = matrix.length*matrix[0].length;\\n        while(list.size() < len){\\n            for(int i=left; i<=right && list.size() < len; i++) list.add(matrix[top][i]);\\n            top++;\\n            for(int i=top; i<=bottom && list.size() < len; i++) list.add(matrix[i][right]);\\n            right--;\\n            for(int i=right; i>=left && list.size() < len; i--) list.add(matrix[bottom][i]);\\n            bottom--;\\n            for(int i=bottom; i>=top && list.size() < len; i--) list.add(matrix[i][left]);\\n            left++;\\n        }\\n        return list;\\n    }\\n}\\n```\n```javascript []\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1\\n    let len = matrix.length*matrix[0].length\\n    while(arr.length < len){\\n        for(let i=left; i<=right && arr.length < len; i++)  arr.push(matrix[top][i])\\n        top++  \\n        for(let i=top; i<=bottom && arr.length < len; i++) arr.push(matrix[i][right])\\n        right--\\n        for(let i=right; i>=left && arr.length < len; i--) arr.push(matrix[bottom][i])\\n        bottom--\\n        for(let i=bottom; i>=top && arr.length < len; i--) arr.push(matrix[i][left])\\n        left++\\n    }\\n    return arr\\n};\\n```\n```python []\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        arr = []\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        n = len(matrix) * len(matrix[0])\\n        while len(arr) < n :\\n            for i in range(left, right+1):\\n                if len(arr) < n:\\n                    arr.append(matrix[top][i])\\n            top += 1\\n            for i in range(top, bottom+1): \\n                if len(arr) < n:\\n                    arr.append(matrix[i][right])\\n            right -= 1\\n            for i in reversed(range(left, right+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[bottom][i])\\n            bottom -= 1\\n            for i in reversed(range(top, bottom+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[i][left])\\n            left += 1\\n        return arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312879,
                "title": "c-faster-than-100-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        int top=0,down=n-1,left=0,right=m-1;\\n        int d=0;\\n        vector<int>v;\\n        while((down>=top)&&(left<=right))\\n        {\\n            if(d==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    v.push_back(arr[top][i]);\\n                }\\n                d=1;\\n                top++;\\n            }\\n            else if(d==1)\\n            {\\n                for(int i=top;i<=down;i++)\\n                {\\n                    v.push_back(arr[i][right]);\\n                }\\n                d=2;\\n                right--;\\n            }\\n            else if(d==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    v.push_back(arr[down][i]);\\n                }\\n                d=3;\\n                down--;\\n            }\\n            else if(d==3)\\n            {\\n                for(int i=down;i>=top;i--)\\n                {\\n                    v.push_back(arr[i][left]);\\n                }\\n                d=0;\\n                left++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.**\\n\\n**If you have any questions, feel free to comment below.**\\n\\n**HAPPY CODING :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        int top=0,down=n-1,left=0,right=m-1;\\n        int d=0;\\n        vector<int>v;\\n        while((down>=top)&&(left<=right))\\n        {\\n            if(d==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    v.push_back(arr[top][i]);\\n                }\\n                d=1;\\n                top++;\\n            }\\n            else if(d==1)\\n            {\\n                for(int i=top;i<=down;i++)\\n                {\\n                    v.push_back(arr[i][right]);\\n                }\\n                d=2;\\n                right--;\\n            }\\n            else if(d==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    v.push_back(arr[down][i]);\\n                }\\n                d=3;\\n                down--;\\n            }\\n            else if(d==3)\\n            {\\n                for(int i=down;i>=top;i--)\\n                {\\n                    v.push_back(arr[i][left]);\\n                }\\n                d=0;\\n                left++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143712,
                "title": "simple-c-solution-faster-than-100-using-4-pointers",
                "content": "* Just keep 4 pointers column start(cs), column end(ce), row start(rs), row start(re).\\n* Make the boundaries smaller after iterating through the current boundary corresponding to cs, ce, rs, re.\\n* **Dont forget to consider the cases where you travel forward and backward on the same row or column leading to duplicate entries.:**\\n\\t\\t\\n\\n```\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n        int rs=0,re=n-1,ce=m-1,cs=0;\\n        \\n        while(rs<=re and cs<=ce){\\n            for(int l=cs;l<=ce;l++){\\n                ans.push_back(matrix[rs][l]);\\n            }\\n            for(int k=rs+1;k<=re;k++){\\n                ans.push_back(matrix[k][ce]);    \\n            }\\n            for(int l=ce-1;l>=cs;l--){\\n                if(rs!=re) ans.push_back(matrix[re][l]);\\n            }\\n            for(int k=re-1;k>rs;k--){\\n                if(cs!=ce) ans.push_back(matrix[k][cs]);    \\n            }\\n            rs++;\\n            re--;\\n            ce--;\\n            cs++;\\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "* Just keep 4 pointers column start(cs), column end(ce), row start(rs), row start(re).\\n* Make the boundaries smaller after iterating through the current boundary corresponding to cs, ce, rs, re.\\n* **Dont forget to consider the cases where you travel forward and backward on the same row or column leading to duplicate entries.:**\\n\\t\\t\\n\\n```\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n        int rs=0,re=n-1,ce=m-1,cs=0;\\n        \\n        while(rs<=re and cs<=ce){\\n            for(int l=cs;l<=ce;l++){\\n                ans.push_back(matrix[rs][l]);\\n            }\\n            for(int k=rs+1;k<=re;k++){\\n                ans.push_back(matrix[k][ce]);    \\n            }\\n            for(int l=ce-1;l>=cs;l--){\\n                if(rs!=re) ans.push_back(matrix[re][l]);\\n            }\\n            for(int k=re-1;k>rs;k--){\\n                if(cs!=ce) ans.push_back(matrix[k][cs]);    \\n            }\\n            rs++;\\n            re--;\\n            ce--;\\n            cs++;\\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 600768,
                "title": "1-liner-javascript",
                "content": "One liner:\\n\\n```js\\nfunction spiral(m) {\\n  return m.shift().concat(m.length ? spiral(m[0].map((_,i) => m.map(x => x[i])).reverse()) : [])\\n}\\n```\\n\\nthe same code but expanded:\\n\\n```js\\nfunction spiral(matrix) {\\n  if (!matrix.length) return matrix;\\n  const firstRow = matrix.shift();\\n  const transponsed = matrix[0].map((a, i) => {\\n    return matrix.map(row => row[i]);\\n  });\\n  const rotated = transponsed.reverse(); // rotated 90*\\n  return firstRow.concat(spiral(rotated));\\n}\\n```\\n\\nthe same logic but in diagram:\\n\\n```\\n|1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n|4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n|7 8 9|      |4 7|\\n\\n// rows extracted:\\n\\n|1 2 3|      |6 9|      |8 7|      |4|      |5|\\n```\\n\\nthe same logic but in english:\\n\\n1. Remove the first row and add it to the answer\\n2. Rotate the reminder of the matrix 90* counter clockwise\\n3. Repeat step 1 and 2 until there\\'s no more rows",
                "solutionTags": [],
                "code": "```js\\nfunction spiral(m) {\\n  return m.shift().concat(m.length ? spiral(m[0].map((_,i) => m.map(x => x[i])).reverse()) : [])\\n}\\n```\n```js\\nfunction spiral(matrix) {\\n  if (!matrix.length) return matrix;\\n  const firstRow = matrix.shift();\\n  const transponsed = matrix[0].map((a, i) => {\\n    return matrix.map(row => row[i]);\\n  });\\n  const rotated = transponsed.reverse(); // rotated 90*\\n  return firstRow.concat(spiral(rotated));\\n}\\n```\n```\\n|1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n|4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n|7 8 9|      |4 7|\\n\\n// rows extracted:\\n\\n|1 2 3|      |6 9|      |8 7|      |4|      |5|\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423891,
                "title": "java-o-mn-recursive-and-iterative-solutions-with-explanation-and-comments",
                "content": "**Recursive**\\n1) We can use four pointers, all at the corners. Left, Right, Top, Bottom. \\n2) Go from left ---> right on top  row. Increase top row index.\\n3) Go from top --> bottom on last column. Decrease right index.\\n4) Go from right ---> left on bottom column. Decrease bottom pointer. Don\\'t forget to make sure that top and bottom pointers have not crossed each other. Since top has moved in bullet 2.\\n5) Go from bottom --> top. Increase left pointer. Don\\'t forget to make sure that left and right pointers have not crossed each other. Since right has moved in bullet 3.\\n6) The remaining matrix is subproblem of original matrix. Hence recurse/iterate till pointers are not crossing.\\n\\nTime Complexity: O(mn). We are visiting every cell only once.\\nSpace Complexity: O(1) iff we ignore the recursive stack space.\\n\\nFor interviews and DS Algo tips you can follow me on https://twitter.com/Jaspind07199761\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n\\n\\n```\\nclass Solution {\\n    List<Integer> result=new ArrayList<>();\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length == 0) return result;\\n        helper(matrix, 0, matrix[0].length - 1, 0, matrix.length - 1);\\n        return result;\\n    }\\n    public void helper(int[][] matrix, int left, int right, int top, int bottom){\\n        // Base case : If pointers cross each other terminate\\n        if(left > right || top > bottom) return;\\n        // top row\\n        for(int i = left; i <= right; i++){\\n            result.add(matrix[top][i]);\\n        }\\n        top++;\\n        //right column\\n        for(int i = top; i <= bottom; i++){\\n            result.add(matrix[i][right]);\\n        }\\n        right--;\\n        // We need to check top <= bottom because original position of top has increased\\n        if(top <= bottom){\\n              //Bottom row\\n            for(int i = right; i >= left; i--){\\n                result.add(matrix[bottom][i]);\\n            }\\n        }\\n        bottom--;\\n           // We need to check left <= right because original position of left has changed\\n        if(left <= right){\\n              //left column\\n            for(int i = bottom; i >= top; i--){\\n                result.add(matrix[i][left]);\\n            }\\n        }\\n        left++;\\n        helper(matrix,left, right, top, bottom); \\n    }\\n}\\n```\\n\\n**Iterative Solution**\\n\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List <Integer> result = new ArrayList<>();\\n         if(matrix.length == 0) return result;\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].length - 1;\\n        int bottom = matrix.length - 1;\\n        while (left <= right && top <= bottom){\\n            // Top row \\n            for(int i = left; i <= right; i++){\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            // right column \\n            for(int i = top; i <= bottom; i++){\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if(top <= bottom){\\n               for(int i = right; i >= left; i--){\\n                    result.add(matrix[bottom][i]);\\n                } \\n            }\\n            bottom--;\\n            if(left <= right){\\n               for(int i = bottom; i >= top; i--){\\n                    result.add(matrix[i][left]);\\n                }  \\n            }\\n            left++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> result=new ArrayList<>();\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length == 0) return result;\\n        helper(matrix, 0, matrix[0].length - 1, 0, matrix.length - 1);\\n        return result;\\n    }\\n    public void helper(int[][] matrix, int left, int right, int top, int bottom){\\n        // Base case : If pointers cross each other terminate\\n        if(left > right || top > bottom) return;\\n        // top row\\n        for(int i = left; i <= right; i++){\\n            result.add(matrix[top][i]);\\n        }\\n        top++;\\n        //right column\\n        for(int i = top; i <= bottom; i++){\\n            result.add(matrix[i][right]);\\n        }\\n        right--;\\n        // We need to check top <= bottom because original position of top has increased\\n        if(top <= bottom){\\n              //Bottom row\\n            for(int i = right; i >= left; i--){\\n                result.add(matrix[bottom][i]);\\n            }\\n        }\\n        bottom--;\\n           // We need to check left <= right because original position of left has changed\\n        if(left <= right){\\n              //left column\\n            for(int i = bottom; i >= top; i--){\\n                result.add(matrix[i][left]);\\n            }\\n        }\\n        left++;\\n        helper(matrix,left, right, top, bottom); \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List <Integer> result = new ArrayList<>();\\n         if(matrix.length == 0) return result;\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].length - 1;\\n        int bottom = matrix.length - 1;\\n        while (left <= right && top <= bottom){\\n            // Top row \\n            for(int i = left; i <= right; i++){\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            // right column \\n            for(int i = top; i <= bottom; i++){\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if(top <= bottom){\\n               for(int i = right; i >= left; i--){\\n                    result.add(matrix[bottom][i]);\\n                } \\n            }\\n            bottom--;\\n            if(left <= right){\\n               for(int i = bottom; i >= top; i--){\\n                    result.add(matrix[i][left]);\\n                }  \\n            }\\n            left++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389896,
                "title": "scala-solution-with-detailed-explanations",
                "content": "This question is very like [RotateImage](https://leetcode.com/problems/rotate-image/), we can reuse the function.\\n\\nConsider this problem can be convert to get the first line, then rotate the matrix counterclockwise.\\nFor Example.\\n```\\n1 2 3              4 5 6              6 9\\n4 5 6  => [1,2,3]  7 8 9   => [1,2,3] 5 8  =>  [1,2,3,6,9] 5 8  => [1,2,3,6,9] 8 7 =>\\n7 8 9                                 4 7                  4 7                 5 4\\n\\n[1,2,3,6,9,8,7] 5 4 => [1,2,3,6,9,8,7] 4 => [1,2,3,6,9,8,7,4] 5 => [1,2,3,6,9,8,7,4,5]\\n                                       5\\n```\\n\\nHow can we rotate the matrix counterclockwise? Well, a trivial solution is rotate it clockwise three times,\\n\\nAnother way is to first transpose it and then reverse it.\\n```\\n4 5 6   =>  4 7  =>  6 9\\n7 8 9       5 8      5 8\\n            6 9      4 7\\n```\\n\\nThen just implement it\\n```scala\\nobject SpiralMatrix {\\n\\n  /** RunTime Info:\\n    * 244ms, 44MB\\n    *\\n    * @param matrix input matrix\\n    * @return matrix elements in spiral order\\n    */\\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\\n    def snail(xs: List[List[Int]]): List[Int] = xs match {\\n      case Nil => Nil\\n      case x :: xs => x ++ snail(xs.transpose.reverse)\\n    }\\n\\n    snail(matrix.toList.map(_.toList))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3              4 5 6              6 9\\n4 5 6  => [1,2,3]  7 8 9   => [1,2,3] 5 8  =>  [1,2,3,6,9] 5 8  => [1,2,3,6,9] 8 7 =>\\n7 8 9                                 4 7                  4 7                 5 4\\n\\n[1,2,3,6,9,8,7] 5 4 => [1,2,3,6,9,8,7] 4 => [1,2,3,6,9,8,7,4] 5 => [1,2,3,6,9,8,7,4,5]\\n                                       5\\n```\n```\\n4 5 6   =>  4 7  =>  6 9\\n7 8 9       5 8      5 8\\n            6 9      4 7\\n```\n```scala\\nobject SpiralMatrix {\\n\\n  /** RunTime Info:\\n    * 244ms, 44MB\\n    *\\n    * @param matrix input matrix\\n    * @return matrix elements in spiral order\\n    */\\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\\n    def snail(xs: List[List[Int]]): List[Int] = xs match {\\n      case Nil => Nil\\n      case x :: xs => x ++ snail(xs.transpose.reverse)\\n    }\\n\\n    snail(matrix.toList.map(_.toList))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 371800,
                "title": "python-simple-solution",
                "content": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        firstRow, firstCol = 0, 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        result = []\\n\\n        while rows > 0 and cols > 0:\\n            lastRow = firstRow + rows - 1\\n            lastCol = firstCol + cols - 1\\n\\n            # Top left to right\\n            for i in range(cols):\\n                result.append(matrix[firstRow][firstCol + i])\\n            # Right top to bottom\\n            for i in range(1, rows):\\n                result.append(matrix[firstRow + i][lastCol])\\n            # Bottom right to left\\n            for i in range(1, cols):\\n                if firstRow != lastRow:\\n                    result.append(matrix[lastRow][lastCol - i])\\n            # Left bottom to top\\n            for i in range(1, rows - 1):\\n                if firstCol != lastCol:\\n                    result.append(matrix[lastRow - i][firstCol])\\n\\n            # Next layer\\n            firstRow += 1\\n            firstCol += 1\\n            rows -= 2\\n            cols -= 2\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        firstRow, firstCol = 0, 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        result = []\\n\\n        while rows > 0 and cols > 0:\\n            lastRow = firstRow + rows - 1\\n            lastCol = firstCol + cols - 1\\n\\n            # Top left to right\\n            for i in range(cols):\\n                result.append(matrix[firstRow][firstCol + i])\\n            # Right top to bottom\\n            for i in range(1, rows):\\n                result.append(matrix[firstRow + i][lastCol])\\n            # Bottom right to left\\n            for i in range(1, cols):\\n                if firstRow != lastRow:\\n                    result.append(matrix[lastRow][lastCol - i])\\n            # Left bottom to top\\n            for i in range(1, rows - 1):\\n                if firstCol != lastCol:\\n                    result.append(matrix[lastRow - i][firstCol])\\n\\n            # Next layer\\n            firstRow += 1\\n            firstCol += 1\\n            rows -= 2\\n            cols -= 2\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286639,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n  if (matrix.length == 0) {\\n    return [];\\n  }\\n  let result = [];\\n  let rowStart = 0;\\n  let rowEnd = matrix.length - 1;\\n  let colStart = 0;\\n  let colEnd = matrix[0].length - 1;\\n  while (true) {\\n    // top\\n    for (let i = colStart; i <= colEnd; i++) {\\n      result.push(matrix[rowStart][i]);\\n    }\\n    rowStart++;\\n    if (rowStart > rowEnd) {\\n      return result;\\n    }\\n    // right\\n    for (let i = rowStart; i <= rowEnd; i++) {\\n      result.push(matrix[i][colEnd]);\\n    }\\n    colEnd--;\\n    if (colEnd < colStart) {\\n      return result;\\n    }\\n    // bottom\\n    for (let i = colEnd; i >= colStart; i--) {\\n      result.push(matrix[rowEnd][i]);\\n    }\\n    rowEnd--;\\n    if (rowEnd < rowStart) {\\n      return result;\\n    }\\n    // left\\n    for (let i = rowEnd; i >= rowStart; i--) {\\n      result.push(matrix[i][colStart]);\\n    }\\n    colStart++;\\n    if (colStart > colEnd) {\\n      return result;\\n    }\\n  }\\n  return result;\\n};\\nconsole.log(\\n  spiralOrder([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13], [14, 15, 16]])\\n);\\nconsole.log(spiralOrder([[7], [9], [6]]));\\nconsole.log(spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]));\\nconsole.log(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n  if (matrix.length == 0) {\\n    return [];\\n  }\\n  let result = [];\\n  let rowStart = 0;\\n  let rowEnd = matrix.length - 1;\\n  let colStart = 0;\\n  let colEnd = matrix[0].length - 1;\\n  while (true) {\\n    // top\\n    for (let i = colStart; i <= colEnd; i++) {\\n      result.push(matrix[rowStart][i]);\\n    }\\n    rowStart++;\\n    if (rowStart > rowEnd) {\\n      return result;\\n    }\\n    // right\\n    for (let i = rowStart; i <= rowEnd; i++) {\\n      result.push(matrix[i][colEnd]);\\n    }\\n    colEnd--;\\n    if (colEnd < colStart) {\\n      return result;\\n    }\\n    // bottom\\n    for (let i = colEnd; i >= colStart; i--) {\\n      result.push(matrix[rowEnd][i]);\\n    }\\n    rowEnd--;\\n    if (rowEnd < rowStart) {\\n      return result;\\n    }\\n    // left\\n    for (let i = rowEnd; i >= rowStart; i--) {\\n      result.push(matrix[i][colStart]);\\n    }\\n    colStart++;\\n    if (colStart > colEnd) {\\n      return result;\\n    }\\n  }\\n  return result;\\n};\\nconsole.log(\\n  spiralOrder([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13], [14, 15, 16]])\\n);\\nconsole.log(spiralOrder([[7], [9], [6]]));\\nconsole.log(spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]));\\nconsole.log(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279629,
                "title": "java-clean-solution",
                "content": "```\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new ArrayList<>();\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        List<Integer> ret = new ArrayList<>();\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; ++i) ret.add(matrix[top][i]);\\n            for (int i = ++top; i <= bottom; ++i) ret.add(matrix[i][right]);\\n            // bug - 1 => avoid duplicates collected;\\n            if (top > bottom) break;\\n            for (int i = --right; i >= left; --i) ret.add(matrix[bottom][i]);\\n            if (left > right) break;\\n            for (int i = --bottom; i >= top; --i) ret.add(matrix[i][left]);\\n            left++;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new ArrayList<>();\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        List<Integer> ret = new ArrayList<>();\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; ++i) ret.add(matrix[top][i]);\\n            for (int i = ++top; i <= bottom; ++i) ret.add(matrix[i][right]);\\n            // bug - 1 => avoid duplicates collected;\\n            if (top > bottom) break;\\n            for (int i = --right; i >= left; --i) ret.add(matrix[bottom][i]);\\n            if (left > right) break;\\n            for (int i = --bottom; i >= top; --i) ret.add(matrix[i][left]);\\n            left++;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197782,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { \\n        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {\\n            case mx if mx.isEmpty => List()\\n            case mx if mx.length == 1 => mx.head.toList\\n            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse) \\n        }\\n        dfs(matrix)\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { \\n        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {\\n            case mx if mx.isEmpty => List()\\n            case mx if mx.length == 1 => mx.head.toList\\n            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse) \\n        }\\n        dfs(matrix)\\n    }    \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110805,
                "title": "only-11-lines-very-simple-python-solution",
                "content": "```  \\n def spiralOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m=len(matrix)\\n        rec=[]\\n        if m==1:\\n            return matrix[0]\\n        if m>1:\\n            while len(matrix)>0:\\n                rec+=matrix[0]\\n                matrix.remove(matrix[0])\\n                matrix=map(list,zip(*matrix))\\n                matrix.reverse()\\n        return  rec   ```",
                "solutionTags": [],
                "code": "```  \\n def spiralOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m=len(matrix)\\n        rec=[]\\n        if m==1:\\n            return matrix[0]\\n        if m>1:\\n            while len(matrix)>0:\\n                rec+=matrix[0]\\n                matrix.remove(matrix[0])\\n                matrix=map(list,zip(*matrix))\\n                matrix.reverse()\\n        return  rec   ```",
                "codeTag": "Python3"
            },
            {
                "id": 20746,
                "title": "my-intuitive-java-solution-very-easy-to-avoid-edge-cases",
                "content": "- In order to coding directly and semantically, use four variables as ___walls___: `l`, `r`, `t`, `b`.\\n\\nAttached is my AC code:\\n\\n    public class Solution {\\n      public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ret=  new ArrayList<Integer>();\\n        if(matrix.length==0 || matrix[0].length==0) return ret;\\n        int b = matrix.length-1, r = matrix[0].length-1, t=0,l=0;\\n        while(t<=b && l<=r){\\n          //Right\\n          for(int j=l;j<=r;j++)\\n            ret.add(matrix[t][j]);\\n          t++;\\n          //Down\\n          for(int i=t;i<=b;i++)\\n            ret.add(matrix[i][r]);\\n          r--;\\n          //Left\\n          for(int j=r;j>=l && t<=b;j--)\\n            ret.add(matrix[b][j]);\\n          b--;\\n          //Up\\n          for(int i=b;i>=t && l<=r;i--)\\n            ret.add(matrix[i][l]);\\n          l++;\\n        }\\n        return ret;\\n      }\\n    }\\n\\n- WA: forget to check `t<=b` and `l<=r` when going left and up.\\n- AC then.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ret=  new ArrayList<Integer>();\\n        if(matrix.length==0 || matrix[0].length==0) return ret;\\n        int b = matrix.length-1, r = matrix[0].length-1, t=0,l=0;\\n        while(t<=b && l<=r){\\n          //Right\\n          for(int j=l;j<=r;j++)\\n            ret.add(matrix[t][j]);\\n          t++;\\n          //Down\\n          for(int i=t;i<=b;i++)\\n            ret.add(matrix[i][r]);\\n          r--;\\n          //Left\\n          for(int j=r;j>=l && t<=b;j--)\\n            ret.add(matrix[b][j]);\\n          b--;\\n          //Up\\n          for(int i=b;i>=t && l<=r;i--)\\n            ret.add(matrix[i][l]);\\n          l++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20712,
                "title": "straightforward-java-solution",
                "content": "    public class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int left = 0, right = col-1;\\n        int top = 0, bottom = row-1;\\n        while(true){\\n            for(int i = left; i<=right; i++){\\n                list.add(matrix[top][i]);\\n            }\\n            top++;\\n            if(top > bottom) break;\\n            for(int i = top; i<=bottom; i++){\\n                list.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(right < left) break;\\n            for(int i = right; i>=left; i--){\\n                list.add(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            if(bottom < top) break;\\n            for(int i = bottom; i>=top; i--){\\n                list.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(left > right) break;\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int left = 0, right = col-1;\\n        int top = 0, bottom = row-1;\\n        while(true){\\n            for(int i = left; i<=right; i++){\\n                list.add(matrix[top][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20825,
                "title": "simple-java-solution",
                "content": "\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {return res;}\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        int tag = 0, row = top, col = left;\\n        // int m = 0;\\n        for (int m = 0; m < matrix.length * matrix[0].length; m++) {\\n            if (tag == 0) {\\n                res.add(matrix[row][col]);\\n                if (col == right) {\\n                    tag = 1;\\n                    top++;\\n                    row = top;\\n                } else {col++;}\\n            } else if (tag == 1) {\\n                res.add(matrix[row][col]);\\n                if (row == bottom) {\\n                    tag = 2;\\n                    right--;\\n                    col = right;\\n                } else {row++;}\\n            } else if (tag == 2) {\\n                res.add(matrix[row][col]);\\n                if (col == left) {\\n                    tag = 3;\\n                    bottom--;\\n                    row = bottom;\\n                } else {col--;}\\n            } else {\\n                res.add(matrix[row][col]);\\n                if (row == top) {\\n                    tag = 0;\\n                    left++;\\n                    col = left;\\n                } else {row--;}\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {return res;}\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        int tag = 0, row = top, col = left;\\n        // int m = 0;\\n        for (int m = 0; m < matrix.length * matrix[0].length; m++) {\\n            if (tag == 0) {\\n                res.add(matrix[row][col]);\\n                if (col == right) {\\n                    tag = 1;\\n                    top++;\\n                    row = top;\\n                } else {col++;}\\n            } else if (tag == 1) {\\n                res.add(matrix[row][col]);\\n                if (row == bottom) {\\n                    tag = 2;\\n                    right--;\\n                    col = right;\\n                } else {row++;}\\n            } else if (tag == 2) {\\n                res.add(matrix[row][col]);\\n                if (col == left) {\\n                    tag = 3;\\n                    bottom--;\\n                    row = bottom;\\n                } else {col--;}\\n            } else {\\n                res.add(matrix[row][col]);\\n                if (row == top) {\\n                    tag = 0;\\n                    left++;\\n                    col = left;\\n                } else {row--;}\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3986119,
                "title": "o-n-m-solution-using-direction-variables",
                "content": "Each time we hit the border, change the direction. Borders will be adjusted based on parsed elements.\\n\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        res = []\\n        m, n = len(matrix), len(matrix[0])\\n        # initial borders\\n        top, right, bottom, left = 0, n-1, m-1, 0\\n        # direction\\n        horizontal, vertical = 1, 0\\n        # start\\n        i, j = 0, 0\\n        \\n        while len(res) < m*n:\\n            res.append(matrix[i][j])\\n            \\n            if (i,j) == (top,right) and horizontal == 1:\\n                horizontal, vertical = 0, 1\\n                top += 1\\n            elif (i,j) == (bottom,right) and vertical == 1:\\n                horizontal, vertical = -1, 0\\n                right -= 1\\n            elif (i,j) == (top,left) and vertical == -1:\\n                horizontal, vertical = 1, 0\\n                left += 1\\n            elif (i,j) == (bottom,left) and horizontal == -1:\\n                horizontal, vertical = 0, -1\\n                bottom -= 1\\n            \\n            i += vertical\\n            j += horizontal\\n               \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "Each time we hit the border, change the direction. Borders will be adjusted based on parsed elements.\\n\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        res = []\\n        m, n = len(matrix), len(matrix[0])\\n        # initial borders\\n        top, right, bottom, left = 0, n-1, m-1, 0\\n        # direction\\n        horizontal, vertical = 1, 0\\n        # start\\n        i, j = 0, 0\\n        \\n        while len(res) < m*n:\\n            res.append(matrix[i][j])\\n            \\n            if (i,j) == (top,right) and horizontal == 1:\\n                horizontal, vertical = 0, 1\\n                top += 1\\n            elif (i,j) == (bottom,right) and vertical == 1:\\n                horizontal, vertical = -1, 0\\n                right -= 1\\n            elif (i,j) == (top,left) and vertical == -1:\\n                horizontal, vertical = 1, 0\\n                left += 1\\n            elif (i,j) == (bottom,left) and horizontal == -1:\\n                horizontal, vertical = 0, -1\\n                bottom -= 1\\n            \\n            i += vertical\\n            j += horizontal\\n               \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3516947,
                "title": "very-easy-c-solution-with-explanation-easy-to-understand",
                "content": "/*question bhot asan h bs khre h hme matrix print krni h kuch iss form me jo picture lgi hui h sbse\\nphle hum iss matrix me kya krre h sbse phle hum print kra re h apni starting row then print kra re h end column then print krare h end row then print kra re h start column abb jb bhi koi print hoga hum update krdenge for rx hmara koi row print hua start row abb usko update kdenge startrow++ abb kyuki first element aa chuka h array ka upar photo me dekhe to 3 aa chuka h to abb three nhi chaiye isleye hi yo update kie start row ab  kya bn gai h 2 yani abb 3 na print hoke 6 se printing shuru hogi \\n\\nasse hi jb hum start row or end col print krdenge hum end col ko bhi kya krdenge ++ krdenge to abb 9 ek hi bar print hoga jb hum end row ko print krre honge  jo hmara endcolumn se shuru hui h or kha tk gai h starting column tk starting column to thik h 0 ha pr end column hme kya krrdia -- krke abb 9 na print hoke 8 hi print hoga */\\n\\n\\n\\nclass Solution {    \\npublic:\\n\\n        \\n\\t\\tvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        \\n        // index used to travel the 2d array \\n        \\n        int startrow = 0;\\n        int endrow = row-1;\\n        int startcol = 0;\\n        int endcol = col-1;\\n        \\n        while(count<total)\\n        {\\n            \\n            // print starting row \\n            for(int index = startcol; count<total && index<=endcol; index++ )\\n            {\\n                 ans.push_back(matrix[startrow][index]);\\n                count++;\\n            }\\n            startrow++;\\n             // print ending colunm \\n            for(int index = startrow; count<total && index<=endrow; index++ )\\n            {\\n                 ans.push_back(matrix[index][endcol]);\\n                 count++;\\n            }\\n            endcol--;\\n            \\n             // print ending row \\n            for(int index = endcol; count<total && index>=startcol; index-- )\\n            {\\n                 ans.push_back(matrix[endrow][index]);\\n                 count++;\\n            }\\n            endrow--;\\n              // print starting  colunm \\n            for(int index = endrow; count<total && index>= startrow; index-- )\\n            {\\n                 ans.push_back(matrix[index][startcol]);\\n                 count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {    \\npublic:\\n\\n        \\n\\t\\tvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        \\n        // index used to travel the 2d array \\n        \\n        int startrow = 0;\\n        int endrow = row-1;\\n        int startcol = 0;\\n        int endcol = col-1;\\n        \\n        while(count<total)\\n        {\\n            \\n            // print starting row \\n            for(int index = startcol; count<total && index<=endcol; index++ )\\n            {\\n                 ans.push_back(matrix[startrow][index]);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3507949,
                "title": "super-solution-using-two-pointer-python3",
                "content": "\\n# Superb Logic Using 2 pointer Python\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        left=0\\n        right=n-1\\n        top=0\\n        bottom=m-1\\n        list1 = []\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1,1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            \\n            for i in range(top,bottom+1,1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==m*n:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        left=0\\n        right=n-1\\n        top=0\\n        bottom=m-1\\n        list1 = []\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1,1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            \\n            for i in range(top,bottom+1,1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==m*n:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507932,
                "title": "java-beats-100-time-oms-easiest-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nLinear\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int left=0, bottom=matrix.length-1, right=matrix[0].length-1, top=0;\\n        while(left<=right || top<=bottom){\\n                if(top<=bottom){\\n                    for(int i=left;i<=right;i++)\\n                    ans.add(matrix[top][i]);\\n                    top++;\\n                }\\n                if(left<=right){\\n                    for(int i=top;i<=bottom;i++)\\n                    ans.add(matrix[i][right]);\\n                    right--;\\n                }\\n                if(top<=bottom){\\n                    for(int i=right;i>=left;i--)\\n                    ans.add(matrix[bottom][i]);\\n                    bottom--;\\n                }\\n                if(left<=right){\\n                    for(int i=bottom;i>=top;i--)\\n                    ans.add(matrix[i][left]);\\n                    left++;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int left=0, bottom=matrix.length-1, right=matrix[0].length-1, top=0;\\n        while(left<=right || top<=bottom){\\n                if(top<=bottom){\\n                    for(int i=left;i<=right;i++)\\n                    ans.add(matrix[top][i]);\\n                    top++;\\n                }\\n                if(left<=right){\\n                    for(int i=top;i<=bottom;i++)\\n                    ans.add(matrix[i][right]);\\n                    right--;\\n                }\\n                if(top<=bottom){\\n                    for(int i=right;i>=left;i--)\\n                    ans.add(matrix[bottom][i]);\\n                    bottom--;\\n                }\\n                if(left<=right){\\n                    for(int i=bottom;i>=top;i--)\\n                    ans.add(matrix[i][left]);\\n                    left++;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507231,
                "title": "explained-with-code-in-c-and-python",
                "content": "# Intuition\\nStart with a **pen paper approach** to **traverse the matrix**. A clear understanding of **nav**igating through the **rows and columns** in important to understand and solve these type of questions.\\n\\n# Approach\\nThere are basically 4 steps to this problem:\\n1. Move from `left to right` for the `first row`, `increment top`\\n2. Move from `top to bottom` for the `right column`, `decrement right`\\n3. Move from `right to left` for the `bottom row`, `decrement bottom`\\n4. Move from `bottom to top` for the `left column`, `increment left` \\n\\nIterate these steps until there are **no rows and columns**, you can do this by checking if `top <= bottom` and `left <= right`\\n\\nRemember that, in Python ranges are not inclusive, i.e., the end is not considered. Therefore, you have to either add 1 or subtract 1 to consider the entire range of the rows and columns.\\n\\n# Complexity\\n- Time complexity: O(n X m)\\n- Space complexity: O(n X m)\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        # Intialize the 4 directions of the matrix\\n        top = 0\\n        bottom = len(matrix) - 1\\n        right = len(matrix[0]) - 1\\n        left = 0\\n        \\n        # Create an array to store the resultant array\\n        res = []\\n\\n        # Iterate until you have no rows and columns\\n        while top <= bottom and left <= right:\\n\\n            # Since Python ranges are not inclusive, we have to consider adding or substracting 1 to allow complete matrix ranges. \\n\\n            # Iterate from left to right\\n            # We have the top as constant as the row number\\n            for i in range(left, right + 1):\\n                res.append(matrix[top][i])\\n            # Now, we can move to the next row\\n            # Increment top by 1 to move to the next row\\n            top += 1\\n            \\n            # Iterate from top to bottom\\n            # We have right as the constant column number\\n            for i in range(top, bottom + 1):\\n                res.append(matrix[i][right])\\n            # Now, we can elimiate the right column\\n            # Decrement right by 1 to move to the previous column\\n            right -= 1\\n\\n            # In case where we have no more rows to print, \\n            # We need to check if the top is still less than or equal to bottom\\n            if top <= bottom: \\n                # Iterate from right to left\\n                # We have the bottom as constant as the row number\\n                for i in range(right, left - 1, -1):\\n                    res.append(matrix[bottom][i])\\n                # Now, we can elimiate the bottom row\\n                # Decrement right by 1 to move to the previous row  \\n                bottom -= 1\\n\\n            # In case where we have no more columns to print, \\n            # We need to check if the left is still less than or equal to right\\n            if left <= right:\\n                # Iterate from bottom to top\\n                # We have the left as constant as the column number\\n                for i in range(bottom, top - 1, -1):\\n                    res.append(matrix[i][left])\\n                # Now, we can elimiate the left column\\n                # Increment left by 1 to move to the next column  \\n                left += 1\\n\\n        return res\\n```\\n``` C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    // Initialize the 4 directions of the matrix\\n    int top = 0;\\n    int bottom = matrixSize - 1;\\n    int right = *matrixColSize - 1;\\n    int left = 0;\\n\\n    // Create an array to store the resultant array\\n    int *res = (int*)malloc(matrixSize * (*matrixColSize) * sizeof(int));\\n    *returnSize = 0;\\n\\n    // Iterate until you have no rows and columns\\n    while (top <= bottom && left <= right) {\\n        // Iterate from left to right\\n        // We have the top as constant as the row number\\n        for (int i = left; i <= right; i++) {\\n            res[(*returnSize)++] = matrix[top][i];\\n        }\\n        // Now, we can move to the next row\\n        // Increment top by 1 to move to the next row\\n        top++;\\n\\n        // Iterate from top to bottom\\n        // We have right as the constant column number\\n        for (int i = top; i <= bottom; i++) {\\n            res[(*returnSize)++] = matrix[i][right];\\n        }\\n        // Now, we can eliminate the right column\\n        // Decrement right by 1 to move to the previous column\\n        right--;\\n\\n        // In case where we have no more rows to print,\\n        // We need to check if the top is still less than or equal to bottom\\n        if (top <= bottom) {\\n            // Iterate from right to left\\n            // We have the bottom as constant as the row number\\n            for (int i = right; i >= left; i--) {\\n                res[(*returnSize)++] = matrix[bottom][i];\\n            }\\n            // Now, we can eliminate the bottom row\\n            // Decrement bottom by 1 to move to the previous row\\n            bottom--;\\n        }\\n\\n        // In case where we have no more columns to print,\\n        // We need to check if the left is still less than or equal to right\\n        if (left <= right) {\\n            // Iterate from bottom to top\\n            // We have left as constant as the column number\\n            for (int i = bottom; i >= top; i--) {\\n                res[(*returnSize)++] = matrix[i][left];\\n            }\\n            // Now, we can eliminate the left column\\n            // Increment left by 1 to move to the next column\\n            left++;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        # Intialize the 4 directions of the matrix\\n        top = 0\\n        bottom = len(matrix) - 1\\n        right = len(matrix[0]) - 1\\n        left = 0\\n        \\n        # Create an array to store the resultant array\\n        res = []\\n\\n        # Iterate until you have no rows and columns\\n        while top <= bottom and left <= right:\\n\\n            # Since Python ranges are not inclusive, we have to consider adding or substracting 1 to allow complete matrix ranges. \\n\\n            # Iterate from left to right\\n            # We have the top as constant as the row number\\n            for i in range(left, right + 1):\\n                res.append(matrix[top][i])\\n            # Now, we can move to the next row\\n            # Increment top by 1 to move to the next row\\n            top += 1\\n            \\n            # Iterate from top to bottom\\n            # We have right as the constant column number\\n            for i in range(top, bottom + 1):\\n                res.append(matrix[i][right])\\n            # Now, we can elimiate the right column\\n            # Decrement right by 1 to move to the previous column\\n            right -= 1\\n\\n            # In case where we have no more rows to print, \\n            # We need to check if the top is still less than or equal to bottom\\n            if top <= bottom: \\n                # Iterate from right to left\\n                # We have the bottom as constant as the row number\\n                for i in range(right, left - 1, -1):\\n                    res.append(matrix[bottom][i])\\n                # Now, we can elimiate the bottom row\\n                # Decrement right by 1 to move to the previous row  \\n                bottom -= 1\\n\\n            # In case where we have no more columns to print, \\n            # We need to check if the left is still less than or equal to right\\n            if left <= right:\\n                # Iterate from bottom to top\\n                # We have the left as constant as the column number\\n                for i in range(bottom, top - 1, -1):\\n                    res.append(matrix[i][left])\\n                # Now, we can elimiate the left column\\n                # Increment left by 1 to move to the next column  \\n                left += 1\\n\\n        return res\\n```\n``` C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    // Initialize the 4 directions of the matrix\\n    int top = 0;\\n    int bottom = matrixSize - 1;\\n    int right = *matrixColSize - 1;\\n    int left = 0;\\n\\n    // Create an array to store the resultant array\\n    int *res = (int*)malloc(matrixSize * (*matrixColSize) * sizeof(int));\\n    *returnSize = 0;\\n\\n    // Iterate until you have no rows and columns\\n    while (top <= bottom && left <= right) {\\n        // Iterate from left to right\\n        // We have the top as constant as the row number\\n        for (int i = left; i <= right; i++) {\\n            res[(*returnSize)++] = matrix[top][i];\\n        }\\n        // Now, we can move to the next row\\n        // Increment top by 1 to move to the next row\\n        top++;\\n\\n        // Iterate from top to bottom\\n        // We have right as the constant column number\\n        for (int i = top; i <= bottom; i++) {\\n            res[(*returnSize)++] = matrix[i][right];\\n        }\\n        // Now, we can eliminate the right column\\n        // Decrement right by 1 to move to the previous column\\n        right--;\\n\\n        // In case where we have no more rows to print,\\n        // We need to check if the top is still less than or equal to bottom\\n        if (top <= bottom) {\\n            // Iterate from right to left\\n            // We have the bottom as constant as the row number\\n            for (int i = right; i >= left; i--) {\\n                res[(*returnSize)++] = matrix[bottom][i];\\n            }\\n            // Now, we can eliminate the bottom row\\n            // Decrement bottom by 1 to move to the previous row\\n            bottom--;\\n        }\\n\\n        // In case where we have no more columns to print,\\n        // We need to check if the left is still less than or equal to right\\n        if (left <= right) {\\n            // Iterate from bottom to top\\n            // We have left as constant as the column number\\n            for (int i = bottom; i >= top; i--) {\\n                res[(*returnSize)++] = matrix[i][left];\\n            }\\n            // Now, we can eliminate the left column\\n            // Increment left by 1 to move to the next column\\n            left++;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507111,
                "title": "c-using-only-single-extra-variable-clean-and-simple",
                "content": "Take a single variable for offset, and then traverse the matrix like you would for the outermost edges and increment the offset each iteration.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> ans;\\n        int st = 0;\\n        int sz = m * n;\\n        while (ans.size() < sz) {\\n            for (int i = st; ans.size() < sz && i < n - st; i++) {\\n                ans.push_back(mat[st][i]);\\n            }\\n            for (int i = st + 1; ans.size() < sz && i < m - st; i++) {\\n                ans.push_back(mat[i][n - st - 1]);\\n            }\\n            for (int i = n - 2 - st; ans.size() < sz && i >= st; i--) {\\n                ans.push_back(mat[m - 1 - st][i]);\\n            }\\n            for (int i = m - 2 - st; ans.size() < sz && i >= st + 1; i--) {\\n                ans.push_back(mat[i][st]);\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> ans;\\n        int st = 0;\\n        int sz = m * n;\\n        while (ans.size() < sz) {\\n            for (int i = st; ans.size() < sz && i < n - st; i++) {\\n                ans.push_back(mat[st][i]);\\n            }\\n            for (int i = st + 1; ans.size() < sz && i < m - st; i++) {\\n                ans.push_back(mat[i][n - st - 1]);\\n            }\\n            for (int i = n - 2 - st; ans.size() < sz && i >= st; i--) {\\n                ans.push_back(mat[m - 1 - st][i]);\\n            }\\n            for (int i = m - 2 - st; ans.size() < sz && i >= st + 1; i--) {\\n                ans.push_back(mat[i][st]);\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506091,
                "title": "c-easy-solution-understand-and-try",
                "content": "# Intuition\\n-> It is a simple simulation problem, just need to define the direction and operations of the directions. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> There will be total of 4 directions to move and the loop will continue till the condition reaches that left bound is lesser than right bound and top bound is lesser than lower bound of the matrix boundries limit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        if (matrix.empty()) {\\n            return ans; // Return empty vector if matrix is empty\\n        }\\n        int dir=0;\\n        int right=matrix[0].size()-1,left=0,top=0,bottom=matrix.size()-1;\\n        while(bottom>=top && right>=left)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                ans.push_back(matrix[top][i]);\\n                }\\n                dir=1;\\n                top++;\\n            }\\n             else if (dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                ans.push_back(matrix[i][right]);\\n                }\\n                dir=2;\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                 ans.push_back(matrix[bottom][i]);\\n                }\\n                dir=3;\\n                bottom--;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                ans.push_back(matrix[i][left]);\\n                }\\n                left++;\\n                dir=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        if (matrix.empty()) {\\n            return ans; // Return empty vector if matrix is empty\\n        }\\n        int dir=0;\\n        int right=matrix[0].size()-1,left=0,top=0,bottom=matrix.size()-1;\\n        while(bottom>=top && right>=left)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                ans.push_back(matrix[top][i]);\\n                }\\n                dir=1;\\n                top++;\\n            }\\n             else if (dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                ans.push_back(matrix[i][right]);\\n                }\\n                dir=2;\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                 ans.push_back(matrix[bottom][i]);\\n                }\\n                dir=3;\\n                bottom--;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                ans.push_back(matrix[i][left]);\\n                }\\n                left++;\\n                dir=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503432,
                "title": "c-solution-easy-to-understand-100-beat",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    vector<int> list;\\n\\n    int rowTop = 0;\\n    int rowBottom = matrix.size() - 1;\\n    int columnLeft = 0;\\n    int columnRight = matrix[0].size() - 1;\\n\\n    int direction = 0; \\n\\n    while (rowTop <= rowBottom && columnLeft <= columnRight) {\\n        if (direction == 0) {\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                list.push_back(matrix[rowTop][i]);\\n            }\\n            rowTop++;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 1) {\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                list.push_back(matrix[i][columnRight]);\\n            }\\n            columnRight--;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 2) {\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                list.push_back(matrix[rowBottom][i]);\\n            }\\n            rowBottom--;\\n            direction = (direction + 1) % 4;\\n        } else {\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                list.push_back(matrix[i][columnLeft]);\\n            }\\n            columnLeft++;\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    return list;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    vector<int> list;\\n\\n    int rowTop = 0;\\n    int rowBottom = matrix.size() - 1;\\n    int columnLeft = 0;\\n    int columnRight = matrix[0].size() - 1;\\n\\n    int direction = 0; \\n\\n    while (rowTop <= rowBottom && columnLeft <= columnRight) {\\n        if (direction == 0) {\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                list.push_back(matrix[rowTop][i]);\\n            }\\n            rowTop++;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 1) {\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                list.push_back(matrix[i][columnRight]);\\n            }\\n            columnRight--;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 2) {\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                list.push_back(matrix[rowBottom][i]);\\n            }\\n            rowBottom--;\\n            direction = (direction + 1) % 4;\\n        } else {\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                list.push_back(matrix[i][columnLeft]);\\n            }\\n            columnLeft++;\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    return list;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503387,
                "title": "c-beats-100-dfs-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isValidIndex(int i, int j, int n, int m){\\n    return (i>=0 and j>=0 and i<n and j<m);\\n}\\n\\nvector<pair<int,int>> moves = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\nvoid dfs(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &vis, vector<int> &ans,int n, int m, bool up){\\n    if(!isValidIndex(i,j,n,m) or vis[i][j]) return;\\n    vis[i][j]=1;\\n    ans.push_back(matrix[i][j]);    \\n    if(up) dfs(i-1,j,matrix,vis,ans,n,m,true);\\n    for(auto x:moves){\\n        int newI=i+x.first;\\n        int newJ=j+x.second;\\n        if((x.first==-1 and x.second==0))\\n        dfs(newI,newJ,matrix,vis,ans,n,m,true);\\n        else dfs(newI,newJ,matrix,vis,ans,n,m,false);  \\n    }\\n} \\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> ans;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        dfs(0,0,matrix,vis,ans,n,m,false);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isValidIndex(int i, int j, int n, int m){\\n    return (i>=0 and j>=0 and i<n and j<m);\\n}\\n\\nvector<pair<int,int>> moves = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\nvoid dfs(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &vis, vector<int> &ans,int n, int m, bool up){\\n    if(!isValidIndex(i,j,n,m) or vis[i][j]) return;\\n    vis[i][j]=1;\\n    ans.push_back(matrix[i][j]);    \\n    if(up) dfs(i-1,j,matrix,vis,ans,n,m,true);\\n    for(auto x:moves){\\n        int newI=i+x.first;\\n        int newJ=j+x.second;\\n        if((x.first==-1 and x.second==0))\\n        dfs(newI,newJ,matrix,vis,ans,n,m,true);\\n        else dfs(newI,newJ,matrix,vis,ans,n,m,false);  \\n    }\\n} \\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> ans;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        dfs(0,0,matrix,vis,ans,n,m,false);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502873,
                "title": "check-on-boundary-and-visited-positions-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sequence of direction change is (right, bottom, left, up). And this happens on encounter **boundary** and **visited position**.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the value of martix is between -100~100, just mark every visited position to 1000. Every time we check next position is boundary or visited position? Change direction when true, otherwise keep original. Repeat this until we collect all elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> ans;        \\n        \\n        int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int currDir = 0;\\n        int currR= 0, currC = 0;\\n        // loop until collect all elements\\n        while(ans.size() < m*n) {            \\n            ans.push_back(matrix[currR][currC]);\\n            matrix[currR][currC] = 1000;  // mark visited\\n            int nextR = currR + dir[currDir][0];\\n            int nextC = currC + dir[currDir][1];\\n            // change direction when encounter invalid cases\\n            if(nextR < 0 || nextR >= m || nextC< 0 || nextC >=n || matrix[nextR][nextC] == 1000) \\n                currDir = (currDir+1)%4;                            \\n            currR += dir[currDir][0];\\n            currC += dir[currDir][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> ans;        \\n        \\n        int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int currDir = 0;\\n        int currR= 0, currC = 0;\\n        // loop until collect all elements\\n        while(ans.size() < m*n) {            \\n            ans.push_back(matrix[currR][currC]);\\n            matrix[currR][currC] = 1000;  // mark visited\\n            int nextR = currR + dir[currDir][0];\\n            int nextC = currC + dir[currDir][1];\\n            // change direction when encounter invalid cases\\n            if(nextR < 0 || nextR >= m || nextC< 0 || nextC >=n || matrix[nextR][nextC] == 1000) \\n                currDir = (currDir+1)%4;                            \\n            currR += dir[currDir][0];\\n            currC += dir[currDir][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502617,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int startingRow=0;\\n    int endingRow=matrix.size()-1;\\n    int startingCol=0;\\n    int endingCol=matrix[0].size()-1;\\n    vector<int> ans;\\n    int total=matrix.size()*matrix[0].size();\\n    int count=0;\\n    while(count<total)\\n    {\\n        //starting row\\n        for(int i=startingCol;i<=endingCol&&count<total;i++)\\n        {\\n            ans.push_back(matrix[startingRow][i]);\\n            count++;\\n        }\\n        startingRow++;\\n        //ending column\\n        for(int i=startingRow;i<=endingRow&&count<total;i++)\\n        {\\n            ans.push_back(matrix[i][endingCol]);\\n            count++;\\n        }\\n        endingCol--;\\n        //ending row\\n        for(int i=endingCol;i>=startingCol&&count<total;i--)\\n        {\\n            ans.push_back(matrix[endingRow][i]);\\n            count++;\\n        }\\n        endingRow--;\\n        //starting column\\n        for(int i=endingRow;i>=startingRow&&count<total;i--)\\n        {\\n            ans.push_back(matrix[i][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int startingRow=0;\\n    int endingRow=matrix.size()-1;\\n    int startingCol=0;\\n    int endingCol=matrix[0].size()-1;\\n    vector<int> ans;\\n    int total=matrix.size()*matrix[0].size();\\n    int count=0;\\n    while(count<total)\\n    {\\n        //starting row\\n        for(int i=startingCol;i<=endingCol&&count<total;i++)\\n        {\\n            ans.push_back(matrix[startingRow][i]);\\n            count++;\\n        }\\n        startingRow++;\\n        //ending column\\n        for(int i=startingRow;i<=endingRow&&count<total;i++)\\n        {\\n            ans.push_back(matrix[i][endingCol]);\\n            count++;\\n        }\\n        endingCol--;\\n        //ending row\\n        for(int i=endingCol;i>=startingCol&&count<total;i--)\\n        {\\n            ans.push_back(matrix[endingRow][i]);\\n            count++;\\n        }\\n        endingRow--;\\n        //starting column\\n        for(int i=endingRow;i>=startingRow&&count<total;i--)\\n        {\\n            ans.push_back(matrix[i][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502597,
                "title": "java-simulation-beats-100-20-lines",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length - 1, n = matrix[0].length;\\n    int x = 0, y = 0;\\n    var list = new ArrayList<Integer>();\\n\\n    while (true) {\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y++) list.add(matrix[x][y]);\\n      x++; y--; n--;\\n\\n      if (m == 0) break;\\n      for (var i=0; i<m; i++, x++) list.add(matrix[x][y]);\\n      y--; x--; m--;\\n\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y--) list.add(matrix[x][y]);\\n      x--; y++; n--;\\n\\n      if (m == 0) break;\\n      for(var i=0; i<m; i++, x--) list.add(matrix[x][y]);\\n      y++; x++; m--;\\n    }\\n    return list;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length - 1, n = matrix[0].length;\\n    int x = 0, y = 0;\\n    var list = new ArrayList<Integer>();\\n\\n    while (true) {\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y++) list.add(matrix[x][y]);\\n      x++; y--; n--;\\n\\n      if (m == 0) break;\\n      for (var i=0; i<m; i++, x++) list.add(matrix[x][y]);\\n      y--; x--; m--;\\n\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y--) list.add(matrix[x][y]);\\n      x--; y++; n--;\\n\\n      if (m == 0) break;\\n      for(var i=0; i<m; i++, x--) list.add(matrix[x][y]);\\n      y++; x++; m--;\\n    }\\n    return list;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502594,
                "title": "daily-leetcoding-challenge-may-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/spiral-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Set Up Boundaries\n\n  \n**Approach 2:** Mark Visited Elements\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/spiral-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3474923,
                "title": "python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        res = []\\n\\n        while left<=right and top<=bottom:\\n\\n            for i in range(left, right+1):\\n                res.append(matrix[top][i])\\n            top += 1\\n\\n            for i in range(top, bottom+1):\\n                res.append(matrix[i][right])\\n            right -= 1\\n\\n            if left>right or top>bottom:\\n                break\\n            \\n            for i in range(right, left-1, -1):\\n                res.append(matrix[bottom][i])\\n            bottom -= 1\\n\\n            for i in range(bottom, top-1, -1):\\n                res.append(matrix[i][left])\\n            left += 1\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        res = []\\n\\n        while left<=right and top<=bottom:\\n\\n            for i in range(left, right+1):\\n                res.append(matrix[top][i])\\n            top += 1\\n\\n            for i in range(top, bottom+1):\\n                res.append(matrix[i][right])\\n            right -= 1\\n\\n            if left>right or top>bottom:\\n                break\\n            \\n            for i in range(right, left-1, -1):\\n                res.append(matrix[bottom][i])\\n            bottom -= 1\\n\\n            for i in range(bottom, top-1, -1):\\n                res.append(matrix[i][left])\\n            left += 1\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284609,
                "title": "one-line-python-solution-with-screenshots",
                "content": "![Screenshot 2023-03-11 at 16.10.07.png](https://assets.leetcode.com/users/images/fd7f120e-b8e5-444a-bc53-84fa4a6a184b_1678547485.512829.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076748,
                "title": "java-optimal-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int left = 0, top = 0, bottom = matrix.length-1, right = matrix[0].length-1;\\n        List<Integer> list = new ArrayList<>();\\n\\n        while(top <= bottom && left <= right){\\n\\n            for(int i=left; i<=right; i++)\\n               list.add(matrix[top][i]);\\n            top++;\\n\\n            for(int i=top; i<=bottom; i++)\\n                list.add(matrix[i][right]);\\n            right--;\\n\\n            if (top <= bottom){\\n            for(int i=right; i>=left; i--)\\n                list.add(matrix[bottom][i]);\\n            bottom--;\\n            }\\n\\n            if (left <= right){\\n            for(int i=bottom; i>=top; i--)\\n                list.add(matrix[i][left]);\\n            left++;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int left = 0, top = 0, bottom = matrix.length-1, right = matrix[0].length-1;\\n        List<Integer> list = new ArrayList<>();\\n\\n        while(top <= bottom && left <= right){\\n\\n            for(int i=left; i<=right; i++)\\n               list.add(matrix[top][i]);\\n            top++;\\n\\n            for(int i=top; i<=bottom; i++)\\n                list.add(matrix[i][right]);\\n            right--;\\n\\n            if (top <= bottom){\\n            for(int i=right; i>=left; i--)\\n                list.add(matrix[bottom][i]);\\n            bottom--;\\n            }\\n\\n            if (left <= right){\\n            for(int i=bottom; i>=top; i--)\\n                list.add(matrix[i][left]);\\n            left++;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991623,
                "title": "super-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row_start=0,col_start=0,row_end=matrix.size()-1,col_end=matrix[0].size()-1;\\n        vector<int> ans;\\n\\n        while(row_start<=row_end && col_start<=col_end){\\n            for(int col=col_start; col<=col_end;col++){\\n                ans.push_back(matrix[row_start][col]);\\n            }\\n            row_start++;\\n             for(int row=row_start; row<=row_end;row++){\\n                ans.push_back(matrix[row][col_end]);\\n            }\\n            col_end--;\\n             for(int col=col_end; col>=col_start && row_start <= row_end;col--){\\n                ans.push_back(matrix[row_end][col]);\\n            }\\n            row_end--;\\n             for(int row=row_end; row>=row_start  && col_start <= col_end;row--){\\n                ans.push_back(matrix[row][col_start]);\\n            }\\n            col_start++;\\n        }\\n        \\n        return ans;\\n        \\n         vector<int>res;\\n        if(matrix.size() == 0) return res;\\n        int minR = 0, maxR = matrix.size() - 1, minC = 0, maxC = matrix[0].size() - 1;\\n        while(minR <= maxR && minC <= maxC){\\n            for(int i = minC; i <= maxC; i++) res.push_back(matrix[minR][i]);\\n            minR++;\\n            for(int i = minR; i <= maxR; i++) res.push_back(matrix[i][maxC]);\\n            maxC--;\\n            for(int i = maxC; i >= minC && minR <= maxR; i--) res.push_back(matrix[maxR][i]);\\n            maxR--;\\n            for(int i = maxR; i >= minR && minC <= maxC; i--) res.push_back(matrix[i][minC]);\\n            minC++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row_start=0,col_start=0,row_end=matrix.size()-1,col_end=matrix[0].size()-1;\\n        vector<int> ans;\\n\\n        while(row_start<=row_end && col_start<=col_end){\\n            for(int col=col_start; col<=col_end;col++){\\n                ans.push_back(matrix[row_start][col]);\\n            }\\n            row_start++;\\n             for(int row=row_start; row<=row_end;row++){\\n                ans.push_back(matrix[row][col_end]);\\n            }\\n            col_end--;\\n             for(int col=col_end; col>=col_start && row_start <= row_end;col--){\\n                ans.push_back(matrix[row_end][col]);\\n            }\\n            row_end--;\\n             for(int row=row_end; row>=row_start  && col_start <= col_end;row--){\\n                ans.push_back(matrix[row][col_start]);\\n            }\\n            col_start++;\\n        }\\n        \\n        return ans;\\n        \\n         vector<int>res;\\n        if(matrix.size() == 0) return res;\\n        int minR = 0, maxR = matrix.size() - 1, minC = 0, maxC = matrix[0].size() - 1;\\n        while(minR <= maxR && minC <= maxC){\\n            for(int i = minC; i <= maxC; i++) res.push_back(matrix[minR][i]);\\n            minR++;\\n            for(int i = minR; i <= maxR; i++) res.push_back(matrix[i][maxC]);\\n            maxC--;\\n            for(int i = maxC; i >= minC && minR <= maxR; i--) res.push_back(matrix[maxR][i]);\\n            maxR--;\\n            for(int i = maxR; i >= minR && minC <= maxC; i--) res.push_back(matrix[i][minC]);\\n            minC++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681041,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        out = []\\n        while matrix:\\n            out+=matrix.pop(0)\\n            if matrix:\\n                for i in range(len(matrix)-1):\\n                    if len(matrix[i])!=0:\\n                        out.append(matrix[i].pop())\\n            if matrix:\\n                out+=matrix.pop()[::-1]\\n            if matrix:\\n                for i in range(1,len(matrix)+1 ):\\n                    if len(matrix[-i])!=0:\\n                        out.append(matrix[-i].pop(0))\\n            \\n        return out\\n```\\n***DO UPVOTE***",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        out = []\\n        while matrix:\\n            out+=matrix.pop(0)\\n            if matrix:\\n                for i in range(len(matrix)-1):\\n                    if len(matrix[i])!=0:\\n                        out.append(matrix[i].pop())\\n            if matrix:\\n                out+=matrix.pop()[::-1]\\n            if matrix:\\n                for i in range(1,len(matrix)+1 ):\\n                    if len(matrix[-i])!=0:\\n                        out.append(matrix[-i].pop(0))\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665398,
                "title": "javascript-simple-and-easy-beginner-friendly",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    \\n    if(matrix.length==0){\\n            return null ;\\n        }\\n        \\n        let rows=matrix.length;\\n        let cols=matrix[0].length;\\n        let col=0,row=0;\\n        let count=0;\\n        let max=rows*cols;\\n        \\n        let mat = [];\\n        \\n        while(count<max){\\n            \\n            for(let i=col;count<max && i<cols;++i){\\n                mat.push(matrix[row][i]);\\n                count++;\\n                }\\n            row++;\\n            \\n            for(let i=row; count<max && i<rows;++i){\\n               mat.push(matrix[i][cols-1]);\\n                count++;\\n            }\\n            cols--;\\n            \\n            for(let i=cols-1; count<max && i>=col;--i){\\n               mat.push(matrix[rows-1][i]);\\n                count++;\\n            }\\n            rows--;\\n            \\n            for(let i=rows-1;count<max && i>=row;--i){\\n              mat.push(matrix[i][col]);\\n                count++;\\n            }\\n            col++;\\n        }\\n        \\n        return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    \\n    if(matrix.length==0){\\n            return null ;\\n        }\\n        \\n        let rows=matrix.length;\\n        let cols=matrix[0].length;\\n        let col=0,row=0;\\n        let count=0;\\n        let max=rows*cols;\\n        \\n        let mat = [];\\n        \\n        while(count<max){\\n            \\n            for(let i=col;count<max && i<cols;++i){\\n                mat.push(matrix[row][i]);\\n                count++;\\n                }\\n            row++;\\n            \\n            for(let i=row; count<max && i<rows;++i){\\n               mat.push(matrix[i][cols-1]);\\n                count++;\\n            }\\n            cols--;\\n            \\n            for(let i=cols-1; count<max && i>=col;--i){\\n               mat.push(matrix[rows-1][i]);\\n                count++;\\n            }\\n            rows--;\\n            \\n            for(let i=rows-1;count<max && i>=row;--i){\\n              mat.push(matrix[i][col]);\\n                count++;\\n            }\\n            col++;\\n        }\\n        \\n        return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485559,
                "title": "kotlin-iterative-simulation",
                "content": "```\\nclass Solution {\\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\\n        val list = mutableListOf<Int>()\\n        var t = 0\\n        var l = 0\\n        var b = matrix.size - 1\\n        var r = matrix[0].size - 1\\n        var dir = 0\\n        while (t <= b && l <= r) {\\n            if (dir == 0) {\\n                for (i in l until r + 1) {\\n                    list.add(matrix[l][i])\\n                }\\n                t++\\n            } else if (dir == 1) {\\n                for (i in t until b + 1) {\\n                    list.add(matrix[i][r])\\n                }\\n                r--\\n            } else if (dir == 2) {\\n                for (i in r downTo l) {\\n                    list.add(matrix[b][i])\\n                }\\n                b--\\n            } else if (dir == 3) {\\n                for (i in b downTo t) {\\n                    list.add(matrix[i][l])\\n                }\\n                l++\\n            }\\n            dir = (dir + 1) % 4\\n            \\n        }\\n        return list\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\\n        val list = mutableListOf<Int>()\\n        var t = 0\\n        var l = 0\\n        var b = matrix.size - 1\\n        var r = matrix[0].size - 1\\n        var dir = 0\\n        while (t <= b && l <= r) {\\n            if (dir == 0) {\\n                for (i in l until r + 1) {\\n                    list.add(matrix[l][i])\\n                }\\n                t++\\n            } else if (dir == 1) {\\n                for (i in t until b + 1) {\\n                    list.add(matrix[i][r])\\n                }\\n                r--\\n            } else if (dir == 2) {\\n                for (i in r downTo l) {\\n                    list.add(matrix[b][i])\\n                }\\n                b--\\n            } else if (dir == 3) {\\n                for (i in b downTo t) {\\n                    list.add(matrix[i][l])\\n                }\\n                l++\\n            }\\n            dir = (dir + 1) % 4\\n            \\n        }\\n        return list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334019,
                "title": "very-simple-dynamic-programming-0ms-java",
                "content": "# **Dynamic Programming Solution (Java)**\\n## Concept\\nThis solution is built around dynamic programming. We know from the problem description that all numbers `x` in the matrix will be `-100 < x < 100`. We leverage this knowledge to denote that `final int VISITED = 101;` in the matrix. Then, we set a direction that the traversal is going, starting with `\"left\"`.\\n\\n## For-Loop Logic\\nThe next assumption we can make is about the loop. My initial thought was to use a while loop, but there would be multiple conditions to track in the while-loop conditional. To simplify this, we can see that traversing every number in the matrix will be `n x m` iterations, where `n = matrix height` and `m = matrix width`. We should never need to re-traverse a part of the matrix, so we can safely set this as the upper bound of the for-loop.\\n\\n## Switch-Statement\\nOnce we are inside the for-loop, we use a switch statement combined with if-statements to check first what direction we\\'re going then if we have reached the end of the unvisited portion of that respective row or column. If we have reached the end of the unvisited section of that row or column, then we switch directions and increment x or y in that direction.\\n\\n### Note:\\nI decided to put the the logic that adds numbers to the solution list and marks the index in the matrix as visited before the switch statement so that it wouldn\\'t have to be duplicated in each case. This is why the else-branches need to begin the traversal for the next direction. That way numbers don\\'t get double-printed.\\n\\n```\\nclass Solution {\\n    final int VISITED = 101; // We know that all numbers x in the matrix will be -100 < x < 100\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        String direction = \"right\";\\n        List<Integer> solution = new ArrayList<Integer>();\\n        int y = 0;\\n        int x = 0;\\n        \\n        for (int i = 0; i < matrix.length * matrix[0].length; i++) {\\n            solution.add(matrix[y][x]);\\n            matrix[y][x] = VISITED;\\n            switch (direction) {\\n                case \"right\":\\n                    if ((x + 1) < matrix[0].length && matrix[y][x + 1] != VISITED) {\\n                        x++;\\n                    }\\n                    else {\\n                        y++;\\n                        direction = \"down\";\\n                    }\\n                    break;\\n                case \"left\":\\n                    if ((x - 1) >= 0 && matrix[y][x - 1] != VISITED) {\\n                        x--;\\n                    }\\n                    else {\\n                        y--;\\n                        direction = \"up\";\\n                    }\\n                    break;\\n                case \"up\":\\n                    if ((y - 1) >= 0 && matrix[y - 1][x] != VISITED) {\\n                        y--;\\n                    }\\n                    else {\\n                        x++;\\n                        direction = \"right\";\\n                    }\\n                    break;\\n                case \"down\":\\n                    if ((y + 1) < matrix.length && matrix[y + 1][x] != VISITED) {\\n                        y++;\\n                    }\\n                    else {\\n                        x--;\\n                        direction = \"left\";\\n                    }\\n                    break;\\n            }\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    final int VISITED = 101; // We know that all numbers x in the matrix will be -100 < x < 100\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        String direction = \"right\";\\n        List<Integer> solution = new ArrayList<Integer>();\\n        int y = 0;\\n        int x = 0;\\n        \\n        for (int i = 0; i < matrix.length * matrix[0].length; i++) {\\n            solution.add(matrix[y][x]);\\n            matrix[y][x] = VISITED;\\n            switch (direction) {\\n                case \"right\":\\n                    if ((x + 1) < matrix[0].length && matrix[y][x + 1] != VISITED) {\\n                        x++;\\n                    }\\n                    else {\\n                        y++;\\n                        direction = \"down\";\\n                    }\\n                    break;\\n                case \"left\":\\n                    if ((x - 1) >= 0 && matrix[y][x - 1] != VISITED) {\\n                        x--;\\n                    }\\n                    else {\\n                        y--;\\n                        direction = \"up\";\\n                    }\\n                    break;\\n                case \"up\":\\n                    if ((y - 1) >= 0 && matrix[y - 1][x] != VISITED) {\\n                        y--;\\n                    }\\n                    else {\\n                        x++;\\n                        direction = \"right\";\\n                    }\\n                    break;\\n                case \"down\":\\n                    if ((y + 1) < matrix.length && matrix[y + 1][x] != VISITED) {\\n                        y++;\\n                    }\\n                    else {\\n                        x--;\\n                        direction = \"left\";\\n                    }\\n                    break;\\n            }\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280721,
                "title": "stuck-like-me-this-may-help-you",
                "content": "Hello, everyone \\n     This is pretty simple question at first but at time of execution it may become trickier\\n\\t Here are some tips which can help you to understand better.\\n1.  Most important is having good and relatable variable name such as we are related to row & column in term of matrix. So, give variable names like \\n**row_begin, row_end, col_begin, col_end.**\\ngiving a names like top, down, start and etc. is okay but it\\'s good to have names like above.\\n2. As shown in diagram we have to traverse thorugh all element and to traverse we have to move right, down, left, up so to traverse accordingly we have to col_begin++,row_begin++,col_end--,row_end-- respectively for desired result.\\n3. having proper condition also hleps a lot. \\nwe\\'ll end our while loop when our row_begin and col_begin reach their limits simultaneously\\n4. Increament & decreament row & col according to need.\\nrest we\\'ll see in code\\n\\nCode: \\n```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int  m = matrix.length-1;\\n        int n = matrix[0].length-1;\\n        int row_begin = 0, col_begin = 0, row_end = m, col_end = n;\\n        while(row_begin <= row_end && col_begin <= col_end){  // setting our condition\\n            for(int i = col_begin; i <= col_end ; i++){      // this for loop will initiate from 0 and will go till 2\\n                list.add(matrix[row_begin][i]);                // list = [ 1,2,3] , remaining [[4,5,6],[7,8,9]]\\n            }\\n            row_begin++;                                              // increamenting row by 1\\n            for(int i = row_begin; i <= row_end ; i++){    // i = 1 till i = 2 because we only need 2 remaining element from end column.\\n                list.add(matrix[i][col_end]);                     // list contains, list = [ 1,2,3,6,9], remaining [[4,5],[7,8]\\n            }\\n            col_end--;                                                   // decreasing our col cause we have to traverse left\\n            if(row_begin <= row_end){                            // if row_begin is greater than 2 than condition won\\'t work\\n                for(int i = col_end; i >= col_begin  ; i--){      // i = 1 till i = 0 \\n                list.add(matrix[row_end][i]);                   // list [1,2,3,6,9,8,7] remaining [[ 4,5]]\\n            }\\n            }\\n            row_end--;                                                  //  decresing rowend will get us upwards\\n            if(col_begin <= col_end){                                \\n                for(int i =row_end; i >= row_begin ; i--){      // i = 1 till i = 0\\n                list.add(matrix[i][colb_egin]);                     // list [ 1,2,3,6,9,8,7,4] remaining [[5]]\\n            }\\n            }\\n            col_begin++;                                               // Increamenting col will give us remaining element and our while loop \\n\\t\\t\\t                                                           // won\\'t break cause colbegin has not exided it\\'s limit yet.\\n        }\\n      return list;\\n    }\\n```\\ni hope this helps you.\\nthanks!\\nKeep grinding!!",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int  m = matrix.length-1;\\n        int n = matrix[0].length-1;\\n        int row_begin = 0, col_begin = 0, row_end = m, col_end = n;\\n        while(row_begin <= row_end && col_begin <= col_end){  // setting our condition\\n            for(int i = col_begin; i <= col_end ; i++){      // this for loop will initiate from 0 and will go till 2\\n                list.add(matrix[row_begin][i]);                // list = [ 1,2,3] , remaining [[4,5,6],[7,8,9]]\\n            }\\n            row_begin++;                                              // increamenting row by 1\\n            for(int i = row_begin; i <= row_end ; i++){    // i = 1 till i = 2 because we only need 2 remaining element from end column.\\n                list.add(matrix[i][col_end]);                     // list contains, list = [ 1,2,3,6,9], remaining [[4,5],[7,8]\\n            }\\n            col_end--;                                                   // decreasing our col cause we have to traverse left\\n            if(row_begin <= row_end){                            // if row_begin is greater than 2 than condition won\\'t work\\n                for(int i = col_end; i >= col_begin  ; i--){      // i = 1 till i = 0 \\n                list.add(matrix[row_end][i]);                   // list [1,2,3,6,9,8,7] remaining [[ 4,5]]\\n            }\\n            }\\n            row_end--;                                                  //  decresing rowend will get us upwards\\n            if(col_begin <= col_end){                                \\n                for(int i =row_end; i >= row_begin ; i--){      // i = 1 till i = 0\\n                list.add(matrix[i][colb_egin]);                     // list [ 1,2,3,6,9,8,7,4] remaining [[5]]\\n            }\\n            }\\n            col_begin++;                                               // Increamenting col will give us remaining element and our while loop \\n\\t\\t\\t                                                           // won\\'t break cause colbegin has not exided it\\'s limit yet.\\n        }\\n      return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2056320,
                "title": "easy-c-solution",
                "content": "\\tHere,       dir=0 -> left to right\\n\\t\\t\\t    dir=1 -> top to bottom\\n\\t\\t\\t    dir=2 -> right to left\\n\\t\\t\\t    dir=3 -> bottom to top\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\tvector<int> ans;\\n\\tint dir = 0;\\n\\tint n = matrix.size();\\n\\tint top = 0, bottom = n - 1, left = 0, right = matrix[0].size() - 1;\\n\\twhile (top <= bottom && left<=right) {\\n\\t\\tif (dir == 0) {\\n\\t\\t\\tfor (int i = left; i <= right; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[top][i]);\\n\\t\\t\\t}\\n                top++;\\n\\t\\t}\\n\\t\\tif (dir == 1) {\\n\\t\\t\\tfor (int i = top; i <= bottom; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][right]);\\n\\t\\t\\t}\\n                right--;\\n\\t\\t}\\n\\t\\tif (dir == 2) {\\n\\t\\t\\tfor (int i = right; i >= left; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[bottom][i]);\\n\\t\\t\\t}\\n                bottom--;\\n\\t\\t}\\n\\t\\tif (dir == 3) {\\n\\t\\t\\tfor (int i = bottom; i >= top; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][left]);\\n\\t\\t\\t}\\n                left++;\\n\\t\\t}\\n\\t\\tdir = (dir + 1) % 4;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\tvector<int> ans;\\n\\tint dir = 0;\\n\\tint n = matrix.size();\\n\\tint top = 0, bottom = n - 1, left = 0, right = matrix[0].size() - 1;\\n\\twhile (top <= bottom && left<=right) {\\n\\t\\tif (dir == 0) {\\n\\t\\t\\tfor (int i = left; i <= right; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[top][i]);\\n\\t\\t\\t}\\n                top++;\\n\\t\\t}\\n\\t\\tif (dir == 1) {\\n\\t\\t\\tfor (int i = top; i <= bottom; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][right]);\\n\\t\\t\\t}\\n                right--;\\n\\t\\t}\\n\\t\\tif (dir == 2) {\\n\\t\\t\\tfor (int i = right; i >= left; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[bottom][i]);\\n\\t\\t\\t}\\n                bottom--;\\n\\t\\t}\\n\\t\\tif (dir == 3) {\\n\\t\\t\\tfor (int i = bottom; i >= top; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][left]);\\n\\t\\t\\t}\\n                left++;\\n\\t\\t}\\n\\t\\tdir = (dir + 1) % 4;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031219,
                "title": "simplest-c-solution",
                "content": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        int startingRow = 0;\\n        int startingCol = 0;\\n        int endingRow = row - 1;\\n        int endingCol = col - 1;\\n        while(count < total)\\n        {\\n            for(int index = startingCol; index <= endingCol && count < total; index++)\\n            {\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n             for(int index = startingRow; index <= endingRow && count < total; index++)\\n            {\\n                ans.push_back(matrix[index][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n             for(int index = endingCol; index >= startingCol && count < total; index--)\\n            {\\n                ans.push_back(matrix[endingRow][index]);\\n                count++;\\n            }\\n            endingRow--;\\n             for(int index = endingRow; index >= startingRow && count < total; index--)\\n            {\\n                ans.push_back(matrix[index][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        int startingRow = 0;\\n        int startingCol = 0;\\n        int endingRow = row - 1;\\n        int endingCol = col - 1;\\n        while(count < total)\\n        {\\n            for(int index = startingCol; index <= endingCol && count < total; index++)\\n            {\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n             for(int index = startingRow; index <= endingRow && count < total; index++)\\n            {\\n                ans.push_back(matrix[index][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n             for(int index = endingCol; index >= startingCol && count < total; index--)\\n            {\\n                ans.push_back(matrix[endingRow][index]);\\n                count++;\\n            }\\n            endingRow--;\\n             for(int index = endingRow; index >= startingRow && count < total; index--)\\n            {\\n                ans.push_back(matrix[index][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1955739,
                "title": "200-easiest-solution",
                "content": "spiralOrder = function(matrix) {\\n    const result = [];\\n    let top =0;\\n    let left =0;\\n    let bottom = matrix.length-1;\\n    let right = matrix[0].length-1;\\n    const size = matrix.length * matrix[0].length;\\n    \\n    while( result.length<size ){\\n        for( let i = left ; i<= right && result.length<size ; i++ ){\\n            result.push(matrix[top][i]);\\n        }\\n        top++;\\n        \\n        for( let i = top ; i <= bottom && result.length<size ; i++ ){\\n            result.push(matrix[i][right]);\\n        }\\n        right--;\\n        \\n        for( let i = right ; i>= left && result.length<size ; i-- ){\\n            result.push(matrix[bottom][i]);\\n        }\\n        bottom--;\\n        \\n        for( let i = bottom ; i>= top && result.length<size ; i-- ){\\n            result.push(matrix[i][left])\\n        }\\n        left++;\\n            \\n    }\\n    return result;",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "spiralOrder = function(matrix) {\\n    const result = [];\\n    let top =0;\\n    let left =0;\\n    let bottom = matrix.length-1;\\n    let right = matrix[0].length-1;\\n    const size = matrix.length * matrix[0].length;\\n    \\n    while( result.length<size ){\\n        for( let i = left ; i<= right && result.length<size ; i++ ){\\n            result.push(matrix[top][i]);\\n        }\\n        top++;\\n        \\n        for( let i = top ; i <= bottom && result.length<size ; i++ ){\\n            result.push(matrix[i][right]);\\n        }\\n        right--;\\n        \\n        for( let i = right ; i>= left && result.length<size ; i-- ){\\n            result.push(matrix[bottom][i]);\\n        }\\n        bottom--;\\n        \\n        for( let i = bottom ; i>= top && result.length<size ; i-- ){\\n            result.push(matrix[i][left])\\n        }\\n        left++;\\n            \\n    }\\n    return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 1941703,
                "title": "c-matrix-easy-understanding-beats-100",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(), col=mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        int top=0,down=row-1;//pointer for our ROW\\n        int left=0,right=col-1;//pointers for our COLUMN\\n        \\n        int dir=0;//helps us in knowing in which direction to traverse\\n        \\n        //dirx: 0->left to right, 1->top to down\\n        //2->right to left  3->down to top\\n        while(top<=down && left<=right){\\n            \\n            if(dir == 0){\\n                for(int i=left; i<=right; i++) //L->R\\n                    ans.push_back(mat[top][i]);\\n                \\n                top += 1;     \\n            }\\n            \\n            else if(dir == 1){//T->D\\n                for(int i=top;i<=down;i++)\\n                    ans.push_back(mat[i][right]);\\n                \\n                right -= 1;\\n            }\\n            \\n            else if(dir == 2){//R->L\\n                for(int i=right; i >= left; i--)\\n                    ans.push_back(mat[down][i]);\\n                \\n                down -= 1;\\n            }\\n            \\n            else if(dir == 3){//D->T\\n                for(int i=down; i>= top ; i--)\\n                    ans.push_back(mat[i][left]);\\n                \\n                left += 1;\\n            }\\n            \\n            //change dirxn \\n            dir = (dir + 1)%4;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote, if this solution been any help to you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(), col=mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        int top=0,down=row-1;//pointer for our ROW\\n        int left=0,right=col-1;//pointers for our COLUMN\\n        \\n        int dir=0;//helps us in knowing in which direction to traverse\\n        \\n        //dirx: 0->left to right, 1->top to down\\n        //2->right to left  3->down to top\\n        while(top<=down && left<=right){\\n            \\n            if(dir == 0){\\n                for(int i=left; i<=right; i++) //L->R\\n                    ans.push_back(mat[top][i]);\\n                \\n                top += 1;     \\n            }\\n            \\n            else if(dir == 1){//T->D\\n                for(int i=top;i<=down;i++)\\n                    ans.push_back(mat[i][right]);\\n                \\n                right -= 1;\\n            }\\n            \\n            else if(dir == 2){//R->L\\n                for(int i=right; i >= left; i--)\\n                    ans.push_back(mat[down][i]);\\n                \\n                down -= 1;\\n            }\\n            \\n            else if(dir == 3){//D->T\\n                for(int i=down; i>= top ; i--)\\n                    ans.push_back(mat[i][left]);\\n                \\n                left += 1;\\n            }\\n            \\n            //change dirxn \\n            dir = (dir + 1)%4;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941255,
                "title": "java-simple-and-easy-to-understand-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rStart = 0, rEnd = matrix.length-1;\\n        int cStart = 0, cEnd = matrix[0].length-1;\\n        while (rStart <= rEnd && cStart <= cEnd) {\\n            for (int c = cStart; c <= cEnd; c++) list.add(matrix[rStart][c]);\\n            for (int r = rStart + 1; r <= rEnd; r++) list.add(matrix[r][cEnd]);\\n            if (rStart < rEnd && cStart < cEnd) {\\n                for (int c = cEnd - 1; c > cStart; c--) list.add(matrix[rEnd][c]);\\n                for (int r = rEnd; r > rStart; r--) list.add(matrix[r][cStart]);\\n            }\\n            rStart++; rEnd--; cStart++; cEnd--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rStart = 0, rEnd = matrix.length-1;\\n        int cStart = 0, cEnd = matrix[0].length-1;\\n        while (rStart <= rEnd && cStart <= cEnd) {\\n            for (int c = cStart; c <= cEnd; c++) list.add(matrix[rStart][c]);\\n            for (int r = rStart + 1; r <= rEnd; r++) list.add(matrix[r][cEnd]);\\n            if (rStart < rEnd && cStart < cEnd) {\\n                for (int c = cEnd - 1; c > cStart; c--) list.add(matrix[rEnd][c]);\\n                for (int r = rEnd; r > rStart; r--) list.add(matrix[r][cStart]);\\n            }\\n            rStart++; rEnd--; cStart++; cEnd--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801118,
                "title": "accepted-in-6ms-easy-fast-and-simple-solution-with-comments",
                "content": "### \\u2714 Spiral Matrix  | C++ | Medium Level | Easy, Fast and Simple | 6ms \\n\\n<br>\\nThis is a very simple and easy to understand solution. I traverse right and increment startRow, then traverse down and decrement endColumn, then I traverse left and decrement endRow, and finally I traverse up and increment startColumn.\\n\\nThe edge case here is that when I traverse left or up I have to check whether the row or column is already taken to prevent duplicates.\\n\\nAny comments greatly appreciated. Please Upvote if you liked the solution :)\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        // Take a vector to store spiral matrix.\\n        vector<int> v;\\n        \\n        // Take row and column size.\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // Take 4 variable for itteration through rows and columns.\\n        int startRow = 0;\\n        int endRow = n - 1;\\n        int startColumn = 0;\\n        int endColumn = m - 1;\\n        \\n        // For boundary checking in rows and columns\\n        while(startRow <= endRow && startColumn <= endColumn){\\n            \\n            // Storing starting row.\\n            for(int column = startColumn; column <= endColumn; column++){\\n                v.push_back(matrix[startRow][column]);\\n            }\\n            \\n            // Storing ending column(Leaving first elemnet which is already taken in starting row)\\n            for(int row = startRow + 1; row <= endRow; row++){\\n                v.push_back(matrix[row][endColumn]);\\n            }\\n            \\n            // Stroring ending row(Leaving last elemnet which is already taken in ending column)\\n            for(int column = endColumn - 1; column >= startColumn; column--){\\n                \\n                // Avoiding Repeating same row twice.\\n                if(startRow == endRow){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[endRow][column]);\\n            }\\n            \\n            // Storing starting column(Leaving first and last elemnet which is already taken in starting row and ending row)\\n            for(int row = endRow - 1; row >= startRow + 1; row--){\\n                \\n                // Avoiding Repeating same column twice.\\n                if(startColumn == endColumn){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[row][startColumn]);\\n            }\\n            \\n            // Increment the start row and start column. \\n            // Decrement the end row and end column.\\n            startRow++;\\n            endColumn--;\\n            endRow--;\\n            startColumn++;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        // Take a vector to store spiral matrix.\\n        vector<int> v;\\n        \\n        // Take row and column size.\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // Take 4 variable for itteration through rows and columns.\\n        int startRow = 0;\\n        int endRow = n - 1;\\n        int startColumn = 0;\\n        int endColumn = m - 1;\\n        \\n        // For boundary checking in rows and columns\\n        while(startRow <= endRow && startColumn <= endColumn){\\n            \\n            // Storing starting row.\\n            for(int column = startColumn; column <= endColumn; column++){\\n                v.push_back(matrix[startRow][column]);\\n            }\\n            \\n            // Storing ending column(Leaving first elemnet which is already taken in starting row)\\n            for(int row = startRow + 1; row <= endRow; row++){\\n                v.push_back(matrix[row][endColumn]);\\n            }\\n            \\n            // Stroring ending row(Leaving last elemnet which is already taken in ending column)\\n            for(int column = endColumn - 1; column >= startColumn; column--){\\n                \\n                // Avoiding Repeating same row twice.\\n                if(startRow == endRow){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[endRow][column]);\\n            }\\n            \\n            // Storing starting column(Leaving first and last elemnet which is already taken in starting row and ending row)\\n            for(int row = endRow - 1; row >= startRow + 1; row--){\\n                \\n                // Avoiding Repeating same column twice.\\n                if(startColumn == endColumn){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[row][startColumn]);\\n            }\\n            \\n            // Increment the start row and start column. \\n            // Decrement the end row and end column.\\n            startRow++;\\n            endColumn--;\\n            endRow--;\\n            startColumn++;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767656,
                "title": "simple-java-loops",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answer = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int rep = 0;\\n        while(answer.size()<m*n){\\n            boundaryAdder(matrix,answer,rep,m-rep-1,rep,n-rep-1);\\n            rep++;\\n        }\\n        return answer;\\n    }\\n    public void boundaryAdder(int[][] matrix,List<Integer> answer,int row1,int row2,int col1,int col2){\\n        for(int i=col1;i<=col2;i++) answer.add(matrix[row1][i]);\\n        if(row1==row2) return;\\n        for(int i=row1+1;i<=row2;i++) answer.add(matrix[i][col2]);\\n        if(col1==col2) return;\\n        for(int i=col2-1;i>=col1;i--) answer.add(matrix[row2][i]);\\n        for(int i=row2-1;i>row1;i--) answer.add(matrix[i][col1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answer = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int rep = 0;\\n        while(answer.size()<m*n){\\n            boundaryAdder(matrix,answer,rep,m-rep-1,rep,n-rep-1);\\n            rep++;\\n        }\\n        return answer;\\n    }\\n    public void boundaryAdder(int[][] matrix,List<Integer> answer,int row1,int row2,int col1,int col2){\\n        for(int i=col1;i<=col2;i++) answer.add(matrix[row1][i]);\\n        if(row1==row2) return;\\n        for(int i=row1+1;i<=row2;i++) answer.add(matrix[i][col2]);\\n        if(col1==col2) return;\\n        for(int i=col2-1;i>=col1;i--) answer.add(matrix[row2][i]);\\n        for(int i=row2-1;i>row1;i--) answer.add(matrix[i][col1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756575,
                "title": "python-simple-using-loops",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        rowStart, rowEnd = 0, len(matrix)-1\\n        colStart, colEnd = 0, len(matrix[0])-1\\n        ans = []\\n        while rowStart<=rowEnd and colStart<=colEnd:\\n            for i in range(colStart, colEnd+1):\\n                ans.append(matrix[rowStart][i])\\n            for i in range(rowStart+1, rowEnd+1):\\n                ans.append(matrix[i][colEnd])\\n            for i in range(colEnd-1, colStart-1, -1):\\n                if rowEnd>rowStart:\\n                    ans.append(matrix[rowEnd][i])\\n            for i in range(rowEnd-1, rowStart, -1):\\n                if colEnd>colStart:\\n                    ans.append(matrix[i][colStart])\\n            rowStart += 1\\n            rowEnd -= 1\\n            colStart += 1\\n            colEnd -= 1 \\n        return ans\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        rowStart, rowEnd = 0, len(matrix)-1\\n        colStart, colEnd = 0, len(matrix[0])-1\\n        ans = []\\n        while rowStart<=rowEnd and colStart<=colEnd:\\n            for i in range(colStart, colEnd+1):\\n                ans.append(matrix[rowStart][i])\\n            for i in range(rowStart+1, rowEnd+1):\\n                ans.append(matrix[i][colEnd])\\n            for i in range(colEnd-1, colStart-1, -1):\\n                if rowEnd>rowStart:\\n                    ans.append(matrix[rowEnd][i])\\n            for i in range(rowEnd-1, rowStart, -1):\\n                if colEnd>colStart:\\n                    ans.append(matrix[i][colStart])\\n            rowStart += 1\\n            rowEnd -= 1\\n            colStart += 1\\n            colEnd -= 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654416,
                "title": "iterative-keep-trying-to-go-right-then-down-then-left-and-then-top-until-all-neighbours-visited",
                "content": "The idea I got it from DFS but it is certainly not a DFS.\\nHere is the idea, I will start to keep trying to go right till it is possible and it is not visited, hence I will keep marking each cell as visited as well by setting the value to 101 as in constraint max value can a cell hold is -100 to 100.\\nThen to go down and then to left and right, untill it is not possible. and I will repeat these steps until I find a cell whose all neighbours are visited.\\n\\nHere is the code in C#:\\nTime Complexity O(mn) as I am visiting each cellonly once.\\nSpace Complexity O(mn) as adding all the numbers in result List object.\\n\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        IList<int> result = new List<int>();\\n        \\n        int i = 0, j = 0;\\n        while(true){\\n            //check if all sides are visited\\n            if((j < n-1 && matrix[i][j+1] != 101) //instead of 101 we can make it int.MaxValue or int.MinValue\\n               || (i < m-1 && matrix[i+1][j] != 101) \\n               || (j > 0 && matrix[i][j-1] != 101) \\n               || (i > 0 && matrix[i-1][j] != 101)){\\n                //do nothing\\n            }\\n            else\\n                break;\\n            \\n            //keep going right\\n            while(j < n-1 && matrix[i][j+1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j++;\\n            }\\n            \\n            //keep going down\\n            while(i < m-1 && matrix[i+1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i++;\\n            }\\n            \\n            //keep going left\\n            while(j > 0 && matrix[i][j-1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j--;\\n            }\\n            \\n            //keep going up\\n            while(i > 0 && matrix[i-1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i--;\\n            }\\n        }\\n        \\n        result.Add(matrix[i][j]);\\n        return result;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Matrix",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        IList<int> result = new List<int>();\\n        \\n        int i = 0, j = 0;\\n        while(true){\\n            //check if all sides are visited\\n            if((j < n-1 && matrix[i][j+1] != 101) //instead of 101 we can make it int.MaxValue or int.MinValue\\n               || (i < m-1 && matrix[i+1][j] != 101) \\n               || (j > 0 && matrix[i][j-1] != 101) \\n               || (i > 0 && matrix[i-1][j] != 101)){\\n                //do nothing\\n            }\\n            else\\n                break;\\n            \\n            //keep going right\\n            while(j < n-1 && matrix[i][j+1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j++;\\n            }\\n            \\n            //keep going down\\n            while(i < m-1 && matrix[i+1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i++;\\n            }\\n            \\n            //keep going left\\n            while(j > 0 && matrix[i][j-1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j--;\\n            }\\n            \\n            //keep going up\\n            while(i > 0 && matrix[i-1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i--;\\n            }\\n        }\\n        \\n        result.Add(matrix[i][j]);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640217,
                "title": "understandable-golang-solution-beats-100",
                "content": "There are no special tricks for this problem, we have to traverse the matrix repeatedly in the order of (right, down, left, up). While traversing, we need to keep track of the boundaries of each direction. Namely, top, left, right, bottom boundaries. For example, the top boundary is initialized to 0; after traversing the first row of the matrix, we need to increment the top boundary by 1 so that when we traverse the matrix in the up direction later on, we don\\'t reach the first row which we\\'ve already visited.  \\n\\nTo keep track of the direction we are going, we can have an array that contains 4 values: 0, 1, 2, 3. Each value represents a direction. We can use an incremental variable `round` to tell us which direction we need to go next. `spDir[round%4]` does this job because we are going in 4 directions repeatedly. For example, when `round=0` we are going right, when `round=4` we are going right again.  \\n\\nThe __ending condition__ is when top boundary exceeds bottom boundary or left boundary exceeds right boundary. That said, the solution can be broken down into the following steps:  \\n1. initialize a direction array `spDir` that holds 4 directions represented as integers (0,1,2,3)\\n2. initialize the four boundaries\\n3. initialize a result array(or slice in golang)\\n4. create a for-loop to traverse the matrix in spiral order until the ending condition is met\\n5. Inside the loop, create a simple switch case to determine which direction we are traversing. Update the corresponding boundaries after each iteration.\\n\\n```\\nconst (\\n    right = iota\\n    down\\n    left\\n    up\\n)\\n\\nfunc spiralOrder(matrix [][]int) []int {\\n    m, n := len(matrix), len(matrix[0])\\n    result := []int{}\\n    spDir := []int{right, down, left, up}\\n    // initialize the 4 boundaries\\n    l, r, t, b := 0, n-1, 0, m-1\\n    // traverse the matrix in spiral order\\n    for round := 0; l <= r && t <= b; round++ {\\n        // in each round, we traverse in 1 direction\\n        switch spDir[round%4] {\\n            case 0:\\n                // traverse in right direction\\n                for i, j := l, t; i <= r; i++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                t++\\n            case 1:\\n                // traverse in down direction\\n                for i, j := r, t; j <= b; j++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                r--\\n            case 2:\\n                // traverse in left direction\\n                for i, j := r, b; i >= l; i-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                b--\\n            case 3:\\n                // traverse in up direction\\n                for i, j := l, b; j >= t; j-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                l++\\n        }\\n    }\\n    return result\\n}\\n```\\n\\nI hope this solution is understandable, feel free to leave a comment if you have any questions.",
                "solutionTags": [],
                "code": "```\\nconst (\\n    right = iota\\n    down\\n    left\\n    up\\n)\\n\\nfunc spiralOrder(matrix [][]int) []int {\\n    m, n := len(matrix), len(matrix[0])\\n    result := []int{}\\n    spDir := []int{right, down, left, up}\\n    // initialize the 4 boundaries\\n    l, r, t, b := 0, n-1, 0, m-1\\n    // traverse the matrix in spiral order\\n    for round := 0; l <= r && t <= b; round++ {\\n        // in each round, we traverse in 1 direction\\n        switch spDir[round%4] {\\n            case 0:\\n                // traverse in right direction\\n                for i, j := l, t; i <= r; i++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                t++\\n            case 1:\\n                // traverse in down direction\\n                for i, j := r, t; j <= b; j++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                r--\\n            case 2:\\n                // traverse in left direction\\n                for i, j := r, b; i >= l; i-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                b--\\n            case 3:\\n                // traverse in up direction\\n                for i, j := l, b; j >= t; j-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                l++\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530816,
                "title": "java-code-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        int left = 0, top = 1, item = 0;\\n        int right = matrix[0].length;\\n        int bottom = matrix.length;\\n        int nItems = right * bottom;\\n        right--; bottom--; // Getting the max index positions\\n        \\n        // Traverse all items in the matrix until the traversed item count == total no. of items in the matrix\\n        while(item < nItems){\\n            // Traverse right from left margin to right margin\\n            for(int i=left; i<= right && item < nItems; i++){\\n                result.add(matrix[left][i]);\\n                item++;\\n            }\\n\\n            // Traverse down from top margin to bottom margin\\n            for(int i=top; i <= bottom && item < nItems; i++){\\n                result.add(matrix[i][right]);\\n                item++;\\n            }\\n\\n            // Traverse left from right margin to left margin\\n            for(int i=right-1; i >= left && item < nItems; i--){\\n                result.add(matrix[bottom][i]);\\n                item++;\\n            }            \\n\\n            // Traverse up from bottom margin to top margin\\n            for(int i=bottom-1; i >= top && item < nItems; i--){\\n                result.add(matrix[i][left]);\\n                item++;\\n            }            \\n            left++; // incrementing as we are going from left to right\\n            top++;  // incrementing as we are going from top to bottom\\n            right--; // decrementing as we are going from right to left \\n            bottom--; // decrementing as we are going from bottom to top\\n        }\\n        return result;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        int left = 0, top = 1, item = 0;\\n        int right = matrix[0].length;\\n        int bottom = matrix.length;\\n        int nItems = right * bottom;\\n        right--; bottom--; // Getting the max index positions\\n        \\n        // Traverse all items in the matrix until the traversed item count == total no. of items in the matrix\\n        while(item < nItems){\\n            // Traverse right from left margin to right margin\\n            for(int i=left; i<= right && item < nItems; i++){\\n                result.add(matrix[left][i]);\\n                item++;\\n            }\\n\\n            // Traverse down from top margin to bottom margin\\n            for(int i=top; i <= bottom && item < nItems; i++){\\n                result.add(matrix[i][right]);\\n                item++;\\n            }\\n\\n            // Traverse left from right margin to left margin\\n            for(int i=right-1; i >= left && item < nItems; i--){\\n                result.add(matrix[bottom][i]);\\n                item++;\\n            }            \\n\\n            // Traverse up from bottom margin to top margin\\n            for(int i=bottom-1; i >= top && item < nItems; i--){\\n                result.add(matrix[i][left]);\\n                item++;\\n            }            \\n            left++; // incrementing as we are going from left to right\\n            top++;  // incrementing as we are going from top to bottom\\n            right--; // decrementing as we are going from right to left \\n            bottom--; // decrementing as we are going from bottom to top\\n        }\\n        return result;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467727,
                "title": "c-single-pass-4-pointer-solution-explained-100-time-95-space",
                "content": "Nice problem and I wanted to give myself the extra challenge to solve it without marking the visited cells in any way, even in place.\\n\\nWe can think at this problem in this way:\\n* we can start running through the first row, then we mark it as taken;\\n* then we go down the last colummn and we mark it too;\\n* now we do the last row (in reverse order) and we mark it;\\n* time to go up through the first column, up to its penultimate element (we took it when we started with the last row);\\n* rinse and repeat, until you have taken all the cells just once.\\n\\nNow, in order to make it work without marking the explored cells in any way, we will need 4 pointers and a few more variables:\\n* `lmtLeft`, `lmtRight`, `lmtUp` and `lmtDown` will limit our exploration of the matrix, being initialised to the indexes of the first and last columns before we start the main loop;\\n* `i` is our iterator to write in `res`;\\n* `tot` is the overall amount of elements in the matrix, obtained by multipling `lmtRight` and `lmtDown` right before reducing them by `1` to match the indexes of the last column and row, respectively;\\n* `res` is our accumulator variable, already created at the right size, to avoid reallocations.\\n\\nWe will then create an infinite loop and:\\n* go right, with `x` going from `lmtLeft` to `lmtRight`, using `lmtUp` as `y`, right before increasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go down, with `y` going from `lmtUp` to `lmtDown`, using `lmtRight` as x`, right before decreasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go left, with `x` going from `lmRight` to `lmtLeft`, using `lmtDown` as `y`, right before decreasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go up, with `y` going from `lmtDown` to `lmtUp`, using `lmtLeft` as `x`, right before increasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        // support variables\\n        int lmtLeft = 0, lmtRight = arr[0].size(), lmtUp = 0, lmtDown = arr.size(), i = 0, tot = lmtRight-- * lmtDown--;\\n        vector<int> res(tot);\\n        while (true) {\\n            // going right\\n            for (int x = lmtLeft, y = lmtUp++; x <= lmtRight; x++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going down\\n            for (int y = lmtUp, x = lmtRight--; y <= lmtDown; y++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going left\\n            for (int x = lmtRight, y = lmtDown--; x >= lmtLeft; x--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going up\\n            for (int y = lmtDown, x = lmtLeft++; y >= lmtUp; y--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        // support variables\\n        int lmtLeft = 0, lmtRight = arr[0].size(), lmtUp = 0, lmtDown = arr.size(), i = 0, tot = lmtRight-- * lmtDown--;\\n        vector<int> res(tot);\\n        while (true) {\\n            // going right\\n            for (int x = lmtLeft, y = lmtUp++; x <= lmtRight; x++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going down\\n            for (int y = lmtUp, x = lmtRight--; y <= lmtDown; y++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going left\\n            for (int x = lmtRight, y = lmtDown--; x >= lmtLeft; x--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going up\\n            for (int y = lmtDown, x = lmtLeft++; y >= lmtUp; y--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1701423,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887881,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887763,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887710,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1776798,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887790,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887838,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1838682,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1565249,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1571130,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1701423,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887881,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887763,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887710,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1776798,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887790,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887838,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1838682,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1565249,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1571130,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1970961,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 2009964,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1887883,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1852970,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1722555,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1574198,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1569810,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1922205,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1888085,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1888001,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1887415,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1855205,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1765957,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1741777,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1887823,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 2030141,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 2024943,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1997584,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1988102,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1987768,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1909933,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1894062,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1891718,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1889722,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888486,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888449,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888379,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888260,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887855,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887792,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887768,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1887746,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1887668,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1868532,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1847295,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1836522,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1819792,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1818373,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1809851,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1801116,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1785122,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1776289,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1750116,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1739912,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1733482,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1725119,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1722701,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1722694,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1721474,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1721237,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1720720,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715567,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709115,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1703586,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1687690,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1684579,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1680122,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1648695,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809611,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732819,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            }
        ]
    }
]