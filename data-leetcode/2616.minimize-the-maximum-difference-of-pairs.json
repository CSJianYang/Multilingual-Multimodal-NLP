[
    {
        "title": "Minimize the Maximum Difference of Pairs",
        "question_content": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.\n&nbsp;\nExample 1:\n\nInput: nums = [10,1,2,7,1,3], p = 2\nOutput: 1\nExplanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. \nThe maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.\n\nExample 2:\n\nInput: nums = [4,2,1,2], p = 1\nOutput: 0\nExplanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 109\n\t0 <= p <= (nums.length)/2",
        "solutions": [
            {
                "id": 3395750,
                "title": "java-c-python-binary-search",
                "content": "# **Intuition**\\nTo solve mini-max problem,\\nwe can apply binary search.\\n<br>\\n\\n# **Explanation**\\nFirst we don\\'t care the original order of `A[i]`,\\nwe want to compare the difference,\\nso we sort them.\\n\\nThe result is in range of `left = 0` and `right = A[n - 1] - A[0]`\\neach iteration of search,\\nwe assume the minimum maximum differenceis `mid = (left + right) / 2`,\\nthen we check if we can have `p` pairs.\\n\\nWe take pairs `(A[i], A[i - 1])` greedily if `A[i] - A[i - 1] <= mid`.\\nIf we take this pair, we move to next availble pair `(A[i + 2], A[i + 1])`\\nIf not, we move to next availble pair `(A[i + 1], A[i])`\\n\\nIn the end of each iteration,\\nwe check if we can have `p` pairs.\\nIf so, `mid` is big enough, `right = mid`\\nIf not, `mid` is too small, `left = mid + 1`.\\n\\nFinally we return the binary seach result `left`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog(max(A)) + nlogn)`\\nSpace `O(logn)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimizeMax(int[] A, int p) {\\n        Arrays.sort(A);\\n        int n = A.length, left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizeMax(vector<int>& A, int p) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        A.sort()\\n        n = len(A)\\n        left, right = 0, A[-1] - A[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            k = 0\\n            i = 1\\n            while i < n:\\n                if A[i] - A[i - 1] <= mid:\\n                    k += 1\\n                    i += 1\\n                i += 1\\n            if k >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2616. [Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/discuss/3395750/JavaC%2B%2BPython-Binary-Search)\\n- 2560. [House Robber IV](https://leetcode.com/problems/house-robber-iv/discuss/3143697/JavaC%2B%2BPython-Binary-Search-O(1)-Space)\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizeMax(int[] A, int p) {\\n        Arrays.sort(A);\\n        int n = A.length, left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int minimizeMax(vector<int>& A, int p) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        A.sort()\\n        n = len(A)\\n        left, right = 0, A[-1] - A[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            k = 0\\n            i = 1\\n            while i < n:\\n                if A[i] - A[i - 1] <= mid:\\n                    k += 1\\n                    i += 1\\n                i += 1\\n            if k >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3395952,
                "title": "in-case-you-are-wondering-why-greedy-works-for-this-problem",
                "content": "There are many good answers binary search + greedy now. I will just explain why greedy works for this problem.\\n\\nImagine you have `[a,b,c,d]`, abcd are just sorted numbers\\n\\nGreedy tells us if `b - a < the threshold we set`, we just pick it. The cost of doing this is if `c - b < threshold` as well, you can never pick `bc` pair anymore because b has been paired with a.\\n\\nWill this cause any problems?\\n\\nThe answer is no\\n\\nBecause if you pick `ab` pair, you will have one pair now. If you pick `bc` pair, you also have one pair, however, if you pick `bc` now what\\'s left is `[a, d]`. Because we have sorted `abcd`, `d - a` is likely to be bigger so it is more likely to exceed the threshold we set.\\nOn the other hand, if we greedily pick `ab` pair, what\\'s left is `[c,d]` and `d - c` is guaranteed to be smaller or equal to `d - a`, so `d-c` is more likely to be a pair that we can pick as well -> being greedy (pick a and b) is more likely to let us have more pairs then not being greedy (pick b and c). Hence for this problem, greedy works\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p == 0) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int minThrehold = 0;\\n        int maxThrehold = nums[nums.size() - 1] - nums[0];\\n\\n        while (minThrehold < maxThrehold) {\\n            int candidateThrehold = minThrehold + (maxThrehold - minThrehold) / 2; // middle threshold\\n            // check how many pairs we can pick with this threshold\\n\\n            int pairs = 0;\\n\\n            // greedily pick pairs\\n            for (int i = 1; i < nums.size(); ++i) {\\n                if (candidateThrehold >= nums[i] - nums[i - 1]) {\\n                    ++pairs;\\n                    ++i; // you have picked i and i -1, you can\\'t pick [i + 1, i] pair anymore\\n                }\\n            }\\n\\n            if (pairs >= p) { // we are being to loose on the threshold and have too many pairs, be more strict on the threhold\\n                maxThrehold = candidateThrehold;\\n            } else { // we are being too strict about threshold and we do not have enough pairs, be more loose on threshold\\n                minThrehold = candidateThrehold + 1;\\n            }\\n        }\\n\\n        return minThrehold;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p == 0) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int minThrehold = 0;\\n        int maxThrehold = nums[nums.size() - 1] - nums[0];\\n\\n        while (minThrehold < maxThrehold) {\\n            int candidateThrehold = minThrehold + (maxThrehold - minThrehold) / 2; // middle threshold\\n            // check how many pairs we can pick with this threshold\\n\\n            int pairs = 0;\\n\\n            // greedily pick pairs\\n            for (int i = 1; i < nums.size(); ++i) {\\n                if (candidateThrehold >= nums[i] - nums[i - 1]) {\\n                    ++pairs;\\n                    ++i; // you have picked i and i -1, you can\\'t pick [i + 1, i] pair anymore\\n                }\\n            }\\n\\n            if (pairs >= p) { // we are being to loose on the threshold and have too many pairs, be more strict on the threhold\\n                maxThrehold = candidateThrehold;\\n            } else { // we are being too strict about threshold and we do not have enough pairs, be more loose on threshold\\n                minThrehold = candidateThrehold + 1;\\n            }\\n        }\\n\\n        return minThrehold;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883965,
                "title": "100-binary-search-greedy-video-in-o-n-log-m-optimal-solution",
                "content": "# Problem Understanding\\n\\nThe problem asks us to find the minimum possible value of the maximum difference between any two pairs from an array, given that we can only form a limited number of pairs. The challenge is to find this minimum possible maximum difference.\\n\\nFor instance, given the array [10,1,2,7,1,3] and the ability to form 2 pairs, the minimum possible maximum difference is 1.\\n\\n![2621_viz.png](https://assets.leetcode.com/users/images/25bc9143-4c1b-4b18-8120-c97e8e677851_1691542468.288261.png)\\n\\n\\n- The green pair formed by indices 1 and 4 has a difference of 0.\\n- The red pair formed by indices 2 and 5 has a difference of 1.\\n\\nThe maximum difference among these pairs is 1, consistent with the expected output.\\n\\n---\\n\\n# Live Coding & Explenation\\nhttps://youtu.be/Ulfzvhy8F5E\\n\\n- [in Rust \\uD83E\\uDD80](https://youtu.be/E11wgsLbq-w)\\n- [in Python \\uD83D\\uDC0D](https://youtu.be/Ulfzvhy8F5E)\\n\\n# Approach\\n\\nTo address this problem, we utilize a blend of binary search and a greedy method. Our primary objective is to pinpoint the smallest possible maximum difference between pairs.\\n\\n## Binary Search on Maximum Difference\\n\\nInstead of trying to find pairs directly, we\\'ll conduct a binary search on the potential range of maximum differences. The range we\\'ll be searching within spans from 0 to the difference between the largest and smallest values in the sorted array.\\n\\nFor every potential maximum difference, denoted as $$ \\\\text{mid} $$, we\\'ll implement a greedy strategy to determine if we can create the requisite number of pairs.\\n\\n## Greedy Pairing\\n\\nGiven a maximum difference $$ \\\\text{mid} $$, we traverse the sorted array and attempt to form pairs in a greedy manner. Whenever two consecutive numbers in the array have a difference that is equal to or less than $$ \\\\text{mid} $$, we pair them together. If, by the end of our traversal, we have been able to form the required number of pairs, it signifies that our $$ \\\\text{mid} $$ value is feasible.\\n\\n## Code Breakdown\\n\\n1. **Helper Function**: \\n    ```python\\n    def can_form_pairs(mid):\\n        ...\\n    ```\\n    This function checks if we can form $$ p $$ pairs where the difference between each pair is less than or equal to $$ \\\\text{mid} $$. \\n   \\n    - We start by initializing counters: `count` for the number of pairs formed and `i` for the current index in `nums`.\\n    - We then iterate over the numbers in `nums` and try to form pairs greedily.\\n    - If the difference between two consecutive numbers (at index `i` and `i+1`) is less than or equal to `mid`, we count it as a pair and skip the next number.\\n    - If we can form exactly `p` pairs with a difference less than or equal to `mid`, the function returns `True`; otherwise, it returns `False`.\\n\\n2. **Main Logic**:\\n    ```python\\n    nums.sort()\\n    low, high = 0, nums[-1] - nums[0]\\n    ...\\n    return low\\n    ```\\n    Here, we are implementing the binary search:\\n    \\n    - First, we sort the array `nums`.\\n    - We define our search space with `low` being 0 and `high` being the difference between the maximum and minimum values in `nums`.\\n    - During each iteration of the binary search, we calculate the mid-point and check if we can form the required pairs using our helper function `can_form_pairs(mid)`.\\n    - If we can form the required pairs, our current `mid` value is feasible, so we might be able to find an even smaller maximum difference. Therefore, we update `high` to `mid`.\\n    - If not, our `mid` value is too small, so we update `low` to `mid + 1`.\\n    - Finally, we return `low`, which will be the smallest maximum difference for which we can form the required number of pairs.\\n\\n\\n## Rationale:\\n\\nThe strength of this approach lies in its ability to seamlessly and efficiently traverse the search space of potential maximum differences. By combining binary search with a greedy pairing strategy, we can identify the smallest maximum difference that allows us to form the desired number of pairs.\\n\\n---\\n\\n# Complexity\\n\\n- **Time Complexity**: O(n log m), where $$ n $$ is the length of the array and $$ m $$ is the difference between the maximum and minimum values in the array. Sorting the array takes O(n log n) and the binary search process, combined with the greedy check, takes O(n log m).\\n  \\n- **Space Complexity**: O(1). We only use a constant amount of space for our variables.\\n\\n# Performance\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 14           | 100%             | 3.4         | 100%            |\\n| Java       | 17           | 95%              | 59.3        | 35.63%          |\\n| Go         | 96           | 100%             | 9.3         | 60%             |\\n| C++        | 129          | 94.77%           | 81.3        | 9.61%           |\\n| JavaScript | 138          | 90.91%           | 54.3        | 90.91%          |\\n| C#         | 196          | 75%              | 57.3        | 50%             |\\n| Python3    | 958          | 87.74%           | 31          | 78.6%           |\\n\\n![perf_2621.png](https://assets.leetcode.com/users/images/4828f099-d2e1-4794-990e-8f24223dafe1_1691548117.745709.png)\\n\\n\\n# Code\\n\\n```Python []\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\n        def can_form_pairs(mid):\\n            count = 0\\n            i = 0\\n            while i < len(nums) - 1 and count < p:\\n                if nums[i+1] - nums[i] <= mid:\\n                    count += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            return count >= p\\n        \\n        nums.sort()\\n        left, right = 0, nums[-1] - nums[0]\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_form_pairs(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n                \\n        return left\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\\n``` Go []\\nfunc minimizeMax(nums []int, p int) int {\\n\\tsort.Ints(nums)\\n\\t\\n\\tleft, right := 0, nums[len(nums)-1] - nums[0]\\n\\t\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif canFormPairs(nums, mid, p) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn left\\n}\\n\\nfunc canFormPairs(nums []int, mid int, p int) bool {\\n\\tcount := 0\\n\\tfor i := 0; i < len(nums) - 1 && count < p; {\\n\\t\\tif nums[i+1] - nums[i] <= mid {\\n\\t\\t\\tcount++\\n\\t\\t\\ti += 2\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn count >= p\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        \\n        int left = 0, right = nums[nums.length - 1] - nums[0];\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean can_form_pairs(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        \\n        int left = 0, right = nums[nums.Length - 1] - nums[0];\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (CanFormPairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private bool CanFormPairs(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.Length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function minimizeMax(nums, p) {\\n    nums.sort((a, b) => a - b);\\n    \\n    let left = 0, right = nums[nums.length - 1] - nums[0];\\n    \\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canFormPairs(nums, mid, p)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return left;\\n}\\n\\nfunction canFormPairs(nums, mid, p) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length - 1 && count < p;) {\\n        if (nums[i+1] - nums[i] <= mid) {\\n            count++;\\n            i += 2;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return count >= p;\\n}\\n```\\n\\n# Live Coding & Explenation in Rust \\nhttps://youtu.be/E11wgsLbq-w",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```python\\n    def can_form_pairs(mid):\\n        ...\\n    ```\n```python\\n    nums.sort()\\n    low, high = 0, nums[-1] - nums[0]\\n    ...\\n    return low\\n    ```\n```Python []\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\n        def can_form_pairs(mid):\\n            count = 0\\n            i = 0\\n            while i < len(nums) - 1 and count < p:\\n                if nums[i+1] - nums[i] <= mid:\\n                    count += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            return count >= p\\n        \\n        nums.sort()\\n        left, right = 0, nums[-1] - nums[0]\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_form_pairs(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n                \\n        return left\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\n``` Go []\\nfunc minimizeMax(nums []int, p int) int {\\n\\tsort.Ints(nums)\\n\\t\\n\\tleft, right := 0, nums[len(nums)-1] - nums[0]\\n\\t\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif canFormPairs(nums, mid, p) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn left\\n}\\n\\nfunc canFormPairs(nums []int, mid int, p int) bool {\\n\\tcount := 0\\n\\tfor i := 0; i < len(nums) - 1 && count < p; {\\n\\t\\tif nums[i+1] - nums[i] <= mid {\\n\\t\\t\\tcount++\\n\\t\\t\\ti += 2\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn count >= p\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        \\n        int left = 0, right = nums[nums.length - 1] - nums[0];\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean can_form_pairs(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        \\n        int left = 0, right = nums[nums.Length - 1] - nums[0];\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (CanFormPairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private bool CanFormPairs(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.Length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function minimizeMax(nums, p) {\\n    nums.sort((a, b) => a - b);\\n    \\n    let left = 0, right = nums[nums.length - 1] - nums[0];\\n    \\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canFormPairs(nums, mid, p)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return left;\\n}\\n\\nfunction canFormPairs(nums, mid, p) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length - 1 && count < p;) {\\n        if (nums[i+1] - nums[i] <= mid) {\\n            count++;\\n            i += 2;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return count >= p;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884188,
                "title": "99-33-fast-easy-code-with-comments-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif it\\'s possible to create `p` pairs with differences less than or equal to the current candidate maximum difference and find till we get minimum difference by search.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/cN4UICj2Rn0\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Sort the given `nums` array in ascending order.\\n2. Initialize `lo` to 0 and `hi` to the maximum difference between the largest and smallest elements in the sorted array.\\n3. Perform a binary search loop while `lo` is less than `hi`.\\n4. Calculate the midpoint `mid` between `lo` and `hi`.\\n5. Count the number of pairs with a difference less than or equal to `mid` while ensuring that no index appears more than once among the pairs.\\n6. If the count is greater than or equal to `p`, update `hi` to `mid`.\\n7. Otherwise, update `lo` to `mid + 1`.\\n8. Return the value of `lo` as the minimum maximum difference that allows forming at least `p` valid pairs.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n*log(d))$$ where d is maximum difference.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n   //able to  find p pairs with maximum difference of mid or not\\n    bool solve(vector<int>& nums,int d,int p){\\n        int n=nums.size();\\n        int c=0;\\n         for (int i = 0; i  < n-1; i++){\\n\\n            if (nums[i + 1] - nums[i] <= d) {\\n               c++;\\n               i++;//no index appears more than once amongst the p pairs\\n            }\\n            if(c>=p)//able to find\\n            return true;\\n           }\\n           return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n    sort(nums.begin(), nums.end());\\n    int n=nums.size();\\n    //maximum difference is maximum element - minimum element\\n    int lo = 0, hi = nums[n-1] - nums[0];\\n    //we are checking for all the difference by binary search instead of linear search\\n    while (lo < hi) {\\n        int mid = (lo + hi) / 2;\\n      \\n        if (solve(nums,mid,p))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean solve(int[] nums, int d, int p) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i + 1] - nums[i] <= d) {\\n                c++;\\n                i++;\\n            }\\n            if (c >= p) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int lo = 0, hi = nums[n - 1] - nums[0];\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (solve(nums, mid, p)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def solve(self, nums, d, p):\\n        n = len(nums)\\n        c = 0\\n        i = 0\\n        while i < n - 1:\\n            if nums[i + 1] - nums[i] <= d:\\n                c += 1\\n                i += 1\\n            if c >= p:\\n                return True\\n            i += 1\\n        return False\\n    \\n    def minimizeMax(self, nums, p):\\n        nums.sort()\\n        n = len(nums)\\n        lo, hi = 0, nums[n - 1] - nums[0]\\n        \\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            \\n            if self.solve(nums, mid, p):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n\\n```\\n# upvote if you understood the solution\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n   //able to  find p pairs with maximum difference of mid or not\\n    bool solve(vector<int>& nums,int d,int p){\\n        int n=nums.size();\\n        int c=0;\\n         for (int i = 0; i  < n-1; i++){\\n\\n            if (nums[i + 1] - nums[i] <= d) {\\n               c++;\\n               i++;//no index appears more than once amongst the p pairs\\n            }\\n            if(c>=p)//able to find\\n            return true;\\n           }\\n           return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n    sort(nums.begin(), nums.end());\\n    int n=nums.size();\\n    //maximum difference is maximum element - minimum element\\n    int lo = 0, hi = nums[n-1] - nums[0];\\n    //we are checking for all the difference by binary search instead of linear search\\n    while (lo < hi) {\\n        int mid = (lo + hi) / 2;\\n      \\n        if (solve(nums,mid,p))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean solve(int[] nums, int d, int p) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i + 1] - nums[i] <= d) {\\n                c++;\\n                i++;\\n            }\\n            if (c >= p) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int lo = 0, hi = nums[n - 1] - nums[0];\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (solve(nums, mid, p)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def solve(self, nums, d, p):\\n        n = len(nums)\\n        c = 0\\n        i = 0\\n        while i < n - 1:\\n            if nums[i + 1] - nums[i] <= d:\\n                c += 1\\n                i += 1\\n            if c >= p:\\n                return True\\n            i += 1\\n        return False\\n    \\n    def minimizeMax(self, nums, p):\\n        nums.sort()\\n        n = len(nums)\\n        lo, hi = 0, nums[n - 1] - nums[0]\\n        \\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            \\n            if self.solve(nums, mid, p):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return lo\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406380,
                "title": "i-kotlin-recursion-dp-explained-non-binary-search-approach",
                "content": "# Can this task be solved without Binary Search?\\n\\nI see a lot of Binary Search based solutions to this problem. It should be mentioned that the Binary search is good enough, but I\\'d like to share with you a different approach, just to show that there is another way of solution.  It is based on recursion with dynamic programming.\\n\\nI\\'m trying to be pretty detailed, so please, feel free to skip any sections if you think that they are pretty obvious.\\n\\n# Why Do We Sort the Input Numbers?\\n\\nAccording to the problem we have to find all pairs with the minimum difference. Let\\'s assume we have an array of 3 elements: `[a, b, c]` and it\\'s given that `a < b < c`. Let\\'s show that `b` is a best pair for `a` than `c` is. As we know, `b < c`, and we can subtract `a` from both sides of `<` and this won\\'t change the inequality: `(b - a) < (c - a)`. And that\\'s true for any `a`, `b`, and `c`.\\n\\nSo it means that the best pair for an element is another element standing next to it in the sorted array. All pairs we are looking for are pairs like `(nums[i], nums[i+1])` in a sorted array `nums`.\\n\\n# Some Boring Math\\n\\nLet\\'s assume there is a function $$f_{nums}(i, p)$$ which returns the minimum maximum difference among all `p` pairs in ascending sorted array `nums` starting from the index `i`.\\n\\nIn general case we have an array of values:\\n\\n![Screenshot from 2023-04-11 13-20-27.png](https://assets.leetcode.com/users/images/afb208e6-62e8-4b77-874e-3592a07efcf2_1681244490.0470169.png)\\n\\n\\nTo calculate the value of $f$ we have two options:\\n## Option 1: Skip the First Element\\n![Screenshot from 2023-04-11 13-20-48.png](https://assets.leetcode.com/users/images/525dab7b-5309-4fe0-b0c0-0ec209a43f16_1681244564.876135.png)\\n\\nTo skip the element $ a_i $ and find `p` pairs in a sub-array starting the index `i+1`:\\n$ f_{nums}(i, p) = f_{nums}(i + 1, p) $\\n## Option 2: Use the First Element\\n![Screenshot from 2023-04-11 13-21-06.png](https://assets.leetcode.com/users/images/21b91431-8881-4c70-b7e1-a4460583dc48_1681244528.5592096.png)\\nIf we use pair of $(a_i, a_{i+1})$ then the difference of this pair is $|a_{i+1} - a_i|$, but it has also been given that `nums` is an ascending sorted array, so $a_i < a_{i+1}$ for any $i$, and we can omit the $|x|$ operation: $(a_{i+1} - a_i)$.\\nAfter we fitted one pair into the array, we have $ p - 1 $ pairs left and we can\\'t use $a_i$ and $a_{i+1}$ anymore. The value of function $f$ for the rest of elements would be equal to $f_{nums}(i + 2, p - 1)$.\\nAs we have to find the max value of all pairs:\\n$$ f_{nums}(i, p) = max((a_{i+1} - a_i), f_{nums}(i + 2, p - 1)) $$\\n## Combining The Options\\nFrom these two options we have to choose the smallest value, because if we choose the biggest one that would mean that among the fitted pairs, there is a pair with not the smallest difference. And this brings us to a final recursive definition of $f$:\\n$ f_{nums}(i, p) = min(f_{nums}(i + 1, p), max((a_{i+1} - a_i), f_{nums}(i + 2, p - 1))) $\\nSo our goal is to calculate the value of $f_{nums}(0, p)$.\\n\\n# Approach\\n\\nSo, let\\'s finally implement the formula. To calculate the value of $f$ of array `(0 .. nums)` we need to know the value of $f$ for the two sub-arrays.\\nIt can be suggested to put the calculation upside down, and calculate $f(i, 1)$ for each `i` in range of `0 .. nums.length - 2`. Then get $f(i, 2)$ for each `i` in range of `0 .. nums.length - 4`, and so on util we reach `p`. And, since to calculate the value at `i` we need to know the value at `i + 1`, so it would make sense to run the calculations from the most right element down to the left one.\\n\\nFor case `p=1` it\\'s just a minimal difference of all neighborhood elements:\\n```\\nval f1 = IntArray(nums.size)\\n// The last value is simply a difference of two last elements in num\\nf1[nums.size - 2] = nums[nums.size - 1] - nums[nums.size - 2]\\nfor (i in nums.size - 3 downTo 0) {\\n    f1[i] = minOf(f1[i + 1], nums[i + 1] - nums[i])\\n}\\n```\\nNow, when we have all values of $f(i, 1)$, we can calculate the values for `p=2`. Because it\\'s required at least 4 elements to fit 2 pairs, the iteration is started from the 4th element from the right\\n```\\nval f2 = IntArray(nums.size)\\n// The last value is simply a difference of two last elements in num\\nf2[nums.size - 4] = nums[nums.size - 1] - nums[nums.size - 2]\\nfor (i in nums.size - 5 downTo 0) {\\n    f2[i] = minOf(f2[i + 1], maxOf(nums[i + 1] - nums[i], f1[i + 2]))\\n}\\n```\\n\\nAnd so on. There are two optimizations that should be mentioned.\\n\\n## Memory Optimization\\nAs it could be seen from the original formula, to calculate `f2` we need values from `f1` only, and for `f3` we need `f2` only, so there is no need to keep all unnecessary arrays in the memory, instead we could have two and swap them on each iteration:\\n\\n\\n```\\nvar results = IntArray(nums.size)\\nvar prevResults = IntArray(nums.size)\\n\\nfor (pairs in 1 .. p) {\\n    // Do the calculations here\\n\\n    // Swap the results, so we can use curResults again.\\n    val tmp = prevResults\\n    prevResults = results\\n    results = tmp\\n}\\n\\nreturn prevResults.first()\\n```\\n\\n## Time Optimization\\nThere is one more optimization to reduce computation time. At the end of the computation the result is holded by `f[0]` cell. To calculate the value we need to know just `f[1]` on the same step and `f[2]` from the previous iteration. Take a look at the schema below:\\n\\n![Screenshot from 2023-04-11 13-33-12.png](https://assets.leetcode.com/users/images/186888b3-5871-4f72-b05c-0ccc6a3f3477_1681245212.0992355.png)\\n\\nAs you can see, we don\\'t actually use the values from cells with gray background to calculate the result. In other words, instead of looping down to `0` we may stop the loop early.\\n\\n```\\nfor (pairs in 1 .. p) {\\n    val range = (nums.size - 2 * pairs) downTo (2 * (p -  pairs))\\n    // Do the calculations here\\n}\\n```\\n# Complexity\\n- Time complexity:\\n  $O(np - p^2)$, where `n` is a number of elements in `nums`, and `p` is a number os pairs.\\n    We do the array sorting and $p$ iterations by $(n - 2p)$ steps, which give us $ O(n logn + p(n - 2p)) $ before reduction.\\n\\n- Space complexity:\\n  $$O(n)$$, where `n` is a number of elements in `nums`. We use two arrays of size `n` to store result on the current and previous iteration.\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        var results = IntArray(nums.size)\\n        // Add one extra element to fit Int.MAX_VALUE on the first iteration. See below.\\n        var prevResults = IntArray(nums.size + 1)\\n\\n        nums.sort()\\n        for (pairs in 1 .. p) {\\n            val range = nums.size - 2 * pairs downTo 2 * (p -  pairs)\\n            // This is a small hack to avoid minOf(results[i + 1], ...) return incorrect result\\n            // on the first iteration.\\n            results[range.first + 1] = Int.MAX_VALUE\\n            for (i in range) {\\n                results[i] = minOf(results[i + 1], maxOf(nums[i + 1] - nums[i], prevResults[i + 2]))\\n            }\\n            // Swap the buffers\\n            val tmp = prevResults\\n            prevResults = results\\n            results = tmp\\n        }\\n\\n        return prevResults.first()\\n    }\\n}\\n```\\n# Bonus: Binary Search\\nI\\'d also be happy to add one more binary search implementation the way it could be written in Kotlin:\\n```\\nclass Solution {\\n    fun IntArray.binarySearch(target: (Int) -> Int): Int {\\n        var left = 0\\n        var right = last() - first()\\n        while (left < right) {\\n            ((left + right) / 2).also {\\n                if (target(it) >= 0) {\\n                    right = it\\n                } else {\\n                    left = it + 1\\n                }\\n            }\\n        }\\n        return left\\n    }\\n\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n      p == 0 && return 0\\n\\n      return nums.apply { sort() }.binarySearch {\\n          var foundPairs = 0\\n          var i = 1\\n          do {\\n              if (nums[i] - nums[i - 1] <= it) {\\n                  ++foundPairs\\n                  ++i\\n              }\\n          } while (++i < nums.size && foundPairs < p)\\n          foundPairs - p\\n      }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nval f1 = IntArray(nums.size)\\n// The last value is simply a difference of two last elements in num\\nf1[nums.size - 2] = nums[nums.size - 1] - nums[nums.size - 2]\\nfor (i in nums.size - 3 downTo 0) {\\n    f1[i] = minOf(f1[i + 1], nums[i + 1] - nums[i])\\n}\\n```\n```\\nval f2 = IntArray(nums.size)\\n// The last value is simply a difference of two last elements in num\\nf2[nums.size - 4] = nums[nums.size - 1] - nums[nums.size - 2]\\nfor (i in nums.size - 5 downTo 0) {\\n    f2[i] = minOf(f2[i + 1], maxOf(nums[i + 1] - nums[i], f1[i + 2]))\\n}\\n```\n```\\nvar results = IntArray(nums.size)\\nvar prevResults = IntArray(nums.size)\\n\\nfor (pairs in 1 .. p) {\\n    // Do the calculations here\\n\\n    // Swap the results, so we can use curResults again.\\n    val tmp = prevResults\\n    prevResults = results\\n    results = tmp\\n}\\n\\nreturn prevResults.first()\\n```\n```\\nfor (pairs in 1 .. p) {\\n    val range = (nums.size - 2 * pairs) downTo (2 * (p -  pairs))\\n    // Do the calculations here\\n}\\n```\n```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        var results = IntArray(nums.size)\\n        // Add one extra element to fit Int.MAX_VALUE on the first iteration. See below.\\n        var prevResults = IntArray(nums.size + 1)\\n\\n        nums.sort()\\n        for (pairs in 1 .. p) {\\n            val range = nums.size - 2 * pairs downTo 2 * (p -  pairs)\\n            // This is a small hack to avoid minOf(results[i + 1], ...) return incorrect result\\n            // on the first iteration.\\n            results[range.first + 1] = Int.MAX_VALUE\\n            for (i in range) {\\n                results[i] = minOf(results[i + 1], maxOf(nums[i + 1] - nums[i], prevResults[i + 2]))\\n            }\\n            // Swap the buffers\\n            val tmp = prevResults\\n            prevResults = results\\n            results = tmp\\n        }\\n\\n        return prevResults.first()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun IntArray.binarySearch(target: (Int) -> Int): Int {\\n        var left = 0\\n        var right = last() - first()\\n        while (left < right) {\\n            ((left + right) / 2).also {\\n                if (target(it) >= 0) {\\n                    right = it\\n                } else {\\n                    left = it + 1\\n                }\\n            }\\n        }\\n        return left\\n    }\\n\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n      p == 0 && return 0\\n\\n      return nums.apply { sort() }.binarySearch {\\n          var foundPairs = 0\\n          var i = 1\\n          do {\\n              if (nums[i] - nums[i - 1] <= it) {\\n                  ++foundPairs\\n                  ++i\\n              }\\n          } while (++i < nums.size && foundPairs < p)\\n          foundPairs - p\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395710,
                "title": "binary-search",
                "content": "We binary search for minimum `m` that can produce `p` pairs.\\n\\nIf we fix `m`, how do we count the number of valid pairs? We sort `n`, and greedily pick numbers next to each other:\\n- If two numbers form a pair, we count it (skip 2).\\n- If they does not, we try the second number again (skip 1).\\n\\nWhy does greedy work? Say we have sorted numbers `i, j, k, l`.\\n\\nIf pairs `{i, k}` and `{j, l}` are valid, then pairs `{i, j}` and `{k, l}` are also valid. \\n\\nThis is because if `k - i <= m` and `l - j <= m`, then `l - k <= m + j - m - i` and `l - k <= j - i`.\\n\\nSince `j - i <= m`, therefore `l - k <= m`, so it is a valid pair.\\n\\n**C++**\\n```cpp\\nint minimizeMax(vector<int>& n, int p) {\\n    sort(begin(n), end(n));\\n    int l = 0, r = n.back() - n.front();\\n    while (l < r) {\\n        int m = (l + r) / 2, cnt = 0;\\n        for (int i = 0; i + 1 < n.size(); ++i)\\n            if (m >= (n[i + 1] - n[i])) {\\n                ++cnt;\\n                ++i;\\n            }\\n        if (cnt >= p)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimizeMax(vector<int>& n, int p) {\\n    sort(begin(n), end(n));\\n    int l = 0, r = n.back() - n.front();\\n    while (l < r) {\\n        int m = (l + r) / 2, cnt = 0;\\n        for (int i = 0; i + 1 < n.size(); ++i)\\n            if (m >= (n[i + 1] - n[i])) {\\n                ++cnt;\\n                ++i;\\n            }\\n        if (cnt >= p)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396031,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nTo minimize the maximum difference amongst all the pairs, we need to find a maximum difference that satisfies the given condition of having p pairs of indices of nums. Since we want to minimize the maximum difference, we can use binary search to find the smallest maximum difference that satisfies the given condition.\\n\\n\\n\\n# Approach\\nFirst, we sort the input list of integers. We define the minimum and maximum possible values for the maximum difference. The minimum value is 0 since the difference between any two elements is at least 0. The maximum value is the difference between the largest and smallest elements in the list since that is the maximum difference possible.\\n\\nWe perform binary search for the smallest maximum difference that satisfies the given condition. In each iteration, we calculate the mid-point of the possible range of maximum differences. We then count the number of pairs of adjacent integers with a difference less than or equal to the mid-point maximum difference. If the number of such pairs is greater than or equal to p, we decrease the maximum possible value of the maximum difference. Otherwise, we increase the minimum possible value of the maximum difference.\\n\\nWe continue this process until the minimum and maximum values converge to the same value, which is the smallest maximum difference that satisfies the given condition.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the binary search algorithm is O(log(max_diff - min_diff) * n), where n is the length of the input list of integers, max_diff is the maximum difference possible (i.e., the difference between the largest and smallest elements), and min_diff is the minimum possible difference (i.e., 0). Since the value of max_diff can be at most 10^9, the time complexity of the algorithm is O(log(10^9) * n), which is approximately O(30 * n) or O(n).\\n- Space complexity:\\nhe space complexity of the algorithm is O(1) since we are not using any extra space besides a few integer variables.b\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # Sort the input list of integers\\n        nums.sort()\\n        n = len(nums)\\n        \\n        # Define the minimum and maximum possible values for the maximum difference\\n        min_max_diff = 0\\n        max_max_diff = nums[-1] - nums[0]\\n        \\n        # Binary search for the smallest maximum difference that satisfies the given condition\\n        while min_max_diff < max_max_diff:\\n            mid_max_diff = (min_max_diff + max_max_diff) // 2\\n            \\n            # Count the number of pairs of adjacent integers with a difference less than or equal to mid_max_diff\\n            pair_count = 0\\n            i = 1\\n            while i < n:\\n                if nums[i] - nums[i-1] <= mid_max_diff:\\n                    pair_count += 1\\n                    i += 1\\n                i += 1\\n            \\n            # If the number of such pairs is greater than or equal to p, decrease the maximum possible value of the maximum difference\\n            if pair_count >= p:\\n                max_max_diff = mid_max_diff\\n            # Otherwise, increase the minimum possible value of the maximum difference\\n            else:\\n                min_max_diff = mid_max_diff + 1\\n        \\n        # Return the smallest maximum difference that satisfies the given condition\\n        return min_max_diff\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # Sort the input list of integers\\n        nums.sort()\\n        n = len(nums)\\n        \\n        # Define the minimum and maximum possible values for the maximum difference\\n        min_max_diff = 0\\n        max_max_diff = nums[-1] - nums[0]\\n        \\n        # Binary search for the smallest maximum difference that satisfies the given condition\\n        while min_max_diff < max_max_diff:\\n            mid_max_diff = (min_max_diff + max_max_diff) // 2\\n            \\n            # Count the number of pairs of adjacent integers with a difference less than or equal to mid_max_diff\\n            pair_count = 0\\n            i = 1\\n            while i < n:\\n                if nums[i] - nums[i-1] <= mid_max_diff:\\n                    pair_count += 1\\n                    i += 1\\n                i += 1\\n            \\n            # If the number of such pairs is greater than or equal to p, decrease the maximum possible value of the maximum difference\\n            if pair_count >= p:\\n                max_max_diff = mid_max_diff\\n            # Otherwise, increase the minimum possible value of the maximum difference\\n            else:\\n                min_max_diff = mid_max_diff + 1\\n        \\n        # Return the smallest maximum difference that satisfies the given condition\\n        return min_max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395863,
                "title": "binary-search-o-nlogn-approach-c-java-python",
                "content": "**Approach**\\n\\n* Sort the array as the difference between 2 adjacent elements in sorted array is least.\\n* Binary search over maximum difference of possible pairs.\\n* count no. of possible pairs for the mid value skipping the pair if difference is more than mid.\\n* note that the indices can be picked in **atmost 1** pairs, so after you pick an index in a pair, do not pick it in another pair.\\n* if no. of possible pairs>=p store mid in hi as the last possible answer.\\n* this step also decreases the range to search as the next answer if possible will be < hi.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& v, int p) {\\n        int n=v.size();\\n        sort(v.begin(),v.end()); //sort the array to get minimum differences\\n\\t\\t\\n\\t\\t//binary search logic\\n        int lo=-1,hi=1e9+7;\\n        while(lo<hi-1){\\n            int mid=lo+(hi-lo)/2;\\n            int a=0;// to count total possible pairs if mid is the max value\\n            for(int i=1;i<n;i++){\\n                if(v[i]-v[i-1]<=mid){ // counting only if difference is <= mid\\n                    i++;\\n                    a++;\\n                }\\n            }\\n            if(a>=p){\\n                hi=mid; // store the last possible value in hi\\n            }\\n            else lo=mid;\\n        }\\n        return hi;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minimizeMax(int[] v, int p) {\\n        int n=v.length;\\n        Arrays.sort(v); // sort to get minimum differences\\n        \\n\\t\\t//binary search logic\\n        int lo=-1,hi=1000000007;\\n        while(lo<hi-1){\\n            int mid=lo+(hi-lo)/2;\\n            int a=0; // to count total possible pairs if mid is the max value\\n            for(int i=1;i<n;i++){\\n                if(v[i]-v[i-1]<=mid){ // counting only if difference is <= mid\\n                    i++;\\n                    a++;\\n                }\\n            }\\n            if(a>=p){\\n                hi=mid;// store the last possible value in hi\\n            }\\n            else lo=mid;\\n        }\\n        return hi;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def minimizeMax(self, v, p):\\n        n=len(v)\\n        v.sort() #sort the array to get minimum difference\\n        \\n        #binary search logic\\n        lo=-1\\n        hi=1000000007\\n        while lo<hi-1:\\n            mid=lo+(hi-lo)/2\\n            a=0 # to count total possible pairs if mid is the max value\\n            i=1\\n            while i<n:\\n                if v[i]-v[i-1]<=mid: # counting only if difference is <= mid\\n                    a+=1;\\n                    i+=1\\n                i+=1\\n            if a>=p:\\n                hi=mid # store the last possible value in hi\\n            else:\\n                lo=mid\\n        return hi\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& v, int p) {\\n        int n=v.size();\\n        sort(v.begin(),v.end()); //sort the array to get minimum differences\\n\\t\\t\\n\\t\\t//binary search logic\\n        int lo=-1,hi=1e9+7;\\n        while(lo<hi-1){\\n            int mid=lo+(hi-lo)/2;\\n            int a=0;// to count total possible pairs if mid is the max value\\n            for(int i=1;i<n;i++){\\n                if(v[i]-v[i-1]<=mid){ // counting only if difference is <= mid\\n                    i++;\\n                    a++;\\n                }\\n            }\\n            if(a>=p){\\n                hi=mid; // store the last possible value in hi\\n            }\\n            else lo=mid;\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizeMax(int[] v, int p) {\\n        int n=v.length;\\n        Arrays.sort(v); // sort to get minimum differences\\n        \\n\\t\\t//binary search logic\\n        int lo=-1,hi=1000000007;\\n        while(lo<hi-1){\\n            int mid=lo+(hi-lo)/2;\\n            int a=0; // to count total possible pairs if mid is the max value\\n            for(int i=1;i<n;i++){\\n                if(v[i]-v[i-1]<=mid){ // counting only if difference is <= mid\\n                    i++;\\n                    a++;\\n                }\\n            }\\n            if(a>=p){\\n                hi=mid;// store the last possible value in hi\\n            }\\n            else lo=mid;\\n        }\\n        return hi;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def minimizeMax(self, v, p):\\n        n=len(v)\\n        v.sort() #sort the array to get minimum difference\\n        \\n        #binary search logic\\n        lo=-1\\n        hi=1000000007\\n        while lo<hi-1:\\n            mid=lo+(hi-lo)/2\\n            a=0 # to count total possible pairs if mid is the max value\\n            i=1\\n            while i<n:\\n                if v[i]-v[i-1]<=mid: # counting only if difference is <= mid\\n                    a+=1;\\n                    i+=1\\n                i+=1\\n            if a>=p:\\n                hi=mid # store the last possible value in hi\\n            else:\\n                lo=mid\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884074,
                "title": "detailed-image-explanation-with-time-and-space-complexity",
                "content": "# Approach\\n\\nIt\\'s kind of dry run with explanation.\\n![Screenshot from 2023-08-09 07-07-34.png](https://assets.leetcode.com/users/images/0875fd16-1bec-46d4-81ef-065bd8f04c19_1691545227.4161913.png)\\n\\n![Screenshot from 2023-08-09 07-08-22.png](https://assets.leetcode.com/users/images/dee57be4-c071-4419-b71b-13574606d48b_1691545241.2015078.png)\\n![Screenshot from 2023-08-09 07-08-58.png](https://assets.leetcode.com/users/images/85530033-c8e9-4000-971d-5154ecb40c00_1691545248.4548926.png)\\n![Screenshot from 2023-08-09 07-09-22.png](https://assets.leetcode.com/users/images/13a0b3cf-34e8-4692-a458-ea04618e9d25_1691545253.03643.png)\\n![Screenshot from 2023-08-09 07-09-58.png](https://assets.leetcode.com/users/images/f8ce1e71-bb17-49b9-bd57-ec616792dcda_1691545257.180134.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        // Sort the input array in ascending order\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n\\n        // Initialize two pointers for binary search\\n        int left = 0, right = nums[n-1] - nums[0];\\n\\n        // Perform binary search on the range [left, right]\\n        while (left < right) {\\n            // Calculate the midpoint\\n            int mid = (right + left) / 2;\\n            \\n            // Initialize a counter to keep track of the number of pairs\\n            int countPairs = 0;\\n            \\n            // Iterate through the array and count pairs with a difference less than or equal to \\'mid\\'\\n            for (int i = 1; i < n && countPairs < p; i++) {\\n                if (nums[i] - nums[i-1] <= mid) {\\n                    i++;  // Move to the next index to avoid double counting\\n                    countPairs++;\\n                }\\n            }\\n\\n            // If the count of valid pairs is greater than or equal to \\'p\\', update the right boundary\\n            if (countPairs >= p) {\\n                right = mid;\\n            } else {\\n                // If the count of valid pairs is less than \\'p\\', update the left boundary\\n                left = mid + 1;\\n            }\\n        }\\n\\n        // Return the minimum value of \\'mid\\' that satisfies the condition\\n        return left;\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting the array takes O(n log n) time.\\nBinary search loop iterates O(log m) times, where \\'m\\' is the range between right and left.\\nOverall time complexity: O(n log n + n log m), which can be simplified as O(n log (n * m)).\\nSpace Complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe algorithm uses a constant amount of extra memory for variables and does not create significant additional data structures.\\nOverall space complexity: O(1), indicating a constant amount of memory usage regardless of input size.\\n\\n\\n![Screenshot from 2023-07-30 16-51-58.png](https://assets.leetcode.com/users/images/d680b867-8e72-4666-a15c-7cb30b5073d3_1691545353.3498166.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        // Sort the input array in ascending order\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n\\n        // Initialize two pointers for binary search\\n        int left = 0, right = nums[n-1] - nums[0];\\n\\n        // Perform binary search on the range [left, right]\\n        while (left < right) {\\n            // Calculate the midpoint\\n            int mid = (right + left) / 2;\\n            \\n            // Initialize a counter to keep track of the number of pairs\\n            int countPairs = 0;\\n            \\n            // Iterate through the array and count pairs with a difference less than or equal to \\'mid\\'\\n            for (int i = 1; i < n && countPairs < p; i++) {\\n                if (nums[i] - nums[i-1] <= mid) {\\n                    i++;  // Move to the next index to avoid double counting\\n                    countPairs++;\\n                }\\n            }\\n\\n            // If the count of valid pairs is greater than or equal to \\'p\\', update the right boundary\\n            if (countPairs >= p) {\\n                right = mid;\\n            } else {\\n                // If the count of valid pairs is less than \\'p\\', update the left boundary\\n                left = mid + 1;\\n            }\\n        }\\n\\n        // Return the minimum value of \\'mid\\' that satisfies the condition\\n        return left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884511,
                "title": "c-binary-search-day-9",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& v, int p) {\\n       sort(v.begin(),v.end());\\n       int n = v.size();\\n       int ans = v[n-1]-v[0];\\n       int i=0,j=ans;\\n       while(i<=j){\\n           int m = (i+j)/2;\\n           int total = 0;\\n           int k = 0;\\n           while(k<n-1){\\n               if(v[k+1]-v[k]<=m){\\n                   total++;\\n                   k+=2;\\n               }\\n               else k++;\\n           }\\n           if(total>=p){\\n               ans = m;\\n               j = m-1;\\n           }\\n           else i = m+1;\\n       }\\n       return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/2172c790-387c-45c8-8bb2-284043435ac3_1691557007.3682246.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& v, int p) {\\n       sort(v.begin(),v.end());\\n       int n = v.size();\\n       int ans = v[n-1]-v[0];\\n       int i=0,j=ans;\\n       while(i<=j){\\n           int m = (i+j)/2;\\n           int total = 0;\\n           int k = 0;\\n           while(k<n-1){\\n               if(v[k+1]-v[k]<=m){\\n                   total++;\\n                   k+=2;\\n               }\\n               else k++;\\n           }\\n           if(total>=p){\\n               ans = m;\\n               j = m-1;\\n           }\\n           else i = m+1;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884240,
                "title": "line-by-line-explanation-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    // min max -> think of binary search\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // sort the input first\\n        sort(nums.begin(), nums.end());\\n        // the possible difference ranges from 0 to the largest value - the smallest value\\n        int n = nums.size(), l = 0 , r = nums.back() - nums.front();\\n        // binary search the min max diff\\n        while (l < r) {\\n            int m = l + (r - l) / 2, cnt = 0;\\n            for (int i = 1; i < n; i++) {\\n                // we can make a pair\\n                if (nums[i] - nums[i - 1] <= m) {\\n                    // increase the number of pairs\\n                    cnt += 1;\\n                    // increase i by 1\\n                    // since it is included in the pair already\\n                    i += 1;\\n                }\\n            }\\n            // not enough pairs, move l pointer excluding m\\n            if (cnt < p) l = m + 1;\\n            // too many pairs, move r to m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // min max -> think of binary search\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // sort the input first\\n        sort(nums.begin(), nums.end());\\n        // the possible difference ranges from 0 to the largest value - the smallest value\\n        int n = nums.size(), l = 0 , r = nums.back() - nums.front();\\n        // binary search the min max diff\\n        while (l < r) {\\n            int m = l + (r - l) / 2, cnt = 0;\\n            for (int i = 1; i < n; i++) {\\n                // we can make a pair\\n                if (nums[i] - nums[i - 1] <= m) {\\n                    // increase the number of pairs\\n                    cnt += 1;\\n                    // increase i by 1\\n                    // since it is included in the pair already\\n                    i += 1;\\n                }\\n            }\\n            // not enough pairs, move l pointer excluding m\\n            if (cnt < p) l = m + 1;\\n            // too many pairs, move r to m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395826,
                "title": "cpp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int> &v,int m,int p) {\\n        int cnt = 0,mx = 0;\\n        for(int i = 1; i < v.size(); i += 1) {\\n            if(v[i] - v[i - 1] <= m) {\\n                i += 1;\\n                cnt += 1;\\n            }\\n        }\\n        return cnt >= p;\\n    }\\n    \\n    int minimizeMax(vector<int>& v, int p) {\\n        sort(v.begin(),v.end());\\n        int l = 0,r = v.back(), ans = -1;\\n        //0,6 --> m = 3\\n        while(r >= l) {\\n            int m = (l + r)/2;\\n            // cout<<\"m : \"<<m<<endl;\\n            if(helper(v,m,p)) {\\n                ans = m;\\n                r = m - 1;\\n            } else l = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int> &v,int m,int p) {\\n        int cnt = 0,mx = 0;\\n        for(int i = 1; i < v.size(); i += 1) {\\n            if(v[i] - v[i - 1] <= m) {\\n                i += 1;\\n                cnt += 1;\\n            }\\n        }\\n        return cnt >= p;\\n    }\\n    \\n    int minimizeMax(vector<int>& v, int p) {\\n        sort(v.begin(),v.end());\\n        int l = 0,r = v.back(), ans = -1;\\n        //0,6 --> m = 3\\n        while(r >= l) {\\n            int m = (l + r)/2;\\n            // cout<<\"m : \"<<m<<endl;\\n            if(helper(v,m,p)) {\\n                ans = m;\\n                r = m - 1;\\n            } else l = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3884652,
                "title": "neat-crisp-code-c-dp-binary-search",
                "content": "\\n\\n# DP SOLUTION GIVES MLE\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&nums,int p,vector<vector<int>>&dp)\\n    {\\n        if(p==0)\\n        return 0;\\n\\n        if(i>=nums.size()-1)\\n        return 1e9;\\n        if(dp[i][p]!=-1)\\n        return dp[i][p];\\n        return dp[i][p]=min(solve(i+1,nums,p,dp),max(abs(nums[i]-nums[i+1]),solve(i+2,nums,p-1,dp)));\\n        \\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>dp(nums.size(),vector<int>(p+1,-1));\\n        return solve(0,nums,p,dp);\\n    }\\n};\\n```\\n# Binary Search Approach .\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&nums,int m,int p)\\n    {\\n        int i=0;\\n        while(i<nums.size()-1)\\n        {\\n            if(abs(nums[i]-nums[i+1])<=m)\\n            {\\n                p--;\\n                i=i+2;\\n            }\\n            else\\n            i++;\\n            \\n        }\\n        return p<=0?1:0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums[nums.size()-1];\\n        int ans=-1;\\n\\n        while(i<=j)\\n        {\\n            int m=(i+j)>>1;\\n            if(check(nums,m,p))\\n            {\\n                ans=m;\\n                j=m-1;\\n            }\\n            else\\n            {\\n                i=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF U LIKED MY SOLUTION",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&nums,int p,vector<vector<int>>&dp)\\n    {\\n        if(p==0)\\n        return 0;\\n\\n        if(i>=nums.size()-1)\\n        return 1e9;\\n        if(dp[i][p]!=-1)\\n        return dp[i][p];\\n        return dp[i][p]=min(solve(i+1,nums,p,dp),max(abs(nums[i]-nums[i+1]),solve(i+2,nums,p-1,dp)));\\n        \\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>dp(nums.size(),vector<int>(p+1,-1));\\n        return solve(0,nums,p,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&nums,int m,int p)\\n    {\\n        int i=0;\\n        while(i<nums.size()-1)\\n        {\\n            if(abs(nums[i]-nums[i+1])<=m)\\n            {\\n                p--;\\n                i=i+2;\\n            }\\n            else\\n            i++;\\n            \\n        }\\n        return p<=0?1:0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums[nums.size()-1];\\n        int ans=-1;\\n\\n        while(i<=j)\\n        {\\n            int m=(i+j)>>1;\\n            if(check(nums,m,p))\\n            {\\n                ans=m;\\n                j=m-1;\\n            }\\n            else\\n            {\\n                i=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884239,
                "title": "c-binary-search-beats-98-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\\nSo, there are several different solutions. which one is better?\\n\\nThe binary search solution takes $O(n\\\\log(n)+\\\\log(\\\\max(nums)n))$ times. If the DP is applied, alone the DP states has $O(pn)$. The constraints say\\n1 <= nums.length <= 10^5\\n0 <= nums[i] <= 10^9\\n0 <= p <= (nums.length)/2\\nIf you look at the recurrence relation \\nfn(i, x) = min(fn(i+1, x), max(abs(nums[i]-nums[i+1]), fn(i+2, x-1));\\n the TC could be $O(n^2)$; it could lead to TLE or MLE. So binary search is the choosen one for this question.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array nums. Define the function ```numsPairs``` returning true when there exists at least p different pairs with ```nums[i+1]-nums[i]<=diff``` which has the elapsed time $O(n)$.\\nApply binarch search to ```nums``` with repect to the function ```numsPairs``` which will take $O(\\\\log \\\\max(nums))$ times searches. \\n\\nSo the main part of TC is $O(\\\\log \\\\max(nums))\\\\times O(n)=O(\\\\log(\\\\max(nums))n)$\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log(n)+\\\\log(\\\\max(nums))n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool numsPairs(vector<int>& nums, int diff, int p){\\n        int c=0;\\n        for(int i=0; i<n-1; i++)\\n            if (nums[i+1]-nums[i]<=diff) {\\n                c++;\\n                if (c>=p) return 1;\\n                i++;//can not be adjacent  \\n            }\\n        return 0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p==0) return 0;//edge case\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n    //    for(int d: nums) cout<<d<<\",\"; cout<<endl;\\n\\n        int l=0, r=nums[n-1]-nums[0], m, ans;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if (numsPairs(nums, m, p)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        \\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sort"
                ],
                "code": "```numsPairs```\n```nums[i+1]-nums[i]<=diff```\n```nums```\n```numsPairs```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool numsPairs(vector<int>& nums, int diff, int p){\\n        int c=0;\\n        for(int i=0; i<n-1; i++)\\n            if (nums[i+1]-nums[i]<=diff) {\\n                c++;\\n                if (c>=p) return 1;\\n                i++;//can not be adjacent  \\n            }\\n        return 0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p==0) return 0;//edge case\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n    //    for(int d: nums) cout<<d<<\",\"; cout<<endl;\\n\\n        int l=0, r=nums[n-1]-nums[0], m, ans;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if (numsPairs(nums, m, p)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3400558,
                "title": "apparently-i-stumbled-upon-non-binary-search-approach",
                "content": "As many of the solutions discussed here are using binary search then greedy / DP which is different from what I happen to implement, I would like to share my approach here if anyone\\'s interested. In general, it is a greedy approach.\\n\\n# Observations\\n\\n- **First**, We most likely would not pair 2 numbers that is not adjacent to each other in a non-decreasing order. Deriving from here, we should have `N-1` possible pairs which are `(sorted_nums[i-1], sorted_nums[i])`.\\n- **Second**, If we have to choose 1 pair from 2 different pairs, we would obviously take the one with smaller differences. So, greedily try to pair the numbers starting rom the smallest difference should work in some cases. It does not work if the smaller pair is not part of the solution but the bigger pair is.\\n- **Third**, What are the cases that don\\'t work for the greedy approach? Let\\'s take a look at an example:\\n  ```text\\n  0 500 501 1000  p=2\\n  # Based on our first observation, we will have 3 possible pairs:\\n  # (0, 500), (500, 501), (501, 1000)\\n  # If we greedily takes the smallest (500, 501) we will have:\\n  0 500_501 1000  p=2  taken=[(500, 501)]\\n  # Next we will try to take the second smallest.\\n  0 500_501_1000  p=2  taken=[(500, 501)]  untaken=[(501, 1000)]\\n  # As 501 has been paired, we have to choose which pair to keep.\\n  # Based on our second observation, we\\'ll take (500, 501)\\n  # since it is the smaller difference pair.\\n  # We still haven\\'t satisfy p=2, so we\\'ll try the last pair.\\n  0_500_501_1000  p=2  taken=[(500, 501)]\\n  untaken=[(501, 1000), (0, 500)]\\n  ```\\n  This is where our greedy falls short as the solution actually includes the pairs we have thrown. But do we have to try all combinations of possible pairs? Yes, we don\\'t. What we need is only knowing the last pair we have iterated such that we can create `p` pairs out of them that don\\'t intersect. Because we order them in non-decreasing order, the last pair will be the pair with the maximum difference. And it is not beneficial for us to continue iterating. *i.e.* we should find the smallest `i` such that we can create `p` pairs out of `sorted_with_diff_pairs[0..i]` \\n- **Fourth**, how do we know how many pairs we could create from the pairs we have iterated? If we could create `x` pairs out of `sorted_with_diff_pairs[0..i]`, then adding `sorted_with_diff_pairs[i+1]` will possibly: increase `x` by `1`, don\\'t increase `x`.\\nWhen will we increase `x`? First, notice that taking a pair is connecting two numbers and it\\'s similar to merging two groups.\\n  ```\\n  # Let\\'s take a look at our previous example:\\n  0 500 501 1000\\n  # All belongs to different groups at first.\\n  a  b   c   d  # groups\\n  0 500 501 1000\\n  # We iterate the first pair.\\n  a  b   b   d\\n  0 500_501 1000\\n  # Iterate the second pair.\\n  a  b   b   b\\n  0 500_501_1000\\n  # Iterate the last pair.\\n  b  b   b   b\\n  0_500_501_1000\\n  ```\\n  Then, notice that the size of the groups is what matters\\n  ```\\n  # Let\\'s see if we have 2 odd-sized groups\\n  a a a b b b\\n  # Group a can create 1 pair, group b can create 1 pair.\\n  # So, by this point, we will have x=2\\n  a a a a a a\\n  # When we merge them, we can actually create 3 pairs now.\\n  a_a a_a a_a\\n  # This is because the extra in both groups can form a new pair.\\n  # So if we only have 1 extra or no extras:\\n  a a b # x=1\\n  a a a # x=1\\n  a a b b # x=2\\n  a a a a # x=2\\n  ```\\n  So, we will only increase `x` if the size of the two groups being merged are both odds.\\n\\n# Implementation\\nWe should sort `nums` and generate `N-1` pairs of `(sorted_nums[i], sorted_nums[i+1])`. Next we can sort the pairs or use a heap and iterate them from the ones with the smallest difference.\\n\\nFor each pair `(i,j)` we will merge `group(i)` with `group(j)` which is achieveable with a disjoint-set/union-find data structure, or maintaining the values in left-most/right-most for each group should also work since a merge will only happen between left-most/right-most of the groups.\\n\\nThe values we should maintain for each group is the parity of the size of the group. So whether a group is odd-sized/even-sized which will then affect our `x` value based on observation 4.\\n\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\nI implemented the heap+disjoint set solution:\\n```python\\nimport heapq\\n\\nclass Solution:\\n    def findRoot(self, roots, idx):\\n        if roots[idx] == idx:\\n            return idx\\n        roots[idx] = self.findRoot(roots, roots[idx])\\n        return roots[idx]\\n    \\n    def merge(self, roots, left, right):\\n        roots[self.findRoot(roots, left)] = self.findRoot(roots, right)\\n\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums = sorted(nums)\\n        heap = []\\n        for i in range(1, len(nums)):\\n            heapq.heappush(heap, (nums[i] - nums[i - 1], i - 1, i))\\n        minMaxDiff = 0\\n        odd = [True for _ in range(len(nums))]\\n        roots = [i for i in range(len(nums))]\\n        while p > 0:\\n            diff, left, right = heapq.heappop(heap)\\n            rootLeft = self.findRoot(roots, left)\\n            rootRight = self.findRoot(roots, right)\\n            self.merge(roots, left, right)\\n            if odd[rootLeft] and odd[rootRight]:\\n                p -= 1\\n                minMaxDiff = diff\\n                odd[self.findRoot(roots, left)] = False\\n            elif odd[rootLeft] or odd[rootRight]:\\n                odd[self.findRoot(roots, left)] = True\\n            \\n        return minMaxDiff\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```text\\n  0 500 501 1000  p=2\\n  # Based on our first observation, we will have 3 possible pairs:\\n  # (0, 500), (500, 501), (501, 1000)\\n  # If we greedily takes the smallest (500, 501) we will have:\\n  0 500_501 1000  p=2  taken=[(500, 501)]\\n  # Next we will try to take the second smallest.\\n  0 500_501_1000  p=2  taken=[(500, 501)]  untaken=[(501, 1000)]\\n  # As 501 has been paired, we have to choose which pair to keep.\\n  # Based on our second observation, we\\'ll take (500, 501)\\n  # since it is the smaller difference pair.\\n  # We still haven\\'t satisfy p=2, so we\\'ll try the last pair.\\n  0_500_501_1000  p=2  taken=[(500, 501)]\\n  untaken=[(501, 1000), (0, 500)]\\n  ```\n```\\n  # Let\\'s take a look at our previous example:\\n  0 500 501 1000\\n  # All belongs to different groups at first.\\n  a  b   c   d  # groups\\n  0 500 501 1000\\n  # We iterate the first pair.\\n  a  b   b   d\\n  0 500_501 1000\\n  # Iterate the second pair.\\n  a  b   b   b\\n  0 500_501_1000\\n  # Iterate the last pair.\\n  b  b   b   b\\n  0_500_501_1000\\n  ```\n```\\n  # Let\\'s see if we have 2 odd-sized groups\\n  a a a b b b\\n  # Group a can create 1 pair, group b can create 1 pair.\\n  # So, by this point, we will have x=2\\n  a a a a a a\\n  # When we merge them, we can actually create 3 pairs now.\\n  a_a a_a a_a\\n  # This is because the extra in both groups can form a new pair.\\n  # So if we only have 1 extra or no extras:\\n  a a b # x=1\\n  a a a # x=1\\n  a a b b # x=2\\n  a a a a # x=2\\n  ```\n```python\\nimport heapq\\n\\nclass Solution:\\n    def findRoot(self, roots, idx):\\n        if roots[idx] == idx:\\n            return idx\\n        roots[idx] = self.findRoot(roots, roots[idx])\\n        return roots[idx]\\n    \\n    def merge(self, roots, left, right):\\n        roots[self.findRoot(roots, left)] = self.findRoot(roots, right)\\n\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums = sorted(nums)\\n        heap = []\\n        for i in range(1, len(nums)):\\n            heapq.heappush(heap, (nums[i] - nums[i - 1], i - 1, i))\\n        minMaxDiff = 0\\n        odd = [True for _ in range(len(nums))]\\n        roots = [i for i in range(len(nums))]\\n        while p > 0:\\n            diff, left, right = heapq.heappop(heap)\\n            rootLeft = self.findRoot(roots, left)\\n            rootRight = self.findRoot(roots, right)\\n            self.merge(roots, left, right)\\n            if odd[rootLeft] and odd[rootRight]:\\n                p -= 1\\n                minMaxDiff = diff\\n                odd[self.findRoot(roots, left)] = False\\n            elif odd[rootLeft] or odd[rootRight]:\\n                odd[self.findRoot(roots, left)] = True\\n            \\n        return minMaxDiff\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396788,
                "title": "sort-binary-search-explained",
                "content": "The solution consist of 3 steps:\\n1) Sort the nums vector so that all the elements with **minimum difference** will be adjacent.\\n2) Apply binary search with helper function on answer with **start = 0 & end = 1e9** (as per constraints).\\n3) Helper function will check that if the given answer is possible, if it is then, it will set **end = mid-1**, else, it will set **start = mid+1**.\\n\\nC++ implementation for the above approach \\uD83D\\uDC47\\n```\\nclass Solution {\\npublic:\\n    \\n    bool helper(int mid, vector<int>& nums, int p){\\n        int ct = 0;\\n        // helper function counts how many pairs are possible with the following \\'mid\\',\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i]-nums[i-1] <= mid){\\n                ct++;\\n                i++;\\n            }\\n        }\\n        // if count of pairs is more than \\'p\\', then, the given mid can be a possible answer.\\n        return ct >= p;\\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int st = 0, end = 1e9, mid, res;\\n        while(st <= end){\\n            mid = st + (end-st)/2;\\n            //checking if \\'mid\\' can be a possible answer.\\n            if(helper(mid, nums, p)){\\n                // if \\'mid\\' can be a answer, store it and try to minimize if possible.\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else st = mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9fba1fae-6755-46d2-9527-49930fd0f355_1681133595.7701724.png)\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(int mid, vector<int>& nums, int p){\\n        int ct = 0;\\n        // helper function counts how many pairs are possible with the following \\'mid\\',\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i]-nums[i-1] <= mid){\\n                ct++;\\n                i++;\\n            }\\n        }\\n        // if count of pairs is more than \\'p\\', then, the given mid can be a possible answer.\\n        return ct >= p;\\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int st = 0, end = 1e9, mid, res;\\n        while(st <= end){\\n            mid = st + (end-st)/2;\\n            //checking if \\'mid\\' can be a possible answer.\\n            if(helper(mid, nums, p)){\\n                // if \\'mid\\' can be a answer, store it and try to minimize if possible.\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else st = mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396104,
                "title": "great-contest-on-my-birthday",
                "content": "# Explanation:\\nFirst we don\\'t care the original order of `A[i]`,\\nwe want to compare the difference,\\nso we sort them.\\n\\nThe result is in range of `0 (lo)` and `A[n - 1] - A[0] (hi)`\\nIn each iteration of search,\\nwe assume the minimum maximum difference is `mid = lo + (hi - lo) / 2`, then we check if we can have `p` pairs.\\n\\nWe take pairs (`A[i], A[i - 1]`) greedily if `A[i] - A[i - 1] <= mid`.\\nIf we take this pair, we move to next availble pair (`A[i + 2], A[i + 1]`)\\nIf not, we move to next availble pair (`A[i + 1], A[i]`)\\n\\nIn the end of each iteration,\\nwe check if we can have `p` pairs.\\nIf so, `mid` is big enough, `right = mid - 1`, by saving this `mid` (potential answer)\\nIf not, mid is too small, `left = mid + 1`.\\n\\nFinally we return the the answer whatever is left in our hands at the end.\\n\\n\\xA9 **[lee215](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3395750/java-c-python-binary-search/?orderBy=most_votes)**\\n\\n---\\n\\n# Code:\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums); \\n        int n = nums.length;\\n        int lo = 0, hi = nums[n - 1] - nums[0]; \\n        int ans = 0;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;  \\n            int possiblePairs = check(nums, mid);\\n            if (possiblePairs >= p) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1; \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int check(int[] nums, int n) {\\n        int count = 0; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - nums[i - 1] <= n) {\\n                count++; i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n### Time complexity: $$O(n.logn) + O(n.log(max - min))$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums); \\n        int n = nums.length;\\n        int lo = 0, hi = nums[n - 1] - nums[0]; \\n        int ans = 0;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;  \\n            int possiblePairs = check(nums, mid);\\n            if (possiblePairs >= p) {\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1; \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int check(int[] nums, int n) {\\n        int count = 0; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - nums[i - 1] <= n) {\\n                count++; i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395769,
                "title": "sort-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int p) {\\n        int cnt = 0, n = nums.size();\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i + 1] - nums[i] <= x) cnt++, i++;\\n        }\\n        return cnt >= p;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int s = 0, e = 1e9, ans;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, p)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int p) {\\n        int cnt = 0, n = nums.size();\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i + 1] - nums[i] <= x) cnt++, i++;\\n        }\\n        return cnt >= p;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int s = 0, e = 1e9, ans;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, p)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884061,
                "title": "rust-python-go-binary-search-greedy",
                "content": "**Intuition** \\uD83E\\uDD14\\n\\nImagine you\\'re trying to pair up dancers based on their height difference. You wouldn\\'t want a towering 6-foot tall dancer paired with someone who\\'s 4-foot tall, would you? That\\'d make for a pretty awkward waltz. Our problem is essentially a refined version of this scenario. We\\'re trying to make pairs with the smallest possible height (or in our case, number) difference. \\n\\n---\\n\\n**Approach** \\uD83D\\uDE80\\n\\nAlright, here\\'s where our trio of languages come to shine:\\n\\n\\uD83E\\uDD80 Rust: \"Alright team, before we embark on this dance of numbers, let\\'s get our act together and sort our dancers (numbers). That way, we\\'ll have a clearer view of the dance floor. But, here\\'s the twist: we\\'re not going to pair them up randomly. We\\'re going to be smart and use a binary search to find the best maximum height difference. Think of it as matchmaking, but with precision!\"\\n\\n\\uD83D\\uDC39 Go: \"You\\'ve hit the nail on the head, Rust! Sorting does give us clarity. But, I have another trick up my sleeve. Instead of simply dancing away, let\\'s see if we can form pairs with a specific difference. And if we can, well, why not aim for an even smaller difference? It\\'s like trying to find the perfect dance partner \\u2013 you want your moves to be in sync!\"\\n\\n\\uD83D\\uDC0D Python: \"Ah, both of you have such enlightening ideas! I\\'ve always believed in harmonious partnerships. We\\'ll first line up our dancers by height, ensuring we see everyone. Then, while the music plays, we\\'ll perform a binary search over the potential height differences. If we can get the required pairs dancing harmoniously with a given difference, it\\'s a sign! We might be shooting for the stars when the moon is just as beautiful. Aim lower, and let\\'s find that perfect dance rhythm!\"\\n\\n---\\n\\n**Complexity** \\uD83E\\uDDEE\\n\\n- **Time complexity:** $$O(n \\\\log n)$$\\n  *Why? Sorting takes $$O(n \\\\log n)$$ and our binary search approach takes $$O(n)$$. So, in total, it\\'s $$O(n \\\\log n)$$.*\\n\\n- **Space complexity:** $$O(1)$$\\n  *We\\'re not using any extra significant space here. Just a couple of variables. So, it\\'s constant space!*\\n\\n---\\n\\n**Code** \\uD83D\\uDCDC\\n\\n```rust\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\\n\\n# Code\\n``` Rust []\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\\n``` Go []\\nfunc minimizeMax(nums []int, p int) int {\\n\\tsort.Ints(nums)\\n\\t\\n\\tleft, right := 0, nums[len(nums)-1] - nums[0]\\n\\t\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif canFormPairs(nums, mid, p) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn left\\n}\\n\\nfunc canFormPairs(nums []int, mid int, p int) bool {\\n\\tcount := 0\\n\\tfor i := 0; i < len(nums) - 1 && count < p; {\\n\\t\\tif nums[i+1] - nums[i] <= mid {\\n\\t\\t\\tcount++\\n\\t\\t\\ti += 2\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn count >= p\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n\\n        def can_form_pairs(mid): \\n            count = 0 \\n            i = 0 \\n            while i < len(nums) - 1 and count < p: \\n                if nums[i+1] - nums[i] <= mid: \\n                    count += 1 \\n                    i += 2 \\n                else: \\n                    i += 1 \\n            return count == p \\n\\n        nums.sort() \\n        low, high = 0, nums[-1] - nums[0] \\n\\n        while low < high: \\n            mid = (low + high) // 2 \\n            if can_form_pairs(mid): \\n                high = mid \\n            else: \\n                low = mid + 1 \\n\\n        return low \\n\\n```\\n\\nAnd there you have it! A dance of numbers, brought to you by our favorite coding mascots: Rust\\'s Ferris \\uD83E\\uDD80, Go\\'s Gopher \\uD83D\\uDC39, and Python\\'s... well, Python \\uD83D\\uDC0D. Remember, it\\'s not about how fast you solve it; it\\'s about understanding the rhythm! \\uD83C\\uDFB6\\uD83D\\uDD7A\\uD83D\\uDC83\\uD83C\\uDFB6\\n",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n        \\n        let mut left = 0;\\n        let mut right = nums[nums.len() - 1] - nums[0];\\n        \\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if Solution::can_form_pairs(&nums, mid, p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        left\\n    }\\n\\n    fn can_form_pairs(nums: &Vec<i32>, mid: i32, p: i32) -> bool {\\n        let mut count = 0;\\n        let mut i = 0;\\n        while i < nums.len() - 1 && count < p {\\n            if nums[i+1] - nums[i] <= mid {\\n                count += 1;\\n                i += 2;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        count >= p\\n    }\\n}\\n```\n``` Go []\\nfunc minimizeMax(nums []int, p int) int {\\n\\tsort.Ints(nums)\\n\\t\\n\\tleft, right := 0, nums[len(nums)-1] - nums[0]\\n\\t\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif canFormPairs(nums, mid, p) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn left\\n}\\n\\nfunc canFormPairs(nums []int, mid int, p int) bool {\\n\\tcount := 0\\n\\tfor i := 0; i < len(nums) - 1 && count < p; {\\n\\t\\tif nums[i+1] - nums[i] <= mid {\\n\\t\\t\\tcount++\\n\\t\\t\\ti += 2\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn count >= p\\n}\\n```\n``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n\\n        def can_form_pairs(mid): \\n            count = 0 \\n            i = 0 \\n            while i < len(nums) - 1 and count < p: \\n                if nums[i+1] - nums[i] <= mid: \\n                    count += 1 \\n                    i += 2 \\n                else: \\n                    i += 1 \\n            return count == p \\n\\n        nums.sort() \\n        low, high = 0, nums[-1] - nums[0] \\n\\n        while low < high: \\n            mid = (low + high) // 2 \\n            if can_form_pairs(mid): \\n                high = mid \\n            else: \\n                low = mid + 1 \\n\\n        return low \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402006,
                "title": "python-3-13-lines-bisect-left-w-example-t-m-96-100",
                "content": "```\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n\\n        def pairCtr(mx: int) -> int:                        # Example: nums = [10,1,2,7,1,3]  p = 2\\n            cnt, idx = 0,1\\n            while idx < n:                                  #     nums.sort(): [1,1,2,3,7,10]\\n                if nums[idx] - nums[idx - 1] <= mx:\\n                    cnt+= 1                                 #            arr = sorted({1-1,2-1,3-2,7-3,10-7})\\n                    idx+= 1                                 #                = sorted({0,1,4,3})\\n                idx+= 1                                     #                = [0, 1, 3,4]\\n            return cnt                                      #                      |\\n                                                            #      arr[bisect_left(arr, p, key = pairCtr)]\\n\\n        if p == 0: return 0\\n\\n        n = len(nums)\\n        nums.sort()\\n        arr = sorted({nums[i] - nums[i - 1] for i in range(1, n)})\\n\\n        return arr[bisect_left(arr, p, key = pairCtr)]\\n```\\n[https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/submissions/931505153/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n\\n        def pairCtr(mx: int) -> int:                        # Example: nums = [10,1,2,7,1,3]  p = 2\\n            cnt, idx = 0,1\\n            while idx < n:                                  #     nums.sort(): [1,1,2,3,7,10]\\n                if nums[idx] - nums[idx - 1] <= mx:\\n                    cnt+= 1                                 #            arr = sorted({1-1,2-1,3-2,7-3,10-7})\\n                    idx+= 1                                 #                = sorted({0,1,4,3})\\n                idx+= 1                                     #                = [0, 1, 3,4]\\n            return cnt                                      #                      |\\n                                                            #      arr[bisect_left(arr, p, key = pairCtr)]\\n\\n        if p == 0: return 0\\n\\n        n = len(nums)\\n        nums.sort()\\n        arr = sorted({nums[i] - nums[i - 1] for i in range(1, n)})\\n\\n        return arr[bisect_left(arr, p, key = pairCtr)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885909,
                "title": "fastest-python-491ms-100-non-binary-search-plz-upvote",
                "content": "# Intuition\\nUncomment the print statements to get some idea what\\'s happening in the code.\\n\\n# Complexity\\n- Time complexity:\\nSorting: O(nlogn)\\nOther: O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        if p == 0: return 0\\n\\n        nums.sort()\\n        # print(\"sorted numbers:\")\\n        # print(nums)\\n        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]\\n        # print(\"difference between each adjcent pairs\")\\n        # print(pairs)\\n        pairs.sort()\\n        # print(\"differences sorted, with their original position\")\\n        # print(pairs)\\n\\n        m = [0]*len(nums)\\n        for i, (d,loc) in enumerate(pairs):\\n            l, r = m[loc-1], m[loc+1]\\n            m[loc] = m[loc-l] = m[loc+r] = l+r+1\\n            p -= 1&~(l|r)\\n            # print(\"\\\\n\",m)\\n            # print(\"diff:\", d,\"loc:\", loc, \"length of left:\", l, \"length of right:\" ,r)\\n            # print(\"remaining pairs:\", p)\\n            if p == 0: return d\\n\\n```\\n\\n## With Edge Case Optimization\\n``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        if p == 0: return 0\\n\\n        nums.sort()\\n        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]\\n        pairs.sort()\\n\\n        # edge case optimization 1 --- copied from some other solution\\n        if len(nums) == 2*p:\\n            (d,i) = pairs.pop()\\n            while (i&1):\\n                (d,i) = pairs.pop()\\n            return d\\n                \\n        # edge case optimization 2 --- copied from some other solution\\n        dictmin = pairs[p-1][0]\\n        dictmax = pairs[2*p-2][0]\\n        if (dictmin == dictmax):\\n            return dictmin\\n\\n        m = [0]*len(nums)\\n        for i, (d,loc) in enumerate(pairs):\\n            l, r = m[loc-1], m[loc+1]\\n            m[loc] = m[loc-l] = m[loc+r] = l+r+1\\n            p -= 1&~(l|r)\\n            if p == 0: return d\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        if p == 0: return 0\\n\\n        nums.sort()\\n        # print(\"sorted numbers:\")\\n        # print(nums)\\n        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]\\n        # print(\"difference between each adjcent pairs\")\\n        # print(pairs)\\n        pairs.sort()\\n        # print(\"differences sorted, with their original position\")\\n        # print(pairs)\\n\\n        m = [0]*len(nums)\\n        for i, (d,loc) in enumerate(pairs):\\n            l, r = m[loc-1], m[loc+1]\\n            m[loc] = m[loc-l] = m[loc+r] = l+r+1\\n            p -= 1&~(l|r)\\n            # print(\"\\\\n\",m)\\n            # print(\"diff:\", d,\"loc:\", loc, \"length of left:\", l, \"length of right:\" ,r)\\n            # print(\"remaining pairs:\", p)\\n            if p == 0: return d\\n\\n```\n``` Python []\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        if p == 0: return 0\\n\\n        nums.sort()\\n        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]\\n        pairs.sort()\\n\\n        # edge case optimization 1 --- copied from some other solution\\n        if len(nums) == 2*p:\\n            (d,i) = pairs.pop()\\n            while (i&1):\\n                (d,i) = pairs.pop()\\n            return d\\n                \\n        # edge case optimization 2 --- copied from some other solution\\n        dictmin = pairs[p-1][0]\\n        dictmax = pairs[2*p-2][0]\\n        if (dictmin == dictmax):\\n            return dictmin\\n\\n        m = [0]*len(nums)\\n        for i, (d,loc) in enumerate(pairs):\\n            l, r = m[loc-1], m[loc+1]\\n            m[loc] = m[loc-l] = m[loc+r] = l+r+1\\n            p -= 1&~(l|r)\\n            if p == 0: return d\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884263,
                "title": "binary-search-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/kvEVrnNuIUc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minimizeMax(int[] A, int p) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int l = 0;\\n        int r = A[n-1]-A[0];\\n        int mid;\\n        while(l<r){\\n            mid = (l+r)/2;\\n            if(helper(A, mid, p)>=p) r = mid;\\n            else l = mid +1;\\n        }\\n        return l;\\n    }\\n    \\n    public int helper(int [] A, int diff, int p){\\n        int i = 1; int count = 0;\\n        while(i<A.length){\\n            if(A[i]-A[i-1]<=diff){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& A, int p) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int l = 0;\\n        int r = A[n - 1] - A[0];\\n        int mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (helper(A, mid, p) >= p) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int helper(vector<int>& A, int diff, int p) {\\n        int i = 1, count = 0;\\n        while (i < A.size()) {\\n            if (A[i] - A[i - 1] <= diff) {\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        n = len(A)\\n        A.sort()\\n        l, r = 0, A[n - 1] - A[0]\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.helper(A, mid, p) >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n    \\n    def helper(self, A: List[int], diff: int, p: int) -> int:\\n        i, count = 1, 0\\n        while i < len(A):\\n            if A[i] - A[i - 1] <= diff:\\n                i += 1\\n                count += 1\\n            i += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] A, int p) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int l = 0;\\n        int r = A[n-1]-A[0];\\n        int mid;\\n        while(l<r){\\n            mid = (l+r)/2;\\n            if(helper(A, mid, p)>=p) r = mid;\\n            else l = mid +1;\\n        }\\n        return l;\\n    }\\n    \\n    public int helper(int [] A, int diff, int p){\\n        int i = 1; int count = 0;\\n        while(i<A.length){\\n            if(A[i]-A[i-1]<=diff){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& A, int p) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int l = 0;\\n        int r = A[n - 1] - A[0];\\n        int mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (helper(A, mid, p) >= p) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int helper(vector<int>& A, int diff, int p) {\\n        int i = 1, count = 0;\\n        while (i < A.size()) {\\n            if (A[i] - A[i - 1] <= diff) {\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        n = len(A)\\n        A.sort()\\n        l, r = 0, A[n - 1] - A[0]\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.helper(A, mid, p) >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n    \\n    def helper(self, A: List[int], diff: int, p: int) -> int:\\n        i, count = 1, 0\\n        while i < len(A):\\n            if A[i] - A[i - 1] <= diff:\\n                i += 1\\n                count += 1\\n            i += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397556,
                "title": "easy-and-intuitive-to-understand-logic-building-binary-search-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first this problem seems hard to break down. Although it is easy to notice that we need to approach the problem by sorting the given array first to increase our likelyhood of getting the correct answer. \\n\\nNext thing to notice here would be to see that if it is possible to get an answer = x then it is also definitely possible to get answer >= x due to the min max nature of the problem. So we could apply binary search on the answer. Call it mid.\\n\\nHaving stated that it is still tricky to notice on how we will go left or right in our binary search.  In such situations it is helpful to think of the deciding parameters in the problem. One such deciding paramter is \\'p\\' which is the number of pairs of indices we are trying to achieve our answer for. \\n\\nSo now we have the deciding parameter but then how to relate between the deciding parameter and the answer we are binary searching on? If we can somehow do that then our problem is solved.\\n\\nOne way to relate them is to notice that we want the maximum number of pairs from our sorted array such that the difference of 2 adjacent indices should remain less than or equal to the current value of the answer in our binary search algorithm.\\n\\nSo if by some mechanism(read below) we are able to find out these maximum amount of pairs then we can compare it with given \\'p\\' our deciding parameter. If its greater than \\'p\\' then there is still scope of improvement of our answer so we go left else if its less than p than the answer definitely lies on the greater side of things.\\n\\nLets discuss this mechanism now:\\nWe make an auxilliary array b which will either contain 0\\'s or 1\\'s. Now\\nb[i] will be 1(because its possible to pick this pair) if a[i]-a[i-1] <= mid else its 0.(because its not possible to pick this pair)\\n\\nSo this problem reduces to an array of 0\\'s and 1\\'s such that we are not allowed to pick adjacent elements from the array and we want to maximize the sum. This is the same as https://leetcode.com/problems/house-robber/description/ !! Which is an easy dp problem.\\n\\nA space optimized solution to above problem is:\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n        int n = (int)a.size();\\n        int dp[3];\\n        dp[0]=a[0];\\n        for(int i=1;i<n;++i){\\n            if(i>1)\\n                dp[i%3]=max(dp[(i-1)%3],dp[(i-2)%3]+a[i]);\\n            else{\\n                dp[1]=max(a[1],dp[0]);\\n            }\\n        }\\n        return dp[(n-1)%3];\\n    }\\n};\\n\\n```\\n\\n\\nWhy are we not allowed to pick adjacent elements?\\nConsider:\\n\\n{a1,a2,a3,a4}->{b1,b2,b3} \\nwhere \\n  b1 = a2 - a1 <= mid ? 1 : 0\\n  b2 = a3 - a2 <= mid ? 1 : 0\\n  b3 = a4 - a3 <=mid ? 1 : 0\\npicking b1 and b2 both would mean that we are picking index 2 twice from a which is not allowed. Therefore we cannot pick adjacent indices.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search on the answer and do a dp inside similiar to House-Robber: 1.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& a, int p) {\\n        int n = (int)a.size();\\n       \\n       sort(a.begin(), a.end());\\n\\n       if(p==0)\\n        return 0;\\n\\n       int l=0, r=1e9;\\n\\n       int ans;\\n\\n       while(l<=r){\\n           int mid = (l+r)/2;\\n           //can we get answer<=mid\\n\\n           vector<int> b;\\n           for(int i=1;i<n;i++){\\n               if(a[i]-a[i-1]<=mid)\\n                b.push_back(1);\\n               else\\n                b.push_back(0);\\n           }\\n           int nb = (int)b.size();\\n\\n            vector<int> dp(nb);\\n            dp[0]=b[0];\\n\\n            for(int i=1;i<nb;i++){\\n                if(i>1)\\n                    dp[i]=max(dp[i-2]+b[i], dp[i-1]);\\n                else{\\n                    dp[1]=max(dp[0],b[1]);\\n                }\\n            }\\n            if(dp[nb-1]>=p){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n       }\\n       return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n        int n = (int)a.size();\\n        int dp[3];\\n        dp[0]=a[0];\\n        for(int i=1;i<n;++i){\\n            if(i>1)\\n                dp[i%3]=max(dp[(i-1)%3],dp[(i-2)%3]+a[i]);\\n            else{\\n                dp[1]=max(a[1],dp[0]);\\n            }\\n        }\\n        return dp[(n-1)%3];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& a, int p) {\\n        int n = (int)a.size();\\n       \\n       sort(a.begin(), a.end());\\n\\n       if(p==0)\\n        return 0;\\n\\n       int l=0, r=1e9;\\n\\n       int ans;\\n\\n       while(l<=r){\\n           int mid = (l+r)/2;\\n           //can we get answer<=mid\\n\\n           vector<int> b;\\n           for(int i=1;i<n;i++){\\n               if(a[i]-a[i-1]<=mid)\\n                b.push_back(1);\\n               else\\n                b.push_back(0);\\n           }\\n           int nb = (int)b.size();\\n\\n            vector<int> dp(nb);\\n            dp[0]=b[0];\\n\\n            for(int i=1;i<nb;i++){\\n                if(i>1)\\n                    dp[i]=max(dp[i-2]+b[i], dp[i-1]);\\n                else{\\n                    dp[1]=max(dp[0],b[1]);\\n                }\\n            }\\n            if(dp[nb-1]>=p){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n       }\\n       return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395760,
                "title": "greedy-works-binary-search-simple-and-short-c-my-idea-of-why-it-works",
                "content": "This is one of those problems that I send without 100% certainty expecting an AC, in fact I solved it 20m after Q4 and it\\'s because even though I had the intuition that it should be solved in a greedy way the at least 3 ways I thought were not convincing but here is the one that get AC.\\n# Intuition\\nSince we need to get the minimum maximum which is a common job for binary search , so we directly search for the answer. \\n\\n# Approach\\nAssuming we know binary search, we first define a binary search on the answer, i.e. the maximum difference, we know that we need a function $f(x)$ that tells us if it is possible to form at least $p$ pairs with maximum difference $x$ , and this function is defined by a greedy algorithm\\n\\nWe sort the array and go from left to right, the intuition here is to try to form a pair with the current index and the greedy is that choosing the next one to the right is optimal (recall that the array is sorted).\\n\\n### Why do I think this works? \\nIf we have the array sorted for some index $i$ the best pair we can form is $({i-1,i})$ or $({i,i+1})$ since they will have the smallest differences so if we go in one direction ,(from left to right) if the pair $({i-1, i})$ is possible then the $i-1$ index will have already formed it and there is no need to worry about the current $i$ so the only option if the $i$ index does not yet have a pair is to take the pair $(i,i+1)$ the difference is $arr[i+1]-arr[i] \\\\leq x$.\\n\\n### And why form other pairs not works\\nNow my first approach was for each index $i$ to take the maximum possible number whose difference does not pass $x$ but that fails for the first case:\\n$[1,1,2,3]$ If we try to check if the maximum difference $x =1$ is possible and try to form pairs with the maximum possible difference that will not work in this case.\\n\\nThe first pair will be $(0,2)$ and we see that in the middle we leave the index $1$ so we already take the two best options that will have that index $1$, leaving it with worst pairs or even no options (the pair $(1,3)$ is not valid) so we can say that forming pairs in this way potentially removes the best possible pairs pairs so this way is incorrect and by intuiton all ways in the middle (not exactly with maximum diference) will be fail in the same way.\\n \\n# Complexity\\n$O(n log(n))$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int x,vector<int> &v,int p){\\n        int n = v.size();\\n        for(int i = 0;i<n-1;i++){\\n            if(v[i+1]-v[i]<=x){\\n                i++;\\n                p--;\\n            }\\n        }\\n        \\n        if(p<=0)return true;\\n        return false;\\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        int l = -1,r = 1e9+7;\\n        \\n        sort(nums.begin(),nums.end());\\n        while(l+1<r){\\n            int m =(l+r)>>1;\\n            if(check(m,nums,p))r = m;\\n            else l = m;\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int x,vector<int> &v,int p){\\n        int n = v.size();\\n        for(int i = 0;i<n-1;i++){\\n            if(v[i+1]-v[i]<=x){\\n                i++;\\n                p--;\\n            }\\n        }\\n        \\n        if(p<=0)return true;\\n        return false;\\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        int l = -1,r = 1e9+7;\\n        \\n        sort(nums.begin(),nums.end());\\n        while(l+1<r){\\n            int m =(l+r)>>1;\\n            if(check(m,nums,p))r = m;\\n            else l = m;\\n            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886865,
                "title": "binary-search-easy-classic-approach",
                "content": "# Approach\\nFinding the minimum possible answer in the valid binary Search space.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n**PLEASE UPVOTE :)**\\n# Code\\n```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums, int p, int diff){\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int low = 0, high = nums[n-1] - nums[0], ans = high;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums, int p, int diff){\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int low = 0, high = nums[n-1] - nums[0], ans = high;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886464,
                "title": "easy-c-soluition-using-binary-search",
                "content": "\\n# Approach\\ncheck Function: This function takes the following parameters:\\n\\nnums: A reference to the input vector of integers.\\np: The maximum number of subarrays to divide into.\\nn: The size of the nums array.\\nmid: The current candidate value for the minimized maximum difference.\\nInside the function:\\n\\nInitialize two variables: in (to keep track if a subarray has already been started) and cnt (to count the number of subarrays formed).\\nIterate through the array from index 1 to n-1.\\nIf in is true (indicating a subarray has been started), reset in to false and skip to the next iteration.\\nIf the difference between the current element nums[i] and the previous element nums[i-1] is less than or equal to mid, start a new subarray by setting in to true and increment cnt.\\nReturn true (1) if cnt is greater than or equal to p, indicating that it\\'s possible to divide the array into at most p subarrays with a maximum difference of mid. Otherwise, return false (0).\\nminimizeMax Function: This function takes the following parameters:\\n\\nnums: A reference to the input vector of integers.\\np: The maximum number of subarrays to divide into.\\nInside the function:\\n\\nSort the nums array in ascending order.\\nInitialize variables low to 0 and high to the difference between the maximum and minimum values in the sorted nums array. This range represents the possible values for the minimized maximum difference.\\nEnter a binary search loop that continues as long as low is less than or equal to high.\\nCalculate the current candidate value for the minimized maximum difference as mid = low + (high - low) / 2.\\nUse the check function to determine if it\\'s possible to divide the array into at most p subarrays with a maximum difference of mid.\\nIf the check is successful, update the ans variable with the current candidate value, and narrow the search range by updating high to mid - 1.\\nIf the check is not successful, update low to mid + 1.\\nReturn the final value of ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint check(vector<int>& nums, int p,int n , int mid )\\n{\\n    int in  = 0;\\n    int cnt=0;\\n    for(int i =1; i<n;i++)\\n    {\\n        if(in)\\n        {\\n            in = 0;\\n            continue;\\n        }\\n        if(nums[i]-nums[i-1]<=mid)\\n        {\\n            in = 1;\\n            cnt++;\\n        }\\n    }\\n    return cnt>=p;\\n}\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int low =0;\\n        int ans=INT_MAX;\\n        int high= nums[n-1]-nums[0];\\n        // int mid = low + (high-low)/2;\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(check(nums,p, n, mid))\\n            {\\n                ans=mid;\\n                high= mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint check(vector<int>& nums, int p,int n , int mid )\\n{\\n    int in  = 0;\\n    int cnt=0;\\n    for(int i =1; i<n;i++)\\n    {\\n        if(in)\\n        {\\n            in = 0;\\n            continue;\\n        }\\n        if(nums[i]-nums[i-1]<=mid)\\n        {\\n            in = 1;\\n            cnt++;\\n        }\\n    }\\n    return cnt>=p;\\n}\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int low =0;\\n        int ans=INT_MAX;\\n        int high= nums[n-1]-nums[0];\\n        // int mid = low + (high-low)/2;\\n        while(low<=high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(check(nums,p, n, mid))\\n            {\\n                ans=mid;\\n                high= mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885721,
                "title": "my-100-fast-simple-short-bs-code",
                "content": "```\\n/**\\n * author: Ashif Akhtar\\n **/\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n#define all(x) (x).begin(),(x).end()\\n\\n\\nclass Solution {\\npublic:\\n\\tint minimizeMax(vector<int>& a, int p) {\\n\\t\\tsort(all(a));\\n\\t\\tint s = 0, e = 1e9;\\n\\t\\twhile (s <= e) {\\n\\t\\t\\tint mid = (s + e) / 2;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 1; i < a.size(); i++) {\\n\\t\\t\\t\\tif (a[i] - a[i - 1] <= mid) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count < p)s = mid + 1;\\n\\t\\t\\telse e = mid - 1;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * author: Ashif Akhtar\\n **/\\nconst static auto initialize = [] { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return nullptr; }();\\n#define all(x) (x).begin(),(x).end()\\n\\n\\nclass Solution {\\npublic:\\n\\tint minimizeMax(vector<int>& a, int p) {\\n\\t\\tsort(all(a));\\n\\t\\tint s = 0, e = 1e9;\\n\\t\\twhile (s <= e) {\\n\\t\\t\\tint mid = (s + e) / 2;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 1; i < a.size(); i++) {\\n\\t\\t\\t\\tif (a[i] - a[i - 1] <= mid) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count < p)s = mid + 1;\\n\\t\\t\\telse e = mid - 1;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3885136,
                "title": "java-solution-2-solutions-binary-search-dp-faster-than-95",
                "content": "# Binary Search\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int low=-1;\\n        int high=(nums[n-1]-nums[0]);\\n        while(low+1<high) {\\n            int mid=(low+high)/2;\\n            if(isGood(nums, p, mid)) {\\n                high=mid;\\n            }else {\\n                low=mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean isGood(int nums[], int p, int threshold) {\\n        int n=nums.length;\\n        int count=0;\\n        int i=0;\\n        while(i<n-1) {\\n            if(nums[i+1]-nums[i]<=threshold) {\\n                count++;\\n                i+=2;\\n                continue;\\n            }\\n            i++;\\n        }\\n        return count>=p;\\n    }\\n}\\n```\\n\\n# Dynamic Programming \\nGives Memory limit exceeded but solution is correct!\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p==0) return 0;\\n        \\n        Arrays.sort(nums);\\n        dp=new Integer[nums.length][p+1];\\n        return util(nums, 0, p);\\n    }\\n    private Integer dp[][];\\n    private int util(int arr[], int i, int p) {\\n        if(p==0) {\\n            return Integer.MIN_VALUE;\\n        }\\n\\n        if(i>=arr.length-1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n        if(dp[i][p]!=null) return dp[i][p];\\n\\n        return dp[i][p]=Math.min ( Math.max( Math.abs(arr[i+1]-arr[i]), util(arr, i+2, p-1) ), \\n                            util(arr, i+1, p) );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int low=-1;\\n        int high=(nums[n-1]-nums[0]);\\n        while(low+1<high) {\\n            int mid=(low+high)/2;\\n            if(isGood(nums, p, mid)) {\\n                high=mid;\\n            }else {\\n                low=mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean isGood(int nums[], int p, int threshold) {\\n        int n=nums.length;\\n        int count=0;\\n        int i=0;\\n        while(i<n-1) {\\n            if(nums[i+1]-nums[i]<=threshold) {\\n                count++;\\n                i+=2;\\n                continue;\\n            }\\n            i++;\\n        }\\n        return count>=p;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p==0) return 0;\\n        \\n        Arrays.sort(nums);\\n        dp=new Integer[nums.length][p+1];\\n        return util(nums, 0, p);\\n    }\\n    private Integer dp[][];\\n    private int util(int arr[], int i, int p) {\\n        if(p==0) {\\n            return Integer.MIN_VALUE;\\n        }\\n\\n        if(i>=arr.length-1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\n        if(dp[i][p]!=null) return dp[i][p];\\n\\n        return dp[i][p]=Math.min ( Math.max( Math.abs(arr[i+1]-arr[i]), util(arr, i+2, p-1) ), \\n                            util(arr, i+1, p) );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885098,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn this problem, we are supposed to find \\'p\\' pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Whenever we come accross a problem containing keywords like search for the \\'maximum difference\\' and then \\'minimize\\' it, all these keywords hint us towards a binary search approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The countPairs function counts pairs with differences less than or equal to the maximum difference.\\n- The minimizeMax function sorts the input array and performs binary search between the minimum and maximum possible differences.\\n- In each binary search iteration, the countPairs function is used to check if there are at least p pairs with differences within the current mid value.\\n- If true, the maximum difference can be reduced, so the right pointer is adjusted.\\n- If false, the maximum difference needs to be increased, so the left pointer is adjusted.\\n- The binary search continues until the left pointer is no longer less than or equal to the right pointer.\\n- The res variable stores the minimum value of the maximum difference that fulfills the condition.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log V), where \\'n\\' is the size of nums and V is the maximum value in nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\n    int countPairs(vector<int>& nums, int p, int diff){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                i++;\\n                p--;\\n            }\\n        }\\n        return p<=0;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int left=0,right=nums[n-1]-nums[0],res=0;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(countPairs(nums,p,mid)){\\n                res=mid;\\n                right=mid-1;\\n            } else {\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int countPairs(vector<int>& nums, int p, int diff){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                i++;\\n                p--;\\n            }\\n        }\\n        return p<=0;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int left=0,right=nums[n-1]-nums[0],res=0;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(countPairs(nums,p,mid)){\\n                res=mid;\\n                right=mid-1;\\n            } else {\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884200,
                "title": "c-solution-for-minimize-the-maximum-difference-of-pairs-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the minimum maximum difference among p pairs of indices in the given sorted array nums. We want to minimize this maximum difference by adjusting the threshold. To do this, the provided solution uses a binary search approach to find the smallest threshold that will allow us to form at least p valid pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used here involves a binary search on the range of possible thresholds. In each iteration of the binary search, the algorithm calculates the count of valid pairs that can be formed using the current threshold. If the count of valid pairs is greater than or equal to p, the binary search narrows the threshold range towards the left side. Otherwise, the threshold range is narrowed towards the right side. The binary search continues until the left pointer is less than the right pointer.\\n\\nInside the binary search loop, the algorithm uses a helper function CountValidPairs to determine the count of valid pairs that can be formed using the current threshold. The CountValidPairs function uses a greedy approach to iterate through the sorted array and find pairs with a difference less than or equal to the threshold.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search is O(log N), where N is the range of possible thresholds, which is the difference between the maximum and minimum values in the sorted array. The CountValidPairs function iterates through the sorted array once, which takes O(N) time. As a result, the overall time complexity of the solution is O(N log N), where N is the length of the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) since the algorithm uses only a constant amount of extra space for variables and pointers. The sorting operation performed on the input array doesn\\'t require additional space because it\\'s done in-place.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        int n = nums.Length;\\n        int left = 0, right = nums[n - 1] - nums[0];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (CountValidPairs(nums, mid) >= p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    private int CountValidPairs(int[] nums, int threshold) {\\n        int index = 0, count = 0;\\n        while (index < nums.Length - 1) {\\n            if (nums[index + 1] - nums[index] <= threshold) {\\n                count++;\\n                index++;\\n            }\\n            index++;\\n        }\\n        return count;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        int n = nums.Length;\\n        int left = 0, right = nums[n - 1] - nums[0];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (CountValidPairs(nums, mid) >= p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    private int CountValidPairs(int[] nums, int threshold) {\\n        int index = 0, count = 0;\\n        while (index < nums.Length - 1) {\\n            if (nums[index + 1] - nums[index] <= threshold) {\\n                count++;\\n                index++;\\n            }\\n            index++;\\n        }\\n        return count;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406626,
                "title": "ruby-solution-with-binary-search-100-100",
                "content": "# Intuition\\nIt\\'s easy to check if a maximum value is possible after sorting.  Use binary search to find the minimum maximum value that works.\\n\\n# Approach\\n1. Sort the numbers and create a new array of differences.\\n2. Using a binary search, find the smallest maximum that\\'s possible to achieve.\\n3. If you use one difference in the helper function, skip over the next (you can\\'t use the same number in multiple pairs).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$ -- $$O(n * log(n))$$ to sort, and also O(n) to check each of $$O(long(n))$$ possibilities in binary search.\\n\\n- Space complexity:\\n$$O(n)$$ for the differences array.\\n\\n# Code\\n```\\ndef minimize_max(nums, pairs)\\n    nums.sort!\\n    diffs = []\\n    (1...nums.length).each do |i|\\n        diffs << nums[i] - nums[i-1]\\n    end\\n\\n    (0..diffs.max).bsearch { |n| valid?(diffs, pairs, n) }\\nend\\n\\ndef valid?(diffs, pairs, n)\\n    i = 0\\n    while i < diffs.length && pairs > 0\\n        if diffs[i] <= n\\n            i += 2\\n            pairs -= 1\\n        else\\n            i += 1\\n        end\\n    end\\n    pairs == 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimize_max(nums, pairs)\\n    nums.sort!\\n    diffs = []\\n    (1...nums.length).each do |i|\\n        diffs << nums[i] - nums[i-1]\\n    end\\n\\n    (0..diffs.max).bsearch { |n| valid?(diffs, pairs, n) }\\nend\\n\\ndef valid?(diffs, pairs, n)\\n    i = 0\\n    while i < diffs.length && pairs > 0\\n        if diffs[i] <= n\\n            i += 2\\n            pairs -= 1\\n        else\\n            i += 1\\n        end\\n    end\\n    pairs == 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3395861,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        left=0\\n        right=nums[-1]-nums[0]\\n        while left<right:\\n            mid=(left+right)//2\\n            k=0\\n            i=1\\n            while i<n:\\n                if nums[i]-nums[i-1]<=mid:\\n                    k+=1\\n                    i+=1\\n\\n                i+=1\\n\\n\\n            if k>=p:\\n                right=mid\\n\\n            else:\\n                left=mid+1\\n\\n        return left                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        left=0\\n        right=nums[-1]-nums[0]\\n        while left<right:\\n            mid=(left+right)//2\\n            k=0\\n            i=1\\n            while i<n:\\n                if nums[i]-nums[i-1]<=mid:\\n                    k+=1\\n                    i+=1\\n\\n                i+=1\\n\\n\\n            if k>=p:\\n                right=mid\\n\\n            else:\\n                left=mid+1\\n\\n        return left                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000204,
                "title": "minimize-the-maximum-difference-of-pairs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int>& nums, int p, int diff){\\n\\n       int count = 0;\\n       int n = nums.size(); int i=0; int j=1;\\n\\n        while(j<n){\\n            if(nums[j]-nums[i] <= diff){\\n            count++; i+=2; j+=2;\\n            }\\n            else{\\n            i++; j++; continue;\\n            } \\n        }\\n       \\n        return count >= p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int n = nums.size();\\n        if(p==0) return 0;\\n\\n        sort(nums.begin(), nums.end());  \\n        int l = 0; int h = nums[n-1]-nums[0];\\n\\n        while(l<=h){\\n\\n            int mid = (l+h)/2;\\n\\n            if(check(nums,p,mid)==true){\\n                h=mid-1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int>& nums, int p, int diff){\\n\\n       int count = 0;\\n       int n = nums.size(); int i=0; int j=1;\\n\\n        while(j<n){\\n            if(nums[j]-nums[i] <= diff){\\n            count++; i+=2; j+=2;\\n            }\\n            else{\\n            i++; j++; continue;\\n            } \\n        }\\n       \\n        return count >= p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int n = nums.size();\\n        if(p==0) return 0;\\n\\n        sort(nums.begin(), nums.end());  \\n        int l = 0; int h = nums[n-1]-nums[0];\\n\\n        while(l<=h){\\n\\n            int mid = (l+h)/2;\\n\\n            if(check(nums,p,mid)==true){\\n                h=mid-1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887425,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# **INTUTION**\\n\\nI will explain you 2 things\\n\\n**1) How do we find, that  we need to apply binary search. in such questions**\\n\\n**2) How do we apply binary search**\\n\\n\\nAnswer 1) let the array be  [10,1,2,7,1,3]  and p = 2, Now if i ask you what is the **max difference you can find betwen two elements..**\\n\\nYou will **subtract the smallest element from the biggest element** ... => **POINT 1**\\n\\nNow, if  i ask you how could you calculate the **smallest differnnce for a particular no**...You would just sort the array....so the array would look like [1,1,2,3,7,10]...Now tell me what could be the smallest differnce be for say **\"3\"** , Now you will just subtract **(3-2)** or you will subtract **(7-3)**...Out of these 2 only..**.you can find the smallest difference...**\\n\\nIt means that for an element..we can **subtarct either the element on the left of it..or on the right of it..to form a pair...**\\n\\nSo, it means we **need to sort the array and sorting will direct us to binary search somehere**\\n\\n\\nNow, in **Point 1** , i asked you what is the max diffrence..so it was **biggest elment - smallest element** and what could be the smallest difference so it will be 0,\\n\\nNow we know that our ans could go fromv **0 to biggest elment - smallest element**....(JUST BEAR WITH ME)..\\n\\nNow , we see that** this is a sorted range and this leads to only 1 thing..that is binary search over this range**\\n\\nNow, if we just calculate that** how many pairs could be formed with a difference which is less then equal to mid**...If it is able to **form p pairs it means that mid could be a possible ans...**\\n\\nHow do we write this in code \\n\\n```\\n        sort(nums.begin(),nums.end());\\n        \\n        int s = 0;\\n        int e = nums[nums.size()-1] - nums[0];\\n        int ans = 0;\\n        \\n        while(s<=e)\\n        {\\n            \\n            int mid = s+ (e-s)/2;\\n            \\n            if(check(mid,p,nums)==true)\\n            {\\n                ans = mid;\\n\\t\\t\\t\\tDO SOMETHING SOMETHING\\n\\t\\t}\\n\\t\\t}\\n```\\n\\nNow, the element **mid which we selected**..if it is able to form **less then p pairs it means that our mid is too small** and we need to **increase it**..so how do we increase it, so that is easy..We will just do **start = mid+1**\\n\\nIf it is able to **form more then p pairs**..it means it could be a **possible ans** , so we will store it and **we will also try to reduce mid** ..because **we need to find minium so we will just do end = mid -1**\\n\\nNow, how do we check whether we are able to **form the pairs or not...**\\n\\nWe will just iterate through the array and **do nums[i]-nums[i-1**]..If this is less then the x, it means it could be a pair , so we will just **decrement the count of p and also increase the value of i by 1**, **because we can\\'t select the same index in 2 pairs...**\\n\\nCode for this ..\\n\\n```\\n   bool check(int diff,int p,vector<int>& nums)\\n    {\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]-nums[i-1]<=diff)\\n            {\\n                p--;\\n                i++;\\n            }\\n        }\\n        \\n        if(p<=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n```\\n\\nThis is how we approach such questions\\n\\n# TIME COMPLEXITY\\n\\nWe just used binary search here, so it will be **O(LOGN)**\\n\\n# CODE\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int diff,int p,vector<int>& nums)\\n    {\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]-nums[i-1]<=diff)\\n            {\\n                p--;\\n                i++;\\n            }\\n        }\\n        \\n        if(p<=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n \\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int s = 0;\\n        int e = nums[nums.size()-1] - nums[0];\\n        int ans = 0;\\n        \\n        while(s<=e)\\n        {\\n            \\n            int mid = s+ (e-s)/2;\\n            \\n            if(check(mid,p,nums)==true)\\n            {\\n                ans = mid;\\n                e  = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }    \\n            \\n        }\\n        return ans;\\n              \\n    }\\n};\\n\\n\\n```\\n**TIME FOR A MEME NOW**\\n\\n![image](https://assets.leetcode.com/users/images/2a098495-07e9-4ea6-ac41-a51256f4a12b_1691603596.370973.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE..**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n        sort(nums.begin(),nums.end());\\n        \\n        int s = 0;\\n        int e = nums[nums.size()-1] - nums[0];\\n        int ans = 0;\\n        \\n        while(s<=e)\\n        {\\n            \\n            int mid = s+ (e-s)/2;\\n            \\n            if(check(mid,p,nums)==true)\\n            {\\n                ans = mid;\\n\\t\\t\\t\\tDO SOMETHING SOMETHING\\n\\t\\t}\\n\\t\\t}\\n```\n```\\n   bool check(int diff,int p,vector<int>& nums)\\n    {\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]-nums[i-1]<=diff)\\n            {\\n                p--;\\n                i++;\\n            }\\n        }\\n        \\n        if(p<=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int diff,int p,vector<int>& nums)\\n    {\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]-nums[i-1]<=diff)\\n            {\\n                p--;\\n                i++;\\n            }\\n        }\\n        \\n        if(p<=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n \\n    }\\n    \\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int s = 0;\\n        int e = nums[nums.size()-1] - nums[0];\\n        int ans = 0;\\n        \\n        while(s<=e)\\n        {\\n            \\n            int mid = s+ (e-s)/2;\\n            \\n            if(check(mid,p,nums)==true)\\n            {\\n                ans = mid;\\n                e  = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }    \\n            \\n        }\\n        return ans;\\n              \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887108,
                "title": "2d-dp-and-3d-dp-soluction",
                "content": "3D Dp :\\nPossible state of answer will be O((n^2)*n/2) and among them which one satisfy condition more effectively will be return.\\n```\\n```class Solution {\\nprivate:\\n    int sub( vector<vector<vector<int>>>&dp,vector<int>&nums,int index,int p,int last){\\n        if(p==0)return 0;\\n        if(index==nums.size())return 1e9;\\n        if(dp[index][last+1][p]!=-1)return dp[index][last+1][p];\\n        int notpick=sub(dp,nums,index+1,p,last);\\n        int pick=0;\\n        if(last==-1){\\n            pick=sub(dp,nums,index+1,p,index);\\n        }else{\\n            pick=max(abs(nums[index]-nums[last]),sub(dp,nums,index+1,p-1,-1));\\n        }\\n        return dp[index][last+1][p]=min(pick,notpick);\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n+1,vector<int>(p+1,-1)));\\n        return sub(dp,nums,0,p,-1);\\n    }\\n};\\n\\n```\\n2D Dp  : \\nPossible state of answer will be O(n*(n/2)) and among them which one satisfy condition more effectively will be return.\\n```\\nclass Solution {\\nprivate:\\n    int sub( vector<vector<int>>&dp,vector<int>&nums,int index,int p){\\n        if(p==0)return 0;\\n        if(index+1>=nums.size())return 1e9;\\n        if(dp[index][p]!=-1)return dp[index][p];\\n        int notpick=sub(dp,nums,index+1,p);\\n        int pick=max(abs(nums[index]-nums[index+1]),sub(dp,nums,index+2,p-1));\\n        return dp[index][p]=min(pick,notpick);\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>dp(n,vector<int>(p+1,-1));\\n        return sub(dp,nums,0,p);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/136c3711-b206-441f-ad94-ae30e446c974_1691599261.365217.jpeg)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n2D Dp  : \\nPossible state of answer will be O(n*(n/2)) and among them which one satisfy condition more effectively will be return.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886782,
                "title": "beats-90-using-sorting-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, nums[n - 1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            j, i = 0, 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= mid:\\n                    j += 1\\n                    i += 1\\n                i += 1\\n            if j >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, nums[n - 1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            j, i = 0, 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= mid:\\n                    j += 1\\n                    i += 1\\n                i += 1\\n            if j >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884772,
                "title": "simple-and-easy-code-java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int low=0;\\n        int high=nums[nums.length-1]-nums[0];\\n        int ans=Integer.MAX_VALUE;\\n        while(low<=high){\\n            int mid= low +(high-low)/2;\\n            if(solve(nums,p,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean solve(int nums[],int p,int mid){\\n        int st=0;\\n        int count=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(st!=0){\\n                st=0;\\n                continue;\\n            }\\n            if(nums[i]-nums[i-1]<=mid){\\n                count++;\\n                st=1;\\n            }\\n        }\\n        return count>=p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int low=0;\\n        int high=nums[nums.length-1]-nums[0];\\n        int ans=Integer.MAX_VALUE;\\n        while(low<=high){\\n            int mid= low +(high-low)/2;\\n            if(solve(nums,p,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean solve(int nums[],int p,int mid){\\n        int st=0;\\n        int count=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(st!=0){\\n                st=0;\\n                continue;\\n            }\\n            if(nums[i]-nums[i-1]<=mid){\\n                count++;\\n                st=1;\\n            }\\n        }\\n        return count>=p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884728,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n\\n    int check(int x) {\\n        int i = 1, cnt = 0;\\n        while (i < num.size()) {\\n            if (num[i] - num[i - 1] <= x) {\\n                cnt++;\\n                i++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        num = nums;\\n        int n = num.size();\\n        int l = 0, r = num[n - 1];\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid) < p) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n\\n    int check(int x) {\\n        int i = 1, cnt = 0;\\n        while (i < num.size()) {\\n            if (num[i] - num[i - 1] <= x) {\\n                cnt++;\\n                i++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        num = nums;\\n        int n = num.size();\\n        int l = 0, r = num[n - 1];\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid) < p) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884553,
                "title": "java-14ms-binary-search",
                "content": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if (p == 0)  return 0;\\n        if (nums.length <= 2)  return Math.abs(nums[0] - nums[1]);\\n        Arrays.sort(nums);\\n        int[] diffs = new int[nums.length - 1];\\n        int right = 0;\\n        int left  = 1_000_000_001;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            right = Math.max(right, (diffs[i] = nums[i + 1] - nums[i]));\\n            left  = Math.min(left,  diffs[i]);\\n        }\\n        if (left == right)  return left;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (isValid(mid, diffs, p)) \\n                right = mid;\\n            else \\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    \\n    private boolean isValid(int guess, int[] diffs, int p) {\\n        int count = p;\\n        for (int i = diffs.length - 1; i >= 0; i--) {\\n            if (diffs[i] <= guess) {\\n                if (--count <= 0)  return true;\\n                i--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if (p == 0)  return 0;\\n        if (nums.length <= 2)  return Math.abs(nums[0] - nums[1]);\\n        Arrays.sort(nums);\\n        int[] diffs = new int[nums.length - 1];\\n        int right = 0;\\n        int left  = 1_000_000_001;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            right = Math.max(right, (diffs[i] = nums[i + 1] - nums[i]));\\n            left  = Math.min(left,  diffs[i]);\\n        }\\n        if (left == right)  return left;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (isValid(mid, diffs, p)) \\n                right = mid;\\n            else \\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    \\n    private boolean isValid(int guess, int[] diffs, int p) {\\n        int count = p;\\n        for (int i = diffs.length - 1; i >= 0; i--) {\\n            if (diffs[i] <= guess) {\\n                if (--count <= 0)  return true;\\n                i--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884482,
                "title": "binary-search-c-classic-format",
                "content": "\\n# Complexity\\n- Time complexity:\\n    Let V be the maximum difference of pair then TC will be\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(Nlog(V))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& nums,int mid, int p){\\n        //this function is greedily choosing the pairs\\n        int idx=0;\\n        int count=0;\\n        while(idx<nums.size()-1){\\n            if(nums[idx+1]-nums[idx]<=mid){\\n                p--;\\n                idx+=2;//if conscecutive elements are a valid pair then increment index by 2\\n                if(p==0 ){\\n                    return true;\\n                }\\n            }\\n            else{\\n                idx+=1;//if conscecutive elements are a valid pair then increment index by 1\\n            }\\n        }\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int maxDiff=nums[nums.size()-1]-nums[0];//maximum difference which can exist\\n        int start=0;\\n        int end=maxDiff;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(valid(nums,mid,p))//if we have found a valid difference,then we try to find a smalller value(as we need to search for minimum)\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& nums,int mid, int p){\\n        //this function is greedily choosing the pairs\\n        int idx=0;\\n        int count=0;\\n        while(idx<nums.size()-1){\\n            if(nums[idx+1]-nums[idx]<=mid){\\n                p--;\\n                idx+=2;//if conscecutive elements are a valid pair then increment index by 2\\n                if(p==0 ){\\n                    return true;\\n                }\\n            }\\n            else{\\n                idx+=1;//if conscecutive elements are a valid pair then increment index by 1\\n            }\\n        }\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int maxDiff=nums[nums.size()-1]-nums[0];//maximum difference which can exist\\n        int start=0;\\n        int end=maxDiff;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(valid(nums,mid,p))//if we have found a valid difference,then we try to find a smalller value(as we need to search for minimum)\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884386,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n        auto go = [&](int x) {\\n            int cnt = 0;\\n            for (int i = 0; i + 1 < n; i++) {\\n                if (nums[i + 1] - nums[i] <= x) {\\n                    i += 1;\\n                    cnt += 1;\\n                }\\n            }\\n            return (cnt >= p);\\n        };\\n        int low = 0, high = nums.back() - nums[0];\\n        while (low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (go(mid)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n        auto go = [&](int x) {\\n            int cnt = 0;\\n            for (int i = 0; i + 1 < n; i++) {\\n                if (nums[i + 1] - nums[i] <= x) {\\n                    i += 1;\\n                    cnt += 1;\\n                }\\n            }\\n            return (cnt >= p);\\n        };\\n        int low = 0, high = nums.back() - nums[0];\\n        while (low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (go(mid)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884334,
                "title": "daily-coding-challenge-video-explanation-with-easy-java-solution-binary-search",
                "content": "# Video Explanation\\nhttps://youtu.be/UnyxPZtJH84\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        int result=0;\\n        Arrays.sort(nums);\\n        int low=0;\\n        int high=nums[nums.length-1]-nums[0];\\n\\n\\n        while(low <= high){\\n            int mid=(low+high)/2;\\n            int count =0;\\n             int i=1;\\n             while(i<nums.length){\\n                 if(nums[i]-nums[i-1]<=mid){\\n                     count++;\\n                     i=i+2;\\n                 }else{\\n                     i++;\\n                 }\\n             }\\n             if(count >=p){\\n                 result =mid;\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        int result=0;\\n        Arrays.sort(nums);\\n        int low=0;\\n        int high=nums[nums.length-1]-nums[0];\\n\\n\\n        while(low <= high){\\n            int mid=(low+high)/2;\\n            int count =0;\\n             int i=1;\\n             while(i<nums.length){\\n                 if(nums[i]-nums[i-1]<=mid){\\n                     count++;\\n                     i=i+2;\\n                 }else{\\n                     i++;\\n                 }\\n             }\\n             if(count >=p){\\n                 result =mid;\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884310,
                "title": "video-solution-c-java-2-optimizations-over-brute-force-dicussed-in-depth",
                "content": "# Intuition, approach and complexity discussed in detail in video solution\\nhttps://youtu.be/pb3FU2hu5O8\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n      return findMinMax(nums, p);\\n    }\\nprivate:\\n    int findMinMax(vector<int>& nums, int p){\\n        sort(nums.begin(), nums.end());\\n        int left = 0, right = 1e9; \\n        int minMaxD = INT_MAX;       \\n        while(left <= right){\\n            int maxDiff = left + (right - left) /2;\\n            if(isDiffPoss(nums, p, maxDiff)){\\n                minMaxD = maxDiff;\\n                right = maxDiff-1;\\n            }else{\\n                left = maxDiff + 1;\\n            }\\n        }\\n        return minMaxD;\\n    }\\n    bool isDiffPoss(vector<int> & nums, int p, int maxDiff){\\n         int sz = nums.size(), pCnt = 0, prevIndxInc = -1;\\n         for(int indx = 0; indx<sz-1; indx++){\\n            if(nums[indx+1] - nums[indx] <= maxDiff){\\n                indx++;\\n                pCnt++;\\n            }\\n         }\\n         return pCnt >= p; \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n         return findMinMax(nums, p);\\n    }\\n    private int findMinMax(int []nums, int p){\\n        Arrays.sort(nums);\\n        int left = 0, right = 1000000000; \\n        int minMaxD = Integer.MAX_VALUE;       \\n        while(left <= right){\\n            int maxDiff = left + (right - left) /2;\\n            if(isDiffPoss(nums, p, maxDiff)){\\n                minMaxD = maxDiff;\\n                right = maxDiff-1;\\n            }else{\\n                left = maxDiff + 1;\\n            }\\n        }\\n        return minMaxD;\\n    }\\n    private boolean isDiffPoss(int nums[], int p, int maxDiff){\\n         int sz = nums.length, pCnt = 0, prevIndxInc = -1;\\n         for(int indx = 0; indx<sz-1; indx++){\\n            if(nums[indx+1] - nums[indx] <= maxDiff){\\n                indx++;\\n                pCnt++;\\n            }\\n         }\\n         return pCnt >= p; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n      return findMinMax(nums, p);\\n    }\\nprivate:\\n    int findMinMax(vector<int>& nums, int p){\\n        sort(nums.begin(), nums.end());\\n        int left = 0, right = 1e9; \\n        int minMaxD = INT_MAX;       \\n        while(left <= right){\\n            int maxDiff = left + (right - left) /2;\\n            if(isDiffPoss(nums, p, maxDiff)){\\n                minMaxD = maxDiff;\\n                right = maxDiff-1;\\n            }else{\\n                left = maxDiff + 1;\\n            }\\n        }\\n        return minMaxD;\\n    }\\n    bool isDiffPoss(vector<int> & nums, int p, int maxDiff){\\n         int sz = nums.size(), pCnt = 0, prevIndxInc = -1;\\n         for(int indx = 0; indx<sz-1; indx++){\\n            if(nums[indx+1] - nums[indx] <= maxDiff){\\n                indx++;\\n                pCnt++;\\n            }\\n         }\\n         return pCnt >= p; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n         return findMinMax(nums, p);\\n    }\\n    private int findMinMax(int []nums, int p){\\n        Arrays.sort(nums);\\n        int left = 0, right = 1000000000; \\n        int minMaxD = Integer.MAX_VALUE;       \\n        while(left <= right){\\n            int maxDiff = left + (right - left) /2;\\n            if(isDiffPoss(nums, p, maxDiff)){\\n                minMaxD = maxDiff;\\n                right = maxDiff-1;\\n            }else{\\n                left = maxDiff + 1;\\n            }\\n        }\\n        return minMaxD;\\n    }\\n    private boolean isDiffPoss(int nums[], int p, int maxDiff){\\n         int sz = nums.length, pCnt = 0, prevIndxInc = -1;\\n         for(int indx = 0; indx<sz-1; indx++){\\n            if(nums[indx+1] - nums[indx] <= maxDiff){\\n                indx++;\\n                pCnt++;\\n            }\\n         }\\n         return pCnt >= p; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884064,
                "title": "simple-binary-search-solution-list-of-11-similar-very-imp-problems",
                "content": "## [List of 11 similar VERY IMP problems](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-11-similar-very-imp-binary-search-questions/)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimizing the maximum of anything always refer to binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Since we do not have do anything with the order of the numbers and binary search is a possible approach, so we sort the array. \\n- Also, we need to minimize the (maximum) difference between numbers which is possible when they are sorted.\\n- We define the search space with start as the minimum number of the array and end as the difference between the largest and the smallest number since the difference cannot be largere than their difference.\\n- For each mid value, we calculate how many pairs are possible. If p pairs are possible then mid is large enough and we move `end = mid` , else we move `start = mid+1`\\n- Instead of trying to explain why greedy works here, I would like to share this easy [explanation](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3395952/in-case-you-are-wondering-why-greedy-works-for-this-problem/) by XavierWantsMoreMoney. You all can check this out for better and easy understanding.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), start = 0, end = nums[n-1] - nums[0];\\n        while(start < end) {\\n            int mid = (start + end) / 2, k = 0;\\n            for(int i = 1; i<n && k<p; i++){\\n                if(nums[i] - nums[i-1] <= mid){\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if(k >= p)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), start = 0, end = nums[n-1] - nums[0];\\n        while(start < end) {\\n            int mid = (start + end) / 2, k = 0;\\n            for(int i = 1; i<n && k<p; i++){\\n                if(nums[i] - nums[i-1] <= mid){\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if(k >= p)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418416,
                "title": "95-faster-c-binary-search-sort-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int mn = 0, mx = nums[nums.size()-1]-nums[0],mid,cnt=0,i,n=nums.size(),ans;\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            cnt = 0;\\n            for(i = 0; i < n-1; i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            if(cnt>=p){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int mn = 0, mx = nums[nums.size()-1]-nums[0],mid,cnt=0,i,n=nums.size(),ans;\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            cnt = 0;\\n            for(i = 0; i < n-1; i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            if(cnt>=p){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402397,
                "title": "javascript-binary-search-solution-with-detailed-explanation",
                "content": "# Intuition\\nin an array [1 ,2 , 3, 4 , 5] for i = 2, which is 3, only the i and i-1 difference will be minimum. while comparing we can only compare ith and i -1th difference,so that first what we need is the array to be sorted.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsince, the array is sorted we can use binary search to find the min element, binary search space lies from 0 to nums[n] - nums[0], because since we are subtracting the number always lies from 0 to max element in an array, since we consider it as pairs it is nums[n] - nums[0].\\n\\nIn binary search we choose an element as mid and check p pairs, if a particular mid has p pairs,if the element has p pairs then that mid also one valid answer, since we try to minimize it, we need set high = mid; if the element is not a valid answer set low = mid +1 , mid+1 because we dont want mid to be searched again and mid is not a valid answer.\\n\\nreturn  low, which contains the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) => n(isValid function) * logn(binary search);\\n\\n- Space complexity:\\nO(logn) sorting space.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  if (p === 0) return 0;\\n  let n = nums.length - 1;\\n  nums.sort((a, b) => a - b);\\n  let low = 0,\\n    high = nums[n] - nums[0];\\n\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isValid(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n\\n  function isValid(max) {\\n    let i = 1,\\n      pairs = 0;\\n\\n    while (i <= n) {\\n      if (nums[i] - nums[i - 1] <= max) {\\n        pairs++;\\n        i = i + 2;\\n      } else {\\n        i++;\\n      }\\n      if (pairs == p) return true;\\n    }\\n    return false;\\n  }\\n};\\n```\\n\\nPlease like if you understand the problem.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  if (p === 0) return 0;\\n  let n = nums.length - 1;\\n  nums.sort((a, b) => a - b);\\n  let low = 0,\\n    high = nums[n] - nums[0];\\n\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isValid(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n\\n  function isValid(max) {\\n    let i = 1,\\n      pairs = 0;\\n\\n    while (i <= n) {\\n      if (nums[i] - nums[i - 1] <= max) {\\n        pairs++;\\n        i = i + 2;\\n      } else {\\n        i++;\\n      }\\n      if (pairs == p) return true;\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395912,
                "title": "binary-seach-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize differences we sort the array. Then we store all the diffrences in a vector(say x).\\nThen we know our ans is always between the min value and the max value of x hence binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array and store all the differences in another array, then we use binary search to look for optimal answer using this array. To check if a answer is viable we make sure we check if we can find \\'p\\' no. of NON_CONSECUTIVE elements in difference array which are less than the current binary search element.\\nWe need to take non-consecutive integers as if we take consecutive then we will repeat index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n//x is storing difference\\nclass Solution {\\npublic:\\n    bool check(vector<int>&x, int m, int p)\\n    {\\n//p is no. of pair req\\n        for(int i=0;i<x.size();i++)\\n        {\\n            if(x[i]<=m)\\n            {\\n                // we found a pair \\n                p--;\\n                //as we cant take consecutive indexes \\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& a, int p) \\n    {\\n        sort(a.begin(),a.end());\\n        vector<int>x;\\n\\n        // s and e are start and end of binary search\\n        int s=0,e=0;\\n        for(int i=1;i<a.size();i++)\\n        {\\n            x.push_back(a[i]-a[i-1]);\\n            e=max(e,x.back());\\n            //maximum value of ans can be the maximum difference we find\\n        }\\n        int ans =e;\\n        while(s<=e)\\n        {\\n            int m = (s+e)/2;\\n            if(check(x,m,p))\\n            {\\n                ans=m;\\n                e=m-1;\\n            }\\n            else\\n            {\\n                s=m+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//x is storing difference\\nclass Solution {\\npublic:\\n    bool check(vector<int>&x, int m, int p)\\n    {\\n//p is no. of pair req\\n        for(int i=0;i<x.size();i++)\\n        {\\n            if(x[i]<=m)\\n            {\\n                // we found a pair \\n                p--;\\n                //as we cant take consecutive indexes \\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& a, int p) \\n    {\\n        sort(a.begin(),a.end());\\n        vector<int>x;\\n\\n        // s and e are start and end of binary search\\n        int s=0,e=0;\\n        for(int i=1;i<a.size();i++)\\n        {\\n            x.push_back(a[i]-a[i-1]);\\n            e=max(e,x.back());\\n            //maximum value of ans can be the maximum difference we find\\n        }\\n        int ans =e;\\n        while(s<=e)\\n        {\\n            int m = (s+e)/2;\\n            if(check(x,m,p))\\n            {\\n                ans=m;\\n                e=m-1;\\n            }\\n            else\\n            {\\n                s=m+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975378,
                "title": "c-easy-binary-search-tc-o-nlogn-sc-o-1",
                "content": "# Intuition\\nLets take example 1 6 8 we need 1 pairs; so we won\\'t take 1-6 we will take 6-8\\nWe need to find the minimum difference in p pairs; We can go for Binary Search because here is uncertainity;\\n\\n# Approach\\n->The algorithm then counts adjacent pairs within \\'mid\\' distance and checks if the count \\'c\\' is greater than or equal to \\'p\\'. \\n->If true, it means we can aim for a smaller maximum difference, so the upper bound is adjusted. \\n->Otherwise, the lower bound is adjusted. This process continues until the bounds converge, and the lower bound \\'l\\' gives the desired minimized maximum difference.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n      int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int l=0;int u=nums[n-1]-nums[0];\\n\\n        while(l<=u)\\n        {\\n          int mid=(l+u)/2;\\n          int c=0;\\n\\n          for(int i=0;i<n-1 && c<p;i++)\\n          {\\n              if(abs(nums[i]-nums[i+1])<=mid)\\n              {\\n               c++;\\n               i++;\\n              }\\n          }\\n\\n          if(c>=p)\\n          u=mid-1;\\n          else\\n          l=mid+1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n      int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int l=0;int u=nums[n-1]-nums[0];\\n\\n        while(l<=u)\\n        {\\n          int mid=(l+u)/2;\\n          int c=0;\\n\\n          for(int i=0;i<n-1 && c<p;i++)\\n          {\\n              if(abs(nums[i]-nums[i+1])<=mid)\\n              {\\n               c++;\\n               i++;\\n              }\\n          }\\n\\n          if(c>=p)\\n          u=mid-1;\\n          else\\n          l=mid+1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888059,
                "title": "c-binary-search-o-n-log-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        // Sort the array as its required for binary search;\\n        sort(nums.begin(),nums.end());\\n        \\n        // taking low as 0;\\n        int low = 0;\\n        \\n        // taking high as a large prime number;\\n        int high = 1e9 + 7;\\n        \\n        \\n        while(low <= high){\\n            // choosing a mid which will act as maximum distance between elements;\\n            int mid = low + (high - low)/2;\\n            \\n            int pairs = 0;\\n            \\n            \\n            for(int i = 1 ; i < nums.size(); i++){\\n                // if the difference is within the mid then we cannot use these pairs again therefore an additional i++;\\n                if((nums[i] - nums[i - 1]) <= mid){\\n                    i++;\\n                    pairs++;\\n                }\\n                \\n            }\\n            \\n            // If the pairs is greater than required pairs then lower the mid else increase it; \\n            if(pairs >= p){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n            \\n        }\\n        \\n        // return the lowest maximum difference\\n        return low;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        // Sort the array as its required for binary search;\\n        sort(nums.begin(),nums.end());\\n        \\n        // taking low as 0;\\n        int low = 0;\\n        \\n        // taking high as a large prime number;\\n        int high = 1e9 + 7;\\n        \\n        \\n        while(low <= high){\\n            // choosing a mid which will act as maximum distance between elements;\\n            int mid = low + (high - low)/2;\\n            \\n            int pairs = 0;\\n            \\n            \\n            for(int i = 1 ; i < nums.size(); i++){\\n                // if the difference is within the mid then we cannot use these pairs again therefore an additional i++;\\n                if((nums[i] - nums[i - 1]) <= mid){\\n                    i++;\\n                    pairs++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3888051,
                "title": "beats-100-time-100-space-binary-search-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic intuition for binary search, sorting for greedy pairing\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog\\\\max\\\\{n,m\\\\})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution(object):\\n    def minimizeMax(self, nums, p):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type p: int\\n        :rtype: int\\n        \"\"\"\\n        ### minimax algo\\n        right = max(nums) - min(nums)\\n        left = 0\\n        nums.sort()\\n\\n        def checkifposs(arr, p, diff):\\n            i = 1\\n            pn = 0\\n            while i < len(arr):\\n                if (arr[i] - arr[i-1]) <= diff:\\n                    pn+=1\\n                    i+=2\\n                else:\\n                    i+=1\\n            return pn >= p\\n                    \\n        ret = 0\\n        while left <= right:\\n            mid = (left + right) >> 1\\n            if checkifposs(nums, p, mid):\\n                ret = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizeMax(self, nums, p):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type p: int\\n        :rtype: int\\n        \"\"\"\\n        ### minimax algo\\n        right = max(nums) - min(nums)\\n        left = 0\\n        nums.sort()\\n\\n        def checkifposs(arr, p, diff):\\n            i = 1\\n            pn = 0\\n            while i < len(arr):\\n                if (arr[i] - arr[i-1]) <= diff:\\n                    pn+=1\\n                    i+=2\\n                else:\\n                    i+=1\\n            return pn >= p\\n                    \\n        ret = 0\\n        while left <= right:\\n            mid = (left + right) >> 1\\n            if checkifposs(nums, p, mid):\\n                ret = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ret\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888032,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* To consider only the minimal differences - sort the numbers first\\n* Then we can check in linear time how many pairs exist for any possible answer\\n    * Greedily grab a pair if its difference is <= *answer*\\n    * There is no point in skipping one, because it will only decrease the number of viable pairs\\n* Since the number of pairs will only increase with the increasing answer - we can binary search on the solution space\\n\\n# Complexity\\n- Time complexity: $$O(N*log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort_unstable();\\n\\n        let count_pairs = |max| {\\n            let mut pairs = 0;\\n            let mut i = 1;\\n            while i < nums.len() {\\n                if (nums[i] - nums[i - 1]) <= max {\\n                    pairs += 1;\\n                    i += 1;\\n                }\\n                i += 1;\\n            }\\n            pairs\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *nums.last().unwrap() - *nums.first().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            if count_pairs(mid) >= p { hi = mid }\\n            else { lo = mid + 1 }\\n        }\\n\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort_unstable();\\n\\n        let count_pairs = |max| {\\n            let mut pairs = 0;\\n            let mut i = 1;\\n            while i < nums.len() {\\n                if (nums[i] - nums[i - 1]) <= max {\\n                    pairs += 1;\\n                    i += 1;\\n                }\\n                i += 1;\\n            }\\n            pairs\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *nums.last().unwrap() - *nums.first().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            if count_pairs(mid) >= p { hi = mid }\\n            else { lo = mid + 1 }\\n        }\\n\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887970,
                "title": "more-such-problems-to-practice-beats-100-binary-search-c",
                "content": "# Intuition\\nAs u see a MIN-MAX problem the first intuition to come to the mind must be the Binary Search!\\nthese problems belongs to Binary search question set of :\\n```\\n1) Allocate books\\n2) Aggresive cows\\n3) split Array largest Sum \\n4) maximum taste of candy basket \\n5) Magnetic force b/w two balls ...\\n```\\npracticing them all will give u a good taste of such questions! \\nIf  this helped you please UPVOTE! cheers!!\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int>& nums, int p, int diff){\\n\\n       int count = 0;\\n       int n = nums.size(); int i=0; int j=1;\\n\\n        while(j<n){\\n            if(nums[j]-nums[i] <= diff){\\n            count++; i+=2; j+=2;\\n            }\\n            else{\\n            i++; j++; continue;\\n            } \\n        }\\n       \\n        return count >= p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int n = nums.size();\\n        if(p==0) return 0;\\n\\n        sort(nums.begin(), nums.end());  // as we dont care bout the order, WE NEED DIFFERENCE!\\n\\n        //minimum diff and maximum diff\\n        int l = 0; int h = nums[n-1]-nums[0]; // (1e9-0) see constraints\\n\\n        while(l<=h){\\n\\n            int mid = (l+h)/2;\\n\\n            if(check(nums,p,mid)==true){\\n                h=mid-1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n1) Allocate books\\n2) Aggresive cows\\n3) split Array largest Sum \\n4) maximum taste of candy basket \\n5) Magnetic force b/w two balls ...\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int>& nums, int p, int diff){\\n\\n       int count = 0;\\n       int n = nums.size(); int i=0; int j=1;\\n\\n        while(j<n){\\n            if(nums[j]-nums[i] <= diff){\\n            count++; i+=2; j+=2;\\n            }\\n            else{\\n            i++; j++; continue;\\n            } \\n        }\\n       \\n        return count >= p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int n = nums.size();\\n        if(p==0) return 0;\\n\\n        sort(nums.begin(), nums.end());  // as we dont care bout the order, WE NEED DIFFERENCE!\\n\\n        //minimum diff and maximum diff\\n        int l = 0; int h = nums[n-1]-nums[0]; // (1e9-0) see constraints\\n\\n        while(l<=h){\\n\\n            int mid = (l+h)/2;\\n\\n            if(check(nums,p,mid)==true){\\n                h=mid-1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887729,
                "title": "java-easy-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*log(max Difference))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int l = 0;\\n        int r = nums[nums.length-1]-nums[0];\\n        int ans = 0;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isGood(nums,mid,p)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isGood(int[] nums, int tgt, int p){\\n        int i=0;\\n        int count = 0;\\n        while(i+1<nums.length){\\n            int differ = nums[i+1]-nums[i];\\n            if(differ<=tgt){\\n                count++;\\n                i+=2;\\n            }\\n            else i+=1;\\n        }\\n        return count>=p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int l = 0;\\n        int r = nums[nums.length-1]-nums[0];\\n        int ans = 0;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isGood(nums,mid,p)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean isGood(int[] nums, int tgt, int p){\\n        int i=0;\\n        int count = 0;\\n        while(i+1<nums.length){\\n            int differ = nums[i+1]-nums[i];\\n            if(differ<=tgt){\\n                count++;\\n                i+=2;\\n            }\\n            else i+=1;\\n        }\\n        return count>=p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887528,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution]() but shorter and functional.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot log_2(k))$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is length of nums`,\\n`k is maximum diff among all possible pairs of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        diffs = tuple(b - a for a, b in pairwise(sorted(nums)))\\n\\n        count_pairs = lambda max_d: sum(accumulate(\\n                map(le, diffs, repeat(max_d)),\\n                lambda a, x: not a and x,\\n                initial=False,\\n            ))\\n        \\n        l, r = 0, max(diffs, default=0)\\n        while l < r:\\n            m = (l + r) // 2\\n            l, r = (m + 1, r) if count_pairs(m) < p else (l, m)\\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizeMax(self, nums: list[int], p: int) -> int:\\n        diffs = tuple(b - a for a, b in pairwise(sorted(nums)))\\n\\n        count_pairs = lambda max_d: sum(accumulate(\\n                map(le, diffs, repeat(max_d)),\\n                lambda a, x: not a and x,\\n                initial=False,\\n            ))\\n        \\n        l, r = 0, max(diffs, default=0)\\n        while l < r:\\n            m = (l + r) // 2\\n            l, r = (m + 1, r) if count_pairs(m) < p else (l, m)\\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887180,
                "title": "learn-through-striver-takeuforward-binary-search-playlist",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search for building this intution please watch Takeuforward binary search playlist it is a gem>>>\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int helper(vector<int>&nums, int p , int mid)\\n   {\\n       int pair=0;\\n\\n       for(int i = 0 ; i < nums.size()-1;i++)\\n       {\\n           if(abs(nums[i]-nums[i+1]) <=mid)\\n           {\\n               pair++;\\n               i++;\\n           }\\n       }\\n       if(pair >=p)\\n        return true;\\n\\n        return false;\\n   }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        int l = 0 , r = nums[n-1]- nums[0];\\n\\n        while(l <=r)\\n        {\\n            int mid = l +(r-l)/2;\\n            \\n            if(helper(nums , p , mid))\\n            {\\n                r= mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }   \\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int helper(vector<int>&nums, int p , int mid)\\n   {\\n       int pair=0;\\n\\n       for(int i = 0 ; i < nums.size()-1;i++)\\n       {\\n           if(abs(nums[i]-nums[i+1]) <=mid)\\n           {\\n               pair++;\\n               i++;\\n           }\\n       }\\n       if(pair >=p)\\n        return true;\\n\\n        return false;\\n   }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        int l = 0 , r = nums[n-1]- nums[0];\\n\\n        while(l <=r)\\n        {\\n            int mid = l +(r-l)/2;\\n            \\n            if(helper(nums , p , mid))\\n            {\\n                r= mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }   \\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887179,
                "title": "easiest-binary-search-solution-100-fast",
                "content": "\\n# Complexity\\n- Time complexity:\\n- M=max difference between 2 elements\\n- O(NLOG(M))\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint count(vector<int> &nums,int m){int n=nums.size(),c=0;\\n    for(int i=1;i<n;i++){\\n        if((nums[i]-nums[i-1])<=m){\\n            c++;i++;\\n        }\\n    }\\n    return c;\\n}\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());int n=nums.size();\\n        int l=0,h=nums[n-1]-nums[0];int ans=0;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(count(nums,m)>=p){\\n                h=m-1;\\n                ans=m;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint count(vector<int> &nums,int m){int n=nums.size(),c=0;\\n    for(int i=1;i<n;i++){\\n        if((nums[i]-nums[i-1])<=m){\\n            c++;i++;\\n        }\\n    }\\n    return c;\\n}\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());int n=nums.size();\\n        int l=0,h=nums[n-1]-nums[0];int ans=0;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(count(nums,m)>=p){\\n                h=m-1;\\n                ans=m;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887176,
                "title": "c-binary-search-beats-100",
                "content": "# Intuition\\nThe key insight of this solution is to perform a binary search on the possible range of values for the maximum difference. Since we are looking for the minimum value of the maximum difference, binary search helps efficiently narrow down the search space to find the optimal solution\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int diff,vector<int>&nums,int p){\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p <= 0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int l = 0, r = nums[n-1] - nums[0];\\n        int result = r;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(isPossible(mid,nums,p)){\\n                result = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int diff,vector<int>&nums,int p){\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p <= 0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int l = 0, r = nums[n-1] - nums[0];\\n        int result = r;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(isPossible(mid,nums,p)){\\n                result = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887096,
                "title": "binary-search-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a,int mid, int p)\\n    {\\n        int n = a.size();\\n        int i = 0;\\n        int cnt = 0;\\n        while(i<n-1)\\n        {\\n            if(a[i+1]-a[i]<=mid)\\n            {\\n                cnt++;\\n                i+=2;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return cnt>=p;\\n    }\\n    \\n    int minimizeMax(vector<int>& a, int p) {\\n        \\n        \\n        int n  = a.size();\\n        sort(a.begin(),a.end());\\n        if(n==0)\\n            return 0;\\n        \\n        int l=0;\\n        int r = a[n-1];\\n        int res =0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(a, mid,p))\\n            {\\n                res = mid;\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n                \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a,int mid, int p)\\n    {\\n        int n = a.size();\\n        int i = 0;\\n        int cnt = 0;\\n        while(i<n-1)\\n        {\\n            if(a[i+1]-a[i]<=mid)\\n            {\\n                cnt++;\\n                i+=2;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return cnt>=p;\\n    }\\n    \\n    int minimizeMax(vector<int>& a, int p) {\\n        \\n        \\n        int n  = a.size();\\n        sort(a.begin(),a.end());\\n        if(n==0)\\n            return 0;\\n        \\n        int l=0;\\n        int r = a[n-1];\\n        int res =0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(a, mid,p))\\n            {\\n                res = mid;\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n                \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886809,
                "title": "easiest-solution-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, nums[n - 1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            j, i = 0, 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= mid:\\n                    j += 1\\n                    i += 1\\n                i += 1\\n            if j >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, nums[n - 1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            j, i = 0, 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= mid:\\n                    j += 1\\n                    i += 1\\n                i += 1\\n            if j >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886799,
                "title": "beats-100-java-solution-explained",
                "content": "# Intuition -\\nThe problem is asking you to minimize the maximum difference between any pair of numbers while maintaining a certain number of pairs. You want to find a value that can be a potential candidate for the minimized maximum difference, and then verify if you can achieve the required number of pairs with that value.\\n\\n# Approach -\\n1. First, the given array `nums` is sorted in ascending order.\\n2. The binary search algorithm is used to find the candidate value for the minimized maximum difference. The binary search is conducted on the range of possible maximum differences, which is between the smallest and largest numbers in the sorted `nums` array.\\n3. Inside the binary search loop, the function `countPairs(nums, maxDiff)` is used to count how many pairs can be formed with a maximum difference of `maxDiff`.\\n4. If the count of pairs with a maximum difference of `maxDiff` is greater than or equal to the required number of pairs `p`, then it means we can potentially minimize the maximum difference further, so the `right` boundary of the binary search is adjusted to `middle`.\\n5. If the count of pairs is less than `p`, then it means we need to increase the maximum difference, so the `left` boundary of the binary search is adjusted to `middle + 1`.\\n6. The binary search continues until the `left` and `right` boundaries meet.\\n\\n# Complexity - \\n- Time complexity: The most time-consuming part of the algorithm is the binary search, which has a time complexity of O(log N), where N is the length of the `nums` array. Inside the binary search loop, the `countPairs` function is called, which has a linear time complexity of O(N), where N is the length of the `nums` array. Therefore, the overall time complexity is O(N * log N).\\n- Space complexity: The algorithm uses a constant amount of extra space for variables and indices, so the space complexity is O(1).\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums[nums.length - 1] - nums[0];\\n        while (left < right) {\\n            final int middle = (left + right) / 2;\\n            if (countPairs(nums, middle) >= p)\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    private int countPairs(int[] nums, int maxDiff) {\\n        int count = 0;\\n        for (int i = 1; i < nums.length; ++i) {\\n            if (nums[i] - nums[i - 1] <= maxDiff) {\\n                ++count;\\n                ++i; \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums[nums.length - 1] - nums[0];\\n        while (left < right) {\\n            final int middle = (left + right) / 2;\\n            if (countPairs(nums, middle) >= p)\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    private int countPairs(int[] nums, int maxDiff) {\\n        int count = 0;\\n        for (int i = 1; i < nums.length; ++i) {\\n            if (nums[i] - nums[i - 1] <= maxDiff) {\\n                ++count;\\n                ++i; \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886674,
                "title": "c-java-easy-and-fast-binary-search-greedy-beats-100",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n<!-- > **Please do UpVote** it took lot of time to figure out these solutions -->\\n\\n# Complexity \\n- Time complexity: $$O(N*logN)$$ where `N = nums.length` \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = nums[n-1]-nums[0], ans;\\n\\n        // Function to check if there are atleast p pairs possible whose difference <= maxDiff\\n        auto isPossible = [nums, p](int maxDiff){\\n            int cnt = 0;\\n            for(int i=0; i<nums.size()-1; i++){\\n                if( abs(nums[i]-nums[i+1]) <= maxDiff ) cnt++, i++;\\n            }\\n            return cnt >= p ;\\n        };\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( isPossible(mid) ) ans = mid, r = mid-1;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length, l = 0, r = nums[n-1]-nums[0], ans = Integer.MAX_VALUE;\\n\\n        // Function to check if there are atleast p pairs possible whose difference <= maxDiff\\n        Function<Integer, Boolean> isPossible = (maxDiff)->{\\n            int cnt = 0;\\n            for(int i=0; i<nums.length-1; i++){\\n                if( Math.abs(nums[i]-nums[i+1]) <= maxDiff ){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            return cnt >= p ;\\n        };\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( isPossible.apply(mid) ){\\n                ans = mid;\\n                r = mid-1;\\n            }else l = mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), l = 0, r = nums[n-1]-nums[0], ans;\\n\\n        // Function to check if there are atleast p pairs possible whose difference <= maxDiff\\n        auto isPossible = [nums, p](int maxDiff){\\n            int cnt = 0;\\n            for(int i=0; i<nums.size()-1; i++){\\n                if( abs(nums[i]-nums[i+1]) <= maxDiff ) cnt++, i++;\\n            }\\n            return cnt >= p ;\\n        };\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( isPossible(mid) ) ans = mid, r = mid-1;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length, l = 0, r = nums[n-1]-nums[0], ans = Integer.MAX_VALUE;\\n\\n        // Function to check if there are atleast p pairs possible whose difference <= maxDiff\\n        Function<Integer, Boolean> isPossible = (maxDiff)->{\\n            int cnt = 0;\\n            for(int i=0; i<nums.length-1; i++){\\n                if( Math.abs(nums[i]-nums[i+1]) <= maxDiff ){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            return cnt >= p ;\\n        };\\n\\n        while( l<=r ){\\n            int mid = (l+r)>>1;\\n            if( isPossible.apply(mid) ){\\n                ans = mid;\\n                r = mid-1;\\n            }else l = mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886609,
                "title": "c-super-easy-clean-code-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint n;\\nclass Solution {\\nprivate:\\n    bool isPossible(int diff, vector<int>& nums, int p){\\n        int count = 0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        n = nums.size();\\n\\n        int low = 0;\\n        int high = nums[n-1] - nums[0];\\n        int ans = 0;\\n\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(isPossible(mid,nums,p)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nint n;\\nclass Solution {\\nprivate:\\n    bool isPossible(int diff, vector<int>& nums, int p){\\n        int count = 0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i] - nums[i-1] <= diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        n = nums.size();\\n\\n        int low = 0;\\n        int high = nums[n-1] - nums[0];\\n        int ans = 0;\\n\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(isPossible(mid,nums,p)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886355,
                "title": "a-greedy-approach-with-binary-search-technique-i-var",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum difference between any pair of number occurs only when they are adjacent when sorted. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use binary search to find our optimal answer over the search space which will be 0 to diff(max number and min number or maximum difference between adjacent pair).\\nFor each potential difference we\\'ll count the number of pair whose difference is less than or equal to current max difference, if this count is greater than or equal to required then this will be our answer until we get a better difference i.e a lower max Difference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\n\\n    int getPairWithMaxDiff(vector<int> nums, int diff){\\n        int count=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i]-nums[i-1])<=diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int st=0;\\n        int ed=nums[n-1]-nums[0];\\n        int mid, pairCount;\\n        int minMax=INT_MAX;\\n        while(st<=ed){\\n            mid = (ed+st)/2;\\n            pairCount = getPairWithMaxDiff(nums, mid);\\n            if(pairCount<p){\\n                st=mid+1;\\n            }else if(pairCount>=p){\\n                minMax = mid;\\n                ed=mid-1;\\n            }\\n        }\\n        return minMax;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def getPairWithMaxDiff(self, nums, diff):\\n        count = 0\\n        i = 1\\n        while i < len(nums):\\n            if abs(nums[i] - nums[i - 1]) <= diff:\\n                count += 1\\n                i += 2\\n            else:\\n                i += 1\\n        return count\\n\\n    def minimizeMax(self, nums, p):\\n        n = len(nums)\\n        nums.sort()\\n        st = 0\\n        ed = nums[n - 1] - nums[0]\\n        minMax = float(\\'inf\\')\\n        while st <= ed:\\n            mid = (ed + st) // 2\\n            pairCount = self.getPairWithMaxDiff(nums, mid)\\n            if pairCount < p:\\n                st = mid + 1\\n            else:\\n                minMax = mid\\n                ed = mid - 1\\n        return minMax\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "``` C++ []\\nclass Solution {\\n\\n    int getPairWithMaxDiff(vector<int> nums, int diff){\\n        int count=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i]-nums[i-1])<=diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int st=0;\\n        int ed=nums[n-1]-nums[0];\\n        int mid, pairCount;\\n        int minMax=INT_MAX;\\n        while(st<=ed){\\n            mid = (ed+st)/2;\\n            pairCount = getPairWithMaxDiff(nums, mid);\\n            if(pairCount<p){\\n                st=mid+1;\\n            }else if(pairCount>=p){\\n                minMax = mid;\\n                ed=mid-1;\\n            }\\n        }\\n        return minMax;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def getPairWithMaxDiff(self, nums, diff):\\n        count = 0\\n        i = 1\\n        while i < len(nums):\\n            if abs(nums[i] - nums[i - 1]) <= diff:\\n                count += 1\\n                i += 2\\n            else:\\n                i += 1\\n        return count\\n\\n    def minimizeMax(self, nums, p):\\n        n = len(nums)\\n        nums.sort()\\n        st = 0\\n        ed = nums[n - 1] - nums[0]\\n        minMax = float(\\'inf\\')\\n        while st <= ed:\\n            mid = (ed + st) // 2\\n            pairCount = self.getPairWithMaxDiff(nums, mid)\\n            if pairCount < p:\\n                st = mid + 1\\n            else:\\n                minMax = mid\\n                ed = mid - 1\\n        return minMax\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885633,
                "title": "simple-beginner-level-c-solution-beats-100-in-runtime-no-explanation-yet",
                "content": "\\n# Complexity\\n- Time complexity:  ```O(nlog(n) + nlog(nums.max - nums.min))```\\n- Space complexity: ```O(nlog(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 99 ms Beats 100% Memory 14.6 MB Beats 66.67%\\nint ascend(const void* pa, const void* pb) {\\n    const int a = *(const int*)pa;\\n    const int b = *(const int*)pb;\\n    if (a == b) {\\n        return 0;\\n    }\\n    return (a < b) ? -1 : 1;\\n}\\nint num_pairs(int* nums, int numsSize, int max_diff) {\\n    // returns the # of pairs that can be obtained \\n    // if the difference between each pair <= \\'max_diff.\\'\\n    int pairs = 0;\\n    for (int i = 1; i < numsSize; i++) {\\n        // greedily paired nums[i] with nums[i - 1]\\n        if (nums[i] - nums[i - 1] > max_diff) continue;\\n        pairs++;\\n        i++;\\n    }\\n    return pairs;\\n}\\nint minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }\\n        else left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```O(nlog(n) + nlog(nums.max - nums.min))```\n```O(nlog(n)```\n```cpp\\n// Runtime 99 ms Beats 100% Memory 14.6 MB Beats 66.67%\\nint ascend(const void* pa, const void* pb) {\\n    const int a = *(const int*)pa;\\n    const int b = *(const int*)pb;\\n    if (a == b) {\\n        return 0;\\n    }\\n    return (a < b) ? -1 : 1;\\n}\\nint num_pairs(int* nums, int numsSize, int max_diff) {\\n    // returns the # of pairs that can be obtained \\n    // if the difference between each pair <= \\'max_diff.\\'\\n    int pairs = 0;\\n    for (int i = 1; i < numsSize; i++) {\\n        // greedily paired nums[i] with nums[i - 1]\\n        if (nums[i] - nums[i - 1] > max_diff) continue;\\n        pairs++;\\n        i++;\\n    }\\n    return pairs;\\n}\\nint minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }\\n        else left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885628,
                "title": "dp-binary-search-2-approaches-fast-c",
                "content": "\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // DP\\n        if(p==0) return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> dp(nums.size()+1, vector<int>(p+1, 0));\\n        for(int len=0; len<=nums.size(); len++) {\\n            for(int cap= 1; cap<=p; cap++) {\\n                if(cap*2 > len) dp[len][cap]= 1e9; \\n                else {\\n                    int ans2= dp[len-1][cap];\\n                    int ans1= max((nums[len-1] - nums[len-2]), dp[len-2][cap-1]);\\n                    dp[len][cap]=min(ans1, ans2);\\n                }\\n            }\\n        }\\n        return dp[nums.size()][p];\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // BS\\n        if(nums.size() == 0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int start= 0;\\n        int end= nums[nums.size()-1]- nums[0];\\n        int ans= 0;\\n        while(end >= start) {\\n            int mid= (end+start)/2;\\n            int count= 0;\\n            for(int i= 0; i<nums.size()-1;) {\\n                if(nums[i+1]-nums[i]<= mid) {\\n                    count++;\\n                    i+= 2;\\n                }\\n                else i++;\\n            }\\n            if(count >= p) {\\n                ans= mid;\\n                end= mid-1;\\n            } else {\\n                start= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // DP\\n        if(p==0) return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> dp(nums.size()+1, vector<int>(p+1, 0));\\n        for(int len=0; len<=nums.size(); len++) {\\n            for(int cap= 1; cap<=p; cap++) {\\n                if(cap*2 > len) dp[len][cap]= 1e9; \\n                else {\\n                    int ans2= dp[len-1][cap];\\n                    int ans1= max((nums[len-1] - nums[len-2]), dp[len-2][cap-1]);\\n                    dp[len][cap]=min(ans1, ans2);\\n                }\\n            }\\n        }\\n        return dp[nums.size()][p];\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // BS\\n        if(nums.size() == 0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int start= 0;\\n        int end= nums[nums.size()-1]- nums[0];\\n        int ans= 0;\\n        while(end >= start) {\\n            int mid= (end+start)/2;\\n            int count= 0;\\n            for(int i= 0; i<nums.size()-1;) {\\n                if(nums[i+1]-nums[i]<= mid) {\\n                    count++;\\n                    i+= 2;\\n                }\\n                else i++;\\n            }\\n            if(count >= p) {\\n                ans= mid;\\n                end= mid-1;\\n            } else {\\n                start= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885467,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity:\\nSort: O(nlog(n))\\nBinary Search: O(nlog(K)) : K is max - min element of nums list\\n\\n- Space complexity:\\nBinary Search: O(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0: return 0\\n        nums.sort()\\n        l, r = 0, nums[-1] - nums[0]\\n        while l < r:\\n            mid = (l+r)//2\\n            pairs = 0 # pairs to pick\\n            i = 1\\n            while i < len(nums):\\n                if mid >= nums[i] - nums[i-1]:\\n                    i += 2\\n                    pairs += 1\\n                else:\\n                    i += 1\\n            if pairs >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0: return 0\\n        nums.sort()\\n        l, r = 0, nums[-1] - nums[0]\\n        while l < r:\\n            mid = (l+r)//2\\n            pairs = 0 # pairs to pick\\n            i = 1\\n            while i < len(nums):\\n                if mid >= nums[i] - nums[i-1]:\\n                    i += 2\\n                    pairs += 1\\n                else:\\n                    i += 1\\n            if pairs >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885442,
                "title": "well-explianed-binary-search-o-nlog-largest-smallest-element-in-the-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>Only way to find min differences is to sort as neighbors are the only ones to be checked\\n>The binary search aspect in most problems is like a tuning scheme for the threshold we want to test (the max of min differences)\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- create a function that takes a value called threshold.\\nloop and find pairs that have  atleast p pairs who\\'s difference  is less than the provided threshold. if so return true, else return false\\n```\\ndef validMaxdiff(thresh):\\n    # given this threshold, can we find p pairs ?\\n    # This func returns true if we find p pairs that are <= thresh\\n    i = 0\\n    count_pairs = 0\\n    while i <len(nums)-1:\\n        if nums[i+1] - nums[i] <= thresh:\\n            count_pairs+= 1\\n            # Note pairs cannot have an element reused\\n            # hence we increment over the \"pair\"\\n            i+=2\\n        else:\\n            i+=1\\n        if count_pairs == p:\\n            return True\\n    return False\\n```\\n\\n    - TC : O(n)\\n\\n- The threshold is the mid value on a scale from 0 to the largest element in the array, \\n```\\n        nums.sort()\\n        print(nums)\\n        l = 0                    #The least value a pair\\'s difference can be\\n        r = nums[-1] - nums[0]   #The max Element in a sorted array, This will yield\\n        res = r-l                #literal max value of the difference\\n\\n\\n        # only edge case where they ask for 0 pairs, max(0)\\n        if p == 0:\\n            return 0\\n\\n        while l <=r:\\n            print(l,r)\\n            # The kewl way to acc calc mid\\n            mid = l + (r-l)//2\\n            print(mid)\\n            if validMaxdiff(mid):\\n                res = mid\\n                # lets try reducing the threshold\\n                r = mid-1\\n            else: # looks like this value of a threshold (mid)is too strict, inc\\n                l = mid+1\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(largest element in the list))\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\n        def validMaxdiff(thresh):\\n            # given this threshold, can we find p pairs ?\\n            # This func returns true if we find p pairs that are <= thresh\\n            i = 0\\n            count_pairs = 0\\n            while i <len(nums)-1:\\n                if nums[i+1] - nums[i] <= thresh:\\n                    count_pairs+= 1\\n                    # Note pairs cannot have an element reused\\n                    # hence we increment over the \"pair\"\\n                    i+=2\\n                else:\\n                    i+=1\\n                if count_pairs == p:\\n                    return True\\n            return False\\n            \\n        # Greedy : We sort the input so that we can check \\n        # only immediate left or right neighbors\\n        # this enables to identify pairs\\n        nums.sort()\\n        print(nums)\\n        l = 0                    #The least value a pair\\'s difference can be\\n        r = nums[-1] - nums[0]   #The max Element in a sorted array, This will yield\\n        res = r-l                #literal max value of the difference\\n\\n\\n        # only edge case where they ask for 0 pairs, max(0)\\n        if p == 0:\\n            return 0\\n\\n        while l <=r:\\n            print(l,r)\\n            # The kewl way to acc calc mid\\n            mid = l + (r-l)//2\\n            print(mid)\\n            if validMaxdiff(mid):\\n                res = mid\\n                # lets try reducing the threshold\\n                r = mid-1\\n            else: # looks like this value of a threshold (mid)is too strict, inc\\n                l = mid+1\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef validMaxdiff(thresh):\\n    # given this threshold, can we find p pairs ?\\n    # This func returns true if we find p pairs that are <= thresh\\n    i = 0\\n    count_pairs = 0\\n    while i <len(nums)-1:\\n        if nums[i+1] - nums[i] <= thresh:\\n            count_pairs+= 1\\n            # Note pairs cannot have an element reused\\n            # hence we increment over the \"pair\"\\n            i+=2\\n        else:\\n            i+=1\\n        if count_pairs == p:\\n            return True\\n    return False\\n```\n```\\n        nums.sort()\\n        print(nums)\\n        l = 0                    #The least value a pair\\'s difference can be\\n        r = nums[-1] - nums[0]   #The max Element in a sorted array, This will yield\\n        res = r-l                #literal max value of the difference\\n\\n\\n        # only edge case where they ask for 0 pairs, max(0)\\n        if p == 0:\\n            return 0\\n\\n        while l <=r:\\n            print(l,r)\\n            # The kewl way to acc calc mid\\n            mid = l + (r-l)//2\\n            print(mid)\\n            if validMaxdiff(mid):\\n                res = mid\\n                # lets try reducing the threshold\\n                r = mid-1\\n            else: # looks like this value of a threshold (mid)is too strict, inc\\n                l = mid+1\\n```\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\n        def validMaxdiff(thresh):\\n            # given this threshold, can we find p pairs ?\\n            # This func returns true if we find p pairs that are <= thresh\\n            i = 0\\n            count_pairs = 0\\n            while i <len(nums)-1:\\n                if nums[i+1] - nums[i] <= thresh:\\n                    count_pairs+= 1\\n                    # Note pairs cannot have an element reused\\n                    # hence we increment over the \"pair\"\\n                    i+=2\\n                else:\\n                    i+=1\\n                if count_pairs == p:\\n                    return True\\n            return False\\n            \\n        # Greedy : We sort the input so that we can check \\n        # only immediate left or right neighbors\\n        # this enables to identify pairs\\n        nums.sort()\\n        print(nums)\\n        l = 0                    #The least value a pair\\'s difference can be\\n        r = nums[-1] - nums[0]   #The max Element in a sorted array, This will yield\\n        res = r-l                #literal max value of the difference\\n\\n\\n        # only edge case where they ask for 0 pairs, max(0)\\n        if p == 0:\\n            return 0\\n\\n        while l <=r:\\n            print(l,r)\\n            # The kewl way to acc calc mid\\n            mid = l + (r-l)//2\\n            print(mid)\\n            if validMaxdiff(mid):\\n                res = mid\\n                # lets try reducing the threshold\\n                r = mid-1\\n            else: # looks like this value of a threshold (mid)is too strict, inc\\n                l = mid+1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885343,
                "title": "java-9",
                "content": "# Code\\n```\\nclass Solution {\\n    // Find the number of valid pairs by greedy approach\\n    private int countValidPairs(int[] nums, int threshold) {\\n        int index = 0, count = 0;\\n        while (index < nums.length - 1) {\\n            // If a valid pair is found, skip both numbers.\\n            if (nums[index + 1] - nums[index] <= threshold) {\\n                count++;\\n                index++;\\n            }\\n            index++;\\n        }\\n        return count;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int left = 0, right = nums[n - 1] - nums[0];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            // If there are enough pairs, look for a smaller threshold.\\n            // Otherwise, look for a larger threshold.\\n            if (countValidPairs(nums, mid) >= p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}//TC:O(n\\u22C5logV), SC:O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    // Find the number of valid pairs by greedy approach\\n    private int countValidPairs(int[] nums, int threshold) {\\n        int index = 0, count = 0;\\n        while (index < nums.length - 1) {\\n            // If a valid pair is found, skip both numbers.\\n            if (nums[index + 1] - nums[index] <= threshold) {\\n                count++;\\n                index++;\\n            }\\n            index++;\\n        }\\n        return count;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int left = 0, right = nums[n - 1] - nums[0];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            // If there are enough pairs, look for a smaller threshold.\\n            // Otherwise, look for a larger threshold.\\n            if (countValidPairs(nums, mid) >= p) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}//TC:O(n\\u22C5logV), SC:O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885303,
                "title": "golang-binarysearch",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn + nlogD)\\nWhere D is max difference\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minimizeMax(nums []int, p int) int {\\n    sort.Ints(nums)\\n    \\n    n := len(nums)\\n    left, right := 0, nums[n-1] - nums[0]\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n        if countPairs(nums, mid, p) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc countPairs(nums []int, pivot, target int) bool {\\n    count := 0\\n    for i := 0; i < len(nums) - 1 && count < target; i++ {\\n        if nums[i+1] - nums[i] <= pivot {\\n            count++\\n            i++\\n        }\\n    }\\n\\n    return count == target\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizeMax(nums []int, p int) int {\\n    sort.Ints(nums)\\n    \\n    n := len(nums)\\n    left, right := 0, nums[n-1] - nums[0]\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n        if countPairs(nums, mid, p) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc countPairs(nums []int, pivot, target int) bool {\\n    count := 0\\n    for i := 0; i < len(nums) - 1 && count < target; i++ {\\n        if nums[i+1] - nums[i] <= pivot {\\n            count++\\n            i++\\n        }\\n    }\\n\\n    return count == target\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885297,
                "title": "easiest-bs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // bool isValid(const vector<int>& nums, int mid, int p) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.size() - 1 && count < p;) {\\n    //         if (nums[i+1] - nums[i] <= mid) {\\n    //             count++;\\n    //             i += 2;\\n    //         } else {\\n    //             i++;\\n    //         }\\n    //     }\\n    //     return count >= p;\\n    // }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int low=0,high=nums[nums.size()-1]-nums[0];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int pairs=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    pairs++;\\n                    i++;\\n                }\\n            }\\n            if(pairs >= p)  high=mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n        // sort(nums.begin(), nums.end());\\n        \\n        // int left = 0, right = nums.back() - nums.front();\\n        \\n        // while (left < right) {\\n        //     int mid = (left + right) / 2;\\n        //     if (isValid(nums, mid, p)) {\\n        //         right = mid;\\n        //     } else {\\n        //         left = mid + 1;\\n        //     }\\n        // }\\n        // return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // bool isValid(const vector<int>& nums, int mid, int p) {\\n    //     int count = 0;\\n    //     for (int i = 0; i < nums.size() - 1 && count < p;) {\\n    //         if (nums[i+1] - nums[i] <= mid) {\\n    //             count++;\\n    //             i += 2;\\n    //         } else {\\n    //             i++;\\n    //         }\\n    //     }\\n    //     return count >= p;\\n    // }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int low=0,high=nums[nums.size()-1]-nums[0];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int pairs=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    pairs++;\\n                    i++;\\n                }\\n            }\\n            if(pairs >= p)  high=mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n        // sort(nums.begin(), nums.end());\\n        \\n        // int left = 0, right = nums.back() - nums.front();\\n        \\n        // while (left < right) {\\n        //     int mid = (left + right) / 2;\\n        //     if (isValid(nums, mid, p)) {\\n        //         right = mid;\\n        //     } else {\\n        //         left = mid + 1;\\n        //     }\\n        // }\\n        // return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885268,
                "title": "bisect-left",
                "content": "To use the built in bisect library in python, for something like this that is not a straightforward search, you can define an object with the appropriate `__getitem__` method. In this case the function returns true if `nums` has p or more pairs with a diff less than or equal to `diff`. We then use `bisect_left` to find the smallest value that returns true.\\n\\n```\\ndef minimizeMax(self, nums: List[int], p: int) -> int:\\n    class M:\\n        def __getitem__(self, diff):\\n            skip = False\\n            count = 0\\n            for a,b in zip(nums, nums[1:]):\\n                if skip:\\n                    skip = False\\n                elif b-a <= diff:\\n                    count += 1\\n                    skip = True\\n\\n            return count >= p\\n\\n    nums.sort()\\n    return bisect.bisect_left(M(), True, 0, nums[-1]-nums[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimizeMax(self, nums: List[int], p: int) -> int:\\n    class M:\\n        def __getitem__(self, diff):\\n            skip = False\\n            count = 0\\n            for a,b in zip(nums, nums[1:]):\\n                if skip:\\n                    skip = False\\n                elif b-a <= diff:\\n                    count += 1\\n                    skip = True\\n\\n            return count >= p\\n\\n    nums.sort()\\n    return bisect.bisect_left(M(), True, 0, nums[-1]-nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885194,
                "title": "binary-search-on-answers-c",
                "content": "# Intuition\\nWe can easily observe that min possible value is 0 and max possible value is difference between largest and smallest element of the nums. so we have a search space of answers in which we can find a eligible one.\\n\\nWe can use binary search on answers having low and high as defined above. We will check for a particular mid value, if we can create p pairs or not. if yes, we can reduce our search space either by eliminating left half or right half.\\n\\n# Approach\\ni am using binary search having low=0 and high=max_element-min_element of nums.\\n\\nAfterwards for each possible mid value , i am executing a isPossible function which is helping to count the number of pairs p. it is return true if we have counted more than or euqal to p pairs, otherwise false.\\n\\njust we are traversing in the array and checking whether it is possible to create a pair having diff<=mid.\\n\\n# Complexity\\n- Time complexity:\\no(log(high-low))*o(n)\\n\\n    first is for the binary search and other for traversing in the  array\\n\\n- Space complexity:\\nWe have not used any extra space, so space complexity is o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid, vector<int>& nums, int p){\\n        int cnt=0;\\n        int i=0;\\n        int j=1;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=mid){\\n                cnt++;\\n                i=i+2;\\n                j=j+2;\\n            }\\n            else{\\n                i=j;\\n                j++;\\n            }\\n            \\n        }\\n        return cnt>=p;\\n\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums[n-1]-nums[0];\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(mid,nums,p)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid, vector<int>& nums, int p){\\n        int cnt=0;\\n        int i=0;\\n        int j=1;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=mid){\\n                cnt++;\\n                i=i+2;\\n                j=j+2;\\n            }\\n            else{\\n                i=j;\\n                j++;\\n            }\\n            \\n        }\\n        return cnt>=p;\\n\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums[n-1]-nums[0];\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(mid,nums,p)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885157,
                "title": "binary-search-intuitive-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int maxi,int p,vector<int>&nums){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=maxi){cnt++;i++;}\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1e9;\\n        int ans=1e9;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(f(mid,p,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int maxi,int p,vector<int>&nums){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=maxi){cnt++;i++;}\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1e9;\\n        int ans=1e9;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(f(mid,p,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885156,
                "title": "binary-search-intuitive-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int maxi,int p,vector<int>&nums){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=maxi){cnt++;i++;}\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1e9;\\n        int ans=1e9;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(f(mid,p,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int maxi,int p,vector<int>&nums){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=maxi){cnt++;i++;}\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1e9;\\n        int ans=1e9;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(f(mid,p,nums)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885141,
                "title": "beats-99-greedy-binary-search-java-beginner-friendly",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairWithDiff(int[] nums, int th){\\n        int count = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            int diff = nums[i + 1] - nums[i];\\n            if(th >= diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int left = 0, right = nums[n - 1] - nums[0];\\n        while(left < right){\\n            int mid = (left + right) / 2;\\n            if(countPairWithDiff(nums, mid) >= p){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairWithDiff(int[] nums, int th){\\n        int count = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            int diff = nums[i + 1] - nums[i];\\n            if(th >= diff){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n\\n        int left = 0, right = nums[n - 1] - nums[0];\\n        while(left < right){\\n            int mid = (left + right) / 2;\\n            if(countPairWithDiff(nums, mid) >= p){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885122,
                "title": "recursion-memoization-binary-search",
                "content": "# Intuition\\nThis kind of problems are generally not intuitive, most of the time we won\\'t get idea for binary search.\\n\\n# Approach\\nFirst we will sort array as we will get maximum of minimum difference so sorting will easy the search.\\n\\nWe will search till 1e9 range as given in constraints \\n\\n# Complexity\\n- Time complexity:\\nO N(log M)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        // return recursion(0,nums,p);\\n\\n        // Memo\\n        // int[][] dp = new int[nums.length+1][p+1];\\n        // for(int[] arr:dp) Arrays.fill(arr,-1);\\n        // return memo(0,nums,p,dp);\\n\\n\\n        // Binary Search\\n        int start = 0, end = (int)1e9;\\n        int ans = 0;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid,nums,p)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isValid(int mid,int[] nums,int p){\\n        int index = 0,count = 0;\\n        while(index < nums.length-1){\\n            if(Math.abs(nums[index] - nums[index+1]) <= mid){\\n                count++;\\n                index+=2;\\n            }else{\\n                index+=1;\\n            }\\n            // means we found pair of number\\n            if(count==p) return true;\\n        }\\n        return false;\\n    }\\n\\n\\n\\n    int memo(int index,int[] nums,int p,int[][] dp){\\n        if(p==0) return 0;\\n        if(index >= nums.length-1) return (int)1e9;\\n        if(dp[index][p]!=-1) return dp[index][p];\\n        int notTake = memo(index+1,nums,p,dp);\\n        int take = Math.max(Math.abs(nums[index]-nums[index+1]),memo(index+2,nums,p-1,dp));\\n        return dp[index][p] = Math.min(take,notTake);\\n    }\\n\\n    int recursion(int index,int[] nums,int p){\\n        if(p==0) return 0;\\n        if(index >= nums.length-1) return (int)1e9;\\n        int notTake = recursion(index+1,nums,p);\\n        int take = Math.max(Math.abs(nums[index] - nums[index+1]),recursion(index+2,nums,p-1));\\n        return Math.min(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        // return recursion(0,nums,p);\\n\\n        // Memo\\n        // int[][] dp = new int[nums.length+1][p+1];\\n        // for(int[] arr:dp) Arrays.fill(arr,-1);\\n        // return memo(0,nums,p,dp);\\n\\n\\n        // Binary Search\\n        int start = 0, end = (int)1e9;\\n        int ans = 0;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid,nums,p)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isValid(int mid,int[] nums,int p){\\n        int index = 0,count = 0;\\n        while(index < nums.length-1){\\n            if(Math.abs(nums[index] - nums[index+1]) <= mid){\\n                count++;\\n                index+=2;\\n            }else{\\n                index+=1;\\n            }\\n            // means we found pair of number\\n            if(count==p) return true;\\n        }\\n        return false;\\n    }\\n\\n\\n\\n    int memo(int index,int[] nums,int p,int[][] dp){\\n        if(p==0) return 0;\\n        if(index >= nums.length-1) return (int)1e9;\\n        if(dp[index][p]!=-1) return dp[index][p];\\n        int notTake = memo(index+1,nums,p,dp);\\n        int take = Math.max(Math.abs(nums[index]-nums[index+1]),memo(index+2,nums,p-1,dp));\\n        return dp[index][p] = Math.min(take,notTake);\\n    }\\n\\n    int recursion(int index,int[] nums,int p){\\n        if(p==0) return 0;\\n        if(index >= nums.length-1) return (int)1e9;\\n        int notTake = recursion(index+1,nums,p);\\n        int take = Math.max(Math.abs(nums[index] - nums[index+1]),recursion(index+2,nums,p-1));\\n        return Math.min(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885108,
                "title": "simple-binary-search-solution-c-video-solution",
                "content": "# Video Solution\\nhttps://youtu.be/432iYP415k8\\n# Intuition\\nWe can solve this question using Binary search over the range of maximum difference and checking whether we can have p or more pairs of a particular maximum difference or not and minimizing it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n**Please upvote if you liked !!!**\\n\\n# Code\\n```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // we will use binary search here to find min maximum difference...\\n        int left=0,right=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int cnt=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    cnt++;\\n                    i++; // we will increase the value of i because the indices i and i+1 will not be repeating....\\n                }\\n            }\\n            if(cnt>=p){\\n                // we will minimize this...\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return ans; // we have to return minimum value thats why we have returned left...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // we will use binary search here to find min maximum difference...\\n        int left=0,right=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            int cnt=0;\\n            for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1]-nums[i]<=mid){\\n                    cnt++;\\n                    i++; // we will increase the value of i because the indices i and i+1 will not be repeating....\\n                }\\n            }\\n            if(cnt>=p){\\n                // we will minimize this...\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return ans; // we have to return minimum value thats why we have returned left...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885105,
                "title": "ruby-binary-search-t-s-o-n-log-n-o-n",
                "content": "# Code\\n```ruby\\nclass Solver\\n    attr_reader :nums, :ds, :maxd\\n\\n    def initialize(nums)\\n        @nums = nums.sort\\n        @ds = @nums.each_cons(2).collect {|(v1,v2)| v2 - v1 }\\n        @maxd = ds.max\\n    end\\n\\n    def check(d)\\n        ds.inject([0, false]) {|(c, taken), curd|\\n            taken ? [c, false] : (curd <= d ? [c+1, true] : [c, false])\\n        }.first\\n    end\\n\\n    def solve(p)\\n        (0..maxd).bsearch {|d| check(d) >= p }\\n    end\\nend\\n\\ndef minimize_max(nums, p)\\n    Solver.new(nums).solve(p)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Solver\\n    attr_reader :nums, :ds, :maxd\\n\\n    def initialize(nums)\\n        @nums = nums.sort\\n        @ds = @nums.each_cons(2).collect {|(v1,v2)| v2 - v1 }\\n        @maxd = ds.max\\n    end\\n\\n    def check(d)\\n        ds.inject([0, false]) {|(c, taken), curd|\\n            taken ? [c, false] : (curd <= d ? [c+1, true] : [c, false])\\n        }.first\\n    end\\n\\n    def solve(p)\\n        (0..maxd).bsearch {|d| check(d) >= p }\\n    end\\nend\\n\\ndef minimize_max(nums, p)\\n    Solver.new(nums).solve(p)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885068,
                "title": "java-binary-search-sorting",
                "content": "```\\nclass Solution {\\n    \\n    public int solvePairs(int[] nums,int dif){\\n        int i = 0 ; \\n        int count = 0;\\n        int n = nums.length;\\n        for(i = 0 ; i < n ; i++){\\n            if(i+1 < n && nums[i+1] - nums[i] <= dif){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int start = 0, end = nums[n-1] - nums[0];\\n        while( start < end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(solvePairs(nums,mid) >= p){\\n                end = mid;\\n            }else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int solvePairs(int[] nums,int dif){\\n        int i = 0 ; \\n        int count = 0;\\n        int n = nums.length;\\n        for(i = 0 ; i < n ; i++){\\n            if(i+1 < n && nums[i+1] - nums[i] <= dif){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int start = 0, end = nums[n-1] - nums[0];\\n        while( start < end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(solvePairs(nums,mid) >= p){\\n                end = mid;\\n            }else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884921,
                "title": "binary-search-on-answer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int mid, vector<int> &nums, int p)\\n{\\n    int n = nums.size();\\n    int count = 0;\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (nums[i] - nums[i - 1] <= mid)\\n        {\\n            count++;\\n            i++;\\n        }\\n    }\\n\\n    return count >= p;\\n}\\n\\nint minimizeMax(vector<int> &nums, int p)\\n{\\n    int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = lb;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isvalid(mid, nums, p))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int mid, vector<int> &nums, int p)\\n{\\n    int n = nums.size();\\n    int count = 0;\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (nums[i] - nums[i - 1] <= mid)\\n        {\\n            count++;\\n            i++;\\n        }\\n    }\\n\\n    return count >= p;\\n}\\n\\nint minimizeMax(vector<int> &nums, int p)\\n{\\n    int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = lb;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isvalid(mid, nums, p))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884887,
                "title": "clean-binary-search-with-complexity-analysis",
                "content": "# Complexity\\n- Time complexity: $$O(N \\\\log M)$$\\nWhere $N$ is the length of $nums$ array and $M$ is the maximum value in $nums$. \\n    - At each step, we need to iterate over $nums$ to determine if there are at least $p$ pairs, which takes $$O(n)$$ time.\\n    - The binary search takes $$O(\\\\log M)$$ steps\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p==0) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = 1_000_000_000;\\n        int res = right;\\n        Arrays.sort(nums);\\n\\n        while(left <= right) {\\n            int mid = right - (right-left)/2;\\n            if(isValid(nums, mid, p)) {\\n                right = mid-1;\\n                res = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValid(int[] nums, int threshold, int p) {\\n        int i=0, count=0;\\n        int n = nums.length;\\n        while(i<n-1) {\\n            if(Math.abs(nums[i]-nums[i+1])<=threshold) {\\n                count++;\\n                // we have seen i and i+1,\\n                // now move to i+2 and i+3\\n                // as we cannot repeat same indices twice\\n                i+=2;\\n            }\\n            else {\\n                // we weren\\'t able to consider i with i+1\\n                // so we would better consider i+1 with i+2\\n                i++;\\n            }\\n            if(count == p) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p==0) {\\n            return 0;\\n        }\\n        int left = 0;\\n        int right = 1_000_000_000;\\n        int res = right;\\n        Arrays.sort(nums);\\n\\n        while(left <= right) {\\n            int mid = right - (right-left)/2;\\n            if(isValid(nums, mid, p)) {\\n                right = mid-1;\\n                res = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValid(int[] nums, int threshold, int p) {\\n        int i=0, count=0;\\n        int n = nums.length;\\n        while(i<n-1) {\\n            if(Math.abs(nums[i]-nums[i+1])<=threshold) {\\n                count++;\\n                // we have seen i and i+1,\\n                // now move to i+2 and i+3\\n                // as we cannot repeat same indices twice\\n                i+=2;\\n            }\\n            else {\\n                // we weren\\'t able to consider i with i+1\\n                // so we would better consider i+1 with i+2\\n                i++;\\n            }\\n            if(count == p) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884801,
                "title": "python-easy-to-understand-fastest",
                "content": "# Python | Easy to Understand | FASTEST\\n```\\nclass Solution:\\n   def minimizeMax(self, A: List[int], p: int) -> int:\\n        A.sort()\\n        n = len(A)\\n        left, right = 0, A[-1] - A[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            k = 0\\n            i = 1\\n            while i < n:\\n                if A[i] - A[i - 1] <= mid:\\n                    k += 1\\n                    i += 1\\n                i += 1\\n            if k >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n   def minimizeMax(self, A: List[int], p: int) -> int:\\n        A.sort()\\n        n = len(A)\\n        left, right = 0, A[-1] - A[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            k = 0\\n            i = 1\\n            while i < n:\\n                if A[i] - A[i - 1] <= mid:\\n                    k += 1\\n                    i += 1\\n                i += 1\\n            if k >= p:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884794,
                "title": "c-easy-to-understand-binary-search-fastest",
                "content": "# C++ | Easy to Understand | Binary Search | Fastest\\n```\\nclass Solution {\\npublic:\\n     int minimizeMax(vector<int>& A, int p) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minimizeMax(vector<int>& A, int p) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), left = 0, right = A[n - 1] - A[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2, k = 0;\\n            for (int i = 1; i < n && k < p; ++i) {\\n                if (A[i] - A[i - 1] <= mid) {\\n                    k++;\\n                    i++;\\n                }\\n            }\\n            if (k >= p)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884709,
                "title": "python-3-optimised-fast-beats-88-please-upvote",
                "content": "**GITHUB LINK:** https://github.com/ghanshyam2/pythonProject/tree/master/LeetCode\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N.logV)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        def form_pairs(max_allow):\\n            pairs = 0\\n            num = 0\\n            while num + 1 < N:\\n                if nums[num + 1] - nums[num] <= max_allow:\\n                    pairs += 1\\n                    num += 1\\n                num += 1\\n            return pairs >= p\\n\\n        N = len(nums)\\n        nums.sort()\\n        left,right = 0, (nums[-1]- nums[0])\\n\\n        while left<right:\\n            mid = left+(right-left)//2\\n            if form_pairs(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n**$$PLEASE UPVOTE$$**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        def form_pairs(max_allow):\\n            pairs = 0\\n            num = 0\\n            while num + 1 < N:\\n                if nums[num + 1] - nums[num] <= max_allow:\\n                    pairs += 1\\n                    num += 1\\n                num += 1\\n            return pairs >= p\\n\\n        N = len(nums)\\n        nums.sort()\\n        left,right = 0, (nums[-1]- nums[0])\\n\\n        while left<right:\\n            mid = left+(right-left)//2\\n            if form_pairs(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884537,
                "title": "c-solution-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(nlog(max(nums) - min(num)) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        int n= nums.Length, left = 0,  right = nums[n-1] - nums[0];\\n\\n        while(left < right){\\n            int mid = (left+right)/2, k = 0;\\n\\n            for(int i=1; i<n && k < p; ++i){\\n                if(nums[i] - nums[i-1] <= mid){\\n                    k++;\\n                    i++;\\n                }\\n            }\\n\\n            if(k >= p){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        Array.Sort(nums);\\n        int n= nums.Length, left = 0,  right = nums[n-1] - nums[0];\\n\\n        while(left < right){\\n            int mid = (left+right)/2, k = 0;\\n\\n            for(int i=1; i<n && k < p; ++i){\\n                if(nums[i] - nums[i-1] <= mid){\\n                    k++;\\n                    i++;\\n                }\\n            }\\n\\n            if(k >= p){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884461,
                "title": "c-java-binary-search-on-answer-similar-problems",
                "content": "## Explanation\\nWhenever the problem asks us to find the Maximum of Minimums, of Minimum of Maximums think of using Binary Search. What will be the range of the answer? If the potential answers fall within a limited range, employing Binary Search on those potential answers becomes a viable strategy!!\\n\\nPractice [List of Similar Problems](https://leetcode.com/list/r75rfnvh) to get a good hold in Binary Search Problems\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    int check(vector<int> &nums, int diff, int p){\\n        int n = size(nums);\\n\\n        // Go greedily\\n        for(int i = 0; i < n - 1; i++){\\n            // If difference between two characters is less than diff\\n            if(abs(nums[i] - nums[i + 1]) <= diff){\\n                // make this a pair and go to nums[i + 2], nums[i + 3] for comparison\\n                p--, i++;\\n            }\\n            // if all pairs are chosen\\n            if(!p) break;\\n        }\\n        // if all pairs are picked, then diff could be an answer\\n        return p == 0;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        // We are finding the minimum of maximums - Hint for Binary Search\\n        int n = size(nums);\\n        // Order of array elements don\\'t matter. So, sort the array\\n        sort(begin(nums), end(nums));\\n\\n        // The range in which answer could lie is (0, nums[n - 1] - nums[n - 2])\\n        int l = 0, r = nums[n - 1] - nums[n - 2], res = 0;\\n\\n        // Same BS on Answer template\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(check(nums, mid, p)){\\n                res = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int check(int[] nums, int diff, int p) {\\n        int n = nums.length;\\n\\n        // Go greedily\\n        for (int i = 0; i < n - 1; i++) {\\n            // If difference between two elements is less than diff\\n            if (Math.abs(nums[i] - nums[i + 1]) <= diff) {\\n                // make this a pair and go to nums[i + 2], nums[i + 3] for comparison\\n                p--;\\n                i++;\\n            }\\n            // if all pairs are chosen\\n            if (p == 0) {\\n                break;\\n            }\\n        }\\n        // if all pairs are picked, then diff could be an answer\\n        return p == 0 ? 1 : 0;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n\\n        // We are finding the minimum of maximums - Hint for Binary Search\\n        int n = nums.length;\\n        // Order of array elements don\\'t matter. So, sort the array\\n        Arrays.sort(nums);\\n\\n        // The range in which answer could lie is (0, nums[n - 1] - nums[0])\\n        int l = 0, r = nums[n - 1] - nums[0], res = 0;\\n\\n        // Same BS on Answer template\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(nums, mid, p) == 1) {\\n                res = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    int check(vector<int> &nums, int diff, int p){\\n        int n = size(nums);\\n\\n        // Go greedily\\n        for(int i = 0; i < n - 1; i++){\\n            // If difference between two characters is less than diff\\n            if(abs(nums[i] - nums[i + 1]) <= diff){\\n                // make this a pair and go to nums[i + 2], nums[i + 3] for comparison\\n                p--, i++;\\n            }\\n            // if all pairs are chosen\\n            if(!p) break;\\n        }\\n        // if all pairs are picked, then diff could be an answer\\n        return p == 0;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        // We are finding the minimum of maximums - Hint for Binary Search\\n        int n = size(nums);\\n        // Order of array elements don\\'t matter. So, sort the array\\n        sort(begin(nums), end(nums));\\n\\n        // The range in which answer could lie is (0, nums[n - 1] - nums[n - 2])\\n        int l = 0, r = nums[n - 1] - nums[n - 2], res = 0;\\n\\n        // Same BS on Answer template\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(check(nums, mid, p)){\\n                res = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int check(int[] nums, int diff, int p) {\\n        int n = nums.length;\\n\\n        // Go greedily\\n        for (int i = 0; i < n - 1; i++) {\\n            // If difference between two elements is less than diff\\n            if (Math.abs(nums[i] - nums[i + 1]) <= diff) {\\n                // make this a pair and go to nums[i + 2], nums[i + 3] for comparison\\n                p--;\\n                i++;\\n            }\\n            // if all pairs are chosen\\n            if (p == 0) {\\n                break;\\n            }\\n        }\\n        // if all pairs are picked, then diff could be an answer\\n        return p == 0 ? 1 : 0;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n\\n        // We are finding the minimum of maximums - Hint for Binary Search\\n        int n = nums.length;\\n        // Order of array elements don\\'t matter. So, sort the array\\n        Arrays.sort(nums);\\n\\n        // The range in which answer could lie is (0, nums[n - 1] - nums[0])\\n        int l = 0, r = nums[n - 1] - nums[0], res = 0;\\n\\n        // Same BS on Answer template\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(nums, mid, p) == 1) {\\n                res = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884445,
                "title": "simple-c-binary-search-approach",
                "content": "# Approach:\\n> has been explained in the code stepwise through comments.\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums, int p, int diff) {\\n        int cnt = 0;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] - nums[i - 1] <= diff) {\\n                cnt++;\\n                i++; // ensure no index appears more than once amongst the p pairs.\\n            }\\n        }\\n        if(cnt >= p) return true; //  we kept `cnt >= p`, because\\n            // if `cnt == p`, then what if `p` was `0` in Question since then `cnt` already \\n            // would have been greater than `p`. Also we don\\'t place if`(cnt >= p)` inside \\n            // for loop because then what if we had an INPUT as `[1]` (edge case) then \\n            // we don\\'t go inside the for loop and the condition won\\'t have been \\n            // checked thus we place `if(cnt >= p) return true;` outside for loop \\n            // so as even if for loop isn\\'t executed we `return true` and get \\n            //`high = mid - 1`, thus approaching minimum difference of `0` which we return ulimately\\n        return false;\\n    }\\n    int minimizeMax(vector<int> &nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0, mid, high = nums[nums.size() - 1] - nums[0];\\n\\n        while(low <= high) {\\n            mid = low + (high - low) / 2;\\n            /* since if isPossible returns true then we try to move towards \\n            a getting a more smaller value as our difference */\\n            if(isPossible(nums, p, mid)) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n# Kindly upvote if this answer helps you !!",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums, int p, int diff) {\\n        int cnt = 0;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] - nums[i - 1] <= diff) {\\n                cnt++;\\n                i++; // ensure no index appears more than once amongst the p pairs.\\n            }\\n        }\\n        if(cnt >= p) return true; //  we kept `cnt >= p`, because\\n            // if `cnt == p`, then what if `p` was `0` in Question since then `cnt` already \\n            // would have been greater than `p`. Also we don\\'t place if`(cnt >= p)` inside \\n            // for loop because then what if we had an INPUT as `[1]` (edge case) then \\n            // we don\\'t go inside the for loop and the condition won\\'t have been \\n            // checked thus we place `if(cnt >= p) return true;` outside for loop \\n            // so as even if for loop isn\\'t executed we `return true` and get \\n            //`high = mid - 1`, thus approaching minimum difference of `0` which we return ulimately\\n        return false;\\n    }\\n    int minimizeMax(vector<int> &nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0, mid, high = nums[nums.size() - 1] - nums[0];\\n\\n        while(low <= high) {\\n            mid = low + (high - low) / 2;\\n            /* since if isPossible returns true then we try to move towards \\n            a getting a more smaller value as our difference */\\n            if(isPossible(nums, p, mid)) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884378,
                "title": "java-easy-to-read-understand-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n\\n        int start = 0;\\n        int end = Integer.MAX_VALUE;\\n        int diffAns = 0;\\n\\n        while(start <= end){\\n            int mid = end - (end - start)/2;\\n\\n            if(isPossible(nums,mid) >= p){\\n                diffAns = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return diffAns;\\n    }\\n\\n    public int isPossible(int nums[], int target){\\n        int count = 0;\\n\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if((nums[i]-nums[i-1]) <= target){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n\\n        int start = 0;\\n        int end = Integer.MAX_VALUE;\\n        int diffAns = 0;\\n\\n        while(start <= end){\\n            int mid = end - (end - start)/2;\\n\\n            if(isPossible(nums,mid) >= p){\\n                diffAns = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return diffAns;\\n    }\\n\\n    public int isPossible(int nums[], int target){\\n        int count = 0;\\n\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if((nums[i]-nums[i-1]) <= target){\\n                count++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884320,
                "title": "using-binary-search-typescript-solution-100-beats-all",
                "content": "# Code\\n```\\nfunction minimizeMax(nums: number[], p: number): number {\\n    if(p === 0) return 0\\n    const sortedArray: number[] = nums.sort((n1, n2) => n1 - n2);\\n    const checkValue = (value: number): boolean => {\\n        let i = 0\\n        let count = 0\\n        while (i < nums.length - 1) {\\n            if (Math.floor(sortedArray[i + 1] - sortedArray[i]) <= value) {\\n                count++\\n                i = i + 2\\n            } else {\\n                i = i + 1\\n            }\\n            if (count === p) return true\\n        }\\n        return false\\n    }\\n    let left: number = 0\\n    let right: number = 10 ** 9 - 1\\n    let ans: number = 10 ** 9\\n    while (left <= right) {\\n        const mid = Math.floor((left + right) / 2)\\n        if (checkValue(mid)) {\\n            right = mid - 1\\n            ans = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction minimizeMax(nums: number[], p: number): number {\\n    if(p === 0) return 0\\n    const sortedArray: number[] = nums.sort((n1, n2) => n1 - n2);\\n    const checkValue = (value: number): boolean => {\\n        let i = 0\\n        let count = 0\\n        while (i < nums.length - 1) {\\n            if (Math.floor(sortedArray[i + 1] - sortedArray[i]) <= value) {\\n                count++\\n                i = i + 2\\n            } else {\\n                i = i + 1\\n            }\\n            if (count === p) return true\\n        }\\n        return false\\n    }\\n    let left: number = 0\\n    let right: number = 10 ** 9 - 1\\n    let ans: number = 10 ** 9\\n    while (left <= right) {\\n        const mid = Math.floor((left + right) / 2)\\n        if (checkValue(mid)) {\\n            right = mid - 1\\n            ans = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884300,
                "title": "c-easy-and-clean-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int mid,int p){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=mid){\\n                cnt++;i++;\\n            }\\n        }\\n        if(cnt>=p) return true;\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int left=0,right=nums[n-1]-nums[0];\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            if(check(nums,mid,p)) right=mid;\\n            else left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int mid,int p){\\n        int cnt=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=mid){\\n                cnt++;i++;\\n            }\\n        }\\n        if(cnt>=p) return true;\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int left=0,right=nums[n-1]-nums[0];\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            if(check(nums,mid,p)) right=mid;\\n            else left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884289,
                "title": "binary-search-very-easy-c-beats-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly **Sort** the Array and Apply **Binary Search** to **Search the Answer** in the Range **[Minimum Difference, Maximum Difference]** and Return **Minimum Value**.\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int> arr,int k,int p)\\n    {\\n        int i = 1;\\n        while(i<arr.size() && p>0)\\n        {\\n            if(arr[i]-arr[i-1]<=k)\\n            {\\n                p-=1;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& arr, int p) {\\n        sort(arr.begin(),arr.end());\\n        int left = 0,right = arr[arr.size()-1]-arr[0],ans = -1;\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,p))\\n            {\\n               right = mid-1; \\n               ans = mid;\\n            } \\n            else left = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/d7b50b06-597b-419d-8b90-184ad3724481_1691552147.2848382.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int> arr,int k,int p)\\n    {\\n        int i = 1;\\n        while(i<arr.size() && p>0)\\n        {\\n            if(arr[i]-arr[i-1]<=k)\\n            {\\n                p-=1;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& arr, int p) {\\n        sort(arr.begin(),arr.end());\\n        int left = 0,right = arr[arr.size()-1]-arr[0],ans = -1;\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,p))\\n            {\\n               right = mid-1; \\n               ans = mid;\\n            } \\n            else left = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884223,
                "title": "100-faster-binary-search-solution-intution-approach",
                "content": "# Intuition\\njust think about nimary serach to minimise the difference betweeen pairs\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1->Sort the Array because without you will be getting larger difference and we want ot get minimum differences.\\n2->set s=0,e=arr[n-1] - arr[0].\\n3->do binary search on differences possible and check which mid \\ngives you paircnt = p.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& arr, int p) {\\n        int n = arr.size();\\n        if(n == 1 || p==0) return 0;\\n        if(n==2) return abs(arr[1]-arr[0]);\\n        sort(arr.begin(),arr.end());\\n        int s=0;\\n        int e = arr.back() - arr.front();\\n        int ans=0;\\n        while(s<e){\\n            int mid = (s+e)>>1;\\n            int cnt=0;\\n            for(int i=1;i<n;i++){\\n                if(mid >= abs(arr[i]-arr[i-1])){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            if(cnt>=p){\\n                e=mid;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n\\n        return s;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& arr, int p) {\\n        int n = arr.size();\\n        if(n == 1 || p==0) return 0;\\n        if(n==2) return abs(arr[1]-arr[0]);\\n        sort(arr.begin(),arr.end());\\n        int s=0;\\n        int e = arr.back() - arr.front();\\n        int ans=0;\\n        while(s<e){\\n            int mid = (s+e)>>1;\\n            int cnt=0;\\n            for(int i=1;i<n;i++){\\n                if(mid >= abs(arr[i]-arr[i-1])){\\n                    cnt++;\\n                    i++;\\n                }\\n            }\\n            if(cnt>=p){\\n                e=mid;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n\\n        return s;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884209,
                "title": "minimize-the-maximum-difference-of-pairs-daily-leetcode-c-9-august",
                "content": "Code:\\n```\\nint minimizeMax(vector<int>& n, int p) {\\n    sort(begin(n), end(n));\\n    int l = 0, r = n.back() - n.front();\\n    while (l < r) {\\n        int m = (l + r) / 2, cnt = 0;\\n        for (int i = 0; i + 1 < n.size(); ++i)\\n            if (m >= (n[i + 1] - n[i])) {\\n                ++cnt;\\n                ++i;\\n            }\\n        if (cnt >= p)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint minimizeMax(vector<int>& n, int p) {\\n    sort(begin(n), end(n));\\n    int l = 0, r = n.back() - n.front();\\n    while (l < r) {\\n        int m = (l + r) / 2, cnt = 0;\\n        for (int i = 0; i + 1 < n.size(); ++i)\\n            if (m >= (n[i + 1] - n[i])) {\\n                ++cnt;\\n                ++i;\\n            }\\n        if (cnt >= p)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884159,
                "title": "o-nlogn-beats-99-binary-search-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nN~10E5, if N^2 then too large, at most NlogN -> binary search + greedy\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search + Greedy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        if p == 0: return 0     # edge\\n\\n        def check(x):   # greedy\\n            cnt = 0\\n            i = 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= x:\\n                    cnt += 1\\n                    if cnt >= p: return True\\n                    i += 2\\n                else:\\n                    i += 1\\n            return False\\n        \\n        left, right = 0, nums[-1] - nums[0] # binary search\\n        ans = 0\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if check(mid):\\n                ans = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        if p == 0: return 0     # edge\\n\\n        def check(x):   # greedy\\n            cnt = 0\\n            i = 1\\n            while i < n:\\n                if nums[i] - nums[i - 1] <= x:\\n                    cnt += 1\\n                    if cnt >= p: return True\\n                    i += 2\\n                else:\\n                    i += 1\\n            return False\\n        \\n        left, right = 0, nums[-1] - nums[0] # binary search\\n        ans = 0\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if check(mid):\\n                ans = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884138,
                "title": "beats-90-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &nums,int mid,int p)\\n    {\\n    int count = 0;\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        if(nums[i]-nums[i-1]<=mid)\\n        {\\n            count++;\\n            i++;\\n        }\\n    }\\n\\n    if(count>=p)\\n    return true;\\n    else\\n    return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int r = nums.back();\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = r-(r-l)/2;\\n            if(solve(nums,mid,p))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l= mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &nums,int mid,int p)\\n    {\\n    int count = 0;\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        if(nums[i]-nums[i-1]<=mid)\\n        {\\n            count++;\\n            i++;\\n        }\\n    }\\n\\n    if(count>=p)\\n    return true;\\n    else\\n    return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int l = 0;\\n        int r = nums.back();\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = r-(r-l)/2;\\n            if(solve(nums,mid,p))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l= mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457345,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(nums.length==1)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        Arrays.sort(nums);\\n        int low=0,high=nums[nums.length-1]-nums[0];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int i=1;\\n            int count=0;\\n            while(i<nums.length)\\n            {\\n                if(nums[i]-nums[i-1]<=mid)\\n                {\\n                    count++;\\n                    i=i+2;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            if(count>=p)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(nums.length==1)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        Arrays.sort(nums);\\n        int low=0,high=nums[nums.length-1]-nums[0];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int i=1;\\n            int count=0;\\n            while(i<nums.length)\\n            {\\n                if(nums[i]-nums[i-1]<=mid)\\n                {\\n                    count++;\\n                    i=i+2;\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            if(count>=p)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413650,
                "title": "binary-search-solution-easy-beginner-friendly-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_possible(vector<int>& nums, int p, int k){\\n        int cnt = 0;\\n        int n = nums.size();\\n        set<int>st; st.insert(nums[0]);\\n        for(int i=1; i<n; i++){\\n            auto itr = st.lower_bound(nums[i]-k);\\n            if(itr==st.end()){\\n                st.insert(nums[i]); continue;\\n            }\\n            if(*itr>=(nums[i]-k)){\\n                cnt++; st.erase(itr);\\n            }\\n            else st.insert(nums[i]);\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        int i=0, j=1e9, ans = 0;\\n        sort(nums.begin(),nums.end());\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(is_possible(nums,p,mid)){\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_possible(vector<int>& nums, int p, int k){\\n        int cnt = 0;\\n        int n = nums.size();\\n        set<int>st; st.insert(nums[0]);\\n        for(int i=1; i<n; i++){\\n            auto itr = st.lower_bound(nums[i]-k);\\n            if(itr==st.end()){\\n                st.insert(nums[i]); continue;\\n            }\\n            if(*itr>=(nums[i]-k)){\\n                cnt++; st.erase(itr);\\n            }\\n            else st.insert(nums[i]);\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        int i=0, j=1e9, ans = 0;\\n        sort(nums.begin(),nums.end());\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n            if(is_possible(nums,p,mid)){\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else{\\n                i = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408310,
                "title": "c-solution-binary-search-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n * log(max_difference))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> &nums, int p, int guess){\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i=0;i<n;){\\n            if(i+1 < n && nums[i+1]-nums[i] <= guess) {count++; i+=2;}\\n            else i++;\\n        }\\n        return (count >= p);\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int lo = 0, hi = nums[n-1]-nums[0];\\n        int ans = hi;\\n        while(lo <= hi){\\n            int mid = (lo+hi) / 2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> &nums, int p, int guess){\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i=0;i<n;){\\n            if(i+1 < n && nums[i+1]-nums[i] <= guess) {count++; i+=2;}\\n            else i++;\\n        }\\n        return (count >= p);\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int lo = 0, hi = nums[n-1]-nums[0];\\n        int ans = hi;\\n        while(lo <= hi){\\n            int mid = (lo+hi) / 2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397256,
                "title": "simple-c-code-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is(vector<int> v,int ans,int p,int n)\\n    {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(v[i+1]-v[i]<=ans)\\n           {\\n               i++;\\n               p--;\\n           }   \\n       }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n         int l=0,r=1e9;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(is(nums,mid,p,n))\\n                r=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(vector<int> v,int ans,int p,int n)\\n    {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(v[i+1]-v[i]<=ans)\\n           {\\n               i++;\\n               p--;\\n           }   \\n       }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n         int l=0,r=1e9;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(is(nums,mid,p,n))\\n                r=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396963,
                "title": "c-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    bool check(vector<int> &nums, int p, int mid) {\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] - nums[i - 1] <= mid) {\\n                p--; i++;\\n            }\\n        }\\n        return p <= 0;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0, high = nums[nums.size() - 1] - nums[0], ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, p, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    bool check(vector<int> &nums, int p, int mid) {\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] - nums[i - 1] <= mid) {\\n                p--; i++;\\n            }\\n        }\\n        return p <= 0;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0, high = nums[nums.size() - 1] - nums[0], ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, p, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396940,
                "title": "swift-solution-using-binary-search-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    func minimizeMax(_ nums: [Int], _ p: Int) -> Int {\\n        let nums = nums.sorted()\\n        var l = 0\\n        var r = nums.last! - nums.first!\\n\\n        while l < r {\\n            let m = (l + r - 1) / 2\\n            var i = 0\\n            var c = 0\\n            while i < nums.count - 1 {\\n                defer { i += 1 }\\n                if nums[i + 1] - nums[i] <= m {\\n                    c += 1\\n                    i += 1\\n                }\\n            }\\n\\n            if c >= p {\\n                r = m\\n            } else {\\n                l = m + 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeMax(_ nums: [Int], _ p: Int) -> Int {\\n        let nums = nums.sorted()\\n        var l = 0\\n        var r = nums.last! - nums.first!\\n\\n        while l < r {\\n            let m = (l + r - 1) / 2\\n            var i = 0\\n            var c = 0\\n            while i < nums.count - 1 {\\n                defer { i += 1 }\\n                if nums[i + 1] - nums[i] <= m {\\n                    c += 1\\n                    i += 1\\n                }\\n            }\\n\\n            if c >= p {\\n                r = m\\n            } else {\\n                l = m + 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395982,
                "title": "binary-search-explained-c-tc-o-nlogn-sc-o-1",
                "content": "# Intuition\\nMost of the times problem which states to \"minimize the maximum\"or to \"maximize the minimum\" is solved by binary search . \\n\\n# Approach\\nWe sort the vector, knowing that the minimum difference of pairs/elements must be in sorted order. \\n\\nThen we binary search for the possible answer. If that answer is possible (if our boolean function f return true) we store it and search for smaller answer , else we look for bigger answer.\\n\\nIn the boolean function **\"f(int mid, vector<int>& nums, int p)\"**\\nwe count the number of pairs which are less than/equal to our possible answer \\'mid\\' ==>**\"(nums[i]-nums[i-1] <=mid)\"**\\n and we increase the iterator by 1  ==>\"i++\" because pair elements in answer need to be unique. At last we check that our count is atleast greater than the number of pairs, if it is we return true else false.\\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        bool f(int mid, vector<int>& nums, int p)\\n        {\\n            int cnt=0;\\n             for(int i=1;i<nums.size();i++)\\n             {\\n                 if(nums[i]-nums[i-1] <=mid){i++;cnt++;}\\n             }\\n            return cnt>=p;\\n        }\\n       int minimizeMax(vector<int>& nums, int p) {\\n     sort(nums.begin(), nums.end());\\n      \\n           int lo = 0,hi = 1e9;\\n           int ans=-1;\\n           while(lo<=hi)\\n           {\\n               int mid= (lo+hi)>>1;\\n               \\n               if(f(mid,nums,p))\\n               {\\n                   ans = mid;\\n                   hi = mid-1;\\n               }\\n               else lo = mid+1;\\n           }\\n             return ans;\\n     \\n           \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        bool f(int mid, vector<int>& nums, int p)\\n        {\\n            int cnt=0;\\n             for(int i=1;i<nums.size();i++)\\n             {\\n                 if(nums[i]-nums[i-1] <=mid){i++;cnt++;}\\n             }\\n            return cnt>=p;\\n        }\\n       int minimizeMax(vector<int>& nums, int p) {\\n     sort(nums.begin(), nums.end());\\n      \\n           int lo = 0,hi = 1e9;\\n           int ans=-1;\\n           while(lo<=hi)\\n           {\\n               int mid= (lo+hi)>>1;\\n               \\n               if(f(mid,nums,p))\\n               {\\n                   ans = mid;\\n                   hi = mid-1;\\n               }\\n               else lo = mid+1;\\n           }\\n             return ans;\\n     \\n           \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395790,
                "title": "binary-search-greedy",
                "content": "# Intuition\\nThe brute force way to do this is to try all possible pairs, which clearly will not run in time.\\n\\nWe might try to optimize this by doing some kind of dynamic programming, but this could take as much as $$O(n^2)$$, which is too slow. As such, we need a greedy solution or something faster.\\n\\nOne thing we can notice is that the problem becomes a lot easier if we are given a maximum possible difference and have to determine whether or not this difference is achievable. This is a big hint to **binary search**!\\n\\n# Approach\\nBinary search for the answer. To determine whether an answer is valid, greedily pick pairs. We always want to pick pairs of `nums` that are adjacent when `nums` is sorted; otherwise, we could do at least as good by swapping with an element that is adjacent.\\n\\nIf some `m` is achievable, then we can search to the left of `m`. Otherwise, search to the right.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\lg(\\\\max(nums) - \\\\min(nums)))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        n = len(nums)\\n        \\n        nums.sort()\\n        \\n        l, r = 0, max(nums) - min(nums)\\n        while l < r:\\n            m = (l + r) // 2\\n            \\n            pairs = 0\\n            prev = False\\n            for i in range(1, n):\\n                if nums[i] - nums[i - 1] <= m and not prev:\\n                    pairs += 1\\n                    prev = True\\n                else:\\n                    prev = False\\n            \\n            if pairs < p:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        n = len(nums)\\n        \\n        nums.sort()\\n        \\n        l, r = 0, max(nums) - min(nums)\\n        while l < r:\\n            m = (l + r) // 2\\n            \\n            pairs = 0\\n            prev = False\\n            for i in range(1, n):\\n                if nums[i] - nums[i - 1] <= m and not prev:\\n                    pairs += 1\\n                    prev = True\\n                else:\\n                    prev = False\\n            \\n            if pairs < p:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395681,
                "title": "cpp-binary-search",
                "content": "\\n\\n### If you helpful this solution, Please Upvote\\n\\n### Approach \\n* We quick realise this question on binary search bcz we need to maximize the mininum diff between two pairs \\n* We guess our ans and maximize using binary search\\n\\n### Time Complexity - `O(N Log(N))`\\n### Space Complexity - `O(1)`\\n\\n\\n### Solution \\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // sort the nums array\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ans = 0;\\n        int lo = 0, hi = nums.back() - nums.front();\\n        \\n        // check given condition here -> we need to maximize the mininum diff between two pairs \\n        auto ok = [&](int guess) {\\n            int pairs = 0, last = nums[0], i = 1;\\n            while(i < n) {\\n                if(nums[i] - last <= guess) {\\n                    pairs++;\\n                    if(i < n - 2) {\\n                        last = nums[i + 1];\\n                        i++;\\n                    }else break;\\n                }else last = nums[i];\\n                i++;\\n            }\\n            return pairs >= p;\\n        };\\n        \\n        // binary search \\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if(ok(mid)) {\\n                ans = mid;\\n                hi = mid - 1;\\n            }else lo = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n##### Thank You!\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        // sort the nums array\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ans = 0;\\n        int lo = 0, hi = nums.back() - nums.front();\\n        \\n        // check given condition here -> we need to maximize the mininum diff between two pairs \\n        auto ok = [&](int guess) {\\n            int pairs = 0, last = nums[0], i = 1;\\n            while(i < n) {\\n                if(nums[i] - last <= guess) {\\n                    pairs++;\\n                    if(i < n - 2) {\\n                        last = nums[i + 1];\\n                        i++;\\n                    }else break;\\n                }else last = nums[i];\\n                i++;\\n            }\\n            return pairs >= p;\\n        };\\n        \\n        // binary search \\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            if(ok(mid)) {\\n                ans = mid;\\n                hi = mid - 1;\\n            }else lo = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098484,
                "title": "bs-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function(nums, p) {\\n    nums.sort((a, b) => a - b);\\n    let l = 0, r = nums[nums.length - 1];\\n    let res = nums[nums.length - 1];\\n    while( l <= r){\\n        let m =  l + Math.floor((r - l)/ 2);\\n        if(isValid(m, nums, p)){\\n            res = m;\\n            r = m - 1;\\n        }else l = m + 1;\\n    }\\n    return res;\\n    \\n};\\n\\nvar isValid = (t, nums, p) => {\\n    let i = 1, count = 0;\\n    while(i < nums.length){\\n        if(nums[i] - nums[i - 1] <= t){\\n            count++;\\n            i = i + 2;\\n        } else i++;\\n    }\\n    return count>=p;;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function(nums, p) {\\n    nums.sort((a, b) => a - b);\\n    let l = 0, r = nums[nums.length - 1];\\n    let res = nums[nums.length - 1];\\n    while( l <= r){\\n        let m =  l + Math.floor((r - l)/ 2);\\n        if(isValid(m, nums, p)){\\n            res = m;\\n            r = m - 1;\\n        }else l = m + 1;\\n    }\\n    return res;\\n    \\n};\\n\\nvar isValid = (t, nums, p) => {\\n    let i = 1, count = 0;\\n    while(i < nums.length){\\n        if(nums[i] - nums[i - 1] <= t){\\n            count++;\\n            i = i + 2;\\n        } else i++;\\n    }\\n    return count>=p;;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064785,
                "title": "step-by-step-solution-c-binary-search",
                "content": "# Approach\\n\\n```cpp\\nstd::vector<int> nums = {10, 1, 2, 7, 1, 3};\\nint p = 2;\\n```\\n\\n1. **Sorting the Input Vector**:\\n   - After sorting `nums`, we get: `{1, 1, 2, 3, 7, 10}`.\\n\\n2. **Initialize Variables**:\\n   - `left` is initially set to 0.\\n   - `right` is initially set to `10 - 1`, which is 9.\\n\\n3. **Binary Search**:\\n   - The binary search begins.\\n\\n4. **Iteration 1**:\\n   - Calculate the midpoint: `mid = (0 + 9) / 2 = 4`.\\n   - Call `can_form_pairs(nums, 4, 2)`.\\n\\n   - Inside `can_form_pairs`, we check if we can form 2 pairs of integers such that the maximum difference within each pair is less than or equal to 4.\\n   - Pair 1: (1, 1), maximum difference = 1 - 1 = 0 (valid).\\n   - Pair 2: (2, 3), maximum difference = 3 - 2 = 1 (valid).\\n\\n   - We have successfully formed 2 valid pairs, which satisfies the condition of `p = 2`. Therefore, `can_form_pairs` returns `true`.\\n\\n   - Update `right` to `mid`, so `right` becomes 4.\\n\\n5. **Iteration 2**:\\n   - Calculate the new midpoint: `mid = (0 + 4) / 2 = 2`.\\n   - Call `can_form_pairs(nums, 2, 2)`.\\n\\n   - Inside `can_form_pairs`, we check if we can form 2 pairs of integers with a maximum difference less than or equal to 2.\\n   - Pair 1: (1, 1), maximum difference = 1 - 1 = 0 (valid).\\n   - Pair 2: (2, 3), maximum difference = 3 - 2 = 1 (valid).\\n\\n   - We have successfully formed 2 valid pairs, which satisfies the condition of `p = 2`. Therefore, `can_form_pairs` returns `true`.\\n\\n   - Update `right` to `mid`, so `right` becomes 2.\\n\\n**Iteration 3**:\\n   - Calculate the new midpoint: `mid = (0 + 2) / 2 = 1`.\\n   - Call `can_form_pairs(nums, 1, 2)`.\\n\\n   - Inside `can_form_pairs`, we check if we can form 2 pairs of integers with a maximum difference less than or equal to 1.\\n   - Pair 1: (1, 1), maximum difference = 1 - 1 = 0 (valid).\\n   - Pair 2: (2, 3), maximum difference = 3 - 2 = 1 (valid).\\n\\n   - We have successfully formed 2 valid pairs, which satisfies the condition of `p = 2`. Therefore, `can_form_pairs` returns `true`.\\n\\n   - Update `right` to `mid`, so `right` becomes 1.\\n\\n**Iteration 4**:\\n   - Calculate the new midpoint: `mid = (0 + 1) / 2 = 0`.\\n   - Call `can_form_pairs(nums, 0, 2)`.\\n\\n   - Inside `can_form_pairs`, we check if we can form 2 pairs of integers with a maximum difference less than or equal to 0.\\n   - Pair 1: (1, 1), maximum difference = 1 - 1 = 0 (valid).\\n\\n   - We have successfully formed 1 valid pair, but we need 2 pairs. `can_form_pairs` returns `false`.\\n\\n   - Update `left` to `mid + 1`, so `left` remains 1.\\n\\n**Iteration 5**:\\n   - At this point, `left` (1) is no longer less than `right` (1), so the binary search loop exits.\\n\\n**Return the Result**:\\n   - The function returns `left`, which is 1.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogm) `n` : length of array. `m` : differnce of maximum and minmun value  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp\\nstd::vector<int> nums = {10, 1, 2, 7, 1, 3};\\nint p = 2;\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007395,
                "title": "fastest-solution-in-python-518ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo need for a binary search - we should be able to calculate this with one pass\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOverall approach:\\n\\n1. Sort nums and calculate the difference between consecutive elements.\\nThen sort the differences, retaining the index.\\n\\n2. Looking at each difference in order from the smallest, imagine a list of runs of differences we have seen (a \\'run\\' being a list of differences with consecutive indices)\\n\\nWe know, for example, that from any run of differences of length 7, we can safely take 4 pairs while ensuring that no index appears more than once.\\n\\n3. We use an array to store the parity (odd/even) length of the run, at both the start and end of the run. The end of the run refers to the index at start, and vice versa, so that we can reach the opposite end of the run and update the information there.\\n\\n4. When we look at a new difference, examine the indices either side and observe if this difference will create a new run, or append to existing run(s) of odd or even length(s). This is enough to determine whether we can safely take an additional pair.\\n\\n5. As soon as we can safely take enough pairs, return the difference that we are looking at: the smallest that allows that many pairs.\\n\\n\\nA few speed-ups:\\n\\n1. If p=0 then immediately return 0, as per the last sentence of the specification.\\n2.  If p is max possible for the length of nums, we would need to take all differences at even indices. Immediately return the largest difference with even index.\\n    *This suggests a significant further speed-up is possible if p is close to the max (not implemented)\\n3.  Lower bound is the pth largest difference; upper bound is (2p-1)th largest difference. If these differences are the same, return it immediately.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) - limited by search\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if (p == 0):\\n            return 0\\n\\n        nums.sort()\\n\\n        lenpairs = len(nums) - 1\\n        pairs = [(nums[i+1] - nums[i],i) for i in range(lenpairs)]\\n        pairs.sort()\\n\\n        if lenpairs == 2*p-1:\\n            (pp,index) = pairs.pop()\\n            while (index%2 == 1):\\n                (pp,index) = pairs.pop()\\n            return pp\\n                \\n        dictmin = pairs[p-1][0]\\n        dictmax = pairs[2*p-2][0]\\n\\n        if (dictmin == dictmax):\\n            return dictmin\\n\\n        runs = {}\\n        for (pair,i) in pairs:\\n            startofrun = i\\n            endofrun = i\\n            prelengtheven = True\\n            postlengtheven = True\\n            \\n            if (i-1) in runs:\\n                (startofrun,prelengtheven) = runs[i-1]\\n                \\n            if (i+1) in runs:\\n                (endofrun,postlengtheven) = runs[i+1]\\n               \\n            if prelengtheven and postlengtheven:\\n                p = p - 1\\n                if (p == 0):\\n                    return pair\\n            \\n            evenlength = postlengtheven != prelengtheven\\n            runs[startofrun] = (endofrun,evenlength)\\n            runs[endofrun] = (startofrun,evenlength)\\n            \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if (p == 0):\\n            return 0\\n\\n        nums.sort()\\n\\n        lenpairs = len(nums) - 1\\n        pairs = [(nums[i+1] - nums[i],i) for i in range(lenpairs)]\\n        pairs.sort()\\n\\n        if lenpairs == 2*p-1:\\n            (pp,index) = pairs.pop()\\n            while (index%2 == 1):\\n                (pp,index) = pairs.pop()\\n            return pp\\n                \\n        dictmin = pairs[p-1][0]\\n        dictmax = pairs[2*p-2][0]\\n\\n        if (dictmin == dictmax):\\n            return dictmin\\n\\n        runs = {}\\n        for (pair,i) in pairs:\\n            startofrun = i\\n            endofrun = i\\n            prelengtheven = True\\n            postlengtheven = True\\n            \\n            if (i-1) in runs:\\n                (startofrun,prelengtheven) = runs[i-1]\\n                \\n            if (i+1) in runs:\\n                (endofrun,postlengtheven) = runs[i+1]\\n               \\n            if prelengtheven and postlengtheven:\\n                p = p - 1\\n                if (p == 0):\\n                    return pair\\n            \\n            evenlength = postlengtheven != prelengtheven\\n            runs[startofrun] = (endofrun,evenlength)\\n            runs[endofrun] = (startofrun,evenlength)\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003004,
                "title": "intuitive-solution-binary-search-and-greedy-select-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCombinatorial solution is too expensive. Has to be greedy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort array\\n- Create array of diffs of adjacent numbers\\n- Max possible difference is the max of the above array\\n- Binary search for min of max difference\\n- At each step of binary search count pairs that fall at or below max allowed difference for that step\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\'\\'\\'\\n        >>> print(Solution().minimizeMax([1,1,0,3], 2))\\n        2\\n        >>> print(Solution().minimizeMax([1,1,0,3], 0))\\n        0\\n        >>> print(Solution().minimizeMax([4,2,1,2], 1))\\n        0\\n        >>> print(Solution().minimizeMax([4,0,2,1,2,5,5,3], 3))\\n        1\\n        >>> print(Solution().minimizeMax([3,6,11,6,8,6,5,3,3,7], 3))\\n        1\\n        >>> print(Solution().minimizeMax([1,2], 1))\\n        1\\n        \\'\\'\\'\\n        if p == 0: return 0\\n        nums.sort()\\n        diffs = lambda : (abs(x - y) for x, y in zip(nums, nums[1:]))\\n        left, right = (0, max(diffs()) + 1)\\n        while left < right:\\n            maxdiff = (left + right) // 2\\n            pairs, curdiff = (0, -1)\\n            diffiter = iter(diffs())\\n            for diff in diffiter:\\n                if diff <= maxdiff:\\n                    pairs += 1\\n                    curdiff = max(curdiff, diff)\\n                    next(diffiter, None) # skip next number\\n            if pairs < p:\\n                left = maxdiff + 1\\n            else:\\n                right = maxdiff\\n        return left if pairs < p else curdiff\\n\\nif __name__ == \"__main__\":\\n    import doctest\\n    doctest.testmod()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        \\'\\'\\'\\n        >>> print(Solution().minimizeMax([1,1,0,3], 2))\\n        2\\n        >>> print(Solution().minimizeMax([1,1,0,3], 0))\\n        0\\n        >>> print(Solution().minimizeMax([4,2,1,2], 1))\\n        0\\n        >>> print(Solution().minimizeMax([4,0,2,1,2,5,5,3], 3))\\n        1\\n        >>> print(Solution().minimizeMax([3,6,11,6,8,6,5,3,3,7], 3))\\n        1\\n        >>> print(Solution().minimizeMax([1,2], 1))\\n        1\\n        \\'\\'\\'\\n        if p == 0: return 0\\n        nums.sort()\\n        diffs = lambda : (abs(x - y) for x, y in zip(nums, nums[1:]))\\n        left, right = (0, max(diffs()) + 1)\\n        while left < right:\\n            maxdiff = (left + right) // 2\\n            pairs, curdiff = (0, -1)\\n            diffiter = iter(diffs())\\n            for diff in diffiter:\\n                if diff <= maxdiff:\\n                    pairs += 1\\n                    curdiff = max(curdiff, diff)\\n                    next(diffiter, None) # skip next number\\n            if pairs < p:\\n                left = maxdiff + 1\\n            else:\\n                right = maxdiff\\n        return left if pairs < p else curdiff\\n\\nif __name__ == \"__main__\":\\n    import doctest\\n    doctest.testmod()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963465,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Value\\'s Min diff will be with adjacent value => So we sort first \\n2) Difference range from 0 to n : We can do BS or Linear search \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     private boolean isPossible(int[] nums, int p, int diff){\\n        int n = nums.length;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums[n-1]-nums[0];\\n        int ans = right;\\n        while(left<=right){\\n            int mid = (left+right)/2;\\n            if(isPossible(nums, p, mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     private boolean isPossible(int[] nums, int p, int diff){\\n        int n = nums.length;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    public int minimizeMax(int[] nums, int p) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums[n-1]-nums[0];\\n        int ans = right;\\n        while(left<=right){\\n            int mid = (left+right)/2;\\n            if(isPossible(nums, p, mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961213,
                "title": "cpp-solution-using-recursion-memoisation-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int p, int i, vector<vector<int>> &dp)\\n    {\\n        if(p == 0)\\n            return 0;\\n\\n        if(i >= nums.size())\\n            return INT_MAX;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int inc = INT_MAX;\\n        if(i < nums.size() - 1)\\n            inc = max(abs(nums[i] - nums[i + 1]), solve(nums, p - 1, i + 2, dp));\\n\\n        int exc = solve(nums, p, i + 1, dp);\\n\\n        return dp[i][p] = min(inc, exc);\\n    }\\n\\n    bool check(int mid, vector<int> &nums, int p)\\n    {\\n        int i = 0;\\n        while(i < nums.size() - 1)\\n        {\\n            if(mid >= abs(nums[i] - nums[i + 1]))\\n            {\\n                --p;\\n                i += 2;\\n            }\\n            else\\n                i++;\\n\\n        }\\n\\n        if( p <= 0)\\n            return true;\\n\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        //vector<vector<int>>dp(nums.size() + 1, vector<int>(p + 1, -1));\\n        //return solve(nums, p, 0, dp);\\n        \\n        int s = 0, e = nums.back(), ans = 0;\\n\\n        while(s <= e)\\n        {\\n            int mid = (s + e) >> 1; // right shift means divide by 2\\n\\n            if(check(mid, nums, p))\\n            {\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else\\n                s = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int p, int i, vector<vector<int>> &dp)\\n    {\\n        if(p == 0)\\n            return 0;\\n\\n        if(i >= nums.size())\\n            return INT_MAX;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int inc = INT_MAX;\\n        if(i < nums.size() - 1)\\n            inc = max(abs(nums[i] - nums[i + 1]), solve(nums, p - 1, i + 2, dp));\\n\\n        int exc = solve(nums, p, i + 1, dp);\\n\\n        return dp[i][p] = min(inc, exc);\\n    }\\n\\n    bool check(int mid, vector<int> &nums, int p)\\n    {\\n        int i = 0;\\n        while(i < nums.size() - 1)\\n        {\\n            if(mid >= abs(nums[i] - nums[i + 1]))\\n            {\\n                --p;\\n                i += 2;\\n            }\\n            else\\n                i++;\\n\\n        }\\n\\n        if( p <= 0)\\n            return true;\\n\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(), nums.end());\\n        //vector<vector<int>>dp(nums.size() + 1, vector<int>(p + 1, -1));\\n        //return solve(nums, p, 0, dp);\\n        \\n        int s = 0, e = nums.back(), ans = 0;\\n\\n        while(s <= e)\\n        {\\n            int mid = (s + e) >> 1; // right shift means divide by 2\\n\\n            if(check(mid, nums, p))\\n            {\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else\\n                s = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958688,
                "title": "python3-simplest-binary-search-solution-readable-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p==0:\\n            return 0\\n        n=len(nums)\\n        nums.sort()\\n        def canFormPairs(pairDiff):\\n            curPairs=0\\n            i=0\\n            while (i+1)<n: \\n                if nums[i+1]-nums[i]<=pairDiff:\\n                    curPairs+=1\\n                    i+=2\\n                else:\\n                    i+=1\\n                if curPairs==p:\\n                    return True\\n            return False\\n        low,high=0,nums[-1]-nums[0]\\n        ans=-1\\n        while low<=high:\\n            mid=(low+high)>>1\\n            if canFormPairs(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p==0:\\n            return 0\\n        n=len(nums)\\n        nums.sort()\\n        def canFormPairs(pairDiff):\\n            curPairs=0\\n            i=0\\n            while (i+1)<n: \\n                if nums[i+1]-nums[i]<=pairDiff:\\n                    curPairs+=1\\n                    i+=2\\n                else:\\n                    i+=1\\n                if curPairs==p:\\n                    return True\\n            return False\\n        low,high=0,nums[-1]-nums[0]\\n        ans=-1\\n        while low<=high:\\n            mid=(low+high)>>1\\n            if canFormPairs(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955325,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        if(p == 0)\\n            return 0;\\n\\n        Array.Sort(nums);\\n        int ans = int.MaxValue, low = 0, high = nums[^1] - nums[0];\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(IsPossible(nums, p, mid)) {\\n                ans = Math.Min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] nums, int p, int diff) {\\n        int i = 0, j = 1;\\n        while(j < nums.Length) {\\n            if(nums[j] - nums[i] <= diff) {\\n                if(--p == 0)\\n                    return true;\\n                    \\n                i = j++;\\n            }\\n\\n            if(++i == j)\\n                j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizeMax(int[] nums, int p) {\\n        if(p == 0)\\n            return 0;\\n\\n        Array.Sort(nums);\\n        int ans = int.MaxValue, low = 0, high = nums[^1] - nums[0];\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(IsPossible(nums, p, mid)) {\\n                ans = Math.Min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] nums, int p, int diff) {\\n        int i = 0, j = 1;\\n        while(j < nums.Length) {\\n            if(nums[j] - nums[i] <= diff) {\\n                if(--p == 0)\\n                    return true;\\n                    \\n                i = j++;\\n            }\\n\\n            if(++i == j)\\n                j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949635,
                "title": "binary-search-on-answers-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(maxDiff))$$ where maxDiff is max(nums) - min(nums) \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    bool can_form_p_pairs(int diff, vector<int>& nums, int p)\\n    {\\n        int i = 1, currPairs = 0;\\n        //greedily count the no. of pairs having diffrence less than \\'diff\\'\\n        while(i < nums.size())\\n        {\\n            if(nums[i] - nums[i-1] <= diff)\\n            {\\n             currPairs++;\\n             i += 2;\\n            }\\n            else\\n             i++;\\n        }\\n    return currPairs >= p; //return whether we were able to make at least p pairs or not\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums[nums.size()-1] - nums[0], mid;\\n        //perform binary search on all possible values of differences\\n        while(low <= high)\\n        {\\n         mid = low + (high-low)/2;\\n         //if we can form at least p pairs with diff = mid\\n         if(can_form_p_pairs(mid,nums,p))\\n          high = mid - 1; //then, we will try for a smaller difference\\n         else\\n          low = mid + 1; //otherwise, we go for a higher difference\\n        }\\n     return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool can_form_p_pairs(int diff, vector<int>& nums, int p)\\n    {\\n        int i = 1, currPairs = 0;\\n        //greedily count the no. of pairs having diffrence less than \\'diff\\'\\n        while(i < nums.size())\\n        {\\n            if(nums[i] - nums[i-1] <= diff)\\n            {\\n             currPairs++;\\n             i += 2;\\n            }\\n            else\\n             i++;\\n        }\\n    return currPairs >= p; //return whether we were able to make at least p pairs or not\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums[nums.size()-1] - nums[0], mid;\\n        //perform binary search on all possible values of differences\\n        while(low <= high)\\n        {\\n         mid = low + (high-low)/2;\\n         //if we can form at least p pairs with diff = mid\\n         if(can_form_p_pairs(mid,nums,p))\\n          high = mid - 1; //then, we will try for a smaller difference\\n         else\\n          low = mid + 1; //otherwise, we go for a higher difference\\n        }\\n     return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944477,
                "title": "java-with-binary-search-beats-98-89-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nalways try to put low= lowest element , and high= highest element which we can reach, \\na number lets say k, and diff<=k. so that no of diff should be >=p, out of which we will calculate lowest one, so j=mid-1;\\n\\n# Complexity\\n- Time complexity:98.89%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:69%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums[nums.length-1]-nums[0];\\n        //int sol=0;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            int count=0;\\n            for(int k=0;k<nums.length-1;k++)\\n            {\\n                if(nums[k+1]-nums[k]<=mid)\\n                {\\n                    count++;\\n                    k++;\\n                }\\n            }\\n            if(count>=p)\\n            {\\n                //sol=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n\\n        }\\n        return i;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums[nums.length-1]-nums[0];\\n        //int sol=0;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            int count=0;\\n            for(int k=0;k<nums.length-1;k++)\\n            {\\n                if(nums[k+1]-nums[k]<=mid)\\n                {\\n                    count++;\\n                    k++;\\n                }\\n            }\\n            if(count>=p)\\n            {\\n                //sol=mid;\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n\\n        }\\n        return i;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938449,
                "title": "c-sorting-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n} + \\\\log{maxDiff})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int p, int maxDiff) {\\n        int cnt = 1;\\n        for (int i = 1; i < nums.size(); ++ i) {\\n            if (nums[i] - nums[i - 1] > maxDiff) {\\n                p -= cnt / 2;\\n                cnt = 1;\\n            } else ++ cnt;\\n        }\\n        p -= cnt / 2;\\n        return p <= 0;\\n    } \\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p == 0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int lo = 0, hi = 0, mid, res;\\n        for (int i = 1; i < nums.size(); ++ i) hi = max(hi, nums[i] - nums[i - 1]);\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (isValid(nums, p, mid)) {\\n                res = mid;\\n                hi = mid - 1;\\n            } else lo = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int p, int maxDiff) {\\n        int cnt = 1;\\n        for (int i = 1; i < nums.size(); ++ i) {\\n            if (nums[i] - nums[i - 1] > maxDiff) {\\n                p -= cnt / 2;\\n                cnt = 1;\\n            } else ++ cnt;\\n        }\\n        p -= cnt / 2;\\n        return p <= 0;\\n    } \\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if (p == 0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int lo = 0, hi = 0, mid, res;\\n        for (int i = 1; i < nums.size(); ++ i) hi = max(hi, nums[i] - nums[i - 1]);\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (isValid(nums, p, mid)) {\\n                res = mid;\\n                hi = mid - 1;\\n            } else lo = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928079,
                "title": "easy-solution-commented",
                "content": "# Complexity\\n- Time complexity: O(NlogM) where \\n- M is the differnece between maximum and minimum value in the array\\n- and N is the size of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# PLS UPVOTE IF YOU liked the SOLUTION :)\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n\\n        // setting ranges for minimum and maximum pair difference\\n        int low=0,high=nums[nums.size()-1]-nums[0];\\n        int ans=-1;\\n        while(low<=high){\\n            // guessing the minimised maximum difference \\n            int mid=low+(high-low)/2;\\n\\n            int pairs=0;\\n            int i=0;\\n\\n            //logic to check if that differnce gets satisfied\\n            // by checking the consecutive difference and\\n            // trying to form a pair and setting the pointer\\n            // at correct position after a pair is picked\\n            while(i<nums.size()-1){\\n                if(pairs==p) break;\\n                \\n                if(nums[i+1]-nums[i]<=mid){\\n                    pairs++;\\n                    i+=2;\\n                }else{\\n                    i++;\\n                }\\n            }\\n            // difference satisfied\\n            if(pairs==p){\\n                high=mid-1;\\n                ans=mid;\\n            }\\n            // difference not satisfied\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n\\n        // setting ranges for minimum and maximum pair difference\\n        int low=0,high=nums[nums.size()-1]-nums[0];\\n        int ans=-1;\\n        while(low<=high){\\n            // guessing the minimised maximum difference \\n            int mid=low+(high-low)/2;\\n\\n            int pairs=0;\\n            int i=0;\\n\\n            //logic to check if that differnce gets satisfied\\n            // by checking the consecutive difference and\\n            // trying to form a pair and setting the pointer\\n            // at correct position after a pair is picked\\n            while(i<nums.size()-1){\\n                if(pairs==p) break;\\n                \\n                if(nums[i+1]-nums[i]<=mid){\\n                    pairs++;\\n                    i+=2;\\n                }else{\\n                    i++;\\n                }\\n            }\\n            // difference satisfied\\n            if(pairs==p){\\n                high=mid-1;\\n                ans=mid;\\n            }\\n            // difference not satisfied\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926434,
                "title": "c-65-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(std::vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        \\n        int left = 0, right = nums.back() - nums.front();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (can_form_pairs(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool can_form_pairs(const std::vector<int>& nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.size() - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925710,
                "title": "non-binary-search-and-not-dependent-on-output-size-slow-on-test-cases-but-asymptotically-fast",
                "content": "# Intuition\\nThis is complicated, but worth sharing because I noticed that some of the faster solutions depend on the output size.\\n\\nIf the input integers were unbounded in precision, then this approach would technically be asymptotically faster.\\n\\nThe idea is to sort indices into the difference array based on the difference array value and index value.\\n\\nFrom there, merge \"intervals\" of indices from left to right such that the value k, which represents the number of non-overlapping differences considered, is less than or equal to p. Once k is equal to p, we can stop.\\n\\nThe key is to notice that while intervals are merged, sometimes a new value is considered in the optimal set of pairs for a given k. The condition that this occurs is exactly when the left and right sizes of intervals that flank the newly considered element are both even in size.\\n\\n# Approach\\nThe approach is somewhat challenging to explain. Ultimately, induction is used to assert that the answer is correct.\\n\\nThe code is relatively straightforward to understand.\\nThere is some unusual stuff in there regarding the \"intervals\" of consecutive indices that are considered. The idea is that each consecutive difference could overlap and therefore preclude that combination of consecutive differences if care is not taken; Thus, \"intervals\" which represent consecutive indices under consideration are used to account for this.\\n\\nEach interval is initially aware of only itself as a single element. The indices already considered are kept track of by making use of a vector of bools.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        std::vector<int> diff(nums.size() - 1, 0);\\n        for(int i = nums.size() - 1; i > 0; --i){\\n            diff[i - 1] = nums[i] - nums[i - 1];\\n        }\\n        std::vector<int> diff_indices(diff.size(), 0);\\n        std::iota(diff_indices.begin(), diff_indices.end(), 0);\\n        const auto cmp = [&](const int index1, const int index2){\\n            return (diff[index1] == diff[index2] && index1 < index2) || diff[index1] < diff[index2];\\n        };\\n        std::sort(diff_indices.begin(), diff_indices.end(), cmp);\\n        const int n = diff.size();\\n        std::vector<int> left(n, 0), right(n, 0);\\n        std::iota(left.begin(), left.end(), 0);\\n        std::iota(right.begin(), right.end(), 0);\\n        std::vector<bool> visited(n, false);\\n        int max_val = 0;\\n        int k = 0;\\n        for(int i = 0; i < n && k < p; ++i){\\n            const int index = diff_indices[i];\\n            visited[index] = true;\\n            int left_index = index, right_index = index;\\n            int left_size = 0, right_size = 0;\\n            if(index > 0 && visited[index - 1]){\\n                left_index = left[index - 1];\\n                left_size = index - left_index;\\n                right_index = index;\\n                right[left_index] = index;\\n                left[index] = left_index;\\n            }\\n            if(index + 1 < n && visited[index + 1]){\\n                left_index = left[index];\\n                right_index = right[index + 1];\\n                right_size = right_index - index;\\n                right[left_index] = right_index;\\n                left[right_index] = left_index;\\n            }\\n            const bool even_sizes = !(right_size & 1) && !(left_size & 1);\\n            if(even_sizes){\\n                max_val = diff[index];\\n            }\\n            k += even_sizes;\\n        }\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        std::sort(nums.begin(), nums.end());\\n        std::vector<int> diff(nums.size() - 1, 0);\\n        for(int i = nums.size() - 1; i > 0; --i){\\n            diff[i - 1] = nums[i] - nums[i - 1];\\n        }\\n        std::vector<int> diff_indices(diff.size(), 0);\\n        std::iota(diff_indices.begin(), diff_indices.end(), 0);\\n        const auto cmp = [&](const int index1, const int index2){\\n            return (diff[index1] == diff[index2] && index1 < index2) || diff[index1] < diff[index2];\\n        };\\n        std::sort(diff_indices.begin(), diff_indices.end(), cmp);\\n        const int n = diff.size();\\n        std::vector<int> left(n, 0), right(n, 0);\\n        std::iota(left.begin(), left.end(), 0);\\n        std::iota(right.begin(), right.end(), 0);\\n        std::vector<bool> visited(n, false);\\n        int max_val = 0;\\n        int k = 0;\\n        for(int i = 0; i < n && k < p; ++i){\\n            const int index = diff_indices[i];\\n            visited[index] = true;\\n            int left_index = index, right_index = index;\\n            int left_size = 0, right_size = 0;\\n            if(index > 0 && visited[index - 1]){\\n                left_index = left[index - 1];\\n                left_size = index - left_index;\\n                right_index = index;\\n                right[left_index] = index;\\n                left[index] = left_index;\\n            }\\n            if(index + 1 < n && visited[index + 1]){\\n                left_index = left[index];\\n                right_index = right[index + 1];\\n                right_size = right_index - index;\\n                right[left_index] = right_index;\\n                left[right_index] = left_index;\\n            }\\n            const bool even_sizes = !(right_size & 1) && !(left_size & 1);\\n            if(even_sizes){\\n                max_val = diff[index];\\n            }\\n            k += even_sizes;\\n        }\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914729,
                "title": "python-n-log-n-not-n-log-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0:\\n            return 0\\n        nums.sort()\\n        differences = set()\\n        for i in range(1, len(nums)):\\n            differences.add(nums[i] - nums[i-1])\\n        differences = sorted(differences)\\n        def test(pivot):\\n            i = 1\\n            count = 0\\n            while i < len(nums):\\n                if nums[i]-nums[i-1] <= pivot:\\n                    count += 1\\n                    if count == p:\\n                        return True\\n                    i += 1 # i += 2 in effect\\n                i += 1\\n            return False\\n        frm, to = 0, len(differences)\\n        while frm < to:\\n            pivot = frm + (to - frm) // 2\\n            if test(differences[pivot]):\\n                to = pivot\\n            else:\\n                frm = pivot + 1\\n        return differences[to]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0:\\n            return 0\\n        nums.sort()\\n        differences = set()\\n        for i in range(1, len(nums)):\\n            differences.add(nums[i] - nums[i-1])\\n        differences = sorted(differences)\\n        def test(pivot):\\n            i = 1\\n            count = 0\\n            while i < len(nums):\\n                if nums[i]-nums[i-1] <= pivot:\\n                    count += 1\\n                    if count == p:\\n                        return True\\n                    i += 1 # i += 2 in effect\\n                i += 1\\n            return False\\n        frm, to = 0, len(differences)\\n        while frm < to:\\n            pivot = frm + (to - frm) // 2\\n            if test(differences[pivot]):\\n                to = pivot\\n            else:\\n                frm = pivot + 1\\n        return differences[to]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904910,
                "title": "kotlin-binary-search-optimized-greedy-approach",
                "content": "# Intuition\\nThe first thing to do is to sort the array, to prevent unnecessary checks (just the closest numbers).\\nThen the intuition is to go greedy, because it works perfectly. If you check it on paper, it is sufficient to check every index i until we find one that satisfies: $$ nums[i+1]-nums[i] <= t $$. But we need to jump over 2 indices, if we find match to prevent counting the same index into two distinct pairs. This is all that our thresholdCount function should do, just iterate the array and check how many pairs are under threshold. \\nThen we need to try out every threshold from $$ t=0 $$ until $$ t=last(nums)-first(nums)$$.\\nThe edge case is p = 0, where we just need to return 0\\n\\nOur working solution should look like this:\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n) + n*(max(nums)-min(nums)))$$\\n\\n- Space complexity:\\n$$O(n)$$ used by the sort algo\\n\\n# Code (greedy)\\n```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        nums.sort()\\n        var t = 0\\n        while (thresholdCount(nums, p, t) != p) t++\\n        return t\\n    }\\n\\n    private fun thresholdCount(nums: IntArray, p: Int, t: Int): Int {\\n        var cnt = 0\\n        var i = 0\\n        while (i < nums.size-1) {\\n            val diff = nums[i+1] - nums[i]\\n            if (diff <= t) {\\n                cnt ++\\n                i += 2\\n            } else {\\n                i++\\n            }\\n\\n            if (cnt >= p) {\\n                return cnt\\n            }\\n        }\\n        \\n        return cnt\\n    }\\n}\\n```\\n\\nThis works, but the closer our threshold is to maximum difference, the worse is the performance, this can be costly.\\nFortunately, we don\\'t need to do $$max(nums)-min(nums)$$ checks. We just need to do $$log(max(nums)-min(nums))$$ if we think about it a little bit:\\n\\n- if there is threshold t that satisfies condition $$ thresholdCount(nums, t) >= p  $$ that must mean that all thresholds larger than t also satisfies this condition, because we loosen our requirements. So we must search left of threshold to find the smallest possible one. Otherwise we must increase the threshold. We can do this with binary search.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n) + n*log(max(nums)-min(nums)))$$\\n\\n- Space complexity:\\n$$O(n)$$ used by the sort algo\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        if (p == 0) return 0\\n        nums.sort()\\n\\n        var left = 0\\n        var right = nums.last() - nums.first()\\n\\n        while (left < right) {\\n            val mid = (left+right)/2\\n\\n            if (thresholdCount(nums, p, mid) == p) {\\n                // threshold is equal or less than, go left\\n                right = mid\\n            } else {\\n                // threshold is more than mid, go right and jump over mid\\n                left = mid+1\\n            }\\n        }\\n\\n        return left\\n    }\\n\\n    private fun thresholdCount(nums: IntArray, p: Int, t: Int): Int {\\n        var cnt = 0\\n        var i = 0\\n        while (i < nums.size-1) {\\n            val diff = nums[i+1] - nums[i]\\n            if (diff <= t) {\\n                cnt ++\\n                i += 2\\n            } else {\\n                i++\\n            }\\n\\n            if (cnt >= p) {\\n                return cnt\\n            }\\n        }\\n        \\n        return cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        nums.sort()\\n        var t = 0\\n        while (thresholdCount(nums, p, t) != p) t++\\n        return t\\n    }\\n\\n    private fun thresholdCount(nums: IntArray, p: Int, t: Int): Int {\\n        var cnt = 0\\n        var i = 0\\n        while (i < nums.size-1) {\\n            val diff = nums[i+1] - nums[i]\\n            if (diff <= t) {\\n                cnt ++\\n                i += 2\\n            } else {\\n                i++\\n            }\\n\\n            if (cnt >= p) {\\n                return cnt\\n            }\\n        }\\n        \\n        return cnt\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimizeMax(nums: IntArray, p: Int): Int {\\n        if (p == 0) return 0\\n        nums.sort()\\n\\n        var left = 0\\n        var right = nums.last() - nums.first()\\n\\n        while (left < right) {\\n            val mid = (left+right)/2\\n\\n            if (thresholdCount(nums, p, mid) == p) {\\n                // threshold is equal or less than, go left\\n                right = mid\\n            } else {\\n                // threshold is more than mid, go right and jump over mid\\n                left = mid+1\\n            }\\n        }\\n\\n        return left\\n    }\\n\\n    private fun thresholdCount(nums: IntArray, p: Int, t: Int): Int {\\n        var cnt = 0\\n        var i = 0\\n        while (i < nums.size-1) {\\n            val diff = nums[i+1] - nums[i]\\n            if (diff <= t) {\\n                cnt ++\\n                i += 2\\n            } else {\\n                i++\\n            }\\n\\n            if (cnt >= p) {\\n                return cnt\\n            }\\n        }\\n        \\n        return cnt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901197,
                "title": "no-need-to-evaluate-difference-again-and-again-c-binary-search-greedy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int &assume,vector<int> &diff,int &p)\\n    {\\n        int pass = 0;\\n\\n        for(int ind=0;ind<diff.size();ind++)\\n        {\\n            if(diff[ind]<=assume)\\n            {\\n                pass++;\\n                ind++;\\n\\n                if(pass>=p)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return pass>=p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        int size = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int left = 0;\\n        int right = nums[size-1];\\n        int mid = 0;\\n        \\n        vector<int> diff;\\n\\n        for(int ind=1;ind<nums.size();ind++)\\n        {\\n            diff.push_back(abs(nums[ind-1]-nums[ind]));\\n        }\\n\\n        while(left<right)\\n        {\\n            mid = left+(right-left)/2;\\n\\n            if(isValid(mid,diff,p))\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int &assume,vector<int> &diff,int &p)\\n    {\\n        int pass = 0;\\n\\n        for(int ind=0;ind<diff.size();ind++)\\n        {\\n            if(diff[ind]<=assume)\\n            {\\n                pass++;\\n                ind++;\\n\\n                if(pass>=p)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return pass>=p;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        int size = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int left = 0;\\n        int right = nums[size-1];\\n        int mid = 0;\\n        \\n        vector<int> diff;\\n\\n        for(int ind=1;ind<nums.size();ind++)\\n        {\\n            diff.push_back(abs(nums[ind-1]-nums[ind]));\\n        }\\n\\n        while(left<right)\\n        {\\n            mid = left+(right-left)/2;\\n\\n            if(isValid(mid,diff,p))\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898241,
                "title": "simple-binary-search-with-explanation",
                "content": "# Intuition\\n1. According to constraints numbers can be upto $$10^5$$ so lets try binary search after sorting.\\n2. If we can somehow find $$p$$ pairs having minimum value $$minval$$ then we can binary search on it.\\n3. We can indeed find it in linear iteration after sorting. lets see how in later section.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array.\\n2. Binary serach of `| mininum difference | `. i.e. if that `| minimum difference |` is available try for lower otherwise upper.\\n3. For getting `| minimum difference |` we can iterate on sorted array and take only adjacent element into consideration. \\n4. If any pair has abs difference less than or equal to given we will consider it and increase two pointer so that we can\\'t reconsider this pairs again ( why because they are the only points that result in minimum difference )\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int [] ar;\\n    int n ;\\n    int last_index;\\n    int required_pairs;\\n    public int minimizeMax(int[] nums, int p) {\\n        // set variables and sorting\\n        ar = nums;\\n        ArrayList <Integer> arlist = new ArrayList<> ();\\n        for(int a : ar){\\n            arlist.add(a);\\n        }\\n        Collections.sort(arlist);\\n        int i = 0;\\n        for(int a : arlist){\\n            ar[i] = arlist.get(i);\\n            i++;\\n        }\\n        n = nums.length;\\n        last_index = n - 1;\\n        required_pairs = p;\\n\\n        // handle 0 case separately\\n        if(p == 0){\\n            return 0;\\n        }\\n\\n\\n        // binary search\\n        int min_dif = 0;\\n        int max_dif = ar[last_index];\\n\\n        int ans = 0;\\n        while(min_dif <= max_dif){\\n            int mid = (min_dif + max_dif)/2;\\n            if(is_possible(mid)){\\n                ans = mid;\\n                max_dif = mid -1;\\n            }else{\\n                min_dif = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean is_possible(int dif){\\n        // linear iteration to find difference <= diff\\n        int count = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            int cur = ar[i];\\n            int next = ar[i+1];\\n            if(Math.abs(cur - next)<=dif){\\n                i+=1;\\n                count++;\\n            }\\n        }\\n        if(count >= required_pairs){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    int [] ar;\\n    int n ;\\n    int last_index;\\n    int required_pairs;\\n    public int minimizeMax(int[] nums, int p) {\\n        // set variables and sorting\\n        ar = nums;\\n        ArrayList <Integer> arlist = new ArrayList<> ();\\n        for(int a : ar){\\n            arlist.add(a);\\n        }\\n        Collections.sort(arlist);\\n        int i = 0;\\n        for(int a : arlist){\\n            ar[i] = arlist.get(i);\\n            i++;\\n        }\\n        n = nums.length;\\n        last_index = n - 1;\\n        required_pairs = p;\\n\\n        // handle 0 case separately\\n        if(p == 0){\\n            return 0;\\n        }\\n\\n\\n        // binary search\\n        int min_dif = 0;\\n        int max_dif = ar[last_index];\\n\\n        int ans = 0;\\n        while(min_dif <= max_dif){\\n            int mid = (min_dif + max_dif)/2;\\n            if(is_possible(mid)){\\n                ans = mid;\\n                max_dif = mid -1;\\n            }else{\\n                min_dif = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean is_possible(int dif){\\n        // linear iteration to find difference <= diff\\n        int count = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            int cur = ar[i];\\n            int next = ar[i+1];\\n            if(Math.abs(cur - next)<=dif){\\n                i+=1;\\n                count++;\\n            }\\n        }\\n        if(count >= required_pairs){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895388,
                "title": "t-c-o-nlogn",
                "content": "# Intuition \\nTo find the minimum in the answers \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntake low=0 because the minimum value in the array is when there is same two values appear, and high=nums[n-1]-nums[0] the maximum diff. after sorting\\nnow eleminate low and high based on the function that returns the no of pairs.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int mid){\\n\\n        int cnt=0;\\n\\n        for(int i=1;i<arr.size();i++){\\n\\n            if((arr[i] - arr[i-1]) <= mid){\\n                cnt++;\\n                i++;//as mention in ques. if pairs found the index will not repeat\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int low=0,high=nums[n-1]-nums[0];\\n\\n        while(low <= high){\\n\\n            int mid=(low+high)/2;\\n\\n            int k=solve(nums,mid);\\n\\n            if(k >= p){\\n                high=mid-1;\\n            }\\n\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int mid){\\n\\n        int cnt=0;\\n\\n        for(int i=1;i<arr.size();i++){\\n\\n            if((arr[i] - arr[i-1]) <= mid){\\n                cnt++;\\n                i++;//as mention in ques. if pairs found the index will not repeat\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int low=0,high=nums[n-1]-nums[0];\\n\\n        while(low <= high){\\n\\n            int mid=(low+high)/2;\\n\\n            int k=solve(nums,mid);\\n\\n            if(k >= p){\\n                high=mid-1;\\n            }\\n\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894140,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int count(vector<int> &nums,int threshold)\\n    {\\n        int ct;\\n        ct=0;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[i]<=threshold)\\n            {\\n                ct++;\\n                i++;\\n            }\\n        }\\n\\n        return ct;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        sort(nums.begin(),nums.end());\\n\\n        int n,low,mid,high;\\n        n=nums.size();\\n        low=0;\\n        high=nums[n-1]-nums[0];\\n\\n        while(low<high)\\n        {\\n            mid=low+(high-low)/2;\\n\\n            if(count(nums,mid)>=p)\\n            {\\n                high=mid;\\n            }\\n\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }   \\n\\n        return low; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int count(vector<int> &nums,int threshold)\\n    {\\n        int ct;\\n        ct=0;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[i]<=threshold)\\n            {\\n                ct++;\\n                i++;\\n            }\\n        }\\n\\n        return ct;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        sort(nums.begin(),nums.end());\\n\\n        int n,low,mid,high;\\n        n=nums.size();\\n        low=0;\\n        high=nums[n-1]-nums[0];\\n\\n        while(low<high)\\n        {\\n            mid=low+(high-low)/2;\\n\\n            if(count(nums,mid)>=p)\\n            {\\n                high=mid;\\n            }\\n\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }   \\n\\n        return low; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892696,
                "title": "javascript-binary-search-greedy",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  const n = nums.length;\\n  nums.sort((a, b) => a - b);\\n  let ans = null;\\n  let low = 0;\\n  let high = nums[n - 1];\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(nums, mid, p, n)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction isOk(nums, target, p, n) {\\n  let count = 0;\\n  let i = 0;\\n  while (i < n - 1) {\\n    if (nums[i + 1] - nums[i] <= target) {\\n      count++;\\n      i += 2;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return count >= p;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  const n = nums.length;\\n  nums.sort((a, b) => a - b);\\n  let ans = null;\\n  let low = 0;\\n  let high = nums[n - 1];\\n\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(nums, mid, p, n)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction isOk(nums, target, p, n) {\\n  let count = 0;\\n  let i = 0;\\n  while (i < n - 1) {\\n    if (nums[i + 1] - nums[i] <= target) {\\n      count++;\\n      i += 2;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return count >= p;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892341,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  nums.sort((a, b) => a-b);\\n  let sz = nums.length;\\n  var cvp = (trh) => {\\n    let idx = 0, cnt = 0;\\n    while (idx < sz - 1) {\\n      if (nums[idx + 1] - nums[idx] <= trh) {\\n        cnt++;\\n        idx++;\\n      }\\n      idx++;\\n    }\\n    return cnt;\\n  };\\n  let l = 0, r = nums[sz-1] - nums[0];\\n  while (l < r) {\\n    let m = l + parseInt((r - l) / 2);\\n    if (cvp(m) >= p) r = m;\\n    else l = m + 1;\\n  }\\n  return l;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function (nums, p) {\\n  nums.sort((a, b) => a-b);\\n  let sz = nums.length;\\n  var cvp = (trh) => {\\n    let idx = 0, cnt = 0;\\n    while (idx < sz - 1) {\\n      if (nums[idx + 1] - nums[idx] <= trh) {\\n        cnt++;\\n        idx++;\\n      }\\n      idx++;\\n    }\\n    return cnt;\\n  };\\n  let l = 0, r = nums[sz-1] - nums[0];\\n  while (l < r) {\\n    let m = l + parseInt((r - l) / 2);\\n    if (cvp(m) >= p) r = m;\\n    else l = m + 1;\\n  }\\n  return l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891659,
                "title": "java-c-python-binary-search",
                "content": "In the given code, the algorithm uses binary search to find the minimum maximum difference that can be achieved when forming `p` pairs of indices from the sorted `nums` array. The goal is to minimize this maximum difference among all possible pairs.\\n\\n\\n1. `l` and `r` are two pointers used to bound the possible range of the minimum maximum difference. Initially, `l` starts from 0 (minimum possible difference) and `r` starts from the maximum difference between the largest and smallest elements in the sorted array (`nums[nums.length - 1] - nums[0]`).\\n\\n2. The binary search iteratively tries to find the best value for the minimum maximum difference. It calculates the middle value `m` between `l` and `r` and then checks if it\\'s possible to form `p` pairs with a maximum difference less than or equal to `m`.\\n\\n3. The inner loop iterates through the sorted array, comparing adjacent elements and checking if the difference between them (`nums[i] - nums[i - 1]`) is less than or equal to the current middle value `m`. If it is, it means we can consider this pair in our count, and we increment both `i` and `k`.\\n\\n4. The binary search adjusts the pointers based on the value of `k` after the inner loop. If `k` equals `p`, it means we were able to find `p` pairs with a maximum difference less than or equal to `m`, and we try to find a smaller value for the minimum maximum difference by adjusting the right pointer `r` to `m - 1`.\\n\\n5. If `k` is less than `p`, it means we couldn\\'t find `p` pairs with a maximum difference less than or equal to `m`, and we need to increase the minimum maximum difference. Therefore, we adjust the left pointer `l` to `m + 1`.\\n\\n6. The binary search continues until `l` is greater than `r`, at which point it has found the smallest possible value for the minimum maximum difference, and this value is stored in `l`.\\n\\nSince `l` represents the smallest value for the minimum maximum difference that can be achieved with `p` pairs of indices, the function returns `l`. It\\'s worth noting that `r` could also be a valid answer, but it might not always represent the smallest value, so we choose the smaller value between `l` and `r`.\\n```\\npublic int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int l = 0, r = nums[nums.length - 1] - nums[0];\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            int k = 0;\\n            for (int i = 1; i < nums.length && k < p; i++) {\\n                if (nums[i] - nums[i - 1] <= m) {\\n                    i++;\\n                    k++;\\n                }\\n            }\\n            if (k == p) {\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int l = 0, r = nums[nums.length - 1] - nums[0];\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            int k = 0;\\n            for (int i = 1; i < nums.length && k < p; i++) {\\n                if (nums[i] - nums[i - 1] <= m) {\\n                    i++;\\n                    k++;\\n                }\\n            }\\n            if (k == p) {\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891463,
                "title": "binary-search-optimal-approach-no-extra-space",
                "content": "# Approach\\nThe code uses a binary search approach to find the minimum possible maximum difference between pairs of elements in the sorted array nums such that there are exactly p pairs with a difference less than or equal to a given mid value. The binary search is performed over the range of possible mid values.\\n\\nThe can_form_pair function is used to determine whether it\\'s possible to form p pairs with a difference less than or equal to mid using the sorted array nums. It does this by iterating through the sorted array and counting the number of pairs that satisfy the condition.\\n\\nThe binary search in the minimizeMax function narrows down the possible values of mid using the can_form_pair function until it finds the smallest mid value that satisfies the condition.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool can_form_pair(vector<int> nums,int mid,int p)\\n    {\\n        int i=1;\\n        int count=0;\\n        while(i<(nums.size()) && count<p){\\n            if(nums[i]-nums[i-1]<=mid){\\n                count++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        return count==p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums[nums.size()-1]-nums[0];\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(can_form_pair(nums,mid,p)) r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool can_form_pair(vector<int> nums,int mid,int p)\\n    {\\n        int i=1;\\n        int count=0;\\n        while(i<(nums.size()) && count<p){\\n            if(nums[i]-nums[i-1]<=mid){\\n                count++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        return count==p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,r=nums[nums.size()-1]-nums[0];\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(can_form_pair(nums,mid,p)) r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890757,
                "title": "easy-c-solution-binary-search-98-42-faster",
                "content": "\\n\\n class Solution {\\npublic:\\n\\n    bool isPossible(vector<int>&nums,int p,int m){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=m){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int s=0,e=nums.back()-nums.front();\\n        int ans=e;\\n        while(s<=e){\\n\\n            int m=s+(e-s)/2;\\n            if(isPossible(nums,p,m)){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;\\n\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isPossible(vector<int>&nums,int p,int m){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=m){\\n                p--;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3890736,
                "title": "easy-c-solution",
                "content": "\\n\\n class Solution {\\npublic:\\n\\n    bool isPossible(vector<int>&nums,int p,int m){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=m){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int s=0,e=nums.back()-nums.front();\\n        int ans=e;\\n        while(s<=e){\\n\\n            int m=s+(e-s)/2;\\n            if(isPossible(nums,p,m)){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else\\n                s=m+1;\\n        }\\n        return ans;\\n\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isPossible(vector<int>&nums,int p,int m){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=m){\\n                p--;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3890578,
                "title": "concise-binary-search-dp-in-python-faster-than-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first $n-1$ minimum difference pairs must be in the pairs of `(nums[i], nums[i+1])` for `0 <= i < len(nums)` in the sorted `nums`. \\nIn this problem, we have to pick up `p` pairs in which the maximum difference is minimized. If we pick up the pair `(nums[i], nums[i+1])`, and then we cannot pick up both `(nums[i-1], nums[i])` and `(nums[i+1], nums[i+2])`. \\nGiven a specific maximum difference `upper_bound`, we can find the largest set of pairs by using DP in $$O(N)$$. So, we can find the minimized `upper_bound` that produces at least `p` pairs by using binary search. \\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N + N \\\\log M)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        diffs = [abs(a - b) for a, b in zip(nums, nums[1:])]\\n        \\n        def check(m):\\n            prev2, prev1 = 0, 0\\n            for diff in diffs:\\n                if diff <= m and prev2 >= prev1:\\n                    prev2, prev1 = prev1, prev2 + 1\\n                else:\\n                    prev2 = prev1\\n            return prev1\\n\\n        lo, hi = 0, max(diffs, default=0)\\n        while lo < hi:\\n            m = (lo + hi) // 2\\n            if check(m) >= p:\\n                hi = m\\n            else:\\n                lo = m + 1\\n        return lo\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        diffs = [abs(a - b) for a, b in zip(nums, nums[1:])]\\n        \\n        def check(m):\\n            prev2, prev1 = 0, 0\\n            for diff in diffs:\\n                if diff <= m and prev2 >= prev1:\\n                    prev2, prev1 = prev1, prev2 + 1\\n                else:\\n                    prev2 = prev1\\n            return prev1\\n\\n        lo, hi = 0, max(diffs, default=0)\\n        while lo < hi:\\n            m = (lo + hi) // 2\\n            if check(m) >= p:\\n                hi = m\\n            else:\\n                lo = m + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890515,
                "title": "13-lines-scala-binary-search",
                "content": "```\\nobject Solution {\\n  def minimizeMax(nums: Array[Int], p: Int): Int = {\\n    def check(idx: Int, threshold: Int, rem: Int): Boolean =\\n      if(rem==0) true\\n      else if(idx >= nums.size-1 ) false\\n      else if((nums(idx+1) - nums(idx)) <= threshold) check(idx+2, threshold, rem-1)\\n      else check(idx+1, threshold, rem)\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = lo + ((hi-lo)>>1) // lo + (hi-lo)/2  or  mid = (lo + hi)/2\\n      if(lo == hi) hi\\n      else if(check(0,mid,p)) bs(lo,mid)\\n      else bs(mid+1,hi)\\n    }\\n    scala.util.Sorting.quickSort(nums)\\n    bs(0,nums.max)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nobject Solution {\\n  def minimizeMax(nums: Array[Int], p: Int): Int = {\\n    def check(idx: Int, threshold: Int, rem: Int): Boolean =\\n      if(rem==0) true\\n      else if(idx >= nums.size-1 ) false\\n      else if((nums(idx+1) - nums(idx)) <= threshold) check(idx+2, threshold, rem-1)\\n      else check(idx+1, threshold, rem)\\n    def bs(lo: Int, hi: Int): Int = {\\n      lazy val mid = lo + ((hi-lo)>>1) // lo + (hi-lo)/2  or  mid = (lo + hi)/2\\n      if(lo == hi) hi\\n      else if(check(0,mid,p)) bs(lo,mid)\\n      else bs(mid+1,hi)\\n    }\\n    scala.util.Sorting.quickSort(nums)\\n    bs(0,nums.max)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3890342,
                "title": "simple-short-c-solution",
                "content": "##  Intuition\\n The code uses binary search to find the minimum acceptable value of \\'max\\' such that the condition in isAcceptable function is satisfied.\\n It means we want min value by which atleast p pairs can be made. \\n\\n ## Approach\\n// The code first sorts the input array \\'nums\\'. For each mid value in the binary search, the isAcceptable function is called to check if it\\'s possible to create atleast \\'p\\' pairs with a maximum difference of \\'mid\\'. If it\\'s possible, the answer is updated with \\'mid\\' and the binary search is continued in the lower half of the range, otherwise, it\\'s continued in the upper half.\\n\\n## Complexity\\n// Time complexity: O(n * log(max_diff))\\n// Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAcceptable(vector<int> nums, int limit, int p)\\n    {\\n        int addPair = 0;\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            if(nums[i] - nums[i-1] <= limit)\\n            {\\n                addPair++;\\n                i++;\\n            }\\n        }\\n        return addPair >= p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(nums.size() < 2)\\n        return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<int> minDiff;\\n        int i = 0, j = INT_MAX, ans = 0;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            bool x = isAcceptable(nums, mid, p);\\n            if(x)\\n            {\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAcceptable(vector<int> nums, int limit, int p)\\n    {\\n        int addPair = 0;\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            if(nums[i] - nums[i-1] <= limit)\\n            {\\n                addPair++;\\n                i++;\\n            }\\n        }\\n        return addPair >= p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(nums.size() < 2)\\n        return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<int> minDiff;\\n        int i = 0, j = INT_MAX, ans = 0;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            bool x = isAcceptable(nums, mid, p);\\n            if(x)\\n            {\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890134,
                "title": "binnary-search-greedy-with-optimization-and-good-explanation",
                "content": "# Intuition\\n\\nThe task was not clear for me. Description and example real bad. I spent a lot of time just to figure out what are requirements. \\n\\nWhen I finally got it then intuition is pretty simple: we need to find value $$v$$ as minimum distance between two integers in the array, so that $$c = count(|nums[i]-nums[j]| <= v): 0<i,j<n, i!=j, c>=p$$\\n\\n# Approach\\n\\nThe solution can be split into parts: \\n1) Guest value `v` \\n2) Calculate `c`\\n\\nFirst part can be solved with using binary search. Prerequisite of binaary search that array is ordered. Means we need to sort the array in ascent order. \\n\\nThen we can start guessing with usign binaary search. As we do search by distance, then it means we need ot use it as criteria: \\n\\n```java\\nvar left = 0; // min distance between two integer \\nvar right = nums[n - 1] - nums[0]; // max distance in the array. \\nvar guess = (right - left)/2 + left; // regular logic of binnary search to take mid point as guess\\n```\\n\\nStep two can be done with usign gredy appraoch. \\n\\nHere\\'s a general outline of how a greedy algorithm works:\\n\\n1. **Initialization**: Start with an empty solution or a trivial solution.\\n2. **Selection**: At each step, choose the best available option according to some criterion. This criterion should be based on the current state of the problem.\\n3. **Feasibility**: Check if the chosen option is feasible and doesn\\'t violate any constraints.\\n4. **Update**: Update the current state based on the chosen option. This could involve removing certain elements, adding elements, or modifying values.\\n5. **Repeat**: Repeat steps 2 to 4 until a termination condition is met. This condition could be reaching a specific goal, exhausting all available options, or encountering some predefined condition.\\n6. **Solution**: The final solution is the result obtained after the algorithm terminates.\\n\\nIn our case we need to answer if count of pair where distance less than `guess` is more or equals to `p`. \\n\\n1. **Initialization**: count = 0 - the most trivial solution, that we don\\'t have any pair. \\n2. **Selection**: as array is sorted, then we choose first possible pair that are nums[0] and nums[1]. Also that array is sorted in ascending order allow us skip absolute thalue nums[i+1] >= nums[i].\\n3. **Feasibility**: check if distance between these two numbers is less than our guess: `nums[i+1] - nums[i] <= guess`\\n4. **Update**: If condition is true - then increase count. If we have coutn of pair more than `p` then we have solution. \\n5. **Repeat**: If pair found in step 3 - move to next pair by moving index twice, otherwise move it only once to check next pair. \\n6. **Solution**: if we reach end of array and didn\\'t found enougth pair then solution is not here. \\n\\nGreedy algorithm works due to fact that `nums` is storted array. In this case distance between $$i,j: i<j$$ always increase:  `nums[i] - nums[i-1] <= nums[i+1]<nums[]`\\n\\n# Example\\n \\n`nums = [10,1,2,7,1,3], p = 2`\\n\\n1) Sort it: `nums=[1,1,2,3,7,10]`\\n2) Guess: `guess=(10-0)/2+0=5`\\n3) Count of pair where distance less or equal than 5: `3` (`[1,1]=0,[2,3]=1,[7,10]=3`)\\n4) Continue binnary search: as we need to minimize and we have count more than `p` then move left, `guess=(5-0)/2+0=2`\\n5) Count of pair where distance less or equal than 2: `3` (`[1,1]=0,[2,3]=1,[7,10]=3`)\\n6) Continue binnary search: as we need to minimize and we have count equals `p` then move left, `guess=(2-0)/2+0=1`\\n7) Count of pair where distance less or equal than 1: `2` (`[1,1]=0,[2,3]=1`)\\n8) Continue binnary search: as we need to minimize and we have count equals `p` then move left, `guess=(1-0)/2+0=0`\\n10) Count of pair where distance less or equal than 0: `1` (`[1,1]=0`)\\n11) Move move to right left boarder of binnary seach, we have: `left=1, right=1`, means we reach end of BS. \\n12) Solution is 1 \\n\\n# Time complexity:\\n$$O(n * log(V))$$ where $$V=max(nums)-min(nums)$$, means max distance between integers in the array. BP search coplexity is $$log(k)$$, we do BS by distance between integers in the array. Also on each step of searhc we need go thought array. \\n\\n# Memory complexity: $$O(1)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p == 0){\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        final var n = nums.length; \\n        var left = 0; \\n        var right = nums[n - 1] - nums[0];\\n\\n        while(left < right){\\n            final var mid = (right - left)/2 + left;\\n            if(checkPais(nums, p, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private final boolean checkPais(final int[] nums, final int p, final int threshold){\\n\\n        var count = 0;\\n        var i = 0; \\n        while(i < nums.length - 1){\\n            if(nums[i+1] - nums[i] <= threshold){\\n                i++;\\n                count++;\\n                if(count >=p){\\n                    return true;\\n                }\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```java\\nvar left = 0; // min distance between two integer \\nvar right = nums[n - 1] - nums[0]; // max distance in the array. \\nvar guess = (right - left)/2 + left; // regular logic of binnary search to take mid point as guess\\n```\n```java\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        if(p == 0){\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        final var n = nums.length; \\n        var left = 0; \\n        var right = nums[n - 1] - nums[0];\\n\\n        while(left < right){\\n            final var mid = (right - left)/2 + left;\\n            if(checkPais(nums, p, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private final boolean checkPais(final int[] nums, final int p, final int threshold){\\n\\n        var count = 0;\\n        var i = 0; \\n        while(i < nums.length - 1){\\n            if(nums[i+1] - nums[i] <= threshold){\\n                i++;\\n                count++;\\n                if(count >=p){\\n                    return true;\\n                }\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890052,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n      Arrays.sort(nums);\\n      int left = 0, right = nums[nums.length - 1] - nums[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (helper(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean helper(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n      Arrays.sort(nums);\\n      int left = 0, right = nums[nums.length - 1] - nums[0];\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (helper(nums, mid, p)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean helper(int[] nums, int mid, int p) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1 && count < p;) {\\n            if (nums[i+1] - nums[i] <= mid) {\\n                count++;\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return count >= p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889912,
                "title": "js-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log m), where n is the length of the array and m is the difference between the maximum and minimum values in the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function(nums, p) {\\n    if (p === 0) return 0\\n    function check_p_pair(value){\\n        let count = 0\\n        let i = 0\\n        while(i < nums.length){\\n            if (Math.abs(nums[i] - nums[i+1]) <= value){\\n                count += 1\\n                i += 2\\n            }else{\\n                i += 1\\n            }\\n            if (count === p){\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n    nums.sort((x, y) =>{return x - y})\\n    let left = 0\\n    let n = nums.length  \\n    let right = nums[n - 1] -  nums[0]\\n    while(left <= right){\\n        let mid_val = Math.floor((left + right) / 2)\\n        if (check_p_pair(mid_val)){\\n            right = mid_val - 1\\n        }else{\\n            left = mid_val + 1\\n        }\\n    }\\n    return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} p\\n * @return {number}\\n */\\nvar minimizeMax = function(nums, p) {\\n    if (p === 0) return 0\\n    function check_p_pair(value){\\n        let count = 0\\n        let i = 0\\n        while(i < nums.length){\\n            if (Math.abs(nums[i] - nums[i+1]) <= value){\\n                count += 1\\n                i += 2\\n            }else{\\n                i += 1\\n            }\\n            if (count === p){\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n    nums.sort((x, y) =>{return x - y})\\n    let left = 0\\n    let n = nums.length  \\n    let right = nums[n - 1] -  nums[0]\\n    while(left <= right){\\n        let mid_val = Math.floor((left + right) / 2)\\n        if (check_p_pair(mid_val)){\\n            right = mid_val - 1\\n        }else{\\n            left = mid_val + 1\\n        }\\n    }\\n    return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889823,
                "title": "c-video-solution-easy-explained-intuition-dry-run-live-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[https://www.youtube.com/watch?v=XrMvvcqlHKc]()\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(vector<int>& nums, int p,int mid){\\n        int count=0;\\n        int i=0;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]-nums[i]<=mid){\\n                count++;\\n                i+=2;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return count>=p;\\n        // if(count>=p){\\n        //     return true;\\n        // }\\n        // return false;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=0;\\n        int end=nums[n-1]-nums[0];\\n        int result=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;//buffer flow\\n            if(isvalid(nums,p,mid)){\\n                result=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(vector<int>& nums, int p,int mid){\\n        int count=0;\\n        int i=0;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]-nums[i]<=mid){\\n                count++;\\n                i+=2;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return count>=p;\\n        // if(count>=p){\\n        //     return true;\\n        // }\\n        // return false;\\n    }\\n\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int start=0;\\n        int end=nums[n-1]-nums[0];\\n        int result=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;//buffer flow\\n            if(isvalid(nums,p,mid)){\\n                result=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889765,
                "title": "100-fast-100-memory-optimised",
                "content": "\\n# Complexity\\n- Time complexity:O(N*log(max(nums[i])))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int FAST = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nbool check(vector<int> &nums, int msxdif, int p){\\n\\n    int n = (int)nums.size();\\n    \\n    int cnt = 0;\\n    for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1] <=msxdif){\\n            cnt++;\\n            i++;\\n        }\\n    }\\n    return cnt>=p;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int n = (int)nums.size();\\n        \\n        int high = nums[n-1]-nums[0], low = 0;\\n        int ans = high;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(nums, mid, p)){\\n                ans = min(ans, mid);\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int FAST = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\nbool check(vector<int> &nums, int msxdif, int p){\\n\\n    int n = (int)nums.size();\\n    \\n    int cnt = 0;\\n    for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1] <=msxdif){\\n            cnt++;\\n            i++;\\n        }\\n    }\\n    return cnt>=p;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0) return 0;\\n        sort(nums.begin(), nums.end());\\n        int n = (int)nums.size();\\n        \\n        int high = nums[n-1]-nums[0], low = 0;\\n        int ans = high;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(nums, mid, p)){\\n                ans = min(ans, mid);\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3889747,
                "title": "20ms-100-00-3-43mb-100-00-rust-solution",
                "content": "```\\nimpl Solution {\\n    fn is_possible_to_form(nums: &Vec<i32>, mut p: i32, diff: i32) -> bool {\\n        let mut i = 0;\\n\\n        while i < nums.len() - 1 && p > 0 {\\n            if nums[i + 1] - nums[i] <= diff {\\n                p -= 1;\\n                i += 2;\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        p <= 0\\n    }\\n\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n\\n        let (mut left, mut right) = (0, nums[nums.len() - 1] - nums[0]);\\n\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if Self::is_possible_to_form(&nums, p, mid) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        left\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn is_possible_to_form(nums: &Vec<i32>, mut p: i32, diff: i32) -> bool {\\n        let mut i = 0;\\n\\n        while i < nums.len() - 1 && p > 0 {\\n            if nums[i + 1] - nums[i] <= diff {\\n                p -= 1;\\n                i += 2;\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        p <= 0\\n    }\\n\\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\\n        nums.sort();\\n\\n        let (mut left, mut right) = (0, nums[nums.len() - 1] - nums[0]);\\n\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if Self::is_possible_to_form(&nums, p, mid) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        left\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889620,
                "title": "binary-search-easy-to-understand-0ms-c",
                "content": "```\\nclass Solution {\\n    int countPairs(vector<int>&nums, int diff){\\n        int i=0, cnt=0;;\\n        while(i<nums.size()-1){\\n            if(abs(nums[i+1]-nums[i])<=diff){\\n                cnt++;\\n                i+=2;\\n            }else i++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(!p || nums.size()==1) return 0;\\n        if(nums.size()==2) return abs(nums[1]-nums[0]);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int low=0, high=nums[nums.size()-1]-nums[0];\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(countPairs(nums, mid)>=p){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int countPairs(vector<int>&nums, int diff){\\n        int i=0, cnt=0;;\\n        while(i<nums.size()-1){\\n            if(abs(nums[i+1]-nums[i])<=diff){\\n                cnt++;\\n                i+=2;\\n            }else i++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(!p || nums.size()==1) return 0;\\n        if(nums.size()==2) return abs(nums[1]-nums[0]);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int low=0, high=nums[nums.size()-1]-nums[0];\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(countPairs(nums, mid)>=p){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889431,
                "title": "binary-search-and-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //recursive solution\\n    int solve(vector<int>& nums,int i,int p,int n,vector<vector<int>>& dp){\\n        if(i>=n-1 || p==0){\\n            if(p==0) return 0;\\n            return INT_MAX;\\n        }\\n\\n        if(dp[i][p]!=-1) return dp[i][p];\\n\\n        int nt=solve(nums,i+1,p,n,dp);\\n        int t=max(abs(nums[i]-nums[i+1]),solve(nums,i+2,p-1,n,dp));\\n\\n        return dp[i][p]=min(t,nt);\\n    }\\n\\n    //binary search solution\\n    bool chk(vector<int>& nums,int thress,int n,int p){\\n        for(int i=0;i<n-1;++i){\\n            if(abs(nums[i]-nums[i+1])<=thress){\\n                p-=1;\\n                i+=1;\\n            }\\n            if(p==0) return true;\\n        }\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0) return 0;\\n        int n=nums.size();\\n        int l=0;\\n        int h=1e9;\\n        sort(nums.begin(),nums.end());\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(chk(nums,mid,n,p)){\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //recursive solution\\n    int solve(vector<int>& nums,int i,int p,int n,vector<vector<int>>& dp){\\n        if(i>=n-1 || p==0){\\n            if(p==0) return 0;\\n            return INT_MAX;\\n        }\\n\\n        if(dp[i][p]!=-1) return dp[i][p];\\n\\n        int nt=solve(nums,i+1,p,n,dp);\\n        int t=max(abs(nums[i]-nums[i+1]),solve(nums,i+2,p-1,n,dp));\\n\\n        return dp[i][p]=min(t,nt);\\n    }\\n\\n    //binary search solution\\n    bool chk(vector<int>& nums,int thress,int n,int p){\\n        for(int i=0;i<n-1;++i){\\n            if(abs(nums[i]-nums[i+1])<=thress){\\n                p-=1;\\n                i+=1;\\n            }\\n            if(p==0) return true;\\n        }\\n        return false;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        if(p==0) return 0;\\n        int n=nums.size();\\n        int l=0;\\n        int h=1e9;\\n        sort(nums.begin(),nums.end());\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(chk(nums,mid,n,p)){\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889365,
                "title": "minimize-the-maximum-difference-of-pairs",
                "content": "# Intuition\\nThe solution could be like a puzzle where you\\'re trying to find the smallest way to fit p pairs together without using any number more than once. By sorting, guessing, checking, and carefully pairing up the numbers, we can find the perfect fit.\\n# Approach\\n1. First, we arrange the numbers in the list from smallest to largest.\\n2. We want to find the smallest difference that allows us to create p pairs. To do this, we use a binary search.\\n3. We make a guess about what the smallest difference could be that allows us to create p pairs.\\n- If our guess is too big, we know the answer must be smaller, so we narrow our search to smaller numbers.\\n- If our guess is too small, we know the answer must be bigger, so we narrow our search to larger numbers.\\n- We keep guessing and checking until we find the exact smallest difference that lets us create p pairs.\\n4. When we\\'re checking our guess, we pair up numbers in the sorted list as long as the difference between them is less than or equal to our guess. We skip to the next unpaired number if the current pair doesn\\'t meet the condition.\\n5. As we pair up the numbers, we keep track of how many pairs we\\'ve made. If we can make p pairs with our current guess, we know our guess is big enough, and we can look for even smaller differences. If we can\\'t make p pairs, we know our guess is too small, and we need to look for bigger differences.\\n6. By repeatedly guessing and checking, we eventually find the exact smallest difference that lets us create p pairs. This difference is the answer to the problem.\\n\\n# Complexity\\n- Time complexity:\\nO(n log(n\\u22C5d))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums, p):\\n        if p == 0:\\n            return 0\\n\\n        nums.sort()\\n\\n        # Function to check if it\\'s possible to form p pairs with max difference mid\\n        def check(mid):\\n            count = 0\\n            i = 0\\n            while i < len(nums) - 1:\\n                if nums[i + 1] - nums[i] <= mid:\\n                    count += 1\\n                    i += 2  # Move to the next unpaired number\\n                else:\\n                    i += 1\\n            return count >= p\\n\\n        # Binary search for the minimum maximum difference\\n        left, right = 0, nums[-1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            if check(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n\\n        return left\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums, p):\\n        if p == 0:\\n            return 0\\n\\n        nums.sort()\\n\\n        # Function to check if it\\'s possible to form p pairs with max difference mid\\n        def check(mid):\\n            count = 0\\n            i = 0\\n            while i < len(nums) - 1:\\n                if nums[i + 1] - nums[i] <= mid:\\n                    count += 1\\n                    i += 2  # Move to the next unpaired number\\n                else:\\n                    i += 1\\n            return count >= p\\n\\n        # Binary search for the minimum maximum difference\\n        left, right = 0, nums[-1] - nums[0]\\n        while left < right:\\n            mid = (left + right) // 2\\n            if check(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n\\n        return left\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889315,
                "title": "binary-search-on-answer-easy-to-understand-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool possible(vector<int>&nums , int diff , int p){\\n\\n\\n        int cnt = 0;\\n\\n        for(int i = 0 ; i<nums.size()-1 && cnt<p;){\\n\\n            if(nums[i+1] - nums[i] <=diff){\\n                cnt++;\\n                i+=2;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return cnt>=p;\\n\\n\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int ans;\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        int low = 0;\\n        int high = nums[n-1] - nums[0];\\n        \\n\\n        while(low<=high){\\n\\n            int mid = low+(high-low)/2;\\n\\n            if(possible(nums, mid , p)){\\n                ans = mid;\\n                high = mid-1;\\n            }else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool possible(vector<int>&nums , int diff , int p){\\n\\n\\n        int cnt = 0;\\n\\n        for(int i = 0 ; i<nums.size()-1 && cnt<p;){\\n\\n            if(nums[i+1] - nums[i] <=diff){\\n                cnt++;\\n                i+=2;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return cnt>=p;\\n\\n\\n    }\\n    int minimizeMax(vector<int>& nums, int p) {\\n        \\n        int ans;\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();\\n        int low = 0;\\n        int high = nums[n-1] - nums[0];\\n        \\n\\n        while(low<=high){\\n\\n            int mid = low+(high-low)/2;\\n\\n            if(possible(nums, mid , p)){\\n                ans = mid;\\n                high = mid-1;\\n            }else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889210,
                "title": "a-concise-two-step-approach-ranking-99-in-time-performance",
                "content": "# Intuition\\nTwo-step approach by sorting the array first, calculate the `diff` of the array, this gives the absolute difference in the ascending order. The trick here is to pick the pth smallest difference without using consecutive indices.\\n# Approach\\nThe `find_pth_smallest_with_skipping` function uses binary search to find the pth smallest value in the input list values that is not adjacent to any other value in the list.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0:\\n            return 0\\n        # using sorting\\n        nums.sort()\\n        # get the difference between consecutive numbers\\n        diff_sorted_nums = [nums[i+1] - nums[i] for i in range(len(nums)-1)]\\n        # cannot use the same number twice\\n        # pick the smallest p difference without using consecutive indices\\n        res = find_pth_smallest_with_skipping(diff_sorted_nums, p)\\n        return res\\n    \\ndef find_pth_smallest_with_skipping(values: List[int], p: int):\\n    # pick the smallest p value without using consecutive indices\\n    def count_less_equal(mid):\\n        count = 0\\n        prev_idx = - 2\\n        \\n        for idx, value in enumerate(values):\\n            # if value is less than mid and the index is not consecutive\\n            if value <= mid and idx != prev_idx + 1: \\n                count += 1\\n                prev_idx = idx\\n        \\n        return count\\n    \\n    left = min(values)\\n    right = max(values)\\n    \\n    while left < right:\\n        mid = left + (right - left) // 2\\n        count = count_less_equal(mid)\\n        \\n        if count > p - 1:\\n            right = mid \\n        else:\\n            left = mid + 1\\n            \\n    return left\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        if p == 0:\\n            return 0\\n        # using sorting\\n        nums.sort()\\n        # get the difference between consecutive numbers\\n        diff_sorted_nums = [nums[i+1] - nums[i] for i in range(len(nums)-1)]\\n        # cannot use the same number twice\\n        # pick the smallest p difference without using consecutive indices\\n        res = find_pth_smallest_with_skipping(diff_sorted_nums, p)\\n        return res\\n    \\ndef find_pth_smallest_with_skipping(values: List[int], p: int):\\n    # pick the smallest p value without using consecutive indices\\n    def count_less_equal(mid):\\n        count = 0\\n        prev_idx = - 2\\n        \\n        for idx, value in enumerate(values):\\n            # if value is less than mid and the index is not consecutive\\n            if value <= mid and idx != prev_idx + 1: \\n                count += 1\\n                prev_idx = idx\\n        \\n        return count\\n    \\n    left = min(values)\\n    right = max(values)\\n    \\n    while left < right:\\n        mid = left + (right - left) // 2\\n        count = count_less_equal(mid)\\n        \\n        if count > p - 1:\\n            right = mid \\n        else:\\n            left = mid + 1\\n            \\n    return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889076,
                "title": "an-easy-binary-search-solution-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool valid(int mid,vector<int>& nums,int p)\\n    {\\n        int cnt = 0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]<=mid)\\n                    cnt++,i++;\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int low = 0,high = 1e9,ans = 0;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(valid(mid,nums,p))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool valid(int mid,vector<int>& nums,int p)\\n    {\\n        int cnt = 0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]<=mid)\\n                    cnt++,i++;\\n        }\\n        return cnt>=p;\\n    }\\n    int minimizeMax(vector<int>& nums, int p) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int low = 0,high = 1e9,ans = 0;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(valid(mid,nums,p))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888834,
                "title": "c-o-nlogn-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(NlogN) \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int min = 0, max = nums[nums.size()-1]-nums[0];\\n        while(min<=max){\\n            int mid  = min + (max-min)/2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                max = mid-1;\\n            }else{\\n                min = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    bool isPossible(vector<int>& nums,int p, int& diff){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int min = 0, max = nums[nums.size()-1]-nums[0];\\n        while(min<=max){\\n            int mid  = min + (max-min)/2;\\n            if(isPossible(nums,p,mid)){\\n                ans = mid;\\n                max = mid-1;\\n            }else{\\n                min = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    bool isPossible(vector<int>& nums,int p, int& diff){\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]<=diff){\\n                p--;\\n                i++;\\n            }\\n        }\\n        return p<=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888612,
                "title": "binary-search-sorting-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int beg = 0, end = nums[nums.length-1] - nums[0];\\n        int ans = 0;\\n\\n        while (beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            int pairs = 0;\\n            for (int i = 0; i < nums.length-1; i++) {\\n                if (nums[i+1] - nums[i] <= mid) {\\n                    pairs++;\\n                    i++;\\n                }\\n            }\\n            if (pairs >= p) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int beg = 0, end = nums[nums.length-1] - nums[0];\\n        int ans = 0;\\n\\n        while (beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            int pairs = 0;\\n            for (int i = 0; i < nums.length-1; i++) {\\n                if (nums[i+1] - nums[i] <= mid) {\\n                    pairs++;\\n                    i++;\\n                }\\n            }\\n            if (pairs >= p) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888496,
                "title": "java-binary-search-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isPair(int[] nums ,int pair,int target){\\n        int i=1, count=0;\\n        while(i<nums.length){\\n            if(nums[i]-nums[i-1]<=target){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count>=pair;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int low = 0,ans=0;\\n        int high = nums[nums.length-1]-nums[0];\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(isPair(nums,p,mid)){\\n                ans = mid;\\n                high = mid;\\n            }\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean isPair(int[] nums ,int pair,int target){\\n        int i=1, count=0;\\n        while(i<nums.length){\\n            if(nums[i]-nums[i-1]<=target){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count>=pair;\\n    }\\n\\n    public int minimizeMax(int[] nums, int p) {\\n        Arrays.sort(nums);\\n        int low = 0,ans=0;\\n        int high = nums[nums.length-1]-nums[0];\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(isPair(nums,p,mid)){\\n                ans = mid;\\n                high = mid;\\n            }\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888480,
                "title": "python3-solution",
                "content": "# What to improve next time\\n<!-- Describe your approach to solving the problem. -->\\n- For each pair, there are two numbers ---> skip index to get next pair\\n- Think about the relationship between pair of values and their count. Which one are more important? In other words, what are we choosing?\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$ as we iterate through entire array for each binary search\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        lo, hi = 0, abs(nums[-1] - nums[0])\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            i, count = 1, 0\\n            while i < n:\\n                curDiff = nums[i] - nums[i - 1]\\n                if curDiff <= mid:\\n                    count += 1\\n                    i += 1\\n                i += 1\\n            if count >= p:\\n                hi = mid\\n            else: \\n                lo = mid + 1\\n        return lo\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        lo, hi = 0, abs(nums[-1] - nums[0])\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            i, count = 1, 0\\n            while i < n:\\n                curDiff = nums[i] - nums[i - 1]\\n                if curDiff <= mid:\\n                    count += 1\\n                    i += 1\\n                i += 1\\n            if count >= p:\\n                hi = mid\\n            else: \\n                lo = mid + 1\\n        return lo\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888452,
                "title": "elixir-binary-search-greedy-functional-tail-recursion",
                "content": "# Intuition\\nAs I am learning more complex algorithms, my intuition was to learn how to solve this problem. This was not solved of my own intuition.\\n\\n# Approach\\nAfter understanding the solution, it was time to think in a functional approach given the immutability of variables in Elixir.\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec minimize_max(nums :: [integer], p :: integer) :: integer\\n  def minimize_max(nums, p) do\\n    sorted = Enum.sort(nums)\\n\\n    minimize_max(sorted, p, 0, List.last(sorted) - hd(sorted))\\n  end\\n\\n  defp minimize_max(_, _, low, high) when low >= high, do: low\\n  defp minimize_max(nums, p, low, high) do\\n    middle = low + high |> div(2)\\n\\n    if pairs?(nums, p, middle, 0) do\\n      minimize_max(nums, p, low, middle)\\n    else\\n      minimize_max(nums, p, middle + 1, high)\\n    end\\n  end\\n\\n  defp pairs?([], p, _, count), do: count >= p\\n  defp pairs?([_last], p, _, count), do: count >= p\\n  defp pairs?([first, second | rest], p, middle, count) do\\n    if second - first <= middle do\\n      pairs?(rest, p, middle, count + 1)\\n    else\\n      pairs?([second | rest], p, middle, count)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec minimize_max(nums :: [integer], p :: integer) :: integer\\n  def minimize_max(nums, p) do\\n    sorted = Enum.sort(nums)\\n\\n    minimize_max(sorted, p, 0, List.last(sorted) - hd(sorted))\\n  end\\n\\n  defp minimize_max(_, _, low, high) when low >= high, do: low\\n  defp minimize_max(nums, p, low, high) do\\n    middle = low + high |> div(2)\\n\\n    if pairs?(nums, p, middle, 0) do\\n      minimize_max(nums, p, low, middle)\\n    else\\n      minimize_max(nums, p, middle + 1, high)\\n    end\\n  end\\n\\n  defp pairs?([], p, _, count), do: count >= p\\n  defp pairs?([_last], p, _, count), do: count >= p\\n  defp pairs?([first, second | rest], p, middle, count) do\\n    if second - first <= middle do\\n      pairs?(rest, p, middle, count + 1)\\n    else\\n      pairs?([second | rest], p, middle, count)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 2006198,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006559,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006257,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006561,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006217,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006521,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006557,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006324,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 1858089,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006218,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006198,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006559,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006257,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006561,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006217,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006521,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006557,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006324,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 1858089,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 2006218,
                "content": [
                    {
                        "username": "zhuzhupang001",
                        "content": "This feels like hard"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I agree with [@Sushil L](/21Cash) there are a lot of medium problems where find the minimal value that satisfies a condition, like: \\n\\n- 875. Koko Eating Bananas and \\n- 1011. Capacity To Ship Packages Within D Days\\n- 2187. Minimum Time to Complete Trips\\n\\nThey\\'re good practice if you struggled with this, you\\'ll probably recognise the pattern after you have done it a couple of times. And you\\'ll be able to use it in actual Hard problems like these:\\n\\n- 1044. Longest Duplicate Substring\\n- 1970. Last Day Where You Can Still Cross\\n\\nMain difference is that you have to combine binary search with other techniques. "
                    },
                    {
                        "username": "21Cash",
                        "content": "i dont think so, its pretty common pattern to binarysearch on res with usually results in O(nlogn)"
                    },
                    {
                        "username": "rohanny_",
                        "content": "Why god why, why my brain cant understand this thing!\nQ. Return the minimum maximum difference\nMe : What"
                    },
                    {
                        "username": "olsonpm",
                        "content": "The sad part is terrible worded questions and esoteric puzzles is good interview practice."
                    },
                    {
                        "username": "RoMANzhula",
                        "content": "First, you need to find the number of pairs (p) with the minimum difference, and then find the maximum of them among these differences."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "first find p pairs and then return the maximum value from those"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Same. It bewildered me"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Same Dude\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is how I made sense of the question:\n<ol>\n<li> Sort the list.\n<li> Guess the minimum maximum difference.\n<li> Count how many pairs in nums have a difference equal to or less than this guess.\n<li> If the count is too high (more than or equal to p) then guess a lower value.\n<li> Otherwise, guess a higher value.\n<li> The smallest guess will be 0 and the highest guess will be nums[numsSize-1] - nums[0] (assuming nums is sorted).\n<li> The answer will be the smallest guess that gives a pair count equal to p\n</ol>"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kartik_45](/kartik_45) \n```       \nif (abs(nums[i] - nums[i+1]) <= guess) {\n    ++count;\n    i += 2;\n } else {\n    ++i;\n}\n```"
                    },
                    {
                        "username": "kartik_45",
                        "content": "sir,how to find how many pairs, different are lesser than or equal to the mid???"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "thank you sir"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "!!! NOT A TIP !!!\\n1 Sort the array\\n2 Construct the array of differences (abs(nums[i] - nums[i - 1]))\\n3 Apply Top down DP + caching\\n4 Get TLE: 1542 / 1582 testcases passed\\n5 ???\\n6 Try to find another solution"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "why would LC give a hint of a dp solution... they just want to see us suffer."
                    },
                    {
                        "username": "ianliu1015",
                        "content": "I went further by doing space-optimized bottom-up DP, only to get a TLE, bruh."
                    },
                    {
                        "username": "ajv97",
                        "content": "ROFL. Nice one."
                    },
                    {
                        "username": "anwendeng",
                        "content": "LC gives a hint for DP, but the question is tagged as Greedy, Binary Search.\nSo, there are several different solutions. which one is better?  A binary Search  solution is not hard. I did try the DP solution and it passed over 98% of the cases but resulted in MLE! "
                    },
                    {
                        "username": "aboocher",
                        "content": "[@endeavor36](/endeavor36) Greedy does not work here.  Greedy would pick (1,1) (difference of 0) and (0,3)  difference of 3.   So your pairs have a largest difference of 3.   Your greedy would return \"3\".   \\n\\nCan you do better by not greedy?  Sure - pick (0,1) and (1,3).  Here the differences are 1 and 2.   So the largest difference is 2.     This is the correct answer for this nums.  "
                    },
                    {
                        "username": "Nameresu",
                        "content": "for here, you can use dp to maintain the maximum number of pairs you pick to index *i*, so that there's no need to guarantee greedy is correct"
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@endeavor36](/endeavor36) this test case is also failing for me. \n*edit: As it turns out, I overlooked the best solution. DP is not working here. "
                    },
                    {
                        "username": "atharva598",
                        "content": "[@webguru77777](/webguru77777) Good observation, I did the same."
                    },
                    {
                        "username": "harsha335",
                        "content": "[@Ultron03](/Ultron03) [1,2,2,3,3,5,6,6] and n=4"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I ruled out DP due to the constraint. 10^5 means you have to come up with O(nlogn) or O(n) solution. With DP, it is O(n^2)"
                    },
                    {
                        "username": "endeavor36",
                        "content": "[@Ultron03](/Ultron03) Hello. Does greedy work here? nums = [1,1,0,3], p = 2. Im new and I dont understand greedy completely but my code fails at this testcase"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@Shrishti_25](/Shrishti_25)  but can you tell me any case where greedy will not work??"
                    },
                    {
                        "username": "Shrishti_25",
                        "content": "[@gmk92lc](/gmk92lc) how is it not dp? this screamed dp to me when i read the question since we have to check for all the possibilities \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "not dp"
                    },
                    {
                        "username": "adhyayathakur",
                        "content": "for nums = [3,4,2,3,2,1,2] and p =3 , why the output is showing 1, shouldn\\u2019t be 0"
                    },
                    {
                        "username": "goel_adii",
                        "content": "[@ayushverma2001](/ayushverma2001) question is asking to return the  minimum of maximum difference,so   minimum is 0\\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@alisaz](/alisaz) And it does. None of the elements is used more than once in forming the pairs."
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "it is showing correct because pairs are (3,3), (2,2), (2,1) if you subtract all these then you get max value as 1"
                    },
                    {
                        "username": "anivaries",
                        "content": "[@Rishab2003](/Rishab2003) Is it not |1-2|? Which also gives 1"
                    },
                    {
                        "username": "alisaz",
                        "content": "[@psionl0](/psionl0) one index can appear only in one pair. "
                    },
                    {
                        "username": "psionl0",
                        "content": "You can group the elements in either of the following ways: [1,(2,2),(2,3),(3,4)] or [(1,2),(2,2),(3,3),4]. In either case, you get 3 pairs with a maximum difference of 1."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "[@Rishab2003](/Rishab2003) 2,2 actually happens twice so 0,0,0 is the minimum of which max in 0 only. correct me if im wrong."
                    },
                    {
                        "username": "Rishab2003",
                        "content": "No, since there should not be any repeating indexes in pairs.\\n(3,3)  =  3-3  = 0\\n(2,2)  =  2-2  = 0\\n(1,2)  =  2-1  = 1\\nThese are the minimum pairs possible and the max among them is 1."
                    },
                    {
                        "username": "Skaifai",
                        "content": "Isn't the name of the problem wrong? It says \"minimize the maximum difference\", but in the actual problem itself we are maximizing the minimum difference? Or am I understanding this wrong?\n*edit: The name of the problem is correct. Even though, in the problem it is asking us to return the maximum minimum difference, what we end up doing is minimizing the maximum difference."
                    },
                    {
                        "username": "aboocher",
                        "content": "[@jems1123](/jems1123) no this isn\\'t what you want to do. Imagine it like this.  You have a large number of relatives and you want to seat them at say p = 5 tables.   I will come around and look at the difference in ages at each table, and take the maximum and write it on the wall.   I\\'ll write \"with your choice of pairings, the max age difference is 10 years\" (or whatever).  Your job - is to find a way so that you MINIMIZE this (max - number) I write down.  In other words you are MINIMIZING the MAXIMUM.  \\n\\nThis is very different than maximizing the minimum, which is where I\\'d write down all the differences and take the minimum, and your goal would be to make that as largest as possible.   \\n\\nEven with  p = 2 you see different answers, with, say [1,2,3,4].   If i want to minimze the max, I\\'d pair (12) and (34) so that your max would be 1.  (That\\'s the best I can do).  But if i wanted to maximize the min, then I\\'d do (13)and (24) so that the min was 2.  "
                    },
                    {
                        "username": "Skaifai",
                        "content": "[@akash_vannam](/akash_vannam) yes, after the whole day of solving this problem, I can finally see that :D You are correct, I misunderstood the problem at first."
                    },
                    {
                        "username": "jems1123",
                        "content": "I also see that name should be \"Maximize the minimum difference\"\\n"
                    },
                    {
                        "username": "LogiCule",
                        "content": "in all combination of taking p pairs from the array \\nyou have to take that specific combination where the maximum pair diff is the minimum among all the other combinations\\nI hope this explains it"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "The heading is correct, it is \"minimize the maximum difference\"\\n"
                    },
                    {
                        "username": "aDDyy",
                        "content": "NOTE : Whenever we have to calculate min of max / max of min then its mostly a problem of \"Binary Search on ANSWER\" . One such similar implementation problem is as follows : https://practice.geeksforgeeks.org/problems/aggressive-cows/0"
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@abhidejavu](/abhidejavu) Bro ANS is basically answer & its a special kind of Binary Search which u will definetely understand in UTUBE but remember in BS on Ans we take are own search space(based on ans) in which the lower limit will be the min possible ans & upper limit will be the max possible ans. I Hope u all got my point & for any queries anyone can ping me on my linkedIN"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@abhidejavu](/abhidejavu) answer space"
                    },
                    {
                        "username": "abhidejavu",
                        "content": "What is ANS ?"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Is it possible to AC this problem using DP (as suggested by the hints)?\\n\\nI tried using DP during the contest, but couldn\\'t get around TLE/MLE when the input sizes were large."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "You do use dynamic programming to solve this problem. Technically solving the inverse problem is still a dynamic programming question, that\\'s why it has this tag.\\n\\nSpecifically if someone said that given this sorted array how many adjacent pairs you make that have difference value <= M for some given M. Its sorta like a variant of kadanes algorithm and other similar style of DP problems. Lots of similar were asked to that this year."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "[@Cokode](/Cokode) DP = Dynamic programming. A common problem-solving pattern here on LC\\n\\nTLE: Time Limit Exceeded\\nMLE: Memory Limit Exceeded"
                    },
                    {
                        "username": "quan_mai",
                        "content": "[@Cokode](/Cokode) DP: Dynamic Programming, Time/Memory Limit Exceeded"
                    },
                    {
                        "username": "Cokode",
                        "content": "What is DP and what is TLE/MLE?"
                    },
                    {
                        "username": "Zugz0Wang",
                        "content": "[@Hyperzsb](/Hyperzsb) I think maybe the best time complexity of DP approach is O(p * n), with O(n) space complexity? I have read the only DP solution post and applied the time optimization, but I still got an TLE with the last 5 testcases."
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@manj8327](/manj8327) I\\'m implementing a similar DP approach, and it\\'s also stuck at the last few test cases."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "[@manj8327](/manj8327) hey can you please share your code ? btw do you coded what exactly you explained here right ?"
                    },
                    {
                        "username": "leonhsi",
                        "content": "[@manj8327](/manj8327) Thanks for your reply! That\\'s very clear. But there is still one thing I couldn\\'t figure out: How to determine the base cases?"
                    },
                    {
                        "username": "manj8327",
                        "content": "[@leonhsi](/leonhsi)  First let sort the array(arr) (will explain later why sort) then for every index i ,we have 2 choices either to form a pair with it or not , let recursive function be f(i,p) denote maximum difference  between 'p' number of pairs that we need to form using index (i till n ), now for first choice ( f(i,p)=max(abs(arr[i+1]-arr[i]),f(i+2,p-1)) ( we form a pair with next element and now we need to form p-1 pair.) and for second choice ( not include it f(i,p)=f(i+1,p) . \nTake min of both choices and answer is present on f(0,p) .\nNow , why sort the array because if an element can not form an pair with its adjacent index , then it cannot form pair with other element also .( that is somewhat greedy idea)\nThanks , kindly ignore my grammer mistakes as it is my first post.\n"
                    },
                    {
                        "username": "leonhsi",
                        "content": "Could you explain what the DP approach is? Even if the ans gets TLE, I still curios about the dp solution, thanks!"
                    },
                    {
                        "username": "manj8327",
                        "content": "No , it will give tle  , because there are n*p no. of states , which is equal to aroung 10^10 states ,which give tle . Sorry for my bad english"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Hints aren\\'t very helpful (except *maybe* Hint 2, if I\\'m being *really* generous).\\n\\nOut of the ~150 solutions (as of this comment), only [**one** of them is a DP solution](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3406380/i-kotlin-recursion-dp-explained-non-binary-search-approach/). Further, the aforementioned solution TLEs (as mentioned in the comments), so DP probably won\\'t work for this problem."
                    }
                ]
            },
            {
                "id": 1859392,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006728,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006382,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2007033,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006282,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006191,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2007082,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006509,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006357,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006268,
                "content": [
                    {
                        "username": "Mek_san",
                        "content": "nums = [8,9,1,5,4,3,6,4,3,7]\\np =4 \\nmy o/p is 2\\nexpected is 1\\ncan anyone explain how?"
                    },
                    {
                        "username": "ayushverma2001",
                        "content": "4,4 3,3 8,9 6,7"
                    },
                    {
                        "username": "Akash_Porwal",
                        "content": "8,9 5,4 4,3 6,7"
                    },
                    {
                        "username": "Mek_san",
                        "content": "[@r_y_s](/r_y_s) ok got it thx buddy"
                    },
                    {
                        "username": "r_y_s",
                        "content": "The four pairs can be (8,9) (4,5) (3,3) (6,7) . Therefore the max difference is 1."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Is it just me, or the more I look at the question, the more complicated it seems?"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "The hint is of no use as DP doesn\\'t work here (gives TLE or MLE).\\nInstead try solving the problem using greedy(sorting) then binary search."
                    },
                    {
                        "username": "nagendra_amara",
                        "content": "[1,1,0,3] and p = 2\\nthe minimum pairs are 1,1 and diff = 0;\\nafter that 0,3 and diff = 3;\\nresult = max(0,3)\\nbut expected is 2?\\nhow is it  possible ?"
                    },
                    {
                        "username": "KotFord",
                        "content": "\\u0442\\u043E\\u0436\\u0435 \\u0447\\u0442\\u043E-\\u0442\\u043E \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u044E"
                    },
                    {
                        "username": "mstuebs",
                        "content": "The minimum pairs for p=2 are (1,0) and (1,3) so the diff is indeed 2."
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Can someone explain what does minimize the maximum means? It just seems so confusing to me."
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "here's what i do (`first do what's written first`), if asked:\n1) `Minimize the maximum` => so first we have to take minimum values and then take the maximum value out of them.\nfor eg, consider this array, `[3,0,4,2,1,5]` and p=`2`\nthen take the MINIMUM 2 values => `[0,1]` -> then take the maximum out of them => `1`, \n->here we had to take p values and and minimize the maximum, so why not take the minimum p values and maximum of it will be the ans.\n\n2) `Maximize the Minimum` => similarly here, first take the maximum p values => `[5,4]`, then take the minimum out of them = `4`\n\nin this ques, we have to do the same among all possible differences that we can have bw a pair (minimize the maximum)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So basically, we need to pick \\'p\\' pairs. All will have some difference. For p pairs, there will be p differences. There will be a maximum among them. So you need to return that maximum difference, but pick those p pairs in such a way that their maximum difference is the minimum compared to any other set of p pairs"
                    },
                    {
                        "username": "neha2343",
                        "content": "me too\\n"
                    },
                    {
                        "username": "longluo",
                        "content": "what if $p=0$ ?"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "return zero"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think it is 0, as mentioned in the last line of the description."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Yea... didn\\'t even consider this case until I got hit with the WA."
                    },
                    {
                        "username": "GitG0",
                        "content": "Really important to remember we are getting the <b>absolute value of a pair</b>. I naively thought we could just sort nums, trim it to nums[0:p*2] and take the first and last values incrementally.."
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Me struggling to solve this problem.\\nLeetcode: HAHA !! p = 0"
                    },
                    {
                        "username": "mufia001",
                        "content": "Why give a hint if you\\'re not going to accept the solution :("
                    },
                    {
                        "username": "fli033",
                        "content": "wow this is SUCH a disguised binary search problem!"
                    },
                    {
                        "username": "Anirudh_Randev",
                        "content": "hey i am applying binary search here but its only passing half test cases , how should i modify my code\\n"
                    },
                    {
                        "username": "neha2343",
                        "content": "yup\\n"
                    }
                ]
            },
            {
                "id": 2006260,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2063858,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2055249,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2050840,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2049664,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2012046,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2010801,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2009658,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2009500,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2008597,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Why does Sorting + Greedy work here?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Greedy works here because we just need to pick one pair if the difference is <= [mid]. We don't need to think otherwise. If we do not pick some element in one pair but pick it in another, both will contribute +1 to the numbers of pair. Thus we need to Greedily pick"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Why give me hints for a solution that exceeds the time limit? "
                    },
                    {
                        "username": "Limon020",
                        "content": "This is a really good problem, it offers up the obvious dynamic programming approach but it takes some thinking to get to the binary search solution. I learned a lot"
                    },
                    {
                        "username": "AndrewGumenyuk",
                        "content": "Test case: 1343 / 1582\\n[1,1,0,3], p=2.\\n\\nExpected result 2. \\nWhaaaaaaaaat? How can it be 2?"
                    },
                    {
                        "username": "jdc711",
                        "content": "I am trying to do the top-down DP after sorting, but my solution is not passing some tests. Can anyone help me figure out the problem?\\nclass Solution:\\n    def minimizeMax(self, nums: List[int], p: int) -> int:\\n        # brute force:\\n            # try all possible combos of p pairs and return the one with the min max diff\\n        \\n        maxDiff = 0\\n        nums.sort()\\n        cache = {}\\n        def dfs(i):\\n            nonlocal p\\n            nonlocal maxDiff\\n            \\n            if (i,p) in cache:\\n                return cache[(i,p)]\\n            if i >= len(nums)-1:\\n                if p == 0:\\n                    return maxDiff\\n                return float(\"inf\")\\n            tempMin = float(\"inf\")\\n            if p > 0:\\n                p -= 1\\n                prevMaxDiff = maxDiff\\n                maxDiff = max(maxDiff, abs(nums[i]-nums[i+1]))\\n                tempMin = min(tempMin,dfs(i+2))\\n                maxDiff = prevMaxDiff\\n                p += 1\\n            tempMin = min(tempMin, dfs(i+1))\\n            cache[(i,p)] = tempMin\\n            return tempMin\\n        return dfs(0)\\n                "
                    },
                    {
                        "username": "Ganes123",
                        "content": "Why does priority queue solution does  not work for this problem?\\nif the input is [3,4,2,3,2,1,2] p=3 \\npairs formed to be [2,2][2,2][3,3]\\nwhere the answer should be 0, but it is showing as 1\\n\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n\\n        priority_queue<int> pq;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]-nums[i-1]);\\n            if(pq.size()>p)\\n            {\\n                pq.pop();\\n            }\\n        }\\n        \\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n"
                    },
                    {
                        "username": "aboocher",
                        "content": "the set only has three 2\\'s, not 4 as in your pairs"
                    },
                    {
                        "username": "indraarora726",
                        "content": "can anyone please explain how the answer for test case [8,9,1,5,4,3,6,4,3,7] for p = 4 equals to 1.\\nWHY???????????????????"
                    },
                    {
                        "username": "indraarora726",
                        "content": "[@souvikmkhrj](/souvikmkhrj)  Ya now i got it , was about to give up on this ques, now i think i can give it another chance."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i hope u understood the question. here p=4 means we have to take 4 pairs.\\nhere those 4 pairs will be [(3,3),(4,4),(5,6),(7,8)].  if we consider these 4 pairs then maximum of these 4 pairs will be 1. and if we consider other pair combinations this 1 value will be minimum . thats why ans is 1.  not gonna lie this question is very hard to understand. if u r still confused about the question and how 1 is the answer feel free to reply"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "1582 test cases, seriously?"
                    },
                    {
                        "username": "meraj05",
                        "content": "for nums=[1,1,0,3] and p=2, why the expected answer is 2 and not 3 \npair i formed [(1,1), (3,0)]"
                    },
                    {
                        "username": "eschrewe",
                        "content": "Well, the other option to form pairs would be:\\n(0,1) and (1,3). \\nDifferences of these pairs are 1 and 2 respectively. The maximum of these two differences is 2, so that\\xB4s the correct answer."
                    },
                    {
                        "username": "amit_9899",
                        "content": "FOR THOSE WHO DIDN'T UNDERSTAND THE QUESTION:\n\nWe have to choose 'p' pairs in the array and find the maximum difference among that 'p' pairs such that it is minimum of all the other combinations of 'p' pairs. For Example:\n nums = [10,1,2,7,1,3]   &   p = 2\n\nLet the first set of two(p=2) pairs be : (10, 7) & (2, 3) , so maximum difference among these pairs are max(3, 1) = 3.\n\nLet (10,2) & (1, 7) be another two pairs, so max diff among them will be max(8, 6) = 8\n                                                                    ..........and so on many pairs can be formed and finally we have to find the MINIMUM of all these MAXIMUMs.\nHence the answer in this will be 1 because of the two pairs (1,1) & (2,3) as explained.\n\n\nTIP : Sort the array and then everything will be clear to you."
                    }
                ]
            },
            {
                "id": 2007766,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007688,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007531,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007497,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007492,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007379,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007346,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007335,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007282,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007266,
                "content": [
                    {
                        "username": "asim35",
                        "content": "Python DP memorization solution not accepted. \n\n```\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n\n        if p == 0:\n            return 0\n\n        sorted_nums = sorted(nums)\n\n        pair_dif = []\n\n        for i in range(1, len(nums)):\n            pair_dif.append(sorted_nums[i] - sorted_nums[i-1])\n\n\n        \n        @cache\n        def get_min(i, left_pair):\n\n            if left_pair == 0:\n                return 0\n\n            if i >= len(pair_dif):\n                return float('inf')\n            \n            return min(\n                get_min(i+1, left_pair),\n                max(pair_dif[i], get_min(i+2, left_pair-1))\n            )\n\n        ans =  get_min(0, p)\n        return ans if ans != float('inf') else 0\n```"
                    },
                    {
                        "username": "manojdohale9689",
                        "content": "I think the question should be phrased like \"maximize the minimum difference\" insted of  \"minimize the maximum difference\"\\nbecause the title of problem statemet is bit confusing"
                    },
                    {
                        "username": "srietz",
                        "content": "Thinking through the following input:\\n   nums=[1, 1, 0, 3]    p=2\\n1. Pairs: (0, 1) (2, 3)\\n2. Output = 3?\\n\\nThe expected output is 2 but I don\\'t understand why :/\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@srietz](/srietz) No the rules is that the same INDEX mustn\\'t be repeated but the same number can still be stored in different index positions. There are two 1\\'s in the array. One is used in pair (0,1) and the other is used in (1,3). Had there been only one 1, it could only be used in one pair."
                    },
                    {
                        "username": "srietz",
                        "content": "[@psionl0](/psionl0) Right, I must be misunderstanding the problem set. Isn\\'t index 1 repeating in the solution you gave going against the rules?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You wrote the pairs wrong. They are (0,1) and (1,3) and the maximum difference is indeed 2."
                    },
                    {
                        "username": "H_Lu",
                        "content": "why would nums.legnth = 1 be allowed when you can\\'t get any pair from it"
                    },
                    {
                        "username": "khe1154",
                        "content": "the hint says dynamic programming the editorial says binary search \\uD83E\\uDD37"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Binary Search FTW!"
                    },
                    {
                        "username": "harchitgulati24",
                        "content": "can someone pls tell why this code is giving test case failed..i first counted all pairs with repeating elements then counting rest pairs which are not consisting repeating elements..pls help to correct the logic error in whichever line it is. \\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n     map<int,int>mpp;\\n     for(int i=0;i<nums.size();i++){\\n         mpp[nums[i]]++;\\n     }\\n     int maxi=INT_MIN;\\n     int pairs=0;\\n for(int j=0;j<mpp.size();j++){\\n     if(mpp[nums[j]]==2){\\n         pairs++;\\n         maxi=max(maxi,0);\\n         \\n     }\\n     if(pairs==p){\\n         return maxi;\\n     }\\n }\\n for(int k=0;k<nums.size();k++){\\n     if(mpp[nums[k]]!=2&&mpp[nums[k+1]]!=2){\\n     maxi=max(maxi,abs(nums[k]-nums[k+1]));\\n     pairs++;\\n     }\\n     if(pairs==p){\\n         break;\\n     }\\n }\\n return maxi;\\n }\\n};"
                    },
                    {
                        "username": "ritish_29",
                        "content": "Can anyone provide the dp code just want to check how the recurrence is written"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Binary search ruling this week!"
                    },
                    {
                        "username": "Le_Deer",
                        "content": "Hint: Can we use dynamic programming here? (`No`)\\nJokes aside, thinking of DP always check for the input constrains. Multidimensional DP often not feasible on big input numbers.."
                    },
                    {
                        "username": "Perpend-cular1",
                        "content": "1=Sort the Array                                                   2=Binary Search on Maximum Difference                     3=Check Feasibility each guess of the maximum difference greedy approach to try to create 4=Binary Search Continuation =feasibility check, adjust the binary search range and continue until you find the minimum maximum difference that satisfies the condition                                      \\n 5=This approach has a time complexity of O(n * log m)                                                                      6=space complexity is O(1)"
                    }
                ]
            },
            {
                "id": 2007226,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007217,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007113,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007100,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007089,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007055,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2007012,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2006955,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2006912,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2006820,
                "content": [
                    {
                        "username": "__himanshu26",
                        "content": "Ques : Minimize the maximum diff of pairs\\nans: Chips maang rha hai"
                    },
                    {
                        "username": "GiskardMx",
                        "content": "There is a test I don\\'t understand why the result is supposed to be 1.\\n\\nnums = [8,9,1,5,4,3,6,4,3,7]\\np = 4\\n\\nThe first pair 3,3, second pair 4,4, then we still have to form 2 pairs, each one of minimum 1. (5,6 & 7,8 for instance)\\n\\nMy algorithm returns 2 and I think is correct, but it seems like the response should be 1 and I don\\'t get it.\\n"
                    },
                    {
                        "username": "SSS33006",
                        "content": "Optimal Pairs: (3, 3), (4, 4), (5, 6), (7,8). The maximum difference is 1."
                    },
                    {
                        "username": "adityak16",
                        "content": "My code is failing for below test case:\\nnums = [1,1,0,3]\\np = 2\\nThe expected output given by leetcode is 2.\\nHowever, shouldn\\'t the output be 3\\nsince, we cannot repeat the indices in any pair the differences can be 0 (1-1) and 3 (0-3).\\nso, output should be 3.\\nIs the test case wrong? \\n "
                    },
                    {
                        "username": "metro187",
                        "content": "How about pairs (0,1) and (1,3)? the max dist is 2 in this case."
                    },
                    {
                        "username": "gonp19",
                        "content": "Is it feasible to employ a min heap? or am I wrong?"
                    },
                    {
                        "username": "aboocher",
                        "content": "[@schatterjee380](/schatterjee380) The question is basically saying:  Hey you have a bunch of players of different skill levels (ints) and you want to form them into p-pairs. Obviously there are lots of ways to do that, but you want to find a way to do it so that the max difference in skill level is as small as possible.   Like don\\'t choose pairs so that there\\'s a team with a difference of 5 unless you have to.  "
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I tried doing this. But I failed on tescase = [3,4,2,3,2,1,2]. I really don\\'t understand the question tbh."
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Binary Search Week"
                    },
                    {
                        "username": "JRcodesgood",
                        "content": "Js PriorityQueue does not work in this even though it is listed as available in this environment.\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "Ummm..... Find wHaT?? \\n"
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Why is answer for this 1? \\n\\nnums = [3,4,2,3,2,1] \\np = 3\\n\\nTo me it seems like answer should be 0 no? "
                    },
                    {
                        "username": "cautious_coder",
                        "content": "Got it. Thanks guys."
                    },
                    {
                        "username": "anivaries",
                        "content": "If you take (2,2), (3,3) as pairs then the third pair would be (4,1) and the highest would be 3. But with 3-4, 2-3, 2-1 pairs then the answer is |-1|, |-1|, |1| which is 1 "
                    },
                    {
                        "username": "LogiCule",
                        "content": "[1 2 ],[ 2 3] ,[3 4]\\nThis will be the pair list for the possible answer\\nso the answer is 1\\nTo get 0 we need to have 1,1 2,2 and 3,3\\nin this example if we try to keep 2,2 and 3,3 so the left pair is 1,4\\nwhich makes the max diff to be 3\\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It cannot be 0 because you need 3 pairs.\\nThe optimal choice here is to arrange the 3 pairs as follows:\\n(1,2)\\n(2,3)\\n(3,4)\\nEach of these has a difference of 1, so our maximum difference is 1. "
                    },
                    {
                        "username": "vodanh9710",
                        "content": "The answer is 3 pairs (1,2), (2,3), (3,4) and the difference of each pair is 1. So the maximum value of the difference among 3 pairs is 1."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Suggesting an approach that leads to MLE... The author really hates people."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "This problem is very confusing. Can anyone plz explain what it is trying to say?"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Ok i got it now. Thank u \\uD83D\\uDE01\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "0x6B0",
                        "content": "Suppose you have the following array: [2,4,4,7] and you require 1 pair. \\nWhat is the lowest possible difference you can attain in this question? 0, because you can choose (4,4), which give us our answer.\\nNow suppose we have the same array, but you require 2 pairs. What is the lowest possible difference? The answer is 3.\\nWe arrange our 2 pairs like so: (2,4) (4,7). The first pair has a difference of 2, whilst the 2nd pair has a difference of 3. So 3 is our answer.\\nNote that if we arranged our answer into (4,4) and (2,7) then the 2nd pair would have had a difference of 5, which is higher than 3, so it wouldn\\'t be the correct solution. "
                    }
                ]
            },
            {
                "id": 2006805,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006776,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006764,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006731,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006683,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006679,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006668,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006644,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006594,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006585,
                "content": [
                    {
                        "username": "vodanh9710",
                        "content": "Some hints:\n- Initial we have n - 1 pairs (i, i+1) with value nums[i+1]-nums[i]\n- Try to remove the pair has largest value nums[i+1]-nums[i] and then the smaller ones, but keep the remain still have possible answer\n- Use array to store a range (u, v) which means pairs (u, u+1), (u+1, u+2), ..., (v, v+1) in the remain\n- In each range (u, v), we can only choose maximum (v-u)/2+1 pairs to build the answer"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I think it\\'s time for me to finally accept that i\\'m terrible at binary search\\n"
                    },
                    {
                        "username": "manjarinm10",
                        "content": "The question asks to find minimum of maximum difference pair, in the examples they are showing the maximum of minimum difference pairs. :( Please correct me if I'm wrong here.\n\n\nTell me what should be the answer of this\nnums = [10,1,2,1,7,3] ; p=3\n1 right?\nIt is showing 3. \nInsights please "
                    },
                    {
                        "username": "0x6B0",
                        "content": "You are seeking to minimize the maximum of the difference within the pairs. Since you seek 3 pairs, those pairs will take up all of the array entries, and (10-7) is the \"smallest\" largest difference we can attain, because if we place any other number into the pair containing 10, we will get a larger number."
                    },
                    {
                        "username": "vivekcoool21",
                        "content": "[@Pritz10](/Pritz10) +1"
                    },
                    {
                        "username": "Pritz10",
                        "content": "No, the answer will be 3. Because, (1,2) , (1,3) and (7,10) will be optimal. The differences of the pairs are 1,2 and 3. The maximum among them is 3. So, 3 will be returned.\n\n\nIf we would have chosen (1,1), (2,3), (7,10) then also the answer will be 3. But if we choose (1,7),(2,3),(1,10) then answer will be 9. So , our target is to minimize the answer."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "Could anyone explain for me the testcase: [1,2,3,4] with p = 2, the expected result is 1 please  "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Two pairs to take. There are three variants at all. If you take (1,2) and (3,4), then the result is max(4 - 3, 2 - 1)  = 1. If you take (1, 3), (2, 4), the result is 2. If  you take  (1, 4), (2, 3) the results if 4 - 1 = 3. So the answer is 1. "
                    },
                    {
                        "username": "julkar9",
                        "content": "Similar question https://leetcode.com/problems/find-k-th-smallest-pair-distance/"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "It\\'s times like these I wish the debugger wasn\\'t a paid feature"
                    },
                    {
                        "username": "swo0sh",
                        "content": "Hint: Think if given a particular difference. Find if it is possible to have p pairs. Then, the best way why this would be a binary search is as follows: As the difference increases, it goes from not possible to possbile. Thus, we need to find the first possbile."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the problem statement isnt worded right"
                    },
                    {
                        "username": "0x6B0",
                        "content": "It is"
                    },
                    {
                        "username": "rugwed_37",
                        "content": "Why is it not possible with the help of priority queue\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& nums, int p) {\\n    int sum = 0;\\n    priority_queue<pair<int, pair<int, int>>, \\n    vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                pq.push({abs(nums[i] - nums[j]), {nums[i], nums[j]}});\\n            }\\n        }\\n\\n        while (p--) {\\n            auto it = pq.top();\\n            int x = it.first;\\n            sum += x;\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\nwatch this sol passes 968 test cases \\nInput\\nnums =\\n[8,9,1,5,4,3,6,4,3,7]\\np =\\n4\\nOutput\\n2\\nExpected\\n1\\nand fails for this dont know why , output should be 2 in this case"
                    },
                    {
                        "username": "pcRipper",
                        "content": "consider, that there can by such a test [1,23,23,99] 2"
                    }
                ]
            },
            {
                "id": 2006515,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006487,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006479,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006478,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006473,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006460,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006433,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006397,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006393,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            },
            {
                "id": 2006365,
                "content": [
                    {
                        "username": "Akash-190",
                        "content": "I am getting my 653/1286 testcases right, don\\'t know where i am missing the key.."
                    },
                    {
                        "username": "Akash-190",
                        "content": "[@sober_junkie](/sober_junkie)  sry ,my mistake"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "bro there are 1582 testcases"
                    },
                    {
                        "username": "dnox",
                        "content": "at first I tried to use a queue but it didn\\'t work because you need to end up with exactly P pairs (and not less)"
                    },
                    {
                        "username": "pramodkumar808751528270",
                        "content": "this questions is too confusing "
                    },
                    {
                        "username": "Akash-190",
                        "content": "I think this is Binary search on Answer type question."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Tricky to arrive at the logic!!!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Greedy Fails at \\n `[1,1,0,3]`\\n`p=2`"
                    },
                    {
                        "username": "psionl0",
                        "content": "Greedy works fine here. [1,1,0,3] when sorted is [0,1,1,3] which can be grouped as [(0,1),(1,3)]. Clearly the maximum difference for p=2 groups is 2."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "What is Navi?!\\n\\nSkip.."
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "the hint is misleading"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Failed with the following test case:\\n```\\n[0,5,3,4]\\n0\\n```\\n\\nYou need to handle `p=0`"
                    },
                    {
                        "username": "kartik_45",
                        "content": "can anyone help me out to write this possible function?\nwith O(n)  ?\n bool posible(int mid,vector<int>nums,int p){\n        int cnt=0;\n        for(int i=0;i<nums.size()-1;i++){\n            int diff=abs(nums[i]-nums[i+1]);\n            if(diff<=mid)cnt++;\n            if(cnt==p)return true;\n        }\n        return false;\n    }     "
                    }
                ]
            }
        ]
    }
]