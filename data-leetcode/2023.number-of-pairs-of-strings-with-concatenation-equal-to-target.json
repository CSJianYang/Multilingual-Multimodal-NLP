[
    {
        "title": "Number of Pairs of Strings With Concatenation Equal to Target",
        "question_content": "Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.\n&nbsp;\nExample 1:\n\nInput: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\nOutput: 4\nExplanation: Valid pairs are:\n- (0, 1): \"777\" + \"7\"\n- (1, 0): \"7\" + \"777\"\n- (2, 3): \"77\" + \"77\"\n- (3, 2): \"77\" + \"77\"\n\nExample 2:\n\nInput: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\nOutput: 2\nExplanation: Valid pairs are:\n- (0, 1): \"123\" + \"4\"\n- (2, 3): \"12\" + \"34\"\n\nExample 3:\n\nInput: nums = [\"1\",\"1\",\"1\"], target = \"11\"\nOutput: 6\nExplanation: Valid pairs are:\n- (0, 1): \"1\" + \"1\"\n- (1, 0): \"1\" + \"1\"\n- (0, 2): \"1\" + \"1\"\n- (2, 0): \"1\" + \"1\"\n- (1, 2): \"1\" + \"1\"\n- (2, 1): \"1\" + \"1\"\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 100\n\t1 <= nums[i].length <= 100\n\t2 <= target.length <= 100\n\tnums[i] and target consist of digits.\n\tnums[i] and target do not have leading zeros.",
        "solutions": [
            {
                "id": 1503157,
                "title": "c-simple-and-easy-solution-with-detailed-explanation",
                "content": "**Idea:**\\nFirst, we store in a map the frequencies of the strings, so that we can find easily which strings we have and how many.\\nNow, we iterate through the `freq` map.\\nFor every string:\\n1. We check if it\\'s a prefix of our `target`.\\n2. If yes, first case is that the target is exactly twice the prefix. If so, we add `frq*(frq-1)` to `res`.\\nThe reason is that the number of combinations for a pattern with frequency n is n * (n-1).\\n3. Otherwise we look in the map if we have the suffix, if so - we add the product of their frequencies to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> freq;\\n        for (auto num : nums) if (num.size() < target.size()) freq[num]++;\\n        \\n        int res = 0;\\n        for (auto [s, frq] : freq) {\\n            \\n            if (target.find(s) == 0) {\\n                \\n                if (s + s == target) \\n                    res += frq*(frq-1);\\n                \\n                else \\n                    res += frq * freq[target.substr(s.size())];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> freq;\\n        for (auto num : nums) if (num.size() < target.size()) freq[num]++;\\n        \\n        int res = 0;\\n        for (auto [s, frq] : freq) {\\n            \\n            if (target.find(s) == 0) {\\n                \\n                if (s + s == target) \\n                    res += frq*(frq-1);\\n                \\n                else \\n                    res += frq * freq[target.substr(s.size())];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499007,
                "title": "python3-freq-table",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/182350e41572fb26ffb8c44204b037cc9f0e5035) for solutions of biweekly 62. \\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        freq = Counter(nums)\\n        ans = 0 \\n        for k, v in freq.items(): \\n            if target.startswith(k): \\n                suffix = target[len(k):]\\n                ans += v * freq[suffix]\\n                if k == suffix: ans -= freq[suffix]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        freq = Counter(nums)\\n        ans = 0 \\n        for k, v in freq.items(): \\n            if target.startswith(k): \\n                suffix = target[len(k):]\\n                ans += v * freq[suffix]\\n                if k == suffix: ans -= freq[suffix]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499306,
                "title": "java-simple-solution-beats-100",
                "content": "Just maintain a map containing the freq. Now all we have to do is to check freq of needed suffix/prefix.  \\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int tot = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (target.startsWith(nums[i])) {\\n                String sub = target.substring(nums[i].length());\\n                if (map.containsKey(sub))\\n                    tot += map.get(sub);\\n            }\\n           if (target.endsWith(nums[i])) {\\n                String sub = target.substring(0, target.length()-nums[i].length());\\n                if (map.containsKey(sub))\\n                    tot += map.get(sub);\\n            }\\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int tot = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (target.startsWith(nums[i])) {\\n                String sub = target.substring(nums[i].length());\\n                if (map.containsKey(sub))\\n                    tot += map.get(sub);\\n            }\\n           if (target.endsWith(nums[i])) {\\n                String sub = target.substring(0, target.length()-nums[i].length());\\n                if (map.containsKey(sub))\\n                    tot += map.get(sub);\\n            }\\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500500,
                "title": "short-self-explanatory-2-approaches-c-beginner-friendly",
                "content": "**Brute Force Approach**\\n**Time: O(n^2) where n is size of nums**\\n**Space: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j and target == nums[i]+nums[j]){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Using unordered map**\\n**Time: O(n + mk) where where n is size of nums, m is target size and k is the length of the resulting substring.\\nSpace: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        int n=target.size();\\n        unordered_map<string, int> map;\\n        for(auto digit : nums)\\n            map[digit]++;\\n        \\n        for(int i=0; i<target.size(); i++){\\n            string s1=target.substr(0,i);\\n            string s2=target.substr(i,n);\\n            if(s1 == s2){\\n               cnt+=map[s1]*(map[s2]-1);\\n            }else{\\n                cnt+=map[s1]*map[s2]; \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j and target == nums[i]+nums[j]){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        int n=target.size();\\n        unordered_map<string, int> map;\\n        for(auto digit : nums)\\n            map[digit]++;\\n        \\n        for(int i=0; i<target.size(); i++){\\n            string s1=target.substr(0,i);\\n            string s2=target.substr(i,n);\\n            if(s1 == s2){\\n               cnt+=map[s1]*(map[s2]-1);\\n            }else{\\n                cnt+=map[s1]*map[s2]; \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499081,
                "title": "java-python-3-one-pass-o-nm-hashtable-codes-w-analysis",
                "content": "```java\\n    public int numOfPairs(String[] nums, String target) {\\n        int cnt = 0, n = target.length();\\n        Map<Integer, Integer> prefix = new HashMap<>(), suffix = new HashMap<>();\\n        for (String num : nums) {\\n            int sz = num.length();\\n            if (target.startsWith(num)) {\\n                cnt += suffix.getOrDefault(n - sz, 0);\\n            }\\n            if (target.endsWith(num)) {\\n                cnt += prefix.getOrDefault(n - sz, 0);\\n            }\\n            if (target.startsWith(num)) {\\n                prefix.put(sz, 1 + prefix.getOrDefault(sz, 0));\\n            }\\n            if (target.endsWith(num)) {\\n                suffix.put(sz, 1 + suffix.getOrDefault(sz, 0));\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n            prefix, suffix = Counter(), Counter()\\n            cnt = 0\\n            for num in nums:\\n                if target.startswith(num):\\n                    cnt += suffix[len(target) - len(num)]\\n                if target.endswith(num):\\n                    cnt += prefix[len(target) - len(num)]\\n                if target.startswith(num):\\n                    prefix[len(num)] += 1\\n                if target.endswith(num):\\n                    suffix[len(num)] += 1\\n            return cnt\\n```\\n**Analysis:**\\n\\nLet `N = nums.length`, `M` be the average size of the digits in `nums`, and `T = target.length()`, then each `startsWith()` cost time O(min(M, T)), therefore the total time is `O(N * M)`, space cost `O(N)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int numOfPairs(String[] nums, String target) {\\n        int cnt = 0, n = target.length();\\n        Map<Integer, Integer> prefix = new HashMap<>(), suffix = new HashMap<>();\\n        for (String num : nums) {\\n            int sz = num.length();\\n            if (target.startsWith(num)) {\\n                cnt += suffix.getOrDefault(n - sz, 0);\\n            }\\n            if (target.endsWith(num)) {\\n                cnt += prefix.getOrDefault(n - sz, 0);\\n            }\\n            if (target.startsWith(num)) {\\n                prefix.put(sz, 1 + prefix.getOrDefault(sz, 0));\\n            }\\n            if (target.endsWith(num)) {\\n                suffix.put(sz, 1 + suffix.getOrDefault(sz, 0));\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n            prefix, suffix = Counter(), Counter()\\n            cnt = 0\\n            for num in nums:\\n                if target.startswith(num):\\n                    cnt += suffix[len(target) - len(num)]\\n                if target.endswith(num):\\n                    cnt += prefix[len(target) - len(num)]\\n                if target.startswith(num):\\n                    prefix[len(num)] += 1\\n                if target.endswith(num):\\n                    suffix[len(num)] += 1\\n            return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1499860,
                "title": "prefix-and-suffix-counts",
                "content": "For each string, check if it\\'s prefix and/or suffix of the target. Track the count of prefixes and suffixes for each position in the target.\\n\\n#### Approach 1: Multiply in the end\\nWe count prefix and suffix matches, and multiply them in the end. Note that we need handle an edge case when the target is symmetric.\\n\\n**C++**\\n```cpp\\nint numOfPairs(vector<string>& nums, string t) {\\n    int pref[101] = {}, suf[101] = {}, sz = t.size();\\n    for (auto &n : nums)\\n        if (n.size() < sz) {\\n            pref[n.size()] += t.compare(0, n.size(), n) == 0;\\n            suf[sz - n.size()] += t.compare(sz - n.size(), n.size(), n) == 0;\\n        }\\n    return inner_product(begin(pref), end(pref), begin(suf), 0) \\n        - (t.substr(0, sz / 2) == t.substr(sz / 2) ? suf[sz / 2] : 0);\\n} \\n```\\n\\n#### Approach 2: Count as you go\\n Unlike the first solution, here we accumulate the matches as we go. \\n \\n**C++**\\n```cpp\\nint numOfPairs(vector<string>& nums, string t) {\\n    int pref[101] = {}, suf[101] = {}, res = 0;\\n    for (auto &n : nums)\\n        if (n.size() < t.size()) {\\n            bool isPref = t.compare(0, n.size(), n) == 0;\\n            bool isSuf = t.compare(t.size() - n.size(), n.size(), n) == 0;\\n            res += (isPref ? suf[n.size()] : 0) + (isSuf ? pref[t.size() - n.size()] : 0);\\n            pref[n.size()] += isPref;\\n            suf[t.size() - n.size()] += isSuf;\\n        }\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numOfPairs(vector<string>& nums, string t) {\\n    int pref[101] = {}, suf[101] = {}, sz = t.size();\\n    for (auto &n : nums)\\n        if (n.size() < sz) {\\n            pref[n.size()] += t.compare(0, n.size(), n) == 0;\\n            suf[sz - n.size()] += t.compare(sz - n.size(), n.size(), n) == 0;\\n        }\\n    return inner_product(begin(pref), end(pref), begin(suf), 0) \\n        - (t.substr(0, sz / 2) == t.substr(sz / 2) ? suf[sz / 2] : 0);\\n} \\n```\n```cpp\\nint numOfPairs(vector<string>& nums, string t) {\\n    int pref[101] = {}, suf[101] = {}, res = 0;\\n    for (auto &n : nums)\\n        if (n.size() < t.size()) {\\n            bool isPref = t.compare(0, n.size(), n) == 0;\\n            bool isSuf = t.compare(t.size() - n.size(), n.size(), n) == 0;\\n            res += (isPref ? suf[n.size()] : 0) + (isSuf ? pref[t.size() - n.size()] : 0);\\n            pref[n.size()] += isPref;\\n            suf[t.size() - n.size()] += isSuf;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566610,
                "title": "java-o-n-beats-99-41-concise-solution-hashmap-with-detailed-explanation",
                "content": "Create  a  hash table to keep the counts of each substring and then calculate the ans by checking whether the susbtring before the partition and substring after partition equal the target and both exist in the map with the partition passing linearly through the target. \\n\\n\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i<nums.length; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        int ans = 0, n = target.length();\\n        String a = \"\", b= \"\";\\n        for (int i = 1; i<n; i++){\\n            a = target.substring(0,i);\\n            b = target.substring(i,n);\\n            if (map.containsKey(a) && map.containsKey(b)){\\n                if (a.equals(b)) ans += (map.get(a) * (map.get(a)-1));\\n                else ans+= (map.get(a) * map.get(b));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i<nums.length; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        int ans = 0, n = target.length();\\n        String a = \"\", b= \"\";\\n        for (int i = 1; i<n; i++){\\n            a = target.substring(0,i);\\n            b = target.substring(i,n);\\n            if (map.containsKey(a) && map.containsKey(b)){\\n                if (a.equals(b)) ans += (map.get(a) * (map.get(a)-1));\\n                else ans+= (map.get(a) * map.get(b));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231891,
                "title": "brute-force-hashing-time-complexity-space-complexity-explanation",
                "content": "# **Brute Force**\\n\\nTime Complexity - The two nested loops create create a time complexity of O(N^2).\\nSpace Complexity - Since we are not using any extra space, space complexity is O(1).\\nExplanation - We take each and every pair possible using nested loops and concatenate the pair to check if we have achieved the target.\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i != j && nums[i] + nums[j] == target) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# **Hashing Approach (optimized)**\\nTime Complexity - Iterating over the entire array takes O(N) time.\\nSpace Complexity - Since we are using a hashmap, space complexity is O(N).\\nExplanation - We store all the possible suffixes in a hashmap mp. Iterating over the array, we take each word individually and check if they can be a possible prefix. Once we find a possible prefix, we find the suffix required to be concatenated with it in order to create our target. If we find that this suffix is present in our hashmap mp, we increase the value of count by mp[suffix] (if prefix and suffix are equal, we increase count by mp[suffix] - 1 to avoid taking the same string as prefix and suffix).\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int prefixLength, targetLength = target.length(), count = 0;\\n        unordered_map<string, int> mp;\\n        for(auto suffix : nums) mp[suffix]++;\\n        \\n        for(auto prefix : nums){\\n            prefixLength = prefix.length();\\n            if(target.substr(0, prefixLength) == prefix){\\n                string suffix = target.substr(prefixLength);\\n                if(mp.find(suffix) != mp.end()){\\n                    count += (prefix == suffix) ? (mp[suffix] - 1) : (mp[suffix]); \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i != j && nums[i] + nums[j] == target) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int prefixLength, targetLength = target.length(), count = 0;\\n        unordered_map<string, int> mp;\\n        for(auto suffix : nums) mp[suffix]++;\\n        \\n        for(auto prefix : nums){\\n            prefixLength = prefix.length();\\n            if(target.substr(0, prefixLength) == prefix){\\n                string suffix = target.substr(prefixLength);\\n                if(mp.find(suffix) != mp.end()){\\n                    count += (prefix == suffix) ? (mp[suffix] - 1) : (mp[suffix]); \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499270,
                "title": "c-frequency-map",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Prefix State Map\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(NW) where `N` is the length of `A` and `W` is the maximum length of elements in `A`\\n// Space: O(U) where `U` is the number of unique strings in `A`.\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& A, string s) {\\n        unordered_map<string, int> m;\\n        int ans = 0;\\n        for (auto &t : A) {\\n            if (t.size() > s.size()) continue;\\n            if (s.substr(0, t.size()) == t) ans += m[s.substr(t.size())];\\n            m[t]++;\\n        }\\n        m.clear();\\n        reverse(begin(A), end(A));\\n        for (auto &t : A) {\\n            if (t.size() > s.size()) continue;\\n            if (s.substr(0, t.size()) == t) ans += m[s.substr(t.size())];\\n            m[t]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Frequency Map\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(NW) where `N` is the length of `A` and `W` is the maximum length of elements in `A`\\n// Space: O(U) where `U` is the number of unique strings in `A`.\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& A, string s) {\\n        unordered_map<string, int> m;\\n        for (auto &t : A) m[t]++;\\n        int ans = 0;\\n        for (auto &[prefix, cnt] : m) {\\n            if (prefix.size() > s.size()) continue;\\n            if (s.substr(0, prefix.size()) == prefix) {\\n                auto suffix = s.substr(prefix.size());\\n                ans += m[prefix] * m[suffix];\\n                if (prefix == suffix) ans -= m[prefix];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(NW) where `N` is the length of `A` and `W` is the maximum length of elements in `A`\\n// Space: O(U) where `U` is the number of unique strings in `A`.\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& A, string s) {\\n        unordered_map<string, int> m;\\n        int ans = 0;\\n        for (auto &t : A) {\\n            if (t.size() > s.size()) continue;\\n            if (s.substr(0, t.size()) == t) ans += m[s.substr(t.size())];\\n            m[t]++;\\n        }\\n        m.clear();\\n        reverse(begin(A), end(A));\\n        for (auto &t : A) {\\n            if (t.size() > s.size()) continue;\\n            if (s.substr(0, t.size()) == t) ans += m[s.substr(t.size())];\\n            m[t]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(NW) where `N` is the length of `A` and `W` is the maximum length of elements in `A`\\n// Space: O(U) where `U` is the number of unique strings in `A`.\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& A, string s) {\\n        unordered_map<string, int> m;\\n        for (auto &t : A) m[t]++;\\n        int ans = 0;\\n        for (auto &[prefix, cnt] : m) {\\n            if (prefix.size() > s.size()) continue;\\n            if (s.substr(0, prefix.size()) == prefix) {\\n                auto suffix = s.substr(prefix.size());\\n                ans += m[prefix] * m[suffix];\\n                if (prefix == suffix) ans -= m[prefix];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029352,
                "title": "c-2-solutions-permutation-and-combination-approach-brute-force",
                "content": "# Intuition - Brute Force\\n- The first apprach is a simple one. You just find all the combinations of the strings, concatenate them and thereafter find whether the concatenated string matches the `target` string.\\n- Had this been the ONLY solution to the problem, this problem would have been marked as an easy problem. However, there\\'s another optimization to the problem which is given below...\\n\\n# Intuition - Optimized Permutation and Combination Approach\\n- Here, rather than concatenating all the given strings, we break the `target` string into substrings and find whether these 2 strings are present in the pool of strings given to us in the `nums` vector. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Since we know that we\\'re going to perform searching in `nums`, we create another `unordered_map` which contains these given strings as well as their frequencies in `nums`.\\n- Now, for every pair of substrins we can create using the `target`, we firstly check whether both of them exists in the pool of strings given to us. If yes, we perform the steps below.\\n- If the 2 substrings not equal, we find the number of occurences of both of these substrings, multiply their occurences and thereafter add the result to an `ans` variable.\\n- If the 2 substrings are equal, we\\'d do the same, rather we\\'ll subtract 1 from either of the frequencies and thereafter add the result in the `ans` variable.\\n\\n# Explanation\\n- The optimized approach is based on Permutation and Combination.\\n- Imagine `N` number of things are to be paired with `M` number of things. The total number of ways in which you can do that is `N x M`. More specifically, it\\'s $${N\\\\choose 1}$$ x $${M\\\\choose 1}$$.\\n- Similarly, if you have `N` number of things and you want to pair them with one another, you can do that in `N x (N - 1)` ways. More specifically, it\\'s $${N\\\\choose 1}$$ x $${N - 1\\\\choose 1}$$ (Since 1 `N` is already chosen).\\n\\n(Here, $${N\\\\choose R}$$ means superscript N, C, subscript R, which means the number of ways of choosing R different things out of N things)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - Brute Force \\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                if(i != j && nums[i] + nums[j] == target){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code - Optimized Approach\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string  , int> allNums;\\n        for(string i : nums){\\n            allNums[i]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 1; i < target.length(); i++){\\n            string s1 = target.substr(0 , i);\\n            string s2 = target.substr(i , target.length() - i);\\n\\n            if(allNums.find(s1) != allNums.end() && allNums.find(s2) != allNums.end()){\\n                if(s1 != s2){\\n                    ans += (allNums[s1] * allNums[s2]);\\n                } else {\\n                    ans += (allNums[s1] * (allNums[s2] - 1));\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Note\\nI\\'m still learning and there maybe a solution which is better than mine. In a case like such, I\\'ll be obliged to discuss in the comment section below. \\n\\nI wish we all land up to the place where we\\'re dreaming of. The goal is to never give up for what\\'s right and not focusing on the people who want you to stop from doing that despite all odds.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                if(i != j && nums[i] + nums[j] == target){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string  , int> allNums;\\n        for(string i : nums){\\n            allNums[i]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 1; i < target.length(); i++){\\n            string s1 = target.substr(0 , i);\\n            string s2 = target.substr(i , target.length() - i);\\n\\n            if(allNums.find(s1) != allNums.end() && allNums.find(s2) != allNums.end()){\\n                if(s1 != s2){\\n                    ans += (allNums[s1] * allNums[s2]);\\n                } else {\\n                    ans += (allNums[s1] * (allNums[s2] - 1));\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518751,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> um;\\n        int n = target.size();\\n        for(string &str : nums)\\n            um[str]++;\\n        int ans = 0;\\n        string p1 = \"\", p2;\\n        for(int i = 0; i < n; i++)\\n        {\\n            //cout << i << \" \";\\n            p1 += target[i];\\n            p2 = target.substr(i+1);\\n            //cout << p1 << \" \" << p2 << endl;\\n            if(p1 == p2)\\n            {\\n                if(!um.count(p1))\\n                    continue;\\n                int val = um[p1];\\n                ans += val*(val-1);\\n            }\\n            else\\n            {\\n                if(um.count(p1) && um.count(p2))\\n                {\\n                    int val1 = um[p1], val2 = um[p2];\\n                    ans += val1*val2;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> um;\\n        int n = target.size();\\n        for(string &str : nums)\\n            um[str]++;\\n        int ans = 0;\\n        string p1 = \"\", p2;\\n        for(int i = 0; i < n; i++)\\n        {\\n            //cout << i << \" \";\\n            p1 += target[i];\\n            p2 = target.substr(i+1);\\n            //cout << p1 << \" \" << p2 << endl;\\n            if(p1 == p2)\\n            {\\n                if(!um.count(p1))\\n                    continue;\\n                int val = um[p1];\\n                ans += val*(val-1);\\n            }\\n            else\\n            {\\n                if(um.count(p1) && um.count(p2))\\n                {\\n                    int val1 = um[p1], val2 = um[p2];\\n                    ans += val1*val2;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1580368,
                "title": "prefix-and-suffix-frequency-c-easy-to-understand-clean-code",
                "content": "\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        \\n        int t = target.size();\\n        \\n        vector<int> prefix(t, 0), suffix(t, 0);\\n        \\n        int count = 0;\\n        for(int i=0; auto& num : nums) {\\n            int n = num.size();\\n            \\n            if(n >= t) continue;\\n            \\n            bool isPrefix = target.compare(0, n, num) == 0;\\n            bool isSuffix = target.compare(t - n, n, num) == 0;\\n            \\n            if(isPrefix) count += suffix[n];\\n            if(isSuffix) count += prefix[t-n-1];\\n            \\n            if(isPrefix) prefix[n-1]++;\\n            if(isSuffix) suffix[t-n]++;\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* **Time** : `O(N * n)` , \\n\\t* N is size of nums array and n is size(*avg*) of each num in nums\\n\\t* Since we are comparing each number with target, so we need to account that as well\\n* **Space** : `O(N)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        \\n        int t = target.size();\\n        \\n        vector<int> prefix(t, 0), suffix(t, 0);\\n        \\n        int count = 0;\\n        for(int i=0; auto& num : nums) {\\n            int n = num.size();\\n            \\n            if(n >= t) continue;\\n            \\n            bool isPrefix = target.compare(0, n, num) == 0;\\n            bool isSuffix = target.compare(t - n, n, num) == 0;\\n            \\n            if(isPrefix) count += suffix[n];\\n            if(isSuffix) count += prefix[t-n-1];\\n            \\n            if(isPrefix) prefix[n-1]++;\\n            if(isSuffix) suffix[t-n]++;\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499029,
                "title": "python-3-simple-one-liner-using-permutations-straightforward",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums, target):\\n        return sum(i + j == target for i, j in permutations(nums, 2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums, target):\\n        return sum(i + j == target for i, j in permutations(nums, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499008,
                "title": "c-unordered-map-solution",
                "content": "Go through every string and check if its a substring of the target. If yes, search for the remaining substring from the target from the map we\\'ve built upfront that tells us where(index) each string was found.\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        std::unordered_map<std::string, std::vector<int>> strings;\\n        \\n        for(size_t i = 0; i < nums.size(); i++) {\\n            strings[nums[i]].push_back(i);\\n        }\\n        size_t total = 0;\\n        for(size_t i = 0; i < nums.size(); i++) {\\n            if (target.compare(0, nums[i].size(), nums[i]) == 0) {\\n                std::string remaining = target.substr(nums[i].size());\\n                auto count_it = strings.find(remaining);\\n                if (count_it != strings.end()) {\\n                    total += count_it->second.size();\\n                    // If the string pairs are identical, we should eliminate (i,i) kind of pairs\\n                    // since the problem states that i != j\\n                    if (remaining == nums[i]) {\\n                        total--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\\n\\nTime Complexity = `O(MN)` where `M` is the average string length of the given strings and `N` is the total number of strings.\\nSpace Complexity = `O(N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        std::unordered_map<std::string, std::vector<int>> strings;\\n        \\n        for(size_t i = 0; i < nums.size(); i++) {\\n            strings[nums[i]].push_back(i);\\n        }\\n        size_t total = 0;\\n        for(size_t i = 0; i < nums.size(); i++) {\\n            if (target.compare(0, nums[i].size(), nums[i]) == 0) {\\n                std::string remaining = target.substr(nums[i].size());\\n                auto count_it = strings.find(remaining);\\n                if (count_it != strings.end()) {\\n                    total += count_it->second.size();\\n                    // If the string pairs are identical, we should eliminate (i,i) kind of pairs\\n                    // since the problem states that i != j\\n                    if (remaining == nums[i]) {\\n                        total--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508864,
                "title": "java-for-loop-solution",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i != j && nums[i].concat(nums[j]).equals(target)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i != j && nums[i].concat(nums[j]).equals(target)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663989,
                "title": "javascript-solution-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/49b311f1-e02d-40fb-9d3c-20bc48bf7009_1641200268.787811.jpeg)\\n```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function(nums, target) {\\n    var count = 0;\\n    var x = 0;\\n    while (x < nums.length) {\\n        for (let y = 0; y<nums.length; y++) {\\n            if (nums[x] + nums[y] == target) {\\n                count += 1;\\n                if (x == y) {\\n                    count -= 1;\\n                }\\n            }\\n        }\\n        x++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function(nums, target) {\\n    var count = 0;\\n    var x = 0;\\n    while (x < nums.length) {\\n        for (let y = 0; y<nums.length; y++) {\\n            if (nums[x] + nums[y] == target) {\\n                count += 1;\\n                if (x == y) {\\n                    count -= 1;\\n                }\\n            }\\n        }\\n        x++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933589,
                "title": "c-clean-explanation-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> mp;\\n        for (string s : nums) mp[s]++;\\n        int ret = 0;\\n        for (string prefix : nums) {\\n            if (target.substr(0, prefix.length()) != prefix) continue;\\n            string suffix = target.substr(prefix.length());\\n            if (mp.find(suffix) == mp.end()) continue;\\n            int c = mp[suffix];\\n            ret += (prefix == suffix ? c-1 : c);\\n        }\\n        return ret;\\n    }\\n};\\n\\n/**\\n\\nBrute Force: N(n^2)\\n\\nUsing Hash Set: O(n)\\n====================\\n1. First count all items and put in map.\\n2. Traverse the array. Find remaining suffix in map.\\n3. If map gives us count C add C into result.\\n4. Exception: If prefix and suffix are same then add C-1 into result.\\n\\n**/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> mp;\\n        for (string s : nums) mp[s]++;\\n        int ret = 0;\\n        for (string prefix : nums) {\\n            if (target.substr(0, prefix.length()) != prefix) continue;\\n            string suffix = target.substr(prefix.length());\\n            if (mp.find(suffix) == mp.end()) continue;\\n            int c = mp[suffix];\\n            ret += (prefix == suffix ? c-1 : c);\\n        }\\n        return ret;\\n    }\\n};\\n\\n/**\\n\\nBrute Force: N(n^2)\\n\\nUsing Hash Set: O(n)\\n====================\\n1. First count all items and put in map.\\n2. Traverse the array. Find remaining suffix in map.\\n3. If map gives us count C add C into result.\\n4. Exception: If prefix and suffix are same then add C-1 into result.\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557794,
                "title": "python3-o-n-solution-made-easy",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        container, res = {}, 0\\n        tlen = len(target)\\n        for i in range(len(nums)):\\n            ilen = len(nums[i])\\n            if target[:ilen] == nums[i] and target[ilen:] in container:\\n                res += container[target[ilen:]]\\n            if target[tlen - ilen:] == nums[i] and target[:tlen - ilen] in container:\\n                res += container[target[:tlen - ilen]]\\n            container[nums[i]] = container.get(nums[i], 0) + 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        container, res = {}, 0\\n        tlen = len(target)\\n        for i in range(len(nums)):\\n            ilen = len(nums[i])\\n            if target[:ilen] == nums[i] and target[ilen:] in container:\\n                res += container[target[ilen:]]\\n            if target[tlen - ilen:] == nums[i] and target[:tlen - ilen] in container:\\n                res += container[target[:tlen - ilen]]\\n            container[nums[i]] = container.get(nums[i], 0) + 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505793,
                "title": "c-using-unordered-map-and-string-functions",
                "content": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n    int n=nums.size();\\n    int ans=0;\\n    unordered_map<string,int> mp;\\n    for(int i=0;i<n;++i){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<n;++i){\\n        if(nums[i]==target.substr(0,nums[i].size())){\\n            string remaining=target.substr(nums[i].size());\\n            if(mp.find(remaining)!=mp.end()){\\n                ans+=mp[remaining];\\n                if(remaining==nums[i]){\\n                    ans--;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n    int n=nums.size();\\n    int ans=0;\\n    unordered_map<string,int> mp;\\n    for(int i=0;i<n;++i){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<n;++i){\\n        if(nums[i]==target.substr(0,nums[i].size())){\\n            string remaining=target.substr(nums[i].size());\\n            if(mp.find(remaining)!=mp.end()){\\n                ans+=mp[remaining];\\n                if(remaining==nums[i]){\\n                    ans--;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499246,
                "title": "java-simple-brute-force-solution-stringbuilder",
                "content": "```\\nint count = 0;\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;     // for Eg: nums[] = [\"123\", \"4\"] and target = \"1234\"\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++){\\n\\t\\t    // add nums[i] in ans, ans = \"123\"\\n            ans.append(nums[i]);\\n            for(int j = 0; j < n; j++){\\n                if(i != j){\\n\\t\\t\\t\\t    //add nums[j] in ans, ans = \"123\" + \"4\" = \"1234\"\\n                    ans.append(nums[j]);\\n\\t\\t\\t\\t\\t//Check if ans == target\\n                    if(ans.toString().equals(target) == true){\\n                        count++;\\n                    }\\n\\t\\t\\t\\t\\t//remove nums[j] added in ans, so delete everything added after nums[i] to last, ans = \"123\"\\n                    ans.delete(nums[i].length(), ans.length());\\n                }\\n            }\\n\\t\\t\\t//remove nums[i] added in ans, ans = \"\" \\n\\t\\t\\tans.delete(0,  ans.length());\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nint count = 0;\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;     // for Eg: nums[] = [\"123\", \"4\"] and target = \"1234\"\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++){\\n\\t\\t    // add nums[i] in ans, ans = \"123\"\\n            ans.append(nums[i]);\\n            for(int j = 0; j < n; j++){\\n                if(i != j){\\n\\t\\t\\t\\t    //add nums[j] in ans, ans = \"123\" + \"4\" = \"1234\"\\n                    ans.append(nums[j]);\\n\\t\\t\\t\\t\\t//Check if ans == target\\n                    if(ans.toString().equals(target) == true){\\n                        count++;\\n                    }\\n\\t\\t\\t\\t\\t//remove nums[j] added in ans, so delete everything added after nums[i] to last, ans = \"123\"\\n                    ans.delete(nums[i].length(), ans.length());\\n                }\\n            }\\n\\t\\t\\t//remove nums[i] added in ans, ans = \"\" \\n\\t\\t\\tans.delete(0,  ans.length());\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499223,
                "title": "c-hash-table-solution-with-explanation-o-n-time-complexity",
                "content": "1. Insert all the elements into hash table. (Unordered_map in c++)\\n2. Traverse the array again. \\n3. Check if this element can be the prefix of the target. If yes, find the string after this prefix in the target. Add its count to the answer.\\n4. Edge case - if the current element and suffix matches, we have counted extra (since ```i!=j```).\\n\\nTime Complexity : ```O(n*m)```\\nSpace Complexity : ```O(n*m)```\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        int n=target.length();\\n        unordered_map<string, int> mp;\\n        for(auto s:nums)\\n            mp[s]++;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            string temp=nums[i];\\n            int len=temp.length();\\n            if(len>n)\\n            {\\n                continue;\\n            }\\n            string s1=target.substr(len, n-len);\\n            string s2=target.substr(0,len);\\n           if(temp== s2)\\n            {\\n                cnt+=mp[s1];\\n                if(s1==s2)\\n                    cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease upvote this solution :)",
                "solutionTags": [],
                "code": "```i!=j```\n```O(n*m)```\n```O(n*m)```\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        int n=target.length();\\n        unordered_map<string, int> mp;\\n        for(auto s:nums)\\n            mp[s]++;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            string temp=nums[i];\\n            int len=temp.length();\\n            if(len>n)\\n            {\\n                continue;\\n            }\\n            string s1=target.substr(len, n-len);\\n            string s2=target.substr(0,len);\\n           if(temp== s2)\\n            {\\n                cnt+=mp[s1];\\n                if(s1==s2)\\n                    cnt--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499101,
                "title": "java-solution",
                "content": "```\\npublic int numOfPairs(String[] nums, String target) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(String s: nums) {\\n            map.put(s, map.getOrDefault(s,0) + 1);\\n        }\\n        int result = 0;\\n        for(int i  = 1; i < target.length(); i++) {\\n            String a1 = target.substring(0,i);\\n            String b1 = target.substring(i);\\n            if (map.containsKey(a1) && map.containsKey(b1)) {\\n                int a = map.get(a1);\\n                int b = map.get(b1);\\n                \\n                //System.out.println(a1 + \" \" + a + \"  \" + b1 + \" \" + b);\\n                if (a1.equals(b1) )\\n                    result += combi(a);\\n                else\\n                    result += a*b;\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int combi(int c) {\\n        if (c <  2)\\n            return 0;\\n        \\n        return c*(c-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numOfPairs(String[] nums, String target) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(String s: nums) {\\n            map.put(s, map.getOrDefault(s,0) + 1);\\n        }\\n        int result = 0;\\n        for(int i  = 1; i < target.length(); i++) {\\n            String a1 = target.substring(0,i);\\n            String b1 = target.substring(i);\\n            if (map.containsKey(a1) && map.containsKey(b1)) {\\n                int a = map.get(a1);\\n                int b = map.get(b1);\\n                \\n                //System.out.println(a1 + \" \" + a + \"  \" + b1 + \" \" + b);\\n                if (a1.equals(b1) )\\n                    result += combi(a);\\n                else\\n                    result += a*b;\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int combi(int c) {\\n        if (c <  2)\\n            return 0;\\n        \\n        return c*(c-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499042,
                "title": "c-super-easy-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n               if(i==j)\\n                   continue;\\n                string a=nums[i]+nums[j];\\n                if(a==target)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n               if(i==j)\\n                   continue;\\n                string a=nums[i]+nums[j];\\n                if(a==target)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505684,
                "title": "java-hashmap",
                "content": "Better Solution:\\n``` \\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String num : nums) {\\n            map.put(num, 1 + map.getOrDefault(num, 0));\\n        }\\n        int res = 0;\\n        for (String s : map.keySet()) {\\n            if (target.startsWith(s)) {\\n                if (target.equals(s + s)) {\\n                    res += map.get(s) * (map.get(s) - 1);\\n                } else if (map.containsKey(target.substring(s.length()))) {\\n                    res += map.get(s) * map.get(target.substring(s.length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\n\\n```\\nclass Solution {\\n    \\n    public boolean match(String s, String target, int ind){\\n        // int tar = \\n        if(ind == 0)\\n            for(int i = ind ; i < s.length() && i<target.length() ; i++)\\n                if(s.charAt(i) != target.charAt(i))\\n                    return false;\\n        int last = s.length()-1;\\n        if(ind == target.length()-1)\\n            for(int i = ind ; last>=0 &&  i>=0 ; i--)\\n                if(s.charAt(last--) != target.charAt(i))\\n                    return false;\\n        return true;\\n        \\n    }\\n        \\n    public int numOfPairs(String[] nums, String target) {\\n        int ans = 0;\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        for(String s: nums){\\n            boolean front = match(s, target, 0);\\n            boolean back = match(s, target, target.length()-1);\\n            if(front){\\n//                 s is the front of target\\n                String part =\"\";\\n                for(int i = s.length() ; i < target.length() ; i++)\\n                    part+=target.charAt(i);\\n                \\n                if(hm.containsKey(part))\\n                    ans+=hm.get(part);\\n            }\\n            if(back){\\n//                 s is the back of target\\n                String part =\"\";\\n                for(int i = 0 ; i < target.length()-s.length() ; i++)\\n                    part+=target.charAt(i);\\n                \\n                if(hm.containsKey(part))\\n                    ans+=hm.get(part);\\n            }\\n            hm.put(s, hm.getOrDefault(s,0)+1);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String num : nums) {\\n            map.put(num, 1 + map.getOrDefault(num, 0));\\n        }\\n        int res = 0;\\n        for (String s : map.keySet()) {\\n            if (target.startsWith(s)) {\\n                if (target.equals(s + s)) {\\n                    res += map.get(s) * (map.get(s) - 1);\\n                } else if (map.containsKey(target.substring(s.length()))) {\\n                    res += map.get(s) * map.get(target.substring(s.length()));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    \\n    public boolean match(String s, String target, int ind){\\n        // int tar = \\n        if(ind == 0)\\n            for(int i = ind ; i < s.length() && i<target.length() ; i++)\\n                if(s.charAt(i) != target.charAt(i))\\n                    return false;\\n        int last = s.length()-1;\\n        if(ind == target.length()-1)\\n            for(int i = ind ; last>=0 &&  i>=0 ; i--)\\n                if(s.charAt(last--) != target.charAt(i))\\n                    return false;\\n        return true;\\n        \\n    }\\n        \\n    public int numOfPairs(String[] nums, String target) {\\n        int ans = 0;\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        for(String s: nums){\\n            boolean front = match(s, target, 0);\\n            boolean back = match(s, target, target.length()-1);\\n            if(front){\\n//                 s is the front of target\\n                String part =\"\";\\n                for(int i = s.length() ; i < target.length() ; i++)\\n                    part+=target.charAt(i);\\n                \\n                if(hm.containsKey(part))\\n                    ans+=hm.get(part);\\n            }\\n            if(back){\\n//                 s is the back of target\\n                String part =\"\";\\n                for(int i = 0 ; i < target.length()-s.length() ; i++)\\n                    part+=target.charAt(i);\\n                \\n                if(hm.containsKey(part))\\n                    ans+=hm.get(part);\\n            }\\n            hm.put(s, hm.getOrDefault(s,0)+1);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312856,
                "title": "python3-beats-94-22",
                "content": "# Please upvote guys!\\n![image.png](https://assets.leetcode.com/users/images/cb2e81c1-3396-47c7-9f61-9ec23de46dee_1679162142.8444855.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]+nums[j] == target and i!=j:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]+nums[j] == target and i!=j:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643482,
                "title": "java-prefix-suffix-counts-hashmap",
                "content": "```\\nTo understand the code better,\\ndry run for the example test case\\nnums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\\n```\\nMethod 1 : Brute Force\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int result = 0 ;\\n        int n = nums.length ;\\n        \\n        for (int i = 0; i < n; i++)\\n            for (int j = i+1; j < n; j++) {\\n                if ((nums[i] + nums[j]).equals(target))\\n                    result++ ;\\n                if ((nums[j] + nums[i]).equals(target))\\n                    result++ ;\\n            }\\n        \\n        return result ;\\n    }\\n}\\n```\\nMethod 2 : Using HashMap (Optimized Solution)\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        HashMap<String, Integer> map = new HashMap<>() ;\\n        int N = nums.length ;\\n        int n = target.length() ;\\n        int result = 0 ;\\n        \\n        for (int i = 0; i < N; i++) {\\n            int m = nums[i].length() ;\\n            \\n            if (target.startsWith(nums[i])) {\\n                String suffix = target.substring(m) ;\\n                if (map.containsKey(suffix))\\n                    result += map.get(suffix) ;\\n            }\\n            \\n            if (target.endsWith(nums[i])) {\\n                String prefix = target.substring(0, n-m) ;\\n                if (map.containsKey(prefix))\\n                    result += map.get(prefix) ;\\n            }\\n            \\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1) ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTo understand the code better,\\ndry run for the example test case\\nnums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\\n```\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int result = 0 ;\\n        int n = nums.length ;\\n        \\n        for (int i = 0; i < n; i++)\\n            for (int j = i+1; j < n; j++) {\\n                if ((nums[i] + nums[j]).equals(target))\\n                    result++ ;\\n                if ((nums[j] + nums[i]).equals(target))\\n                    result++ ;\\n            }\\n        \\n        return result ;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        HashMap<String, Integer> map = new HashMap<>() ;\\n        int N = nums.length ;\\n        int n = target.length() ;\\n        int result = 0 ;\\n        \\n        for (int i = 0; i < N; i++) {\\n            int m = nums[i].length() ;\\n            \\n            if (target.startsWith(nums[i])) {\\n                String suffix = target.substring(m) ;\\n                if (map.containsKey(suffix))\\n                    result += map.get(suffix) ;\\n            }\\n            \\n            if (target.endsWith(nums[i])) {\\n                String prefix = target.substring(0, n-m) ;\\n                if (map.containsKey(prefix))\\n                    result += map.get(prefix) ;\\n            }\\n            \\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1) ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635608,
                "title": "using-startswith-method",
                "content": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function(nums, target) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (target.startsWith(nums[i])) {\\n            for (let j = 0; j < nums.length; j++) {\\n                if (i != j && nums[i] + nums[j] === target) {\\n                    count++\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function(nums, target) {\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (target.startsWith(nums[i])) {\\n            for (let j = 0; j < nums.length; j++) {\\n                if (i != j && nums[i] + nums[j] === target) {\\n                    count++\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2441199,
                "title": "python-7-line-counter-solution-2-sum-in-string",
                "content": "```\\ndef numOfPairs(self, nums: List[str], tar: str) -> int:\\n\\tcnter, ans = Counter(nums), 0\\n\\tfor n in cnter:\\n\\t\\tif n+n==tar:\\n\\t\\t\\tans += cnter[n]*(cnter[n]-1)\\n\\t\\telif tar[:len(n)]==n:\\n\\t\\t\\tans += cnter[n]*cnter[tar[len(n):]]\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfPairs(self, nums: List[str], tar: str) -> int:\\n\\tcnter, ans = Counter(nums), 0\\n\\tfor n in cnter:\\n\\t\\tif n+n==tar:\\n\\t\\t\\tans += cnter[n]*(cnter[n]-1)\\n\\t\\telif tar[:len(n)]==n:\\n\\t\\t\\tans += cnter[n]*cnter[tar[len(n):]]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2403596,
                "title": "simple-elegant-clever-optimum",
                "content": "Success\\nDetails \\nRuntime: 58 ms, faster than **81.66%** of Python3 online submissions.\\nMemory Usage: 14 MB, less than **68.18%** of Python3 online submissions.\\n\\n1. Creat a hashmap for elements in nums as a key with the frequency of occurence as a value.\\n\\n2. Itterate over nums: if the current element is equal to the first half of the target AND the remaining half is present in the hashmap then increment if count by the frequency of that remainig part.\\n\\n3. if the current element is euqal to the remaing half then decrement the count by one. We do this to avoid the pairing of the current element with itself. \\n\\n***If this helps, Leave an upvote !!!***\\n\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d={}\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        c=0\\n        for i in nums:\\n            if i ==target[:len(i)] and target[len(i):] in d:\\n                c=c+d[target[len(i):]]\\n                if i == target[len(i):]:\\n                    c=c-1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d={}\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        c=0\\n        for i in nums:\\n            if i ==target[:len(i)] and target[len(i):] in d:\\n                c=c+d[target[len(i):]]\\n                if i == target[len(i):]:\\n                    c=c-1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133708,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, x: List[str], target: str) -> int:\\n        return sum(sum(1 if i!=j and x[i]+x[j]==target else 0 for  j in range(len(x))) for i in range(len(x)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, x: List[str], target: str) -> int:\\n        return sum(sum(1 if i!=j and x[i]+x[j]==target else 0 for  j in range(len(x))) for i in range(len(x)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032032,
                "title": "c-solution-similar-to-twosum-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool starts_with(string_view target, string_view nums){\\n        if(nums.size()>target.size()) return false;\\n        for(int i = 0;i<nums.size();i++)\\n            if(nums[i]!=target[i]) return false;\\n        \\n        return true;\\n    }\\n    bool half_equal(string_view target){\\n        if(target.size()%2!=0) return false;\\n        int n = target.size()/2;\\n        for(int i = 0;i<n;i++){\\n            if(target[i]!=target[i+n]) return false;\\n        }\\n        return true;\\n    }\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int res = 0;\\n        unordered_map<string, int> freq;\\n        for(const auto& num: nums)\\n            freq[num]++;\\n        \\n        int flag = half_equal(target);\\n        string half {target.begin(), target.begin()+target.size()/2};\\n        if(flag){\\n            if(freq.find(half)!=freq.end()){\\n                int n = freq[half];\\n                res+= n*(n-1);\\n            }\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(!flag || nums[i]!=half){\\n                if(!starts_with(target, nums[i])) continue;\\n                \\n                // stoi(target) - stoi(nums[i])\\n                string rest {target.begin()+nums[i].size(), target.end()};\\n                if(freq.find(rest)!=freq.end())\\n                    res+=freq[rest];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool starts_with(string_view target, string_view nums){\\n        if(nums.size()>target.size()) return false;\\n        for(int i = 0;i<nums.size();i++)\\n            if(nums[i]!=target[i]) return false;\\n        \\n        return true;\\n    }\\n    bool half_equal(string_view target){\\n        if(target.size()%2!=0) return false;\\n        int n = target.size()/2;\\n        for(int i = 0;i<n;i++){\\n            if(target[i]!=target[i+n]) return false;\\n        }\\n        return true;\\n    }\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int res = 0;\\n        unordered_map<string, int> freq;\\n        for(const auto& num: nums)\\n            freq[num]++;\\n        \\n        int flag = half_equal(target);\\n        string half {target.begin(), target.begin()+target.size()/2};\\n        if(flag){\\n            if(freq.find(half)!=freq.end()){\\n                int n = freq[half];\\n                res+= n*(n-1);\\n            }\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(!flag || nums[i]!=half){\\n                if(!starts_with(target, nums[i])) continue;\\n                \\n                // stoi(target) - stoi(nums[i])\\n                string rest {target.begin()+nums[i].size(), target.end()};\\n                if(freq.find(rest)!=freq.end())\\n                    res+=freq[rest];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882957,
                "title": "java-o-n-frequency-map",
                "content": "Just track the frequency of each ```num``` in a HashMap. Then iterate over the array, for each ```num``` if ```target``` starts with that ```num``` check for the frequncy of the suffix (remaining part) in the map. Take care of the case where ```num``` itself is also the suffix.\\n\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int cnt=0;\\n        HashMap<String, Integer> frq=new HashMap();\\n        \\n        for(String num:nums){\\n            frq.put(num, frq.getOrDefault(num, 0)+1);\\n        }\\n        \\n        for(String num:nums){\\n            if(target.startsWith(num)){\\n                String suf=target.substring(num.length());\\n                if(frq.containsKey(suf)){\\n                    cnt+=frq.get(suf)-(num.equals(suf)? 1:0);\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```num```\n```num```\n```target```\n```num```\n```num```\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int cnt=0;\\n        HashMap<String, Integer> frq=new HashMap();\\n        \\n        for(String num:nums){\\n            frq.put(num, frq.getOrDefault(num, 0)+1);\\n        }\\n        \\n        for(String num:nums){\\n            if(target.startsWith(num)){\\n                String suf=target.substring(num.length());\\n                if(frq.containsKey(suf)){\\n                    cnt+=frq.get(suf)-(num.equals(suf)? 1:0);\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745241,
                "title": "100-faster-yet-easy-js-solution",
                "content": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function (nums, target) {\\n  let len = nums.length\\n  let res = 0\\n  for (let i = 0; i < len - 1; i++) {\\n    for (let j = i + 1; j < len; j++) {\\n      if (nums[i] + nums[j] === target) res++\\n      if (nums[j] + nums[i] === target) res++\\n    }\\n  }\\n  return res\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/5e8b0d00-45d4-4f60-bea6-3cf4fcd12ca1_1644006544.0827103.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function (nums, target) {\\n  let len = nums.length\\n  let res = 0\\n  for (let i = 0; i < len - 1; i++) {\\n    for (let j = i + 1; j < len; j++) {\\n      if (nums[i] + nums[j] === target) res++\\n      if (nums[j] + nums[i] === target) res++\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499619,
                "title": "python-3-hashtable-commented-and-explained",
                "content": "\\tdef numOfPairs(self, nums: List[str], target: str) -> int:\\n\\t\\t\\t# Creating a dictionary for storing the frequency of every string in nums \\n\\t\\t\\tmyDict = collections.Counter(nums)\\n\\t\\t\\tcount = 0\\n\\t\\t\\t\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t# Finding a substring without the current element\\n\\t\\t\\t\\t# Point to be noted: replace only ONCE thats why the count in replace method is set to 1\\n\\t\\t\\t\\tsub = target.replace(i,\"\",1)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Check if the substring obtained is in the dictionary or not\\n\\t\\t\\t\\tif myDict.get(sub,None) != None:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# To check for same elements that adds upto the target element Eg: \"1\"+\"1\" = \"11\"\\n\\t\\t\\t\\t\\tif sub == i:\\n\\t\\t\\t\\t\\t\\t# If same element then we add total frequency of that element-1 as it indexes should be different\\n\\t\\t\\t\\t\\t\\tcount += myDict[sub]-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# If the current element and substring forms the target string then we add the frequency of the substring as the current element will form that many pairs\\n\\t\\t\\t\\t\\t\\tif (i+sub)==target:\\n\\t\\t\\t\\t\\t\\t\\tcount += myDict[sub]\\n\\t\\t\\t# Returning the final count \\n\\t\\t\\treturn count\\n\\n\\n![image](https://assets.leetcode.com/users/images/8b57c7c2-67eb-473d-9940-f6b3ad6325f4_1633202940.776434.png)\\n\\nPlease **UPVOTE** if you like my solution, it motivates me a lot!",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "\\tdef numOfPairs(self, nums: List[str], target: str) -> int:\\n\\t\\t\\t# Creating a dictionary for storing the frequency of every string in nums \\n\\t\\t\\tmyDict = collections.Counter(nums)\\n\\t\\t\\tcount = 0\\n\\t\\t\\t\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t# Finding a substring without the current element\\n\\t\\t\\t\\t# Point to be noted: replace only ONCE thats why the count in replace method is set to 1\\n\\t\\t\\t\\tsub = target.replace(i,\"\",1)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Check if the substring obtained is in the dictionary or not\\n\\t\\t\\t\\tif myDict.get(sub,None) != None:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# To check for same elements that adds upto the target element Eg: \"1\"+\"1\" = \"11\"\\n\\t\\t\\t\\t\\tif sub == i:\\n\\t\\t\\t\\t\\t\\t# If same element then we add total frequency of that element-1 as it indexes should be different\\n\\t\\t\\t\\t\\t\\tcount += myDict[sub]-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# If the current element and substring forms the target string then we add the frequency of the substring as the current element will form that many pairs\\n\\t\\t\\t\\t\\t\\tif (i+sub)==target:\\n\\t\\t\\t\\t\\t\\t\\tcount += myDict[sub]\\n\\t\\t\\t# Returning the final count \\n\\t\\t\\treturn count\\n\\n\\n![image](https://assets.leetcode.com/users/images/8b57c7c2-67eb-473d-9940-f6b3ad6325f4_1633202940.776434.png)\\n\\nPlease **UPVOTE** if you like my solution, it motivates me a lot!",
                "codeTag": "Python3"
            },
            {
                "id": 1499241,
                "title": "c-brute-force",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numOfPairs(vector<string>& nums, string target) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++){\\n\\t\\t\\t\\t\\tif(i == j){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[i]  + nums[j] == target){\\n\\t\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numOfPairs(vector<string>& nums, string target) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++){\\n\\t\\t\\t\\t\\tif(i == j){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1499149,
                "title": "c-2023-number-of-pairs-of-strings-with-concatenation-equal-to-target",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> freq; \\n        for (auto& x : nums) freq[x]++; \\n        \\n        int ans = 0; \\n        for (auto& [k, v] : freq) \\n            if (target.substr(0, k.size()) == k) {\\n                string suffix = target.substr(k.size()); \\n                ans += v * freq[suffix];\\n                if (k == suffix) ans -= freq[suffix]; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int> freq; \\n        for (auto& x : nums) freq[x]++; \\n        \\n        int ans = 0; \\n        for (auto& [k, v] : freq) \\n            if (target.substr(0, k.size()) == k) {\\n                string suffix = target.substr(k.size()); \\n                ans += v * freq[suffix];\\n                if (k == suffix) ans -= freq[suffix]; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499039,
                "title": "c",
                "content": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=i+1; j<nums.size(); j++)\\n            {\\n                if(nums[i]+nums[j] == target)\\n                    count++;\\n                if(nums[j]+nums[i] == target)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=i+1; j<nums.size(); j++)\\n            {\\n                if(nums[i]+nums[j] == target)\\n                    count++;\\n                if(nums[j]+nums[i] == target)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1498998,
                "title": "a-few-solutions",
                "content": "Brute-force consider all `i`,`j` pairs.\\n    \\n---\\n    \\n*Kotlin*\\n```\\nclass Solution {\\n    fun numOfPairs(A: Array<String>, T: String): Int {\\n        var N = A.size\\n        var cnt = 0\\n        for (i in 0 until N)\\n            for (j in 0 until N)\\n                if (i != j && \"${A[i]}${A[j]}\" == T)\\n                    ++cnt\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numOfPairs = (A, T, cnt = 0) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            cnt += i != j && `${A[i]}${A[j]}` == T;\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numOfPairs(self, A: List[str], T: str, cnt = 0) -> int:\\n        N = len(A)\\n        for i in range(N):\\n            for j in range(N):\\n                cnt += i != j and f\\'{A[i]}{A[j]}\\' == T\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfPairs(VS& A, string T, int cnt = 0) {\\n        auto N = A.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                cnt += i != j && A[i] + A[j] == T;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numOfPairs(A: Array<String>, T: String): Int {\\n        var N = A.size\\n        var cnt = 0\\n        for (i in 0 until N)\\n            for (j in 0 until N)\\n                if (i != j && \"${A[i]}${A[j]}\" == T)\\n                    ++cnt\\n        return cnt\\n    }\\n}\\n```\n```\\nlet numOfPairs = (A, T, cnt = 0) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            cnt += i != j && `${A[i]}${A[j]}` == T;\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def numOfPairs(self, A: List[str], T: str, cnt = 0) -> int:\\n        N = len(A)\\n        for i in range(N):\\n            for j in range(N):\\n                cnt += i != j and f\\'{A[i]}{A[j]}\\' == T\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numOfPairs(VS& A, string T, int cnt = 0) {\\n        auto N = A.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                cnt += i != j && A[i] + A[j] == T;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949304,
                "title": "2lines-brute-force-jai-shree-ram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(i!=j && nums[i]+nums[j]==target)\\n                {\\n                    ans+=1;\\n                }\\n               // else if(i==j || nums[i]+nums[j]!=target)\\n                //{\\n                  //  j++;\\n               // }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(i!=j && nums[i]+nums[j]==target)\\n                {\\n                    ans+=1;\\n                }\\n               // else if(i==j || nums[i]+nums[j]!=target)\\n                //{\\n                  //  j++;\\n               // }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510600,
                "title": "number-of-pairs-of-strings-with-concatenation-equal-to-target-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int i, j, count=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(i!=j && nums[i]+nums[j]==target)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/62ba077e-9a6f-4790-841c-95e336489f2b_1683772356.124512.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int i, j, count=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(i!=j && nums[i]+nums[j]==target)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499304,
                "title": "dictionary-list-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = defaultdict(int)\\n        for char in nums:\\n            d[char] += 1\\n            \\n        arr = []\\n        for char in target:\\n            arr.append(char)\\n        \\n        pairs = 0\\n        num = \"\"\\n        while len(arr) > 1:\\n            num += arr.pop()\\n            findNum = \"\".join(arr)\\n            if num[::-1] not in d or findNum not in d:\\n                continue\\n\\n            c1 = d[num[::-1]]\\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\\n            \\n            c2 = d[findNum]\\n            d[num[::-1]] += 1 # make the count again same.\\n\\n            pairs += c1 * c2\\n        return pairs\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = defaultdict(int)\\n        for char in nums:\\n            d[char] += 1\\n            \\n        arr = []\\n        for char in target:\\n            arr.append(char)\\n        \\n        pairs = 0\\n        num = \"\"\\n        while len(arr) > 1:\\n            num += arr.pop()\\n            findNum = \"\".join(arr)\\n            if num[::-1] not in d or findNum not in d:\\n                continue\\n\\n            c1 = d[num[::-1]]\\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\\n            \\n            c2 = d[findNum]\\n            d[num[::-1]] += 1 # make the count again same.\\n\\n            pairs += c1 * c2\\n        return pairs\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362425,
                "title": "simple-ruby-solution",
                "content": "```\\n# @param {String[]} nums\\n# @param {String} target\\n# @return {Integer}\\ndef num_of_pairs(nums, target)\\n    nums.permutation(2).count { _1 + _2 == target }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String[]} nums\\n# @param {String} target\\n# @return {Integer}\\ndef num_of_pairs(nums, target)\\n    nums.permutation(2).count { _1 + _2 == target }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3295739,
                "title": "recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void checkPairs(vector<string>& nums,string& target,int i,int j,int& count){\\n         \\n        if(i>=nums.size()){\\n          return;\\n        }\\n        if(j>=nums.size()){\\n            checkPairs(nums,target,i+1,i+1,count);\\n            return;\\n        }\\n        if((i!=j) && (nums[i]+nums[j]  == target)){\\n      //    cout<<i<<\" \"<<j<<endl;\\n          count++;\\n           checkPairs(nums,target,i,j+1,count);\\n        }else{\\n           checkPairs(nums,target,i,j+1,count);\\n        }\\n\\n    }\\n    void checkPairs1(vector<string>& nums,string& target,int i,int j,int& count){\\n         \\n       if(i<0){\\n         return;\\n       }\\n       if(j<0){\\n          checkPairs1(nums,target,i-1,i-1,count);\\n          return;\\n       }\\n       if((i!=j) && nums[i]+nums[j] == target){\\n       //     cout<<j<<\" \"<<i<<endl;\\n         count++;\\n          checkPairs1(nums,target,i,j-1,count);\\n       }else{\\n         checkPairs1(nums,target,i,j-1,count);\\n       }\\n\\n    }\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count = 0;\\n\\n        checkPairs(nums,target,0,0,count);\\n        checkPairs1(nums,target,nums.size()-1,nums.size()-1,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void checkPairs(vector<string>& nums,string& target,int i,int j,int& count){\\n         \\n        if(i>=nums.size()){\\n          return;\\n        }\\n        if(j>=nums.size()){\\n            checkPairs(nums,target,i+1,i+1,count);\\n            return;\\n        }\\n        if((i!=j) && (nums[i]+nums[j]  == target)){\\n      //    cout<<i<<\" \"<<j<<endl;\\n          count++;\\n           checkPairs(nums,target,i,j+1,count);\\n        }else{\\n           checkPairs(nums,target,i,j+1,count);\\n        }\\n\\n    }\\n    void checkPairs1(vector<string>& nums,string& target,int i,int j,int& count){\\n         \\n       if(i<0){\\n         return;\\n       }\\n       if(j<0){\\n          checkPairs1(nums,target,i-1,i-1,count);\\n          return;\\n       }\\n       if((i!=j) && nums[i]+nums[j] == target){\\n       //     cout<<j<<\" \"<<i<<endl;\\n         count++;\\n          checkPairs1(nums,target,i,j-1,count);\\n       }else{\\n         checkPairs1(nums,target,i,j-1,count);\\n       }\\n\\n    }\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count = 0;\\n\\n        checkPairs(nums,target,0,0,count);\\n        checkPairs1(nums,target,nums.size()-1,nums.size()-1,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3178771,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;\\n        int ans=0;\\n        for(int i =0;i<n;i++){\\n            for(int j =0; j<n;j++){\\n                if( i != j){\\n                    String str = nums[i] + nums[j];\\n                    if (str.equals(target)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;\\n        int ans=0;\\n        for(int i =0;i<n;i++){\\n            for(int j =0; j<n;j++){\\n                if( i != j){\\n                    String str = nums[i] + nums[j];\\n                    if (str.equals(target)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995692,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numOfPairs(self,nums:List[str],target:str)->int:\\n        n=len(nums)\\n        count=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        count+=1\\n\\n        return count                      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self,nums:List[str],target:str)->int:\\n        n=len(nums)\\n        count=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        count+=1\\n\\n        return count                      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989280,
                "title": "java-map",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int cnt = 0;\\n        for(String str : nums){\\n            if(target.startsWith(str)){\\n                String suffix = target.substring(str.length());\\n                cnt += map.getOrDefault(suffix, 0);\\n            }\\n            if(target.endsWith(str)){\\n                String prefix = target.substring(0, target.length() - str.length());\\n                cnt += map.getOrDefault(prefix, 0);\\n            }\\n            map.put(str, map.getOrDefault(str, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int cnt = 0;\\n        for(String str : nums){\\n            if(target.startsWith(str)){\\n                String suffix = target.substring(str.length());\\n                cnt += map.getOrDefault(suffix, 0);\\n            }\\n            if(target.endsWith(str)){\\n                String prefix = target.substring(0, target.length() - str.length());\\n                cnt += map.getOrDefault(prefix, 0);\\n            }\\n            map.put(str, map.getOrDefault(str, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955378,
                "title": "javascript-reduce",
                "content": "```\\nconst numOfPairs = (nums, target) =>\\n  nums.reduce((a, c, i, arr) => {\\n    for (let j = 0; j < arr.length; j++) {\\n      if (j === i) continue;\\n      if (c + arr[j] === target) a++;\\n    }\\n    return a;\\n  }, 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numOfPairs = (nums, target) =>\\n  nums.reduce((a, c, i, arr) => {\\n    for (let j = 0; j < arr.length; j++) {\\n      if (j === i) continue;\\n      if (c + arr[j] === target) a++;\\n    }\\n    return a;\\n  }, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816240,
                "title": "beste-easy-solution-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate And Slicing\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)): \\n            lst=[]          \\n            lst=nums[:i]+nums[i+1:]\\n            for j in lst:\\n                if nums[i]+j==target:\\n                    c+=1\\n        return c            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)): \\n            lst=[]          \\n            lst=nums[:i]+nums[i+1:]\\n            for j in lst:\\n                if nums[i]+j==target:\\n                    c+=1\\n        return c            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592640,
                "title": "95-fast-counter-based-easy-python-solution-explained",
                "content": "Logic is we calculate the number of unique words in nums using counter. We then form all prefix and suffix pairs of  the target and check if they are in the dict or not. If they are present we multiply their counts and add it to ans. \\n**Edge case: if pref and suff are equal, we have to multiply count * (count - 1), since we cant the same pref/suff more than once.**\\n\\nUpvote if you understood the logic :)\\n\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        mem = Counter(nums)\\n        ans = 0\\n        \\n        for i in range(1,len(target)):\\n            pref = target[:i]\\n            suff = target[i:]\\n            x = y = 0\\n            \\n            if pref == suff and pref in mem:\\n                x = mem[pref]\\n                y = x - 1\\n            else:                \\n                if pref in mem:\\n                    x = mem[pref]\\n                else:\\n                    continue\\n                if suff in mem:\\n                    y = mem[suff]\\n                else:\\n                    continue\\n\\n            ans += (x*y)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        mem = Counter(nums)\\n        ans = 0\\n        \\n        for i in range(1,len(target)):\\n            pref = target[:i]\\n            suff = target[i:]\\n            x = y = 0\\n            \\n            if pref == suff and pref in mem:\\n                x = mem[pref]\\n                y = x - 1\\n            else:                \\n                if pref in mem:\\n                    x = mem[pref]\\n                else:\\n                    continue\\n                if suff in mem:\\n                    y = mem[suff]\\n                else:\\n                    continue\\n\\n            ans += (x*y)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561306,
                "title": "c-solution-easy-to-understand-brute-force-and-optimized-solution",
                "content": "\\n\\n# BRUTE FORCE\\n\\n\\n    class Solution {\\n    public:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                if(nums[i]+nums[j]==target){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n        }\\n      };\\n\\t  \\n\\t  \\n# OPTIMIZED SOLUTION\\n\\n\\n    class Solution {\\n    public:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        string check1=\"\",check2=\"\";\\n        int ans=0;\\n        for(int i=0;i<target.length();i++){\\n            check1+=target[i];\\n            check2=target.substr(i+1);\\n            if(mp.find(check1)!=mp.end() and mp.find(check2)!=mp.end()){\\n                if(check1==check2){\\n                    ans+=mp[check1]*(mp[check1]-1);\\n                }\\n                else{\\n                    ans+=mp[check1]*mp[check2];\\n                }\\n            }\\n        }\\n        return ans;\\n       }\\n     };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i==j){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2421975,
                "title": "java-98-7-faster-simple-hashmap-explain",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        // Using hashmap, idea from other discussion post\\n        // first we put the number and occurances into the map\\n        Map<String, Integer> mapping = new HashMap<>();\\n        \\n        for (int i = 0; i<nums.length; i++) {\\n            // Here we put the number into the map\\n            // if key exists, update the value to be original + 1\\n            // otherwise, makes the value equal to 0+1 = 1 (one occurance)\\n            mapping.put(nums[i], mapping.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 1; i < target.length(); i++) {\\n            // We seperate the target into two substrings each time\\n            // and check if both substrings are in the mapping\\n            // notice that substring function is inclusive for start and exclusive for end\\n            // i starts from 1 because substring(0, 0) will be \"\" and we won\\'t have this\\n            // key in our mapping.\\n            String sub1 = target.substring(0, i);\\n            String sub2 = target.substring(i, target.length());\\n            \\n            if (mapping.containsKey(sub1) && mapping.containsKey(sub2)) {\\n                // found the pair, update our count\\n                if (sub1.equals(sub2)) {\\n                    // They are the same, so refers to the same key value pairs, thus we should\\n                    // reduce the number of occurance by 1 to make sure we don\\'t use\\n                    // a number on the same position(index) twice.\\n                    // For example, [\"20\", \"20\"], target = \"2023\"\\n                    // the output should be 2*1 = 2 instead of 2*2 = 4.\\n                    result += mapping.get(sub1) * (mapping.get(sub1)-1);\\n                } else {\\n                    // They are different, so just do times\\n                    result += mapping.get(sub1) * mapping.get(sub2);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        // Using hashmap, idea from other discussion post\\n        // first we put the number and occurances into the map\\n        Map<String, Integer> mapping = new HashMap<>();\\n        \\n        for (int i = 0; i<nums.length; i++) {\\n            // Here we put the number into the map\\n            // if key exists, update the value to be original + 1\\n            // otherwise, makes the value equal to 0+1 = 1 (one occurance)\\n            mapping.put(nums[i], mapping.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 1; i < target.length(); i++) {\\n            // We seperate the target into two substrings each time\\n            // and check if both substrings are in the mapping\\n            // notice that substring function is inclusive for start and exclusive for end\\n            // i starts from 1 because substring(0, 0) will be \"\" and we won\\'t have this\\n            // key in our mapping.\\n            String sub1 = target.substring(0, i);\\n            String sub2 = target.substring(i, target.length());\\n            \\n            if (mapping.containsKey(sub1) && mapping.containsKey(sub2)) {\\n                // found the pair, update our count\\n                if (sub1.equals(sub2)) {\\n                    // They are the same, so refers to the same key value pairs, thus we should\\n                    // reduce the number of occurance by 1 to make sure we don\\'t use\\n                    // a number on the same position(index) twice.\\n                    // For example, [\"20\", \"20\"], target = \"2023\"\\n                    // the output should be 2*1 = 2 instead of 2*2 = 4.\\n                    result += mapping.get(sub1) * (mapping.get(sub1)-1);\\n                } else {\\n                    // They are different, so just do times\\n                    result += mapping.get(sub1) * mapping.get(sub2);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402230,
                "title": "4-line-java-solution-o-n-2-time-complexity",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(i!=j && (nums[i]+nums[j]).equals(target)) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(i!=j && (nums[i]+nums[j]).equals(target)) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361443,
                "title": "c-simple-and-best-for-beginners",
                "content": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                if(i == j) continue;\\n                string s = nums[i] + nums[j];\\n                if(s == target) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                if(i == j) continue;\\n                string s = nums[i] + nums[j];\\n                if(s == target) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2334295,
                "title": "python-solutions-from-brute-force-o-nn-accepted-to-o-n-with-counter",
                "content": "**solution 1:**\\nwe can burte force check if every pair of elements in nums can be form tagret,this will take O(nn) time with O(1) space\\n**solution 2:**\\nbrute force is trvial, if there are many duplicated elements will waste time,anther solution: split target into all possibles, check and count how many subparties can be formed from nums:\\neg: taget=\"221\" nums=[\\'1,\\'1\\',\\'2,\\'2\\',\\'22\\'],  possible splits: \"221\"=\"2\"+\"21\"(but there\\'s no \\'21\\', so it\\'s not valid split), \"221\"=\"22\"+\"1\"\\nthere are 2 \\'1\\' and 1 \\'22\\' in nums so there are  2* 1 paires of the splits.\\n\\n\\n```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        #sol1:brute force check\\n        ans=0\\n        for i in range(len(nums)):\\n            fst=nums[i]\\n            for j in range(len(nums)):\\n                if i==j:continue\\n                if fst+nums[j]==target:ans=ans+1\\n        return ans\\n```\\n```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        #sol2 using Counter and iterative check\\n        counter,ans=Counter(nums),0\\n        for i in range(1,len(target)):\\n            a,b=target[:i],target[i:]\\n            if a not in counter or b not in counter:continue\\n            ans=ans+counter[a]*counter[b] if a!=b else ans+counter[a]*(counter[a]-1)\\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        #sol1:brute force check\\n        ans=0\\n        for i in range(len(nums)):\\n            fst=nums[i]\\n            for j in range(len(nums)):\\n                if i==j:continue\\n                if fst+nums[j]==target:ans=ans+1\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        #sol2 using Counter and iterative check\\n        counter,ans=Counter(nums),0\\n        for i in range(1,len(target)):\\n            a,b=target[:i],target[i:]\\n            if a not in counter or b not in counter:continue\\n            ans=ans+counter[a]*counter[b] if a!=b else ans+counter[a]*(counter[a]-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328225,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int>mp;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        \\n        int ans=0;\\n        string start=\"\", end=\"\";\\n        \\n        for(int i=0;i<target.size()-1;i++){\\n            start+=target[i];\\n            end=target.substr(i+1,target.size()-i-1);\\n            \\n            if(start!=end)\\n            ans+=mp[start]*mp[end];\\n            else\\n            ans+=(mp[start]*(mp[start]-1));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int>mp;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        \\n        int ans=0;\\n        string start=\"\", end=\"\";\\n        \\n        for(int i=0;i<target.size()-1;i++){\\n            start+=target[i];\\n            end=target.substr(i+1,target.size()-i-1);\\n            \\n            if(start!=end)\\n            ans+=mp[start]*mp[end];\\n            else\\n            ans+=(mp[start]*(mp[start]-1));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205730,
                "title": "python-math-hash-with-explanation",
                "content": "**\\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F Up Vote If You Like My Answers \\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F**\\n\\nWe make a counter (HashMap that counts each element)of each str in nums, then we take the prefix and postfix statring from i = 1 until i=len(target)-1 (so we won\\'t check the whole word), and check if they are in the counter.\\n**If prefix==postfix** - we need to check that the counter is greater then 1, if so, we append using the formula:\\n![image](https://assets.leetcode.com/users/images/ca2b05af-5c31-4d15-9968-e828f94a6f5c_1656343025.1779404.png)\\nwhere n = counter[prefix] and k = 2.\\n*For those who are not farmiliar with this formula :*\\n*This is the formula for counting how many diffrent combination we have of taking k-element from the n-total, BUT until n C k, here the order matther, meaning that if you have two blue balls - let\\'s say A,B then:\\nn C k would be = 1 (because they are both blue so A,B = B,A)\\nBut with this formula = 2 (because it will count A,B and B,A as two diffrent combinations).*\\n**If prefix  != postfix** then we just append he multiplication of both counts.\\n\\n\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c = Counter(nums)\\n        ans = 0\\n        for i in range(1,len(target)):\\n            if target[:i] in c and target[i:] in c:\\n                if target[:i] == target[i:]:\\n                    ans += (c[target[:i]] > 1) and math.factorial(c[target[:i]])//math.factorial(c[target[:i]]-2)\\n                else:\\n                    ans += c[target[:i]]*c[target[i:]]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c = Counter(nums)\\n        ans = 0\\n        for i in range(1,len(target)):\\n            if target[:i] in c and target[i:] in c:\\n                if target[:i] == target[i:]:\\n                    ans += (c[target[:i]] > 1) and math.factorial(c[target[:i]])//math.factorial(c[target[:i]]-2)\\n                else:\\n                    ans += c[target[:i]]*c[target[i:]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007151,
                "title": "javascript-solution-brute-force",
                "content": "```\\nvar numOfPairs = function(nums, target) {\\n    const n = nums.length;\\n    const map = new Map();\\n    \\n    for (const num of nums) {\\n        if (!map.has(num)) map.set(num, 0);\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    let res = 0;\\n    \\n    for (const [word1, count1] of map) {\\n        for (const [word2, count2] of map) {\\n            if (word1 + word2 === target) {\\n                if (word1 === word2) {\\n                    res += count1 * (count1 - 1);\\n                }\\n                else {\\n                    res += count1 * count2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfPairs = function(nums, target) {\\n    const n = nums.length;\\n    const map = new Map();\\n    \\n    for (const num of nums) {\\n        if (!map.has(num)) map.set(num, 0);\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    let res = 0;\\n    \\n    for (const [word1, count1] of map) {\\n        for (const [word2, count2] of map) {\\n            if (word1 + word2 === target) {\\n                if (word1 === word2) {\\n                    res += count1 * (count1 - 1);\\n                }\\n                else {\\n                    res += count1 * count2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975584,
                "title": "c-solution",
                "content": "\\n    int numOfPairs(char ** nums, int numsSize, char * target)\\n    {\\n        \\n        int count = 0;\\n        \\n        char *arr = (char *)malloc(sizeof(char) * (strlen(target)+1) );\\n        for(int i = 0 ; i < numsSize ; i++)\\n        {\\n            for ( int j = 0 ; j < numsSize ; j++)\\n            {\\n                if ( i != j && (strlen(nums[i])+strlen(nums[j]) == strlen(target)) )\\n                {\\n                    strcpy(arr,  nums[i]);\\n                    strcpy(arr+strlen(nums[i]) , nums[j] );\\n                    if ( strcmp(arr , target ) == 0 )\\n                        count++;\\n                                 \\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n        \\n    }\\n                                       \\n    \\n                \\n            \\n                \\n        \\n    \\n",
                "solutionTags": [],
                "code": "\\n    int numOfPairs(char ** nums, int numsSize, char * target)\\n    {\\n        \\n        int count = 0;\\n        \\n        char *arr = (char *)malloc(sizeof(char) * (strlen(target)+1) );\\n        for(int i = 0 ; i < numsSize ; i++)\\n        {\\n            for ( int j = 0 ; j < numsSize ; j++)\\n            {\\n                if ( i != j && (strlen(nums[i])+strlen(nums[j]) == strlen(target)) )\\n                {\\n                    strcpy(arr,  nums[i]);\\n                    strcpy(arr+strlen(nums[i]) , nums[j] );\\n                    if ( strcmp(arr , target ) == 0 )\\n                        count++;\\n                                 \\n                }\\n            }\\n        }\\n        \\n        \\n        return count;\\n        \\n        \\n    }\\n                                       \\n    \\n                \\n            \\n                \\n        \\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1898953,
                "title": "python3-95-two-dictionaries-and-a-counter",
                "content": "This is a one-pass algorithm using 2 dictionaries ```d1``` and ```d2```. Both of these relate a valid start string with the required end string. In ```d1```, the keys are the starts, and the values are the ends. In ```d2```, the keys are the ends, and the values are the starts. We also maintain a count of each string that we see.\\n\\nSo our algorithm is:\\n* Initialize ```out``` to 0.\\n* For each string ```n``` we see:\\n\\t* Check if ```n``` is a key in ```d1```. If it is, increment ```out``` by the count of  ```d1[n]```.\\n\\t* Check if ```n``` is a key in ```d2```. If it is, increment ```out``` by the count of  ```d2[n]```.\\n\\t* Increase the count of ```n``` by 1.\\n\\t* If ```n``` is a valid start of ```target```, create an entry in ```d2``` where the key is the corresponding end.\\n\\t* If ```n``` is a valid end of ```target```, create an entry in ```d1``` where the key is the corresponding start.\\n* Return ```out```.\\n\\n```\\ndef numOfPairs(self, nums: List[str], target: str) -> int:        \\n        d1, d2 = {}, {}\\n        counts = Counter()\\n        \\n        out = 0\\n        \\n        for n in nums:            \\n            if n in d1:\\n                out += counts[d1[n]]\\n            if n in d2:\\n                out += counts[d2[n]]\\n            \\n            counts[n] += 1\\n            \\n            l = len(n)\\n            \\n            if n == target[:l]:\\n                d2[target[l:]] = n\\n                \\n            if n == target[-l:]:\\n                d1[target[:-l]] = n\\n        \\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```d1```\n```d2```\n```d1```\n```d2```\n```out```\n```n```\n```n```\n```d1```\n```out```\n```d1[n]```\n```n```\n```d2```\n```out```\n```d2[n]```\n```n```\n```n```\n```target```\n```d2```\n```n```\n```target```\n```d1```\n```out```\n```\\ndef numOfPairs(self, nums: List[str], target: str) -> int:        \\n        d1, d2 = {}, {}\\n        counts = Counter()\\n        \\n        out = 0\\n        \\n        for n in nums:            \\n            if n in d1:\\n                out += counts[d1[n]]\\n            if n in d2:\\n                out += counts[d2[n]]\\n            \\n            counts[n] += 1\\n            \\n            l = len(n)\\n            \\n            if n == target[:l]:\\n                d2[target[l:]] = n\\n                \\n            if n == target[-l:]:\\n                d1[target[:-l]] = n\\n        \\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879232,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816166,
                "title": "easy-java-solution-single-if-statement",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            for(int j =0;j<nums.length;j++)\\n            {\\n                if(i!=j && (nums[i]+nums[j]).equals(target))\\n                {\\n                   c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            for(int j =0;j<nums.length;j++)\\n            {\\n                if(i!=j && (nums[i]+nums[j]).equals(target))\\n                {\\n                   c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746487,
                "title": "python-brute-force-and-optimized-prefix-sum-method",
                "content": "```\\n\\'\\'\\'\\nBrute:\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n,count = len(nums),0\\n        for i in range(n):\\n          for j in range(0,n):\\n            if i!=j:\\n              if nums[i]+nums[j]==target:\\n                # print(nums[i],nums[j])\\n                count+=1\\n        return count\\n\\'\\'\\'\\n\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n,count = len(nums),0\\n        h = {}\\n        \\n        \\'\\'\\'\\n        We use two passes to prevent counting self pairs like (i,i) and   (j,j).\\n        In both the passes,we build the Counter dictionary as we iterate making sure that we dont add nums[i] only after checking for target-nums[i].\\n        Doing two pass ensures that (i,j) and (j,i) if valid are counted.\\n        \\'\\'\\'\\n        #foward pass\\n        for k in nums:\\n          if target[0:len(k)]==k:\\n            nk = target[len(k):len(target)]\\n            if nk in h:\\n              count+=h[nk]\\n          if k in h: h[k]+=1\\n          else: h[k]=1\\n              \\n        #backward pass\\n        h.clear()\\n        for k in nums[::-1]:\\n          if target[0:len(k)]==k:\\n            nk=target[len(k):len(target)]\\n            if nk in h:\\n              count+=h[nk]\\n          if k in h: h[k]+=1\\n          else: h[k]=1\\n          \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\'\\'\\'\\nBrute:\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n,count = len(nums),0\\n        for i in range(n):\\n          for j in range(0,n):\\n            if i!=j:\\n              if nums[i]+nums[j]==target:\\n                # print(nums[i],nums[j])\\n                count+=1\\n        return count\\n\\'\\'\\'\\n\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n,count = len(nums),0\\n        h = {}\\n        \\n        \\'\\'\\'\\n        We use two passes to prevent counting self pairs like (i,i) and   (j,j).\\n        In both the passes,we build the Counter dictionary as we iterate making sure that we dont add nums[i] only after checking for target-nums[i].\\n        Doing two pass ensures that (i,j) and (j,i) if valid are counted.\\n        \\'\\'\\'\\n        #foward pass\\n        for k in nums:\\n          if target[0:len(k)]==k:\\n            nk = target[len(k):len(target)]\\n            if nk in h:\\n              count+=h[nk]\\n          if k in h: h[k]+=1\\n          else: h[k]=1\\n              \\n        #backward pass\\n        h.clear()\\n        for k in nums[::-1]:\\n          if target[0:len(k)]==k:\\n            nk=target[len(k):len(target)]\\n            if nk in h:\\n              count+=h[nk]\\n          if k in h: h[k]+=1\\n          else: h[k]=1\\n          \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673013,
                "title": "my-python-solution",
                "content": "**Brute Force Solution**\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)) :\\n            for j in range(len(nums)) :\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        c+=1\\n        return c\\n        \\n```\\n**TC: O(N^2)**\\n**SC: O(1)**\\n\\n**Optimized solution**\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        freq = Counter(nums)\\n        ans = 0 \\n        for k, v in freq.items(): \\n            if target.startswith(k): \\n                suffix = target[len(k):]\\n                ans += v * freq[suffix]\\n                if k == suffix: ans -= freq[suffix]\\n        return ans \\n\\n```\\n**TC: O(N)**\\n**SC: O(N)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)) :\\n            for j in range(len(nums)) :\\n                if i!=j:\\n                    if nums[i]+nums[j]==target:\\n                        c+=1\\n        return c\\n        \\n```\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        freq = Counter(nums)\\n        ans = 0 \\n        for k, v in freq.items(): \\n            if target.startswith(k): \\n                suffix = target[len(k):]\\n                ans += v * freq[suffix]\\n                if k == suffix: ans -= freq[suffix]\\n        return ans \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666741,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i != j:\\n                    res = nums[i] + nums[j]\\n                    if target == res:\\n                        count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i != j:\\n                    res = nums[i] + nums[j]\\n                    if target == res:\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659332,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int pairs = 0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            StringBuilder str = new StringBuilder();\\n            str.append(nums[i]);\\n            for(int j =0;j<nums.length;j++)\\n            {\\n                if(i == j)continue;\\n                str.append(nums[j]);\\n                if(target.equals(str.toString()))pairs++;\\n                str.delete(nums[i].length(),str.length());\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int pairs = 0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            StringBuilder str = new StringBuilder();\\n            str.append(nums[i]);\\n            for(int j =0;j<nums.length;j++)\\n            {\\n                if(i == j)continue;\\n                str.append(nums[j]);\\n                if(target.equals(str.toString()))pairs++;\\n                str.delete(nums[i].length(),str.length());\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622726,
                "title": "javascript-hashmap-production-ready-code",
                "content": "```\\nvar numOfPairs = function(nums, target) {\\n    const numCount = new Map();\\n    let ans = 0;\\n\\n    for (const num of nums)\\n        numCount.set(num, 1 + (numCount.get(num) || 0));\\n\\n    for (const [num, count] of numCount) {\\n        if (target.startsWith(num)) {\\n            const pair = target.substring(num.length);\\n\\n            if (num == pair)\\n                ans += count * (count - 1);\\n            else\\n                ans += count * (numCount.get(pair) || 0);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```\\n```\\nvar numOfPairs = function(nums, target) {\\n    let count = new Map(), totalPairs = 0;\\n\\n    for (const num of nums) {\\n        if (num.length < target.length) {\\n            totalPairs +=\\n                (target.startsWith(num) && count.has(target.slice(num.length))\\n                    ? count.get(target.slice(num.length))\\n                    : 0) +\\n                (target.endsWith(num) &&\\n                count.has(target.slice(0, target.length - num.length))\\n                    ? count.get(target.slice(0, target.length - num.length))\\n                    : 0);\\n\\t\\t}\\n        count.set(num, 1 + (count.has(num) ? count.get(num) : 0));\\n    }\\n\\n    return totalPairs;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numOfPairs = function(nums, target) {\\n    const numCount = new Map();\\n    let ans = 0;\\n\\n    for (const num of nums)\\n        numCount.set(num, 1 + (numCount.get(num) || 0));\\n\\n    for (const [num, count] of numCount) {\\n        if (target.startsWith(num)) {\\n            const pair = target.substring(num.length);\\n\\n            if (num == pair)\\n                ans += count * (count - 1);\\n            else\\n                ans += count * (numCount.get(pair) || 0);\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```\n```\\nvar numOfPairs = function(nums, target) {\\n    let count = new Map(), totalPairs = 0;\\n\\n    for (const num of nums) {\\n        if (num.length < target.length) {\\n            totalPairs +=\\n                (target.startsWith(num) && count.has(target.slice(num.length))\\n                    ? count.get(target.slice(num.length))\\n                    : 0) +\\n                (target.endsWith(num) &&\\n                count.has(target.slice(0, target.length - num.length))\\n                    ? count.get(target.slice(0, target.length - num.length))\\n                    : 0);\\n\\t\\t}\\n        count.set(num, 1 + (count.has(num) ? count.get(num) : 0));\\n    }\\n\\n    return totalPairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602480,
                "title": "easy-java-solution-using-hashmap-faster-than-99",
                "content": "Approach:\\n**//the logic is similar to the two sum problem \\n//first lets say we count the freq of each value of given array\\n//iterate on the given array and find out if that string is present as a prefix or not if it is present then just find if remaining suffix is present if yes increase count by number of suffix present \\n//just a corner case in above logic if the prefix and suffix are same then while count we need to decrease freq by 1 ie for excluding self frquency for forming target eg case target=\"11\" ar=[1,1,1]**\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        HashMap<String,Integer>h=new HashMap<String,Integer>();\\n    int ans=0;\\n     for(int i=0;i<nums.length;i++){\\n    \\th.put(nums[i],h.getOrDefault(nums[i], 0)+1);\\n    }\\n    for(int i=0;i<nums.length;i++){\\n        if(target.startsWith(nums[i])&&h.containsKey(target.substring(nums[i].length()))) {\\n           if(nums[i].equals(target.substring(nums[i].length()))){\\n               ans+=h.get(target.substring(nums[i].length()))-1;\\n           }\\n           else\\n            ans+=h.get(target.substring(nums[i].length()));\\n        }       \\n    }\\n    return ans;\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        HashMap<String,Integer>h=new HashMap<String,Integer>();\\n    int ans=0;\\n     for(int i=0;i<nums.length;i++){\\n    \\th.put(nums[i],h.getOrDefault(nums[i], 0)+1);\\n    }\\n    for(int i=0;i<nums.length;i++){\\n        if(target.startsWith(nums[i])&&h.containsKey(target.substring(nums[i].length()))) {\\n           if(nums[i].equals(target.substring(nums[i].length()))){\\n               ans+=h.get(target.substring(nums[i].length()))-1;\\n           }\\n           else\\n            ans+=h.get(target.substring(nums[i].length()));\\n        }       \\n    }\\n    return ans;\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596875,
                "title": "python3-solution-with-using-two-sum-principal",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = collections.defaultdict(int)\\n        \\n        for num in nums:\\n            d[num] += 1\\n        \\n        res = 0\\n        for num in nums:\\n            if len(num) < len(target) and num == target[:len(num)]:\\n                val = target[len(num):]\\n                val_cnt = d[target[len(num):]]\\n                if val == num:\\n                    val_cnt -= 1\\n                    \\n                res += val_cnt\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = collections.defaultdict(int)\\n        \\n        for num in nums:\\n            d[num] += 1\\n        \\n        res = 0\\n        for num in nums:\\n            if len(num) < len(target) and num == target[:len(num)]:\\n                val = target[len(num):]\\n                val_cnt = d[target[len(num):]]\\n                if val == num:\\n                    val_cnt -= 1\\n                    \\n                res += val_cnt\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594753,
                "title": "c-hashmap-of-strings-counting-from-prefix-suffix-combinations",
                "content": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n            \\n        unordered_map<string,int> mp;\\n        \\n        int result=0;\\n        \\n        for(auto s:nums){\\n            mp[s]++; //Building Frquency of strings\\n        }\\n        \\n        for(int i=1;i<=target.size();i++){\\n            //building all combination of prefix and suffix from \\n            //target\\n            string prefix  = target.substr(0, i);\\n            string suffix = target.substr(i, target.size()-i);\\n            if(mp[prefix]!=0 && mp[suffix]!=0){\\n                \\n                if(prefix!=suffix){\\n                     //If prefix and suffix are not equal, its just a product\\n                     result+=(mp[prefix]*mp[suffix]);\\n                    \\n                 }\\n                else\\n                    //Else its a product based on combinations\\n                    result+=(mp[prefix]*(mp[prefix]-1));\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n            \\n        unordered_map<string,int> mp;\\n        \\n        int result=0;\\n        \\n        for(auto s:nums){\\n            mp[s]++; //Building Frquency of strings\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1583654,
                "title": "python-with-hash-modification-of-2-sum-non-commutative-addition",
                "content": "```\\nclass Solution:\\n    \"\"\"O(N) variation of two sum:\\n    \\n    iterate array from left to right. At index i with string s, if target ends with s, we are looking for the prefix target[-len(s)] on the left. Each different ocurrence of prefix leads to a different pair, such that i<j. We then have to check target begins with s and we can find the suffix earlier, this gives the pairs j<i.\\n    \\n    We can keep a running hash of the occurences of previous strings in the list, and look for target[-len(s)]\\n    \\n    Since i,j have to be distinct, we need to check the hash first\"\"\"\\n\\t\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        hist=collections.defaultdict(int)\\n        output=0\\n        \\n        for i,s in enumerate(nums):\\n            if target.endswith(s):\\n                prefix=target[:-len(s)]\\n                output+=hist[prefix]\\n            if target.startswith(s):\\n                suffix=target[len(s):]\\n                output+=hist[suffix]\\n            hist[s]+=1\\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \"\"\"O(N) variation of two sum:\\n    \\n    iterate array from left to right. At index i with string s, if target ends with s, we are looking for the prefix target[-len(s)] on the left. Each different ocurrence of prefix leads to a different pair, such that i<j. We then have to check target begins with s and we can find the suffix earlier, this gives the pairs j<i.\\n    \\n    We can keep a running hash of the occurences of previous strings in the list, and look for target[-len(s)]\\n    \\n    Since i,j have to be distinct, we need to check the hash first\"\"\"\\n\\t\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        hist=collections.defaultdict(int)\\n        output=0\\n        \\n        for i,s in enumerate(nums):\\n            if target.endswith(s):\\n                prefix=target[:-len(s)]\\n                output+=hist[prefix]\\n            if target.startswith(s):\\n                suffix=target[len(s):]\\n                output+=hist[suffix]\\n            hist[s]+=1\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540724,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n=nums.size();\\n        \\n        int res=0;\\n        \\n        map<string,int>mp;\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]]++;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string s=nums[i];\\n            string t=target.substr(0,s.size());\\n            \\n            //cout<<s<<\" \"<<t<<endl;\\n            \\n            if(s==t)\\n            {\\n                string k=target.substr(s.size());\\n                \\n                //cout<<k<<endl;\\n                \\n                if(mp.find(k)!=mp.end())\\n                {\\n                    //cout<<k<<endl;\\n                    res+=mp[k];\\n                }\\n                \\n                if(k==s)\\n                {\\n                    res--;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n=nums.size();\\n        \\n        int res=0;\\n        \\n        map<string,int>mp;\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]]++;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string s=nums[i];\\n            string t=target.substr(0,s.size());\\n            \\n            //cout<<s<<\" \"<<t<<endl;\\n            \\n            if(s==t)\\n            {\\n                string k=target.substr(s.size());\\n                \\n                //cout<<k<<endl;\\n                \\n                if(mp.find(k)!=mp.end())\\n                {\\n                    //cout<<k<<endl;\\n                    res+=mp[k];\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1529985,
                "title": "c-beats-99-time-and-beats-88-memory",
                "content": "here we have two maps \\none to count frequency of explored strings...and another to keep track of their needs (if the string can be the prefix of the target,,,then the need of that string is the rest of the target )\\nwhenever we explore a string we check whether any other explored string needs our current string.\\nif a certain no of string does require the current string in order to form the target , we add that no to our count\\nthen we check if our current string \"needs\" any explored string to form the target\\nif it does we add the frequency of the needed string\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> hm;\\n        unordered_map<string,int> needs;\\n        int m=target.length();\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(needs[nums[i]]){\\n                count+=needs[nums[i]];\\n            }\\n            int n=nums[i].length();\\n            string str=target.substr(0,n);\\n            if(nums[i]==str){\\n                str=target.substr(n,m);\\n                needs[str]++;\\n                if(hm[str]) {\\n                    count+=hm[str];\\n                }\\n            }\\n            hm[nums[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> hm;\\n        unordered_map<string,int> needs;\\n        int m=target.length();\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(needs[nums[i]]){\\n                count+=needs[nums[i]];\\n            }\\n            int n=nums[i].length();\\n            string str=target.substr(0,n);\\n            if(nums[i]==str){\\n                str=target.substr(n,m);\\n                needs[str]++;\\n                if(hm[str]) {\\n                    count+=hm[str];\\n                }\\n            }\\n            hm[nums[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508606,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                    string a=nums[i]+nums[j];\\n                    string b=nums[j]+ nums[i];\\n                    if(a==target)\\n                    {\\n                      ans++;  \\n                    }\\n                    if(b==target)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int ans=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                    string a=nums[i]+nums[j];\\n                    string b=nums[j]+ nums[i];\\n                    if(a==target)\\n                    {\\n                      ans++;  \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1506133,
                "title": "c-o-n-2-clean-solution-using-hashmap-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefix(string&target, string&source){\\n        if(source.length() > target.length()){\\n            return false;\\n        }\\n        int i;\\n        for(i = 0; i < source.length(); i++){\\n            if(source[i] != target[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int>hashMap;\\n        int i, j;\\n        for(i = 0; i < nums.size(); i++){\\n            hashMap[nums[i]]++;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < nums.size(); i++){\\n            if(isPrefix(target, nums[i])){\\n                string str = target.substr(nums[i].length(), target.length() - nums[i].length());\\n                if(str == nums[i]){\\n                    ans += hashMap[str] - 1;\\n                } \\n                else{\\n                    ans += hashMap[str];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefix(string&target, string&source){\\n        if(source.length() > target.length()){\\n            return false;\\n        }\\n        int i;\\n        for(i = 0; i < source.length(); i++){\\n            if(source[i] != target[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int>hashMap;\\n        int i, j;\\n        for(i = 0; i < nums.size(); i++){\\n            hashMap[nums[i]]++;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < nums.size(); i++){\\n            if(isPrefix(target, nums[i])){\\n                string str = target.substr(nums[i].length(), target.length() - nums[i].length());\\n                if(str == nums[i]){\\n                    ans += hashMap[str] - 1;\\n                } \\n                else{\\n                    ans += hashMap[str];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503020,
                "title": "c-100-100",
                "content": "```\\npublic int NumOfPairs(string[] nums, string target)\\n{\\n\\tvar pairs = 0;\\n\\tvar freqs = nums.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\n\\tforeach (var (key, value) in freqs)\\n\\t{\\n\\t\\tif (!target.StartsWith(key)) continue;\\n\\t\\tvar rest = target[key.Length..];\\n\\t\\tif (!freqs.ContainsKey(rest)) continue;\\n\\n\\t\\tvar freq = freqs[rest];\\n\\t\\tif (key == rest) freq--;\\n\\t\\tpairs += value * freq;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumOfPairs(string[] nums, string target)\\n{\\n\\tvar pairs = 0;\\n\\tvar freqs = nums.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\n\\tforeach (var (key, value) in freqs)\\n\\t{\\n\\t\\tif (!target.StartsWith(key)) continue;\\n\\t\\tvar rest = target[key.Length..];\\n\\t\\tif (!freqs.ContainsKey(rest)) continue;\\n\\n\\t\\tvar freq = freqs[rest];\\n\\t\\tif (key == rest) freq--;\\n\\t\\tpairs += value * freq;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502446,
                "title": "beginner-friendly-solution-c",
                "content": "My first post : This Solution was \\nRuntime: 127 ms, faster than **94.12%** of C++ online submissions for Number of Pairs of Strings With Concatenation Equal to Target.\\nMemory Usage: 56.1 MB, less than **11.76%** of C++ online submissions for Number of Pairs of Strings With Concatenation Equal to Target.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Eliminate the one we don\\'t want\\n    bool check(string a,string target){    \\n        for(int i=0;i<a.size();i++){\\n            if(a[i]!=target[i])return false;\\n        }\\n        return true;\\n    }\\n    // Final check for substrings buit\\n     bool checkFinal(string a,string target){\\n\\t \\n        if(a.size()!=target.size())return false;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]!=target[i])return false;\\n        }\\n        return true;\\n    }\\n        \\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n=nums.size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(check(nums[i],target)){\\n            \\n                for(int j=0;j<n;j++){\\n                    if(i==j){}\\n                    else if(checkFinal(nums[i]+nums[j],target)){\\n                        count++;\\n                    }\\n                }\\n            \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\nDo upvote if you like it.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Eliminate the one we don\\'t want\\n    bool check(string a,string target){    \\n        for(int i=0;i<a.size();i++){\\n            if(a[i]!=target[i])return false;\\n        }\\n        return true;\\n    }\\n    // Final check for substrings buit\\n     bool checkFinal(string a,string target){\\n\\t \\n        if(a.size()!=target.size())return false;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]!=target[i])return false;\\n        }\\n        return true;\\n    }\\n        \\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n=nums.size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(check(nums[i],target)){\\n            \\n                for(int j=0;j<n;j++){\\n                    if(i==j){}\\n                    else if(checkFinal(nums[i]+nums[j],target)){\\n                        count++;\\n                    }\\n                }\\n            \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501515,
                "title": "100-faster-8ms-100-less-space-than-all-c-submissions",
                "content": "```\\n    int numOfPairs(vector<string>& nums, string target) {\\n        map<string,int> mp;\\n        int res = 0;\\n        int m = target.size();\\n        for(string s : nums){\\n            int n = s.size();\\n            if(n>m){ continue; }\\n            if(s == target.substr(0,n)){\\n                string temp = target.substr(n);\\n                if(mp.find(temp) != mp.end()){\\n                    res += mp[temp];\\n                }\\n            }\\n            if(s == target.substr(m-n)){\\n                string temp = target.substr(0,m-n);\\n                if(mp.find(temp) != mp.end()){\\n                    res += mp[temp];\\n                }\\n            } \\n            mp[s]++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numOfPairs(vector<string>& nums, string target) {\\n        map<string,int> mp;\\n        int res = 0;\\n        int m = target.size();\\n        for(string s : nums){\\n            int n = s.size();\\n            if(n>m){ continue; }\\n            if(s == target.substr(0,n)){\\n                string temp = target.substr(n);\\n                if(mp.find(temp) != mp.end()){\\n                    res += mp[temp];\\n                }\\n            }\\n            if(s == target.substr(m-n)){\\n                string temp = target.substr(0,m-n);\\n                if(mp.find(temp) != mp.end()){\\n                    res += mp[temp];\\n                }\\n            } \\n            mp[s]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500639,
                "title": "javascript-direct-way-99ms",
                "content": "```\\nconst numOfPairs = (a, t) => {\\n    let n = a.length, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i == j) continue;\\n            if (a[i] + a[j] == t) res++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numOfPairs = (a, t) => {\\n    let n = a.length, res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i == j) continue;\\n            if (a[i] + a[j] == t) res++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500373,
                "title": "rust-functional",
                "content": "\\n```rust\\n\\nimpl Solution {\\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\\n        let rg: Vec<i32> = (0..nums.len() as i32).collect();\\n        rg.iter()\\n            .fold(0, |res, &i| {\\n                res + rg.iter()\\n                    .filter(|&&j| {\\n                        i != j && (nums[i as usize].to_owned() + &nums[j as usize]) == target\\n                    })\\n                    .count() as i32\\n            })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn num_of_pairs(nums: Vec<String>, target: String) -> i32 {\\n        let rg: Vec<i32> = (0..nums.len() as i32).collect();\\n        rg.iter()\\n            .fold(0, |res, &i| {\\n                res + rg.iter()\\n                    .filter(|&&j| {\\n                        i != j && (nums[i as usize].to_owned() + &nums[j as usize]) == target\\n                    })\\n                    .count() as i32\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500283,
                "title": "two-loops-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/32807aef-b9dc-4430-864b-f8d1118eec5e_1633236442.4528859.png)\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count, len_nums = 0, len(nums)\\n        for i in range(len_nums - 1):\\n            for j in range(i + 1, len_nums):\\n                if nums[i] + nums[j] == target:\\n                    count += 1\\n                if nums[j] + nums[i] == target:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count, len_nums = 0, len(nums)\\n        for i in range(len_nums - 1):\\n            for j in range(i + 1, len_nums):\\n                if nums[i] + nums[j] == target:\\n                    count += 1\\n                if nums[j] + nums[i] == target:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499791,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function (nums, target) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (i !== j && nums[i] + nums[j] === target) {\\n        a++;\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {string} target\\n * @return {number}\\n */\\nvar numOfPairs = function (nums, target) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = 0; j < nums.length; j++) {\\n      if (i !== j && nums[i] + nums[j] === target) {\\n        a++;\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499586,
                "title": "c-brute-force",
                "content": "\\n    int numOfPairs(vector<string>& nums, string target) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]+nums[j]==target&&i!=j)\\n                    ans++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int numOfPairs(vector<string>& nums, string target) \\n    {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]+nums[j]==target&&i!=j)\\n                    ans++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1499489,
                "title": "java-100-fast-easy-code",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    String res = nums[i].concat(nums[j]);\\n                    if(res.equals(target))\\n                    {\\n                        count++;   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    String res = nums[i].concat(nums[j]);\\n                    if(res.equals(target))\\n                    {\\n                        count++;   \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1499364,
                "title": "java-hashmap-simple-code",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        // Map to store frequency of strings\\n        Map<String, Integer> map= new HashMap<>();\\n        for(String s: nums){\\n            map.put(s, map.getOrDefault(s, 0)+1);\\n        }\\n        \\n        int ans=0;\\n        \\n        // Iterate over hashmap and find the pairs;\\n        for(Map.Entry<String, Integer> m: map.entrySet()){\\n            String key=m.getKey();\\n            if(key.length()>target.length()){\\n                continue;\\n            }\\n            //if the first half of string target matches with the key\\n            if(target.substring(0, key.length()).equals(key)){\\n                String suffix=target.substring(key.length());\\n                if(map.containsKey(suffix)){\\n                    ans+=(m.getValue()* map.get(suffix));\\n                    // if both suffix and prefix are equal then we reduce it by the frequency to avoid repetitions\\n                    if(suffix.equals(key)){\\n                        ans-=m.getValue();\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        \\n        // Map to store frequency of strings\\n        Map<String, Integer> map= new HashMap<>();\\n        for(String s: nums){\\n            map.put(s, map.getOrDefault(s, 0)+1);\\n        }\\n        \\n        int ans=0;\\n        \\n        // Iterate over hashmap and find the pairs;\\n        for(Map.Entry<String, Integer> m: map.entrySet()){\\n            String key=m.getKey();\\n            if(key.length()>target.length()){\\n                continue;\\n            }\\n            //if the first half of string target matches with the key\\n            if(target.substring(0, key.length()).equals(key)){\\n                String suffix=target.substring(key.length());\\n                if(map.containsKey(suffix)){\\n                    ans+=(m.getValue()* map.get(suffix));\\n                    // if both suffix and prefix are equal then we reduce it by the frequency to avoid repetitions\\n                    if(suffix.equals(key)){\\n                        ans-=m.getValue();\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499315,
                "title": "c-map-solution-beats-100-runtime-and-100-memory-usage",
                "content": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n    int n=nums.size();\\n    int ans=0;\\n    unordered_map<string,int> mp;\\n    for(int i=0;i<n;++i){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<n;++i){\\n        if(nums[i]==target.substr(0,nums[i].size())){\\n            string remaining=target.substr(nums[i].size());\\n            if(mp.find(remaining)!=mp.end()){\\n                ans+=mp[remaining];\\n                if(remaining==nums[i]){\\n                    ans--;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numOfPairs(vector<string>& nums, string target) {\\n    int n=nums.size();\\n    int ans=0;\\n    unordered_map<string,int> mp;\\n    for(int i=0;i<n;++i){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<n;++i){\\n        if(nums[i]==target.substr(0,nums[i].size())){\\n            string remaining=target.substr(nums[i].size());\\n            if(mp.find(remaining)!=mp.end()){\\n                ans+=mp[remaining];\\n                if(remaining==nums[i]){\\n                    ans--;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499229,
                "title": "python3-true-o-n-with-explanation-tc-100-sc-100-40ms-14-3mb",
                "content": "1. Create a table count the number of different slice in nums: O(n)\\n2. Iterate all possible (left slice, right slice) requred by target: O(2l) ~ O(n), \\n\\tDenote: l: length of string. In quesiton setting, max(l) = max(n) <= 100\\n\\t2.1. If the left slice is same with the right slice, number of ways to choose left and right = count(slice) *  (count(slice)-1)\\n\\t2.1. If the left slice is different with the right slice, number of ways to choose left and right = count(left slice) *  count(right slice)\\n\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        \\n        # 1. Get counts of different kind of slices, O(n)\\n        nums_count = {}\\n        for num in nums:\\n            if num in nums_count:\\n                nums_count[num] +=1\\n            else:\\n                nums_count[num] = 1\\n        \\n        # 2. Iterate over all different possible slices, O(l)\\n        ans = 0\\n        for i in range(1,len(target)): # O(l)\\n            # 2.1. if left and right slice are same, one one time of O(l): \\n            # Note: for \"if cond1 and cond2\" statement, if cond1 is False, cond2 will not execute.\\n            if i==len(target)-i and target[:i] == target[i:]: \\n                    ans+= ( nums_count.get(target[:i],0) * (nums_count.get(target[:i],0)-1) )\\n            # 2.2. if left and right slice are different, O(1)\\n            else:\\n                ans += nums_count.get(target[:i],0)*nums_count.get(target[i:],0)\\n                \\n        return int(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        \\n        # 1. Get counts of different kind of slices, O(n)\\n        nums_count = {}\\n        for num in nums:\\n            if num in nums_count:\\n                nums_count[num] +=1\\n            else:\\n                nums_count[num] = 1\\n        \\n        # 2. Iterate over all different possible slices, O(l)\\n        ans = 0\\n        for i in range(1,len(target)): # O(l)\\n            # 2.1. if left and right slice are same, one one time of O(l): \\n            # Note: for \"if cond1 and cond2\" statement, if cond1 is False, cond2 will not execute.\\n            if i==len(target)-i and target[:i] == target[i:]: \\n                    ans+= ( nums_count.get(target[:i],0) * (nums_count.get(target[:i],0)-1) )\\n            # 2.2. if left and right slice are different, O(1)\\n            else:\\n                ans += nums_count.get(target[:i],0)*nums_count.get(target[i:],0)\\n                \\n        return int(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499142,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                string temp=nums[i]+nums[j];\\n                if(temp==target)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                string temp=nums[i]+nums[j];\\n                if(temp==target)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499114,
                "title": "python-3-brute-force",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i!=j and nums[i]+nums[j]==target:\\n                    answ+=1\\n        return answ\\n```\\nOne Line version:\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        return sum(i!=j and nums[i]+nums[j]==target for i in range(len(nums)) for j in range(len(nums)))   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i!=j and nums[i]+nums[j]==target:\\n                    answ+=1\\n        return answ\\n```\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        return sum(i!=j and nums[i]+nums[j]==target for i in range(len(nums)) for j in range(len(nums)))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499078,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int k=0,a=0,g;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n            if(nums[i]+nums[j]==target)\\n                k++;\\n        }\\n    }\\n        for(int i=nums.size()-1;i>=1;i--){\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                 if(nums[i]+nums[j]==target)\\n                a++;\\n            }\\n        }\\n        \\n        g=a+k;\\n        return g;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int k=0,a=0,g;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n            if(nums[i]+nums[j]==target)\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1499058,
                "title": "c-using-map",
                "content": "First of all we calculate number of each substring in nums. Than we try to split target in different positions and sum number of `left parts` * number of `right parts`. Separately we need to check the case, when `left part` and `right part` are the same.\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        map<string, int> m;\\n        \\n        for (const auto& str : nums) {\\n            ++m[str];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i <= target.size(); ++i) {\\n            string str1 = target.substr(0, i), str2 = target.substr(i);\\n            \\n            if (str1 != str2) {\\n                if (auto it1 = m.find(str1), it2 = m.find(str2); it1 != m.end() && it2 != m.end()) {\\n                    res += it1->second * it2->second;\\n                }\\n            } else {\\n                if (auto it1 = m.find(str1); it1 != m.end()) {\\n                    res += it1->second * (it1->second - 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        map<string, int> m;\\n        \\n        for (const auto& str : nums) {\\n            ++m[str];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i <= target.size(); ++i) {\\n            string str1 = target.substr(0, i), str2 = target.substr(i);\\n            \\n            if (str1 != str2) {\\n                if (auto it1 = m.find(str1), it2 = m.find(str2); it1 != m.end() && it2 != m.end()) {\\n                    res += it1->second * it2->second;\\n                }\\n            } else {\\n                if (auto it1 = m.find(str1); it1 != m.end()) {\\n                    res += it1->second * (it1->second - 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499028,
                "title": "easy-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int N = nums.length, count = 0;\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i + 1; j < N; j++) {\\n                String result1 = nums[i] + nums[j];\\n                String result2 = nums[j] + nums[i];\\n                if(result1.equals(target))\\n                    count++;\\n                if(result2.equals(target))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int N = nums.length, count = 0;\\n        for(int i = 0; i < N; i++) {\\n            for(int j = i + 1; j < N; j++) {\\n                String result1 = nums[i] + nums[j];\\n                String result2 = nums[j] + nums[i];\\n                if(result1.equals(target))\\n                    count++;\\n                if(result2.equals(target))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058337,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i= 0; i<nums.length; i++){\\n            for(int j = 0; j <nums.length; j++){\\n                if(i != j && (nums[i]+nums[j]).equals(target)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i= 0; i<nums.length; i++){\\n            for(int j = 0; j <nums.length; j++){\\n                if(i != j && (nums[i]+nums[j]).equals(target)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046327,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i!=j&&target.equals(nums[i]+nums[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i!=j&&target.equals(nums[i]+nums[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046325,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i!=j&&target.equals(nums[i]+nums[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(i!=j&&target.equals(nums[i]+nums[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044034,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        int l=nums.length;\\n        for(int i=0;i<l;i++){\\n        \\n            for(int j=0;j<l;j++){\\n               if(i!=j){\\n                   String s=nums[i]+nums[j];\\n                   if(s.equals(target)){\\n                       c++;\\n                   }\\n               }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        int l=nums.length;\\n        for(int i=0;i<l;i++){\\n        \\n            for(int j=0;j<l;j++){\\n               if(i!=j){\\n                   String s=nums[i]+nums[j];\\n                   if(s.equals(target)){\\n                       c++;\\n                   }\\n               }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042154,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        String s = \"\";\\n        String str = \"\";\\n        int x = 0;\\n    \\n        for(int i=0;i<nums.length;i++){\\n           s = \"\";\\n           for(int j=0;j<nums.length;j++){\\n               s = nums[i]+nums[j];\\n               if(i!=j && s.equals(target)){\\n                   x++;\\n               }\\n           }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        String s = \"\";\\n        String str = \"\";\\n        int x = 0;\\n    \\n        for(int i=0;i<nums.length;i++){\\n           s = \"\";\\n           for(int j=0;j<nums.length;j++){\\n               s = nums[i]+nums[j];\\n               if(i!=j && s.equals(target)){\\n                   x++;\\n               }\\n           }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035735,
                "title": "java-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(i != j){\\n                    String str =  nums[i] + nums[j];\\n                    if(str.equals(target)){\\n                        count++;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(i != j){\\n                    String str =  nums[i] + nums[j];\\n                    if(str.equals(target)){\\n                        count++;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027722,
                "title": "beats-all-postions-83-full-java",
                "content": "`code`# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n       int count=0;\\n       String a=\"\";\\n       String b=\"\";\\n       HashMap<String,Integer> map=new HashMap<>();\\n       for (String num:nums){\\n           map.put(num,map.getOrDefault(num,0)+1);\\n       }\\n       for(int i=1;i<target.length();i++){\\n           a=target.substring(0,i);\\n           b=target.substring(i,target.length());\\n           if(map.containsKey(a)&& map.containsKey(b)){\\n               if(a.equals(b)){\\n                   count+=map.get(a)*(map.get(a)-1);\\n               }\\n               else{\\n                   count+=map.get(a)*map.get(b);\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n       int count=0;\\n       String a=\"\";\\n       String b=\"\";\\n       HashMap<String,Integer> map=new HashMap<>();\\n       for (String num:nums){\\n           map.put(num,map.getOrDefault(num,0)+1);\\n       }\\n       for(int i=1;i<target.length();i++){\\n           a=target.substring(0,i);\\n           b=target.substring(i,target.length());\\n           if(map.containsKey(a)&& map.containsKey(b)){\\n               if(a.equals(b)){\\n                   count+=map.get(a)*(map.get(a)-1);\\n               }\\n               else{\\n                   count+=map.get(a)*map.get(b);\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027713,
                "title": "best-fast-most-original-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = Counter(nums)\\n        result = 0\\n        for k, v in d.items():\\n            if target.startswith(k):\\n                suffix = target[len(k):]\\n                result += v * d[suffix]\\n                if k == suffix: result -= d[suffix]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = Counter(nums)\\n        result = 0\\n        for k, v in d.items():\\n            if target.startswith(k):\\n                suffix = target[len(k):]\\n                result += v * d[suffix]\\n                if k == suffix: result -= d[suffix]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013705,
                "title": "o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> freq;\\n        for(auto i:nums)\\n        if(i.size()<target.size())freq[i]++;\\n\\n        int res=0;\\n        for(auto [s,frq]:freq){\\n            if(target.find(s)==0)\\n            if(s+s==target)\\n            res+=frq*(frq-1);\\n            else\\n            res+=frq*freq[target.substr(s.size())];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> freq;\\n        for(auto i:nums)\\n        if(i.size()<target.size())freq[i]++;\\n\\n        int res=0;\\n        for(auto [s,frq]:freq){\\n            if(target.find(s)==0)\\n            if(s+s==target)\\n            res+=frq*(frq-1);\\n            else\\n            res+=frq*freq[target.substr(s.size())];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010689,
                "title": "easy-understandabe-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if((nums[i]+nums[j]).equals(target) && (i!=j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if((nums[i]+nums[j]).equals(target) && (i!=j)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983626,
                "title": "java-2ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String  , Integer> dic = new HashMap<>();\\n        for( var el : nums){\\n            if(! dic.containsKey(el)) dic.put(el , 0);\\n            dic.put(el , dic.get(el) + 1);\\n        }\\n        int res = 0 ;\\n        for( var el : nums){\\n            if(target.startsWith(el)){\\n                String sub = target.substring(el.length());\\n                res = res + dic.getOrDefault(sub , 0);\\n                if( sub.equals(el)) res--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Map<String  , Integer> dic = new HashMap<>();\\n        for( var el : nums){\\n            if(! dic.containsKey(el)) dic.put(el , 0);\\n            dic.put(el , dic.get(el) + 1);\\n        }\\n        int res = 0 ;\\n        for( var el : nums){\\n            if(target.startsWith(el)){\\n                String sub = target.substring(el.length());\\n                res = res + dic.getOrDefault(sub , 0);\\n                if( sub.equals(el)) res--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982131,
                "title": "solution-for-number-of-pairs-of-strings-with-concatenation-equal-to-target",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;\\n        int ans=0;\\n        for(int i =0;i<n;i++){\\n            for(int j =0; j<n;j++){\\n                if( i != j){\\n                    String str = nums[i] + nums[j];\\n                    if (str.equals(target)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int n = nums.length;\\n        int ans=0;\\n        for(int i =0;i<n;i++){\\n            for(int j =0; j<n;j++){\\n                if( i != j){\\n                    String str = nums[i] + nums[j];\\n                    if (str.equals(target)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966190,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        // we have array of strings\\n\\n        StringBuilder sb = new StringBuilder();\\nint count =0;\\n        for(int i=0;i<nums.length;i++)\\n        for(int j=i+1;j<nums.length;j++){\\n           sb.append(nums[i]);\\n           sb.append(nums[j]);\\n           if(target.equals(sb.toString())){\\n               count++;\\n           }\\n           else{\\n               sb.delete(0,sb.length()-1);\\n           }\\n        }\\n\\n        return count;\\n    }\\n}\\n*/\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) \\n            for (int j = 0; j < nums.length; j++) {\\n                if (i != j) {\\n                    String concat1 = nums[i] + nums[j];\\n                  \\n                    \\n                    if (target.equals(concat1)) {\\n                        count++;\\n                    }\\n                    else{\\n                        concat1 =\"\";\\n                    }\\n            }\\n        }\\n        \\n        return count;\\n    \\n}\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*class Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        // we have array of strings\\n\\n        StringBuilder sb = new StringBuilder();\\nint count =0;\\n        for(int i=0;i<nums.length;i++)\\n        for(int j=i+1;j<nums.length;j++){\\n           sb.append(nums[i]);\\n           sb.append(nums[j]);\\n           if(target.equals(sb.toString())){\\n               count++;\\n           }\\n           else{\\n               sb.delete(0,sb.length()-1);\\n           }\\n        }\\n\\n        return count;\\n    }\\n}\\n*/\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) \\n            for (int j = 0; j < nums.length; j++) {\\n                if (i != j) {\\n                    String concat1 = nums[i] + nums[j];\\n                  \\n                    \\n                    if (target.equals(concat1)) {\\n                        count++;\\n                    }\\n                    else{\\n                        concat1 =\"\";\\n                    }\\n            }\\n        }\\n        \\n        return count;\\n    \\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962200,
                "title": "easy-c-10ms-hashmap-solution",
                "content": "# Intuition\\n<!--think about hashmap to count frequency -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n     unordered_map<string,int>mp;\\n     for(auto it:nums)mp[it]++;\\n     int ans=0;\\n     string s;\\n     for(int i=0;i<target.size()-1;i++){\\n         s.push_back(target[i]);\\n         if(s==target.substr(i+1,target.size()-i-1))\\n         ans+=(mp[s]*(mp[target.substr(i+1,target.size()-i-1)]-1));\\n         else\\n         ans+=(mp[s]*mp[target.substr(i+1,target.size()-i-1)]);\\n       }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n     unordered_map<string,int>mp;\\n     for(auto it:nums)mp[it]++;\\n     int ans=0;\\n     string s;\\n     for(int i=0;i<target.size()-1;i++){\\n         s.push_back(target[i]);\\n         if(s==target.substr(i+1,target.size()-i-1))\\n         ans+=(mp[s]*(mp[target.substr(i+1,target.size()-i-1)]-1));\\n         else\\n         ans+=(mp[s]*mp[target.substr(i+1,target.size()-i-1)]);\\n       }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956722,
                "title": "beats-97-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        count = 0 \\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i!=j :\\n                    if nums[i]+nums[j] == target:\\n                        count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        count = 0 \\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i!=j :\\n                    if nums[i]+nums[j] == target:\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955300,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            string temp;\\n            for(int j=0;j<nums.size();j++){\\n               temp+=nums[i];\\n               temp+=nums[j];\\n               if(temp==target && i!=j) count++;\\n               temp=\"\";\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            string temp;\\n            for(int j=0;j<nums.size();j++){\\n               temp+=nums[i];\\n               temp+=nums[j];\\n               if(temp==target && i!=j) count++;\\n               temp=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3954212,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i] + nums[j] == target and i != j:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i] + nums[j] == target and i != j:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953558,
                "title": "number-of-pairs-of-strings-with-concatenation-equal-to-target-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] + nums[j] == target and nums[j] + nums[i] == target:\\n                    count+=2\\n                elif nums[i] + nums[j] == target or nums[j] + nums[i] == target:\\n                    count+=1\\n        return count\\n        \\n        \\nobj = Solution()\\nobj.numOfPairs([\"777\",\"7\",\"77\",\"77\"],\"7777\")\\n\\n# obj.numOfPairs([\"1\",\"111\"],\"11\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfPairs(self, nums, target):\\n        \"\"\"\\n        :type nums: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(nums)-1):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] + nums[j] == target and nums[j] + nums[i] == target:\\n                    count+=2\\n                elif nums[i] + nums[j] == target or nums[j] + nums[i] == target:\\n                    count+=1\\n        return count\\n        \\n        \\nobj = Solution()\\nobj.numOfPairs([\"777\",\"7\",\"77\",\"77\"],\"7777\")\\n\\n# obj.numOfPairs([\"1\",\"111\"],\"11\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950503,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int numOfPairs(List<String> nums, String target) {\\n      var c = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          for (int j = i + 1; j < nums.length; j++) {\\n              if (nums[i] + nums[j] == target) {\\n                  c += 1;\\n              }\\n              if (nums[j] + nums[i] == target) {\\n                  c += 1;\\n              }\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numOfPairs(List<String> nums, String target) {\\n      var c = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          for (int j = i + 1; j < nums.length; j++) {\\n              if (nums[i] + nums[j] == target) {\\n                  c += 1;\\n              }\\n              if (nums[j] + nums[i] == target) {\\n                  c += 1;\\n              }\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927849,
                "title": "beats-91-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        import collections\\n        my_dict=collections.defaultdict(set)\\n        res=0\\n        for i,a in enumerate(nums):\\n            my_dict[a].add(i)\\n            \\n        for i , a in enumerate(nums):\\n            l=len(a)\\n            if a == target[:-l] and target[-l:] in my_dict:\\n                if i in my_dict[target[-l:]]:\\n                    res+=len(my_dict[target[-l:]])-1\\n                else:\\n                    res+=len(my_dict[target[-l:]])\\n\\n            elif a==target[:l] and target[l:] in my_dict:\\n                if i in my_dict[target[l:]]:\\n                    res+=len(my_dict[target[l:]])-1\\n                else:\\n                    res+=len(my_dict[target[l:]])\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        import collections\\n        my_dict=collections.defaultdict(set)\\n        res=0\\n        for i,a in enumerate(nums):\\n            my_dict[a].add(i)\\n            \\n        for i , a in enumerate(nums):\\n            l=len(a)\\n            if a == target[:-l] and target[-l:] in my_dict:\\n                if i in my_dict[target[-l:]]:\\n                    res+=len(my_dict[target[-l:]])-1\\n                else:\\n                    res+=len(my_dict[target[-l:]])\\n\\n            elif a==target[:l] and target[l:] in my_dict:\\n                if i in my_dict[target[l:]]:\\n                    res+=len(my_dict[target[l:]])-1\\n                else:\\n                    res+=len(my_dict[target[l:]])\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926855,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int count = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i != j && nums[i] + nums[j] == target) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size();\\n        int count = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i != j && nums[i] + nums[j] == target) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922180,
                "title": "simple-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count=0\\n        for i, j in permutations(nums, 2):\\n           print(i,j)\\n           if i + j == target:\\n               count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count=0\\n        for i, j in permutations(nums, 2):\\n           print(i,j)\\n           if i + j == target:\\n               count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920213,
                "title": "python-solution-using-two-pointers-explained-and-easy-to-understand",
                "content": "# Intuition\\nThe intuition behind the solution for this problem is that in order for two values in nums to be a valid pair, each number in nums requires a complementary pair that will satisfy the target given as long as the indexes are different. Ex. If you have \\'777\\' in nums, you will need to find \\'7\\' in nums in order to satisfy the target \\'7777\\'.\\n# Approach\\nFor this problem, I decided to use two pointers. One pointer will be at an indice in nums while the second pointer searches the rest of nums for a complementary number to satisfy the target. If no complementary number that satisfies the target is found, you move the first pointer along nums to the next number and repeat the process.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        ans = 0\\n        right = 0\\n\\n        for i in range(len(nums)): # i is the first pointer\\n            \\n            while right < len(nums): # right, the second pointer, searches throughout the entire list for a complementary number.\\n                if nums[i] + nums[right] == target and right != i:\\n                    ans += 1\\n                right += 1\\n                \\n            right = 0 # The second pointer is set to 0 once it has travelled through the whole list.\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        ans = 0\\n        right = 0\\n\\n        for i in range(len(nums)): # i is the first pointer\\n            \\n            while right < len(nums): # right, the second pointer, searches throughout the entire list for a complementary number.\\n                if nums[i] + nums[right] == target and right != i:\\n                    ans += 1\\n                right += 1\\n                \\n            right = 0 # The second pointer is set to 0 once it has travelled through the whole list.\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914613,
                "title": "using-hashmap-of-prefix-and-suffix-of-target",
                "content": "# Intuition\\nFirstly, we look at the target and create its hashmap where they key\\nwill be prefix and the value will be suffix.\\nThen after that we create another hashmap, counter to get he count of each value inside the given array.\\nNow we iterate over counter hashmap and check if the key is a prefix of the target string, by using the prefix hashmap we created earlier on. If it is, then we use its value which is the suffix required to get the target and check whether such string exist in our counter. If it does, then we just get the product of our current prefix count and suffix count. \\nOnly edge case we have to take care of is when the prefix === suffix. For example, when the target is 7777 then suffix for the prefix of 77 will be 77. Lets say we got 5 such 77 in our nums array, then the count of it will be 5. So the product of it will be 5x5 = 25. However, that 25 will include itself for each 77 and hence to get rid of that we need to deduct by its count.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n\\n        #Hashmap where key is prefix and value is suffix\\n        #the concatation of the key and value === target\\n        p = {}\\n        p_ = []\\n        s_ = list(target)\\n        for l in target:\\n            p_.append(l)\\n            s_.pop(0)\\n            p[\"\".join(p_)] = \"\".join(s_)\\n                \\n        #Hashmap (counter) to get the count of each value\\n        c = {}\\n        for n in nums:\\n            c[n] = c.get(n,0) + 1\\n        \\n        #answer\\n        counts = 0\\n\\n        #iterate over counter and we check if the key is a prefix of our target\\n        for prefix,count in c.items():\\n\\n            #check if prefix exist            \\n            suffix = p.get(prefix,\"\")            \\n\\n            #if the key was a valid prefix of the target then we try\\n            #to find its suffix in our counter\\n            suffix_count = c.get(suffix,0)\\n\\n            #now if our suffix == prefix we will get \\n            #each pair count times where prefix includes itself as the suffix too\\n            if suffix == prefix:\\n                counts += (suffix_count * count) - count\\n            else:                \\n                counts += suffix_count * count\\n        \\n        return counts\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n\\n        #Hashmap where key is prefix and value is suffix\\n        #the concatation of the key and value === target\\n        p = {}\\n        p_ = []\\n        s_ = list(target)\\n        for l in target:\\n            p_.append(l)\\n            s_.pop(0)\\n            p[\"\".join(p_)] = \"\".join(s_)\\n                \\n        #Hashmap (counter) to get the count of each value\\n        c = {}\\n        for n in nums:\\n            c[n] = c.get(n,0) + 1\\n        \\n        #answer\\n        counts = 0\\n\\n        #iterate over counter and we check if the key is a prefix of our target\\n        for prefix,count in c.items():\\n\\n            #check if prefix exist            \\n            suffix = p.get(prefix,\"\")            \\n\\n            #if the key was a valid prefix of the target then we try\\n            #to find its suffix in our counter\\n            suffix_count = c.get(suffix,0)\\n\\n            #now if our suffix == prefix we will get \\n            #each pair count times where prefix includes itself as the suffix too\\n            if suffix == prefix:\\n                counts += (suffix_count * count) - count\\n            else:                \\n                counts += suffix_count * count\\n        \\n        return counts\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899503,
                "title": "using-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if((nums[i]+nums[j]).equals(target) && i!=j){\\n                    c=c+1;\\n\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if((nums[i]+nums[j]).equals(target) && i!=j){\\n                    c=c+1;\\n\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894667,
                "title": "golang-bruteforce",
                "content": "# Intuition & Approach\\n\\nJust two loops with O(n^2).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc numOfPairs(nums []string, target string) int {\\n    var ans int\\n    for i := 0; i < len(nums); i++ {\\n        for j := i + 1; j < len(nums); j++ {\\n            if nums[i]+nums[j] == target {\\n                ans++\\n            }\\n            if nums[j]+nums[i] == target {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numOfPairs(nums []string, target string) int {\\n    var ans int\\n    for i := 0; i < len(nums); i++ {\\n        for j := i + 1; j < len(nums); j++ {\\n            if nums[i]+nums[j] == target {\\n                ans++\\n            }\\n            if nums[j]+nums[i] == target {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872129,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- count each string appearances and store in the dictionary\\n- split target into two strings and see if we can find both in the dictionary\\n- if both strings are in the dictionary, number of pairs are simply all possible combinations with i = j\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumOfPairs(string[] nums, string target) {\\n        Dictionary<string, int> dict = nums.GroupBy(s => s).ToDictionary(group => group.Key, group => group.Count());\\n        int pairs = 0;\\n\\n        for(int i = 1; i < target.Length; i++)\\n        {\\n            string s1 = target.Substring(0, i);\\n            string s2 = target.Substring(i);\\n\\n            if (dict.ContainsKey(s1) && dict.ContainsKey(s2))\\n            {\\n                // cannot use string with same index\\n                pairs += dict[s1] * (s1 == s2? (dict[s2] - 1) : dict[s2]);\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumOfPairs(string[] nums, string target) {\\n        Dictionary<string, int> dict = nums.GroupBy(s => s).ToDictionary(group => group.Key, group => group.Count());\\n        int pairs = 0;\\n\\n        for(int i = 1; i < target.Length; i++)\\n        {\\n            string s1 = target.Substring(0, i);\\n            string s2 = target.Substring(i);\\n\\n            if (dict.ContainsKey(s1) && dict.ContainsKey(s2))\\n            {\\n                // cannot use string with same index\\n                pairs += dict[s1] * (s1 == s2? (dict[s2] - 1) : dict[s2]);\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865639,
                "title": "easy-understandable",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int sz = nums.size();\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            for(int j  = 0; j < sz; j++){\\n                if(i==j)continue;\\n                else if(nums[i]+nums[j]==target){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int sz = nums.size();\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            for(int j  = 0; j < sz; j++){\\n                if(i==j)continue;\\n                else if(nums[i]+nums[j]==target){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861455,
                "title": "simplest-and-shortest",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>&n , string t){\\n        int c=0;\\n        for(int i=0; i<n.size(); i++){\\n            string chk=n[i];\\n            for(int j=0; j<n.size(); j++){\\n                if(chk+n[j]==t && j!=i){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>&n , string t){\\n        int c=0;\\n        for(int i=0; i<n.size(); i++){\\n            string chk=n[i];\\n            for(int j=0; j<n.size(); j++){\\n                if(chk+n[j]==t && j!=i){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861315,
                "title": "c-very-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& n, string t) {\\n        int count = 0;\\n        for(int i=0;i<n.size();i++){\\n            for(int j=i+1;j<n.size();j++){\\n                if((n[i]+n[j]) == t)    count += 1;\\n                if((n[j]+n[i]) == t)    count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& n, string t) {\\n        int count = 0;\\n        for(int i=0;i<n.size();i++){\\n            for(int j=i+1;j<n.size();j++){\\n                if((n[i]+n[j]) == t)    count += 1;\\n                if((n[j]+n[i]) == t)    count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858963,
                "title": "python-easiest-way-2-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        res = 0\\n        l = len(nums)\\n        for i in range(l):\\n            for j in range(l):\\n                if nums[i]+nums[j] == target and i != j:\\n                    res += 1\\n        return res\\n```\\n\\n#### It is true that this code has n**2 time complexity, but on the other hand, it is the simplest way.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        res = 0\\n        l = len(nums)\\n        for i in range(l):\\n            for j in range(l):\\n                if nums[i]+nums[j] == target and i != j:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849655,
                "title": "python3-simple-hashing",
                "content": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        def startWith(a,b):\\n            ptr1,ptr2 = 0,0\\n            while ptr1 < len(a) and ptr2 < len(b) and a[ptr1] == b[ptr2]:\\n                ptr1 += 1\\n                ptr2 += 1\\n            return ptr1 == len(a)\\n        def endWith(a,b):\\n            ptr1,ptr2 = len(a) - 1,len(b) - 1\\n            while ptr1 >= 0 and ptr2 >= 0 and a[ptr1] == b[ptr2]:\\n                ptr1 -= 1\\n                ptr2 -= 1\\n            return ptr1 == -1\\n        hmap = defaultdict(int)\\n        size = len(nums)\\n        ans = 0\\n        for i in range(size):\\n            op1 = startWith(nums[i],target)\\n            if op1 == True:\\n                remain1 = target[len(nums[i]):]\\n                if remain1 in hmap:\\n                    ans += hmap[remain1]\\n            op2 = endWith(nums[i],target)\\n            if op2 == True:\\n                remain2 = target[:len(target)-len(nums[i])]\\n                if remain2 in hmap:\\n                    ans += hmap[remain2]\\n            hmap[nums[i]] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        def startWith(a,b):\\n            ptr1,ptr2 = 0,0\\n            while ptr1 < len(a) and ptr2 < len(b) and a[ptr1] == b[ptr2]:\\n                ptr1 += 1\\n                ptr2 += 1\\n            return ptr1 == len(a)\\n        def endWith(a,b):\\n            ptr1,ptr2 = len(a) - 1,len(b) - 1\\n            while ptr1 >= 0 and ptr2 >= 0 and a[ptr1] == b[ptr2]:\\n                ptr1 -= 1\\n                ptr2 -= 1\\n            return ptr1 == -1\\n        hmap = defaultdict(int)\\n        size = len(nums)\\n        ans = 0\\n        for i in range(size):\\n            op1 = startWith(nums[i],target)\\n            if op1 == True:\\n                remain1 = target[len(nums[i]):]\\n                if remain1 in hmap:\\n                    ans += hmap[remain1]\\n            op2 = endWith(nums[i],target)\\n            if op2 == True:\\n                remain2 = target[:len(target)-len(nums[i])]\\n                if remain2 in hmap:\\n                    ans += hmap[remain2]\\n            hmap[nums[i]] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846574,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\nasdf\\n# Code\\n```\\nclass Solution {\\n    private: \\n    bool f(string str,string target)\\n    {\\n        if(target.find(str)==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int>ourmap;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ourmap[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           string prefix=nums[i];\\n           string suffix=\"\";\\n           if(f(prefix,target))\\n           suffix=target.substr(prefix.size());\\n           else\\n           continue;\\n           if(ourmap.find(suffix)!=ourmap.end())\\n           {\\n           if(prefix==suffix)\\n           {\\n               ans+=ourmap[suffix]-1;\\n           }\\n           else{\\n               ans+=ourmap[suffix];\\n           }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    private: \\n    bool f(string str,string target)\\n    {\\n        if(target.find(str)==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int>ourmap;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ourmap[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           string prefix=nums[i];\\n           string suffix=\"\";\\n           if(f(prefix,target))\\n           suffix=target.substr(prefix.size());\\n           else\\n           continue;\\n           if(ourmap.find(suffix)!=ourmap.end())\\n           {\\n           if(prefix==suffix)\\n           {\\n               ans+=ourmap[suffix]-1;\\n           }\\n           else{\\n               ans+=ourmap[suffix];\\n           }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841622,
                "title": "share-my-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Arrays.sort(nums);\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        int cnt = 0;\\n        for (String num : nums) {\\n            if (target.startsWith(num)) {\\n                String toFind = target.substring(target.indexOf(num) + num.length());\\n                cnt += map.getOrDefault(toFind, 0);\\n            }\\n            if (target.endsWith(num)) {\\n                String toFind = target.substring(0, target.lastIndexOf(num));\\n                cnt += map.getOrDefault(toFind, 0);\\n            }\\n\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        Arrays.sort(nums);\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        int cnt = 0;\\n        for (String num : nums) {\\n            if (target.startsWith(num)) {\\n                String toFind = target.substring(target.indexOf(num) + num.length());\\n                cnt += map.getOrDefault(toFind, 0);\\n            }\\n            if (target.endsWith(num)) {\\n                String toFind = target.substring(0, target.lastIndexOf(num));\\n                cnt += map.getOrDefault(toFind, 0);\\n            }\\n\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823968,
                "title": "simple-java-solution",
                "content": "# Simple JAVA Solution!!!\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) \\n    {\\n        int ans =0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j && target.equals(nums[i]+nums[j])) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) \\n    {\\n        int ans =0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(i!=j && target.equals(nums[i]+nums[j])) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823005,
                "title": "java-easy-solution-tc-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n          int numberofpair = 0;\\n    for(int i = 0; i<nums.length; i++){\\n      for(int j = 0; j<nums.length; j++){\\n        if(i!=j){\\n          if(target.equals(nums[i]+nums[j])){\\n            numberofpair++;\\n          }\\n        }\\n      }\\n    }\\n    return numberofpair;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n          int numberofpair = 0;\\n    for(int i = 0; i<nums.length; i++){\\n      for(int j = 0; j<nums.length; j++){\\n        if(i!=j){\\n          if(target.equals(nums[i]+nums[j])){\\n            numberofpair++;\\n          }\\n        }\\n      }\\n    }\\n    return numberofpair;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787549,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j:\\n                    continue\\n                if nums[i] + nums[j] == target:\\n                    res += 1\\n        return res\\n```\\n![catty.png](https://assets.leetcode.com/users/images/02f8b49b-cb34-4efb-bb8c-b55cd3925200_1689767842.3089883.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j:\\n                    continue\\n                if nums[i] + nums[j] == target:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779553,
                "title": "2sum-approach-reduce-no-of-comparisons",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think of this problem and relate it to 2Sum problem. Here we are given strings instead of integers. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force approach would be to check every pair (i, j) if i!=j and nums[i] + nums[j] == target. This approach would require O(n^2) time and every pair will be checked.\\n\\nA better approach would be to reduce the no. of comparisons we do by checking if the sum of lengths of the items that we are combining is equal to length of the target.\\n\\nSo, first we take a dictionary(hashmap), where the key would be the length of a string and value would be a list (I used a set idk why), \\nwhich would contain indexes where this length string occurs.\\n\\nAfter we have this stored, then we iterate over the array of strings and check if the complement of the current string\\'s length is in hashmap. If we find it, then we start another loop to iterate over the value at that key in hashmap. Now we check every element using a helper function, if it matches the target, we increase the counter by 1.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case = O(n^2) (rare case of when length of each element of nums = len(target)/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n\\n        d = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            if len(target) > len(nums[i]):\\n                if len(nums[i]) in d:\\n                    d[len(nums[i])].add(i)\\n                else:\\n                    d[len(nums[i])] = set()\\n                    d[len(nums[i])].add(i)\\n        def check(i, j):\\n            return target == nums[i] + nums[j]\\n        for i in range(len(nums)):\\n            if len(target) - len(nums[i]) in d:\\n                for j in d[len(target) - len(nums[i])]:\\n                    if j!=i and check(i,j):\\n                        count+=1\\n        print(d)\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n\\n        d = {}\\n        count = 0\\n        for i in range(len(nums)):\\n            if len(target) > len(nums[i]):\\n                if len(nums[i]) in d:\\n                    d[len(nums[i])].add(i)\\n                else:\\n                    d[len(nums[i])] = set()\\n                    d[len(nums[i])].add(i)\\n        def check(i, j):\\n            return target == nums[i] + nums[j]\\n        for i in range(len(nums)):\\n            if len(target) - len(nums[i]) in d:\\n                for j in d[len(target) - len(nums[i])]:\\n                    if j!=i and check(i,j):\\n                        count+=1\\n        print(d)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770777,
                "title": "c-beats-99-8-o-n-fast-solution",
                "content": "# Intuition\\nAt the first pass we can check all the strings to detect which of them can be placed at the start or at the end of the target.\\nWe can count only amount of items in nums that can be placed at the beginning or at the end of `target` and their sizes. Also we need to count amount of numbers that concatination to themselves gives `target`, because we shouldn\\'t count in the result pairs with equals prefix and suffix indices.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n = max(nums.size(), target.size())`\\n- Space complexity: $$O(k)$$, where `k = target.size()`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        vector<int> prefixes(target.size()+1); // size to indices count\\n        vector<int> suffixes(target.size()+1); // start target index to indices count\\n        int numPrefixesAndSuffixesAtCenter = 0;\\n        int halfTargetSize = target.size() % 2 == 0 ? target.size() / 2 : -1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            const auto& s = nums[i];\\n            if (s.size() > target.size())\\n                continue;\\n            bool isPrefix = target.compare(0, s.size(), s) == 0;\\n            bool isSuffix = target.compare(target.size() - s.size(), s.size(), s) == 0;\\n            prefixes[s.size()] += isPrefix;\\n            suffixes[target.size() - s.size()] += isSuffix;\\n            numPrefixesAndSuffixesAtCenter += s.size() == halfTargetSize && isPrefix && isSuffix;\\n        }\\n\\n        return inner_product(prefixes.begin(), prefixes.end(), suffixes.begin(), -numPrefixesAndSuffixesAtCenter);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        vector<int> prefixes(target.size()+1); // size to indices count\\n        vector<int> suffixes(target.size()+1); // start target index to indices count\\n        int numPrefixesAndSuffixesAtCenter = 0;\\n        int halfTargetSize = target.size() % 2 == 0 ? target.size() / 2 : -1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            const auto& s = nums[i];\\n            if (s.size() > target.size())\\n                continue;\\n            bool isPrefix = target.compare(0, s.size(), s) == 0;\\n            bool isSuffix = target.compare(target.size() - s.size(), s.size(), s) == 0;\\n            prefixes[s.size()] += isPrefix;\\n            suffixes[target.size() - s.size()] += isSuffix;\\n            numPrefixesAndSuffixesAtCenter += s.size() == halfTargetSize && isPrefix && isSuffix;\\n        }\\n\\n        return inner_product(prefixes.begin(), prefixes.end(), suffixes.begin(), -numPrefixesAndSuffixesAtCenter);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760953,
                "title": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        String str = new String();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                str = nums[i]+nums[j];\\n                if(str.equals(target)&&i!=j)\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        String str = new String();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                str = nums[i]+nums[j];\\n                if(str.equals(target)&&i!=j)\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760565,
                "title": "best-solution-ye",
                "content": "# Intuition\\n![271-2719747_like-thumb-up-vote-thumb-up-icon-free.png](https://assets.leetcode.com/users/images/4bf391a1-c73a-4010-a148-dcb5f055d2b7_1689270437.208573.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> mp;\\n        for(string num:nums){\\n            if(target.size()>num.size()){\\n                mp[num]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            string s=it.first;\\n            int freq=it.second;\\n            if(target.find(s)==0){\\n                if(s+s==target){\\n                    ans=ans+freq*(freq-1);\\n\\n\\n                }\\n                else{\\n                    ans=ans+freq*mp[target.substr(s.size())];\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "MySQL"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string,int> mp;\\n        for(string num:nums){\\n            if(target.size()>num.size()){\\n                mp[num]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            string s=it.first;\\n            int freq=it.second;\\n            if(target.find(s)==0){\\n                if(s+s==target){\\n                    ans=ans+freq*(freq-1);\\n\\n\\n                }\\n                else{\\n                    ans=ans+freq*mp[target.substr(s.size())];\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755769,
                "title": "easy-c-solution-string",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count =0;\\n        for(int i =0;i<nums.size();i++){\\n            string temp1 = nums[i];\\n            for(int j =0;j<nums.size();j++){\\n                if(i==j) continue;\\n                string temp2 = nums[j];\\n                if(temp1+temp2 == target) count++; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int count =0;\\n        for(int i =0;i<nums.size();i++){\\n            string temp1 = nums[i];\\n            for(int j =0;j<nums.size();j++){\\n                if(i==j) continue;\\n                string temp2 = nums[j];\\n                if(temp1+temp2 == target) count++; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747616,
                "title": "using-a-map-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        duplicate = {}\\n        for input in nums:\\n            if input not in duplicate:\\n                duplicate[input] = 0\\n            duplicate[input] += 1\\n        \\n        for i in range(len(nums)):\\n            if target.startswith(nums[i]):\\n                suffix = target[len(nums[i]):]\\n                if suffix in duplicate.keys():\\n                    count+=(duplicate[target[len(nums[i]):]])\\n                    if suffix == nums[i]:\\n                        count-=1\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        duplicate = {}\\n        for input in nums:\\n            if input not in duplicate:\\n                duplicate[input] = 0\\n            duplicate[input] += 1\\n        \\n        for i in range(len(nums)):\\n            if target.startswith(nums[i]):\\n                suffix = target[len(nums[i]):]\\n                if suffix in duplicate.keys():\\n                    count+=(duplicate[target[len(nums[i]):]])\\n                    if suffix == nums[i]:\\n                        count-=1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745337,
                "title": "loop-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n \\n    public int numOfPairs(String[] nums, String target) {\\n        // int n=nums.length;\\n        // int count=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n               \\n        //       if(i!=j){\\n        //         String s=nums[i];\\n        //          s+=nums[j];\\n        //          if(s.equals(target)){\\n        //              count++;\\n        //          }\\n        //         }   \\n        //  }\\n        // }\\n        //  return count;\\n         HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i<nums.length; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        int ans = 0, n = target.length();\\n        String a = \"\", b= \"\";\\n        for (int i = 1; i<n; i++){\\n            a = target.substring(0,i);\\n            b = target.substring(i,n);\\n            if (map.containsKey(a) && map.containsKey(b)){\\n                if (a.equals(b)) ans += (map.get(a) * (map.get(a)-1));\\n                else ans+= (map.get(a) * map.get(b));\\n            }\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n \\n    public int numOfPairs(String[] nums, String target) {\\n        // int n=nums.length;\\n        // int count=0;\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++){\\n               \\n        //       if(i!=j){\\n        //         String s=nums[i];\\n        //          s+=nums[j];\\n        //          if(s.equals(target)){\\n        //              count++;\\n        //          }\\n        //         }   \\n        //  }\\n        // }\\n        //  return count;\\n         HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i<nums.length; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\\n        }\\n        \\n        int ans = 0, n = target.length();\\n        String a = \"\", b= \"\";\\n        for (int i = 1; i<n; i++){\\n            a = target.substring(0,i);\\n            b = target.substring(i,n);\\n            if (map.containsKey(a) && map.containsKey(b)){\\n                if (a.equals(b)) ans += (map.get(a) * (map.get(a)-1));\\n                else ans+= (map.get(a) * map.get(b));\\n            }\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732926,
                "title": "very-simple-implementation-brute-force-beginner-s-friendly",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size(), ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            { //try concatenation of all pairs \\n              if(nums[i] + nums[j] == target) ans++;   \\n              if(nums[j] + nums[i] == target) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        int n = nums.size(), ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            { //try concatenation of all pairs \\n              if(nums[i] + nums[j] == target) ans++;   \\n              if(nums[j] + nums[i] == target) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732688,
                "title": "c-trie-o-n-m-k",
                "content": "# Intuition\\nUse a trie to store input words, then branch out each time we find the end of a word to look for the remaining substring\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n + m*k) \\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Node\\n    {\\n        int ends{ 0 };\\n        map<char, Node> children; // lookup in map is O(1) as it can hold at most 10 elements\\n    };\\n\\n    Node root{};\\n    string tg;\\n\\n    int Total(Node& curr, size_t pos, Node* first)\\n    {\\n        if (pos == tg.size())\\n        {\\n            if (!first || !curr.ends)\\n                return 0;\\n\\n            return first != &curr? first->ends * curr.ends : curr.ends * (curr.ends - 1);\\n        }        \\n\\n        int res{ 0 };\\n        if (!first && curr.ends)\\n            res += Total(root, pos, &curr);\\n\\n        auto it{ curr.children.find(tg[pos]) };\\n        if (it != curr.children.end())\\n            res += Total(it->second, pos + 1, first);\\n\\n        return res;\\n    }\\n    \\n    int numOfPairs(vector<string>& nums, string target) \\n    {\\n        for (string& word : nums)\\n        {\\n            size_t pos{ 0 };\\n            Node* curr{ &root };\\n\\n            while (pos < word.size())\\n                curr = &curr->children[word[pos++]];\\n\\n            ++curr->ends;\\n        }\\n\\n        tg = move(target);\\n        return Total(root, 0, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node\\n    {\\n        int ends{ 0 };\\n        map<char, Node> children; // lookup in map is O(1) as it can hold at most 10 elements\\n    };\\n\\n    Node root{};\\n    string tg;\\n\\n    int Total(Node& curr, size_t pos, Node* first)\\n    {\\n        if (pos == tg.size())\\n        {\\n            if (!first || !curr.ends)\\n                return 0;\\n\\n            return first != &curr? first->ends * curr.ends : curr.ends * (curr.ends - 1);\\n        }        \\n\\n        int res{ 0 };\\n        if (!first && curr.ends)\\n            res += Total(root, pos, &curr);\\n\\n        auto it{ curr.children.find(tg[pos]) };\\n        if (it != curr.children.end())\\n            res += Total(it->second, pos + 1, first);\\n\\n        return res;\\n    }\\n    \\n    int numOfPairs(vector<string>& nums, string target) \\n    {\\n        for (string& word : nums)\\n        {\\n            size_t pos{ 0 };\\n            Node* curr{ &root };\\n\\n            while (pos < word.size())\\n                curr = &curr->children[word[pos++]];\\n\\n            ++curr->ends;\\n        }\\n\\n        tg = move(target);\\n        return Total(root, 0, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730792,
                "title": "two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        int k=2;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n            String a=\"\";\\n             if(i!=j){\\n             a=nums[i].concat(nums[j]);\\n             if(a.equals(target)){\\n                count++;\\n              }\\n             }\\n          \\n             \\n          }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        int k=2;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n            String a=\"\";\\n             if(i!=j){\\n             a=nums[i].concat(nums[j]);\\n             if(a.equals(target)){\\n                count++;\\n              }\\n             }\\n          \\n             \\n          }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711699,
                "title": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if((nums[i]+nums[j]).equals(target) && i!=j){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if((nums[i]+nums[j]).equals(target) && i!=j){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706062,
                "title": "short-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i =0; i<nums.length; i++){\\n            for(int j =0; j<nums.length; j++){\\n                String word = nums[i]+nums[j];\\n                if(word.equals(target) && i !=j){\\n                    count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i =0; i<nums.length; i++){\\n            for(int j =0; j<nums.length; j++){\\n                String word = nums[i]+nums[j];\\n                if(word.equals(target) && i !=j){\\n                    count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699370,
                "title": "java-solution-simple-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            for(int j = 0; j < nums.length; j++)\\n                if(target.equals(nums[i]+nums[j]) && i != j)\\n                    count++;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            for(int j = 0; j < nums.length; j++)\\n                if(target.equals(nums[i]+nums[j]) && i != j)\\n                    count++;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684716,
                "title": "c-two-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string tg) {\\n        int ans = 0;\\n        unordered_map<string, int> mpBeg;\\n        unordered_map<string, int> mpEnd;\\n        for(string& s : nums) {\\n            if (tg.size() <= s.size()) {\\n                continue;\\n            }\\n            bool begGood = true;\\n            for(int i = 0; i < min(s.size(), tg.size()); i++) {\\n                if (s[i] != tg[i]) {\\n                    begGood = false;\\n                    break;\\n                }\\n            }\\n            bool endGood = true;\\n            for(int i = tg.size()-1, j = s.size()-1; min(i,j) >= 0; i--, j--) {\\n                if (s[j] != tg[i]) {\\n                    endGood = false;\\n                    break;\\n                }\\n            }\\n            ans += begGood? mpBeg[s] : 0;\\n            ans += endGood? mpEnd[s] : 0;\\n\\n            if (begGood) {\\n                mpEnd[tg.substr(s.size(), -1)]++;\\n            }\\n            if (endGood) {\\n                mpBeg[tg.substr(0, tg.size() - s.size())]++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string tg) {\\n        int ans = 0;\\n        unordered_map<string, int> mpBeg;\\n        unordered_map<string, int> mpEnd;\\n        for(string& s : nums) {\\n            if (tg.size() <= s.size()) {\\n                continue;\\n            }\\n            bool begGood = true;\\n            for(int i = 0; i < min(s.size(), tg.size()); i++) {\\n                if (s[i] != tg[i]) {\\n                    begGood = false;\\n                    break;\\n                }\\n            }\\n            bool endGood = true;\\n            for(int i = tg.size()-1, j = s.size()-1; min(i,j) >= 0; i--, j--) {\\n                if (s[j] != tg[i]) {\\n                    endGood = false;\\n                    break;\\n                }\\n            }\\n            ans += begGood? mpBeg[s] : 0;\\n            ans += endGood? mpEnd[s] : 0;\\n\\n            if (begGood) {\\n                mpEnd[tg.substr(s.size(), -1)]++;\\n            }\\n            if (endGood) {\\n                mpBeg[tg.substr(0, tg.size() - s.size())]++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680005,
                "title": "ruby-solution",
                "content": "\\n```\\n# @param {String[]} nums\\n# @param {String} target\\n# @return {Integer}\\ndef num_of_pairs(nums, target)\\n  cache = Hash.new(0)\\n  nums.reduce(0) do |memo, num|\\n    if target.start_with?(num)\\n      complement = target[num.size..]\\n      memo += cache[complement]\\n    end\\n    if target.end_with?(num)\\n      complement = target[...-num.size]\\n      memo += cache[complement]\\n    end\\n    cache[num] += 1\\n    memo\\n  end\\nend\\n\\nrequire \"minitest/autorun\"\\n\\nclass NumberOfPairsTest < Minitest::Test\\n  def test_simple\\n    assert_equal(6, num_of_pairs([\"1\",\"1\",\"1\"], \"11\"))\\n    assert_equal(2, num_of_pairs([\"123\",\"4\",\"12\",\"34\"], \"1234\"))\\n    assert_equal(4, num_of_pairs([\"777\",\"7\",\"77\",\"77\"], \"7777\"))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String[]} nums\\n# @param {String} target\\n# @return {Integer}\\ndef num_of_pairs(nums, target)\\n  cache = Hash.new(0)\\n  nums.reduce(0) do |memo, num|\\n    if target.start_with?(num)\\n      complement = target[num.size..]\\n      memo += cache[complement]\\n    end\\n    if target.end_with?(num)\\n      complement = target[...-num.size]\\n      memo += cache[complement]\\n    end\\n    cache[num] += 1\\n    memo\\n  end\\nend\\n\\nrequire \"minitest/autorun\"\\n\\nclass NumberOfPairsTest < Minitest::Test\\n  def test_simple\\n    assert_equal(6, num_of_pairs([\"1\",\"1\",\"1\"], \"11\"))\\n    assert_equal(2, num_of_pairs([\"123\",\"4\",\"12\",\"34\"], \"1234\"))\\n    assert_equal(4, num_of_pairs([\"777\",\"7\",\"77\",\"77\"], \"7777\"))\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662402,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int>freq;\\n\\n        for(auto num:nums){\\n            if(num.size() < target.size()){\\n                freq[num]++;\\n            }\\n        }\\n\\n        int res=0;\\n\\n        for(auto [s,frq]:freq){\\n            if(target.find(s)==0){\\n                if(s+s == target){\\n                    res += frq*(frq-1);\\n                }else{\\n                    res += frq*freq[target.substr(s.size())];\\n                }\\n            }\\n        }\\n        return res;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string target) {\\n        unordered_map<string, int>freq;\\n\\n        for(auto num:nums){\\n            if(num.size() < target.size()){\\n                freq[num]++;\\n            }\\n        }\\n\\n        int res=0;\\n\\n        for(auto [s,frq]:freq){\\n            if(target.find(s)==0){\\n                if(s+s == target){\\n                    res += frq*(frq-1);\\n                }else{\\n                    res += frq*freq[target.substr(s.size())];\\n                }\\n            }\\n        }\\n        return res;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629261,
                "title": "solution-explained-in-detail-o-n-time-space-best-approach-ever",
                "content": "# Solution :\\n\\t\\n\\u2712\\uFE0F given an array of strings of number, we have to concatenate string and make it equal to Target and count the number of these pairs.\\n\\n\\u2712\\uFE0F we will maintain one Hash map to find second part of the Target in O (n) time.\\n\\n\\u2712\\uFE0F we will loop in array and find prefix of Target of current element size in map and add frequency of suffix of the Target into Result. ( suggestion : if current element size > Target size then skip that element, because it will not subarray of target.)\\n\\n\\u2712\\uFE0F Reverse the given array and clear the Hash table. Now do the same as prefix for suffix.\\n\\n\\u2712\\uFE0F Simply return Result variable.\\n\\t\\n# Complexity :\\nTime complexity : O (2 * n)\\nSpace complexity : O (n) = O (n)\\n\\n---\\n\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\nFollow [Jemish khunt](https://www.linkedin.com/in/jemish-khunt/) on linkedin for more and Like the post if you find useful and share it with your friends.\\n\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string t) {\\n     unordered_map<string,int> mp;\\n     int cnt = 0, n = nums.size();\\n\\n     for(auto i : nums){\\n         if(i.size() > t.size()) continue;\\n         if(t.substr(0,i.size()) == i) cnt += mp[t.substr(i.size())];\\n         mp[i]++;\\n     }\\n     mp.clear();\\n     reverse(nums.begin(), nums.end());\\n     for(auto i : nums){\\n         if(i.size() > t.size()) continue;\\n         if(t.substr(0,i.size()) == i) cnt += mp[t.substr(i.size())];\\n         mp[i]++;\\n     }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& nums, string t) {\\n     unordered_map<string,int> mp;\\n     int cnt = 0, n = nums.size();\\n\\n     for(auto i : nums){\\n         if(i.size() > t.size()) continue;\\n         if(t.substr(0,i.size()) == i) cnt += mp[t.substr(i.size())];\\n         mp[i]++;\\n     }\\n     mp.clear();\\n     reverse(nums.begin(), nums.end());\\n     for(auto i : nums){\\n         if(i.size() > t.size()) continue;\\n         if(t.substr(0,i.size()) == i) cnt += mp[t.substr(i.size())];\\n         mp[i]++;\\n     }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600098,
                "title": "javascript-solution",
                "content": "- Time complexity:\\nO(n x nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numOfPairs(nums: string[], target: string): number {\\n    let result = 0;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const current = nums[i];\\n\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if (current + nums[j] === target) {\\n                result++;\\n            }\\n\\n            if (nums[j] + current === target) {\\n                result++;\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numOfPairs(nums: string[], target: string): number {\\n    let result = 0;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const current = nums[i];\\n\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if (current + nums[j] === target) {\\n                result++;\\n            }\\n\\n            if (nums[j] + current === target) {\\n                result++;\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576925,
                "title": "c-clean-code-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& n, string t) {\\n        map<string,int> p;\\n        for(auto i : n)\\n        p[i]++;\\n         int c=0;\\n        for(auto i : n)\\n         {\\n            string s=t;\\n            auto j=t.find(i);\\n            if(j!=std::string::npos)\\n            {\\n              p[i]--;  \\n             s.erase(j,i.size());\\n            if(i+s==t)\\n            c+=p[s];\\n            p[i]++;\\n            }\\n         }\\n         return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfPairs(vector<string>& n, string t) {\\n        map<string,int> p;\\n        for(auto i : n)\\n        p[i]++;\\n         int c=0;\\n        for(auto i : n)\\n         {\\n            string s=t;\\n            auto j=t.find(i);\\n            if(j!=std::string::npos)\\n            {\\n              p[i]--;  \\n             s.erase(j,i.size());\\n            if(i+s==t)\\n            c+=p[s];\\n            p[i]++;\\n            }\\n         }\\n         return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575721,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        i = j = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i != j and nums[i] + nums[j] == target:\\n                    count += 1\\n        return count            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        count = 0\\n        i = j = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i != j and nums[i] + nums[j] == target:\\n                    count += 1\\n        return count            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543772,
                "title": "direct-approach-beat-100-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i =0;i<nums.length;i++){\\n            for(int j  =0;j<nums.length;j++){\\n                if(i!=j){\\n                    String temp = nums[i].concat(nums[j]);\\n                    if(temp.equals(target)) \\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfPairs(String[] nums, String target) {\\n        int count = 0;\\n        for(int i =0;i<nums.length;i++){\\n            for(int j  =0;j<nums.length;j++){\\n                if(i!=j){\\n                    String temp = nums[i].concat(nums[j]);\\n                    if(temp.equals(target)) \\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541598,
                "title": "most-simple-solution-python-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]+nums[j]==target:\\n                    c+=1\\n                if nums[j]+nums[i]==target:\\n                    c+=1\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]+nums[j]==target:\\n                    c+=1\\n                if nums[j]+nums[i]==target:\\n                    c+=1\\n        return c\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1823016,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            },
            {
                "id": 1654466,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            },
            {
                "id": 1801285,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            },
            {
                "id": 2025405,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            },
            {
                "id": 2015987,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            },
            {
                "id": 1998453,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is pretty much similar to Two Sum problem. \\nThis should be in the easy category."
                    },
                    {
                        "username": "avinash_00",
                        "content": "how to solve this question in O(n) time complexity and without using map"
                    },
                    {
                        "username": "farago1",
                        "content": "[@Avinash Atkale](/avinash_00) you can use prefix and suffix counts using arrays only."
                    },
                    {
                        "username": "Aayush65",
                        "content": "Looking at the constraints......Why this isn\\'t a easy question?"
                    },
                    {
                        "username": "MertErdem",
                        "content": "This should definitley be an easy problem as bruteforce works "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Constraints should make this an easy."
                    },
                    {
                        "username": "rudrasihare",
                        "content": "class Solution:\\n    def numOfPairs(self, a: List[str], target: str) -> int:\\n        count=0\\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                if i!=j and a[i]+a[j]== target:\\n                    count+=1\\n        return count\\n\\nsmall solution"
                    }
                ]
            }
        ]
    }
]