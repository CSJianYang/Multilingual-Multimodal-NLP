[
    {
        "title": "Perfect Squares",
        "question_content": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n&nbsp;\nExample 1:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\nExample 2:\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 71488,
                "title": "summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics",
                "content": "Came up with the 2 solutions of breadth-first search and dynamic programming. Also \"copied\" StefanPochmann's static dynamic programming solution (https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms) and davidtan1890's mathematical solution (https://leetcode.com/discuss/57066/4ms-c-code-solve-it-mathematically) here with minor style changes and some comments. Thank Stefan and David for posting their nice solutions!\\n\\n**1.Dynamic Programming:** 440ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Note that cntPerfectSquares[0] is 0.\\n            vector<int> cntPerfectSquares(n + 1, INT_MAX);\\n            cntPerfectSquares[0] = 0;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                // For each i, it must be the sum of some number (i - j*j) and \\n                // a perfect square number (j*j).\\n                for (int j = 1; j*j <= i; j++)\\n                {\\n                    cntPerfectSquares[i] = \\n                        min(cntPerfectSquares[i], cntPerfectSquares[i - j*j] + 1);\\n                }\\n            }\\n            \\n            return cntPerfectSquares.back();\\n        }\\n    };\\n\\n**2.Static Dynamic Programming:** 12ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Since cntPerfectSquares is a static vector, if \\n            // cntPerfectSquares.size() > n, we have already calculated the result \\n            // during previous function calls and we can just return the result now.\\n            static vector<int> cntPerfectSquares({0});\\n            \\n            // While cntPerfectSquares.size() <= n, we need to incrementally \\n            // calculate the next result until we get the result for n.\\n            while (cntPerfectSquares.size() <= n)\\n            {\\n                int m = cntPerfectSquares.size();\\n                int cntSquares = INT_MAX;\\n                for (int i = 1; i*i <= m; i++)\\n                {\\n                    cntSquares = min(cntSquares, cntPerfectSquares[m - i*i] + 1);\\n                }\\n                \\n                cntPerfectSquares.push_back(cntSquares);\\n            }\\n            \\n            return cntPerfectSquares[n];\\n        }\\n    };\\n\\n**3.Mathematical Solution:** 4ms\\n\\n    class Solution \\n    {  \\n    private:  \\n        int is_square(int n)\\n        {  \\n            int sqrt_n = (int)(sqrt(n));  \\n            return (sqrt_n*sqrt_n == n);  \\n        }\\n        \\n    public:\\n        // Based on Lagrange's Four Square theorem, there \\n        // are only 4 possible results: 1, 2, 3, 4.\\n        int numSquares(int n) \\n        {  \\n            // If n is a perfect square, return 1.\\n            if(is_square(n)) \\n            {\\n                return 1;  \\n            }\\n            \\n            // The result is 4 if and only if n can be written in the \\n            // form of 4^k*(8*m + 7). Please refer to \\n            // Legendre's three-square theorem.\\n            while ((n & 3) == 0) // n%4 == 0  \\n            {\\n                n >>= 2;  \\n            }\\n            if ((n & 7) == 7) // n%8 == 7\\n            {\\n                return 4;\\n            }\\n            \\n            // Check whether 2 is the result.\\n            int sqrt_n = (int)(sqrt(n)); \\n            for(int i = 1; i <= sqrt_n; i++)\\n            {  \\n                if (is_square(n - i*i)) \\n                {\\n                    return 2;  \\n                }\\n            }  \\n            \\n            return 3;  \\n        }  \\n    }; \\n\\n**4.Breadth-First Search:** 80ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // perfectSquares contain all perfect square numbers which \\n            // are smaller than or equal to n.\\n            vector<int> perfectSquares;\\n            // cntPerfectSquares[i - 1] = the least number of perfect \\n            // square numbers which sum to i.\\n            vector<int> cntPerfectSquares(n);\\n            \\n            // Get all the perfect square numbers which are smaller than \\n            // or equal to n.\\n            for (int i = 1; i*i <= n; i++)\\n            {\\n                perfectSquares.push_back(i*i);\\n                cntPerfectSquares[i*i - 1] = 1;\\n            }\\n            \\n            // If n is a perfect square number, return 1 immediately.\\n            if (perfectSquares.back() == n)\\n            {\\n                return 1;\\n            }\\n            \\n            // Consider a graph which consists of number 0, 1,...,n as\\n            // its nodes. Node j is connected to node i via an edge if  \\n            // and only if either j = i + (a perfect square number) or \\n            // i = j + (a perfect square number). Starting from node 0, \\n            // do the breadth-first search. If we reach node n at step \\n            // m, then the least number of perfect square numbers which \\n            // sum to n is m. Here since we have already obtained the \\n            // perfect square numbers, we have actually finished the \\n            // search at step 1.\\n            queue<int> searchQ;\\n            for (auto& i : perfectSquares)\\n            {\\n                searchQ.push(i);\\n            }\\n            \\n            int currCntPerfectSquares = 1;\\n            while (!searchQ.empty())\\n            {\\n                currCntPerfectSquares++;\\n                \\n                int searchQSize = searchQ.size();\\n                for (int i = 0; i < searchQSize; i++)\\n                {\\n                    int tmp = searchQ.front();\\n                    // Check the neighbors of node tmp which are the sum \\n                    // of tmp and a perfect square number.\\n                    for (auto& j : perfectSquares)\\n                    {\\n                        if (tmp + j == n)\\n                        {\\n                            // We have reached node n.\\n                            return currCntPerfectSquares;\\n                        }\\n                        else if ((tmp + j < n) && (cntPerfectSquares[tmp + j - 1] == 0))\\n                        {\\n                            // If cntPerfectSquares[tmp + j - 1] > 0, this is not \\n                            // the first time that we visit this node and we should \\n                            // skip the node (tmp + j).\\n                            cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;\\n                            searchQ.push(tmp + j);\\n                        }\\n                        else if (tmp + j > n)\\n                        {\\n                            // We don't need to consider the nodes which are greater ]\\n                            // than n.\\n                            break;\\n                        }\\n                    }\\n                    \\n                    searchQ.pop();\\n                }\\n            }\\n            \\n            return 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71495,
                "title": "an-easy-understanding-dp-solution-in-java",
                "content": "dp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n    dp[0] = 0 \\n    dp[1] = dp[0]+1 = 1\\n    dp[2] = dp[1]+1 = 2\\n    dp[3] = dp[2]+1 = 3\\n    dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n          = Min{ dp[3]+1, dp[0]+1 } \\n          = 1\\t\\t\\t\\t\\n    dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n          = Min{ dp[4]+1, dp[1]+1 } \\n          = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n           = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n           = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\n\\n\\n\\nand the sample code is like below:\\n\\n    public int numSquares(int n) {\\n\\t\\tint[] dp = new int[n + 1];\\n\\t\\tArrays.fill(dp, Integer.MAX_VALUE);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 1; i <= n; ++i) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint j = 1;\\n\\t\\t\\twhile(i - j*j >= 0) {\\n\\t\\t\\t\\tmin = Math.min(min, dp[i - j*j] + 1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = min;\\n\\t\\t}\\t\\t\\n\\t\\treturn dp[n];\\n\\t}\\n\\nHope it can help to understand the DP solution.",
                "solutionTags": [],
                "code": "dp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n    dp[0] = 0 \\n    dp[1] = dp[0]+1 = 1\\n    dp[2] = dp[1]+1 = 2\\n    dp[3] = dp[2]+1 = 3\\n    dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n          = Min{ dp[3]+1, dp[0]+1 } \\n          = 1\\t\\t\\t\\t\\n    dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n          = Min{ dp[4]+1, dp[1]+1 } \\n          = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n           = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n           = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\n\\n\\n\\nand the sample code is like below:\\n\\n    public int numSquares(int n) {\\n\\t\\tint[] dp = new int[n + 1];\\n\\t\\tArrays.fill(dp, Integer.MAX_VALUE);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 1; i <= n; ++i) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint j = 1;\\n\\t\\t\\twhile(i - j*j >= 0) {\\n\\t\\t\\t\\tmin = Math.min(min, dp[i - j*j] + 1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = min;\\n\\t\\t}\\t\\t\\n\\t\\treturn dp[n];\\n\\t}\\n\\nHope it can help to understand the DP solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 71475,
                "title": "short-python-solution-using-bfs",
                "content": "    def numSquares(self, n):\\n        if n < 2:\\n            return n\\n        lst = []\\n        i = 1\\n        while i * i <= n:\\n            lst.append( i * i )\\n            i += 1\\n        cnt = 0\\n        toCheck = {n}\\n        while toCheck:\\n            cnt += 1\\n            temp = set()\\n            for x in toCheck:\\n                for y in lst:\\n                    if x == y:\\n                        return cnt\\n                    if x < y:\\n                        break\\n                    temp.add(x-y)\\n            toCheck = temp\\n    \\n        return cnt\\n\\nThe basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0:\\n\\n![0_1467720854827_XCoQwiN.png](/uploads/files/1467720855285-xcoqwin.png)",
                "solutionTags": [],
                "code": "    def numSquares(self, n):\\n        if n < 2:\\n            return n\\n        lst = []\\n        i = 1\\n        while i * i <= n:\\n            lst.append( i * i )\\n            i += 1\\n        cnt = 0\\n        toCheck = {n}\\n        while toCheck:\\n            cnt += 1\\n            temp = set()\\n            for x in toCheck:\\n                for y in lst:\\n                    if x == y:\\n                        return cnt\\n                    if x < y:\\n                        break\\n                    temp.add(x-y)\\n            toCheck = temp\\n    \\n        return cnt\\n\\nThe basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0:\\n\\n![0_1467720854827_XCoQwiN.png](/uploads/files/1467720855285-xcoqwin.png)",
                "codeTag": "Python3"
            },
            {
                "id": 1520447,
                "title": "c-dp-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/6f9ff4fa-088f-41db-b464-307c119d55ba_1634187491.871502.jpeg)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //vector for updating the dp array/values\\n        vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n) {\\n        int sq = count*count;\\n        for(int i = sq; i < n+1; i++) {\\n            dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n\\n```\\n\\nComplexity\\n\\nTime complexity: **O(n*sqrt(n))** outer loop is of sqrt(n) iterations and in the inner loop <n iterations roughly.\\n\\nSpace Complexity: **O(n)**.\\n\\n*like it? upvote if you can..!*\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //vector for updating the dp array/values\\n        vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n) {\\n        int sq = count*count;\\n        for(int i = sq; i < n+1; i++) {\\n            dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71532,
                "title": "o-sqrt-n-about-0-034-ms-and-0-018-ms",
                "content": "For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do.\\n\\n(**Update:** After qgambit2's challenge, I [optimized my my original approach](https://leetcode.com/discuss/57185/o-sqrt-n-about-0-03-ms?show=57682#c57682) and now that's my fastest, with about 180 ms.)\\n\\nFirst I use the fact that [four squares always suffice](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) and the fact that [four squares are only needed for numbers of the form 4<sup>a</sup>(8b+7)](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares.\\n\\nFor that, I use a kind of two-pointers-approach. Instead of going through squares a<sup>2</sup> and checking whether n-a<sup>2</sup> is a square (which would involve computing lots of square roots), imagine you start with a=0<sup>2</sup> and b=floor(sqrt(n))<sup>2</sup> and as long as a<=b, either make `a` the next larger square or make `b` the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it's exactly right).\\n\\nBut in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my `a` and `b` aren't squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn't even have multiplications. Just simple addition/subtraction and comparisons.\\n\\nThe solution:\\n\\n    int numSquaresReal(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        int a = -1, b = sqrt(n);\\n        n -= b * b;\\n        b += b + 1;\\n        while (a <= b) {\\n            if (n < 0)\\n                n += b -= 2;\\n            else if (n > 0)\\n                n -= a += 2;\\n            else\\n                return a < 0 ? 1 : 2;\\n        }\\n        return 3;\\n    }\\n\\n    \\nThe wrapper for better time measurement:\\n\\n    int numSquares(int n) {\\n        int sum = 0;\\n        for (int i=0; i<10000; i++)\\n            sum += numSquaresReal(n);\\n        return sum / 10000;\\n    }",
                "solutionTags": [],
                "code": "For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do.\\n\\n(**Update:** After qgambit2's challenge, I [optimized my my original approach](https://leetcode.com/discuss/57185/o-sqrt-n-about-0-03-ms?show=57682#c57682) and now that's my fastest, with about 180 ms.)\\n\\nFirst I use the fact that [four squares always suffice](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) and the fact that [four squares are only needed for numbers of the form 4<sup>a</sup>(8b+7)](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares.\\n\\nFor that, I use a kind of two-pointers-approach. Instead of going through squares a<sup>2</sup> and checking whether n-a<sup>2</sup> is a square (which would involve computing lots of square roots), imagine you start with a=0<sup>2</sup> and b=floor(sqrt(n))<sup>2</sup> and as long as a<=b, either make `a` the next larger square or make `b` the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it's exactly right).\\n\\nBut in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my `a` and `b` aren't squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn't even have multiplications. Just simple addition/subtraction and comparisons.\\n\\nThe solution:\\n\\n    int numSquaresReal(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        int a = -1, b = sqrt(n);\\n        n -= b * b;\\n        b += b + 1;\\n        while (a <= b) {\\n            if (n < 0)\\n                n += b -= 2;\\n            else if (n > 0)\\n                n -= a += 2;\\n            else\\n                return a < 0 ? 1 : 2;\\n        }\\n        return 3;\\n    }\\n\\n    \\nThe wrapper for better time measurement:\\n\\n    int numSquares(int n) {\\n        int sum = 0;\\n        for (int i=0; i<10000; i++)\\n            sum += numSquaresReal(n);\\n        return sum / 10000;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71512,
                "title": "static-dp-c-12-ms-python-172-ms-ruby-384-ms",
                "content": "There are so **many** \"large\" test cases that it's worthwhile to keep data between test cases rather than recomputing from scratch all the time. At least in the slower languages. My `dp` tells the numbers of squares needed for the first integers, and when asked about a new `n`, I extend `dp` just as much as necessary.\\n\\n---\\n\\n**C++** ... 28 ms\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        while (dp.size() <= n) {\\n            int m = dp.size(), squares = INT_MAX;\\n            for (int i=1; i*i<=m; ++i)\\n                squares = min(squares, dp[m-i*i] + 1);\\n            dp.push_back(squares);\\n        }\\n        return dp[n];\\n    }\\n\\n**C++** ... 12 ms\\n\\nSwitching the loops makes it less nice but faster:\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        int m = dp.size();\\n        dp.resize(max(m, n+1), INT_MAX);\\n        for (int i=1, i2; (i2 = i*i)<=n; ++i)\\n            for (int j=max(m, i2); j<=n; ++j)\\n                if (dp[j] > dp[j-i2] + 1)\\n                    dp[j] = dp[j-i2] + 1;\\n        return dp[n];\\n    }\\n\\n---\\n\\n**Python** ... 172 ms\\n\\n    class Solution(object):\\n        _dp = [0]\\n        def numSquares(self, n):\\n            dp = self._dp\\n            while len(dp) <= n:\\n                dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\\n            return dp[n]\\n\\n---\\n\\n**Ruby** ... 384 ms\\n\\n    $dp = [0]\\n    def num_squares(n)\\n      $dp << (1..$dp.size**0.5).map { |i| $dp[-i*i] }.min + 1 until $dp[n]\\n      $dp[n]\\n    end\\n\\nThere's probably a cleaner way than using a global variable, but I'm new to Ruby and don't know one.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "class Solution(object):\\n        _dp = [0]\\n        def numSquares(self, n):\\n            dp = self._dp\\n            while len(dp) <= n:\\n                dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\\n            return dp[n]\\n\\n---\\n\\n**Ruby** ... 384 ms\\n\\n    $dp = [0]\\n    def num_squares(n)\\n      $dp << (1..$dp.size**0.5).map { |i| $dp[-i*i] }",
                "codeTag": "Java"
            },
            {
                "id": 707526,
                "title": "python-fastest-o-sqrt-n-solution-with-math-explanied",
                "content": "First of all, there is a statement that any number can be represented as sum of 4 squares:\\nhttps://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem. So, answer always will be 4? No, when we talk about `4` squares, it means that some of them can be equal to zero. So, we have `4` options: either `1`, `2`, `3` or `4` squares and we need to choose one of these numbers.\\n\\n1. How to check if number is full square? Just compare square of integer part of root and this number. Complexity of this part is `O(1)`.\\n2. How to check if number is sum of `2` squares: `n = i*i + j*j`? iterate ovell all `i < sqrt(n)` and check that `n - i*i` is full square. Complexity of this part is `O(sqrt(n))`.\\n3. How to check that number is sum of `4` squares? In the same link for wikipedia: \\n` by proving that a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for integers k and m`. So, what we need to do is to check this condition and return true if it fulfilled. Complexity is `O(log n)`\\n4. Do we need to check anything else? No, because we have only one options left: `3` squares.\\n\\n**Complexity**: time complexity is `O(sqrt(n))` and space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def numSquares(self, n):\\n        if int(sqrt(n))**2 == n: return 1\\n        for j in range(int(sqrt(n)) + 1):\\n            if int(sqrt(n - j*j))**2 == n - j*j: return 2\\n            \\n        while n % 4 == 0: \\n            n >>= 2\\n        if n % 8 == 7: return 4\\n        return 3\\n```\\n\\n**Further discussion**. What if you do not know this `4^k(8m+7)` formula on real interview? Then you need to check if number is sum of `3` squares by hands: `n = i*i + j*j + k*k` with complexity `O(n)`: we check all pairs `i,j < sqrt(n)`. What if we do not know, that each number is sum of `4` squares? Then we need to check also possible sums of `4` squares with complexity `O(n sqrt(n))`.\\n\\nWe can handle our problem as **dynamic programming** one, where `dp[i]` is minumum numer of squares to get `i`. Then to evaluate `dp[i]` we need to look at all `j`, such that `j*j <= i`. Complexity of this approach is `O(n sqrt(n))`.\\n\\nNote, that there is also a way to check if `n` is sum of two squares, https://en.wikipedia.org/wiki/Sum_of_two_squares_theorem, each odd prive divisor should have a form `4k + 1`, but this is a bit more difficult to check and complexity will be also `O(sqrt(n))`.\\n\\n Open question, is there solution with comlexity better than `O(sqrt(n))`. If you have ideas, let me know!\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n):\\n        if int(sqrt(n))**2 == n: return 1\\n        for j in range(int(sqrt(n)) + 1):\\n            if int(sqrt(n - j*j))**2 == n - j*j: return 2\\n            \\n        while n % 4 == 0: \\n            n >>= 2\\n        if n % 8 == 7: return 4\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275311,
                "title": "python-dp-bfs",
                "content": "First solution is to use DP.\\nSuppose ```dp[i]``` records to least number of perfect square numbers that sum up to ```i```. And there are multiple ways for perfect square numbers to sum up to ```i```. \\nThe candidate way is to add a perfect square number ```j*j``` to a sum of perfect square numbers that equals to ```i```. And it can be generized as ```i-j*j + j*j```. So the least number of perfect square numbers that sum up to ```i-j*j``` is ```dp[i-j*j]```. So candidate answer is ```dp[i-j*j]+1```(add one more number ```j*j```). \\nSo for ```dp[i]```, we just pick the minimum of all candidates:\\n```\\ndp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n```\\nTime complexity is O(n\\u221An). Actually running time is 2500ms.\\n```\\ndef numSquares(n):\\n\\tdp = [0] + [float(\\'inf\\')]*n\\n\\tfor i in range(1, n+1):\\n\\t\\tdp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n\\treturn dp[n]\\n```\\n\\nAnother solution is to use BFS.\\nThe root node is ```n```, and we are trying to keep reduce a perfect square number from it each layer. So the next layer nodes are ```{n - i**2 for i in range(1, int(n**0.5)+1)}```. And target leaf node is ```0```, indicates ```n``` is made up of a number of perfect square numbers and depth is the least number of perfect square numbers.\\n```\\ndef numSquares(self, n):\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\td, q, nq = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return d\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tnq.add(node-square)\\n\\t\\tq, nq, d = nq, set(), d+1\\n```\\nEach while loop takes ```Si```, which is the number of the values that is within range ```{1, n}``` whose least number of perfect squares is ```i```. E.g. ```S1 = \\u221An```. \\nSo total time cost should be ```c\\u2211Si = cS1+cS2+...+cSd```. Since I used a set for queue here, ```\\u2211Si \\u2264 n```, and time complexity is O(n). The worst case would be ```n``` happen to have a larger least number of perfect square than any number from ```{1, n-1}```. Actually running time is 220ms.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i]```\n```i```\n```i```\n```j*j```\n```i```\n```i-j*j + j*j```\n```i-j*j```\n```dp[i-j*j]```\n```dp[i-j*j]+1```\n```j*j```\n```dp[i]```\n```\\ndp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n```\n```\\ndef numSquares(n):\\n\\tdp = [0] + [float(\\'inf\\')]*n\\n\\tfor i in range(1, n+1):\\n\\t\\tdp[i] = min(dp[i-j*j] for j in range(1, int(i**0.5)+1)) + 1\\n\\treturn dp[n]\\n```\n```n```\n```{n - i**2 for i in range(1, int(n**0.5)+1)}```\n```0```\n```n```\n```\\ndef numSquares(self, n):\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\td, q, nq = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return d\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tnq.add(node-square)\\n\\t\\tq, nq, d = nq, set(), d+1\\n```\n```Si```\n```{1, n}```\n```i```\n```S1 = \\u221An```\n```c\\u2211Si = cS1+cS2+...+cSd```\n```\\u2211Si \\u2264 n```\n```n```\n```{1, n-1}```",
                "codeTag": "Python3"
            },
            {
                "id": 71533,
                "title": "o-sqrt-n-in-ruby-c-c",
                "content": "These solutions use some number theory (see explanation further down).\\n\\n---\\n\\n**Ruby solution**\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      return 3 if n.prime_division.any? { |p, e| p % 4 == 3 && e.odd? }\\n      (n**0.5).to_i**2 == n ? 1 : 2\\n    end\\n\\nOr:\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      pd = n.prime_division\\n      return 3 if pd.any? { |p, e| p % 4 == 3 && e.odd? }\\n      pd.any? { |_, e| e.odd? } ? 2 : 1\\n    end\\n\\n---\\n\\n**C++ solution**\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        bool min2 = false;\\n        for (int i=2; i<=n; ++i) {\\n            if (i > n/i)\\n                i = n;\\n            int e = 0;\\n            while (n % i == 0)\\n                n /= i, ++e;\\n            if (e % 2 && i % 4 == 3)\\n                return 3;\\n            min2 |= e % 2;\\n        }\\n        return 1 + min2;\\n    }\\n\\n---\\n\\n**C solution**\\n\\nInspired by [kevin36's solution](https://leetcode.com/discuss/57020/java-solution-o-n-1-2-time-and-o-1-space). We don't really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler.\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        for (int a=0; a*a<=n; ++a) {\\n            int b = sqrt(n - a*a);\\n            if (a*a + b*b == n)\\n                return 1 + !!a;\\n        }\\n        return 3;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nI happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number's prime factorization. A natural number is...\\n\\n- ... a **square** if and only if each prime factor occurs to an even power in the number's prime factorization.\\n- ... a [**sum of two squares**](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n- ... a [**sum of three squares**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) if and only if it's not of the form 4<sup>a</sup>(8b+7) with integers a and b.\\n- ... a [**sum of four squares**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem). Period. No condition. You never need more than four.\\n\\nOf course single squares can also be identified by comparing a given number with the square of the rounded root of the number.\\n\\nThe problem statement says *\"1, 4, 9, 16, ...\"*, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a<sup>2</sup>+b<sup>2</sup> to the sum of three squares a<sup>2</sup>+b<sup>2</sup>+0<sup>2</sup>. Put differently, if n isn't a sum of three squares, then it also isn't a sum of two squares. So you can read the above statements as *\"... a sum of m **(or fewer)** squares\"*. Thanks to ruben3 for asking about this in the comments.\\n\\nIn my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn't affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares.\\n\\nArmed with just the knowledge that you never need more than four squares, it's also easy to write O(n) solutions, e.g.:\\n\\n    int numSquares(int n) {\\n        int ub = sqrt(n);\\n        for (int a=0; a<=ub; ++a) {\\n            for (int b=a; b<=ub; ++b) {\\n                int c = sqrt(n - a*a - b*b);\\n                if (a*a + b*b + c*c == n)\\n                    return !!a + !!b + !!c;\\n            }\\n        }\\n        return 4;\\n    }",
                "solutionTags": [
                    "C++",
                    "Ruby",
                    "Math"
                ],
                "code": "These solutions use some number theory (see explanation further down).\\n\\n---\\n\\n**Ruby solution**\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      return 3 if n.prime_division.any? { |p, e| p % 4 == 3 && e.odd? }\\n      (n**0.5).to_i**2 == n ? 1 : 2\\n    end\\n\\nOr:\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      pd = n.prime_division\\n      return 3 if pd.any? { |p, e| p % 4 == 3 && e.odd? }\\n      pd.any? { |_, e| e.odd? } ? 2 : 1\\n    end\\n\\n---\\n\\n**C++ solution**\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        bool min2 = false;\\n        for (int i=2; i<=n; ++i) {\\n            if (i > n/i)\\n                i = n;\\n            int e = 0;\\n            while (n % i == 0)\\n                n /= i, ++e;\\n            if (e % 2 && i % 4 == 3)\\n                return 3;\\n            min2 |= e % 2;\\n        }\\n        return 1 + min2;\\n    }\\n\\n---\\n\\n**C solution**\\n\\nInspired by [kevin36's solution](https://leetcode.com/discuss/57020/java-solution-o-n-1-2-time-and-o-1-space). We don't really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler.\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        for (int a=0; a*a<=n; ++a) {\\n            int b = sqrt(n - a*a);\\n            if (a*a + b*b == n)\\n                return 1 + !!a;\\n        }\\n        return 3;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nI happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number's prime factorization. A natural number is...\\n\\n- ... a **square** if and only if each prime factor occurs to an even power in the number's prime factorization.\\n- ... a [**sum of two squares**](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n- ... a [**sum of three squares**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) if and only if it's not of the form 4<sup>a</sup>(8b+7) with integers a and b.\\n- ... a [**sum of four squares**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem). Period. No condition. You never need more than four.\\n\\nOf course single squares can also be identified by comparing a given number with the square of the rounded root of the number.\\n\\nThe problem statement says *\"1, 4, 9, 16, ...\"*, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a<sup>2</sup>+b<sup>2</sup> to the sum of three squares a<sup>2</sup>+b<sup>2</sup>+0<sup>2</sup>. Put differently, if n isn't a sum of three squares, then it also isn't a sum of two squares. So you can read the above statements as *\"... a sum of m **(or fewer)** squares\"*. Thanks to ruben3 for asking about this in the comments.\\n\\nIn my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn't affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares.\\n\\nArmed with just the knowledge that you never need more than four squares, it's also easy to write O(n) solutions, e.g.:\\n\\n    int numSquares(int n) {\\n        int ub = sqrt(n);\\n        for (int a=0; a<=ub; ++a) {\\n            for (int b=a; b<=ub; ++b) {\\n                int c = sqrt(n - a*a - b*b);\\n                if (a*a + b*b + c*c == n)\\n                    return !!a + !!b + !!c;\\n            }\\n        }\\n        return 4;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2837992,
                "title": "java-recursion-memoization-dp-3-square-theorem-explained",
                "content": "**Approach #1: Brute Force (Recursion) - TLE**\\n\\n```\\npublic int numSquares(int n) {\\n\\tif (n < 4)\\n\\t\\treturn n;\\n\\t\\n\\tint ans = n;\\n\\t\\n\\tfor (int i = 1; i * i <= n; i++) {\\n\\t\\tint square = i * i;\\n\\t\\tans = Math.min(ans, 1 + numSquares(n - square));\\n\\t}\\n\\t\\n\\treturn ans;\\n}\\n```\\n\\n**Approach #2: Top Down DP (Recursion + Memoization)**\\n\\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\t\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n + 1];\\n        return helper(n, memo);\\n    }\\n    \\n    public int helper(int n, int[] memo) {\\n        if (n < 4)\\n            return n;\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        \\n        int ans = n;\\n        \\n        for (int i = 1; i * i <= n; i++) {\\n            int square = i * i;\\n            ans = Math.min(ans, 1 + helper(n - square, memo));\\n        }\\n        \\n        return memo[n] = ans;\\n    }\\n}\\n```\\n\\n**Approach #3: Bottom UP DP (Using DP Array)**\\n\\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\npublic int numSquares(int n) {\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 0;\\n\\t\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tdp[i] = i;\\n\\t\\t\\n\\t\\tfor (int j = 1; j * j <= i; j++) {\\n\\t\\t\\tint square = j * j;\\n\\t\\t\\tdp[i] = Math.min(dp[i], 1 + dp[i - square]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n**Approach #4: Legendre\\'s 3-Square Theorem**\\n\\n* 4-Square theorem: Every natural no is sum of 4 squares.\\n* 3-Square Theorem: Every natural no is sum of 3 squares if it does not satisfies 4^a (8b + 7) = N\\n* So our answer will be 1, 2, 3 or 4.\\n\\n**Steps:**\\n* If it\\'s perfect square, return 1\\n* If it satisfies 4^a (8b + 7), return 4\\n* If it\\'s sum of 2 perfect squares, return 2\\n* Otherwise, return 3\\n\\n```\\n// Time complexity: O(sqrt(N))\\n// Space complexity: O(1)\\n\\t\\npublic int numSquares(int n) {\\n\\tint sqrt = (int) Math.sqrt(n);\\n\\n\\tif (sqrt * sqrt == n) // Perfect square\\n\\t\\treturn 1;\\n\\n\\twhile (n % 4 == 0) // 4^a (8b + 7)\\n\\t\\tn = n / 4;\\n\\n\\tif (n % 8 == 7)\\n\\t\\treturn 4;\\n\\n\\tfor (int i = 1; i * i <= n; i++) { // Sum of two perfect squares\\n\\t\\tint square = i * i;\\n\\t\\tint base = (int) Math.sqrt(n - square);\\n\\n\\t\\tif (base * base == n - square)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn 3;\\n}\\n```\\n\\n**Please upvote if you find these solutions useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic int numSquares(int n) {\\n\\tif (n < 4)\\n\\t\\treturn n;\\n\\t\\n\\tint ans = n;\\n\\t\\n\\tfor (int i = 1; i * i <= n; i++) {\\n\\t\\tint square = i * i;\\n\\t\\tans = Math.min(ans, 1 + numSquares(n - square));\\n\\t}\\n\\t\\n\\treturn ans;\\n}\\n```\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\t\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n + 1];\\n        return helper(n, memo);\\n    }\\n    \\n    public int helper(int n, int[] memo) {\\n        if (n < 4)\\n            return n;\\n        \\n        if (memo[n] != 0)\\n            return memo[n];\\n        \\n        int ans = n;\\n        \\n        for (int i = 1; i * i <= n; i++) {\\n            int square = i * i;\\n            ans = Math.min(ans, 1 + helper(n - square, memo));\\n        }\\n        \\n        return memo[n] = ans;\\n    }\\n}\\n```\n```\\n// Time complexity: O(N * sqrt(N))\\n// Space complexity: O(N)\\n\\npublic int numSquares(int n) {\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 0;\\n\\t\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tdp[i] = i;\\n\\t\\t\\n\\t\\tfor (int j = 1; j * j <= i; j++) {\\n\\t\\t\\tint square = j * j;\\n\\t\\t\\tdp[i] = Math.min(dp[i], 1 + dp[i - square]);\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\n```\\n// Time complexity: O(sqrt(N))\\n// Space complexity: O(1)\\n\\t\\npublic int numSquares(int n) {\\n\\tint sqrt = (int) Math.sqrt(n);\\n\\n\\tif (sqrt * sqrt == n) // Perfect square\\n\\t\\treturn 1;\\n\\n\\twhile (n % 4 == 0) // 4^a (8b + 7)\\n\\t\\tn = n / 4;\\n\\n\\tif (n % 8 == 7)\\n\\t\\treturn 4;\\n\\n\\tfor (int i = 1; i * i <= n; i++) { // Sum of two perfect squares\\n\\t\\tint square = i * i;\\n\\t\\tint base = (int) Math.sqrt(n - square);\\n\\n\\t\\tif (base * base == n - square)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn 3;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71605,
                "title": "java-dp-solution-with-explanation",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int sqrt = (int)Math.sqrt(i);\\n            \\n            // If the number is already a perfect square,\\n            // then dp[number] can be 1 directly. This is\\n            // just a optimization for this DP solution.\\n            if (sqrt * sqrt == i) {\\n                dp[i] = 1;\\n                continue;                \\n            }\\n            \\n            // To get the value of dp[n], we should choose the min\\n            // value from:\\n            //     dp[n - 1] + 1,\\n            //     dp[n - 4] + 1,\\n            //     dp[n - 9] + 1,\\n            //     dp[n - 16] + 1\\n            //     and so on...\\n            for (int j = 1; j <= sqrt; j++) {\\n                int dif = i - j * j;\\n                dp[i] = Math.min(dp[i], (dp[dif] + 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2838408,
                "title": "python-c-java-rust-faster-than-99-math-dp-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs several facts from mathematics and a cheap brute force. Time complexity **O(sqrtN)**. Space complexity is **O(1)**. \\n****\\n\\n**Comment.** This solution employs the following known facts from mathematics regarding the decomposition of a number into a sum of squares:\\n * [**Lagrange\\'s four-square theorem**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem), stating that every natural number can be represented as the sum of four integer squares, and\\n * [**Legendre\\'s three-square theorem**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem), stating that a natural number `n` can be represented as the sum of three squares of integers if and only if `n` is **NOT** of the form `n=4**a * (8*b+7)` for nonnegative integers `a` and `b`.\\n\\nThus, our strategy for solving this problem is to perform trivial tests for 1 & 3 summands, brute force for 2 summands and return 4 if all of those tests failed.\\n\\n**Python #1.** Smart brute-force (for only pairs of squares). This [**solution**](https://leetcode.com/submissions/detail/847883817/) demonstrated **25 ms runtime (99.95%)**. \\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self , n):\\n        \\n        if isqrt(n)**2 == n : return 1               # [1] already a square\\n        \\n        for i in range(1,isqrt(n)+1):                # [2] check pairs of squares\\n            if (j := n - i**2) == isqrt(j)**2:\\n                return 2\\n            \\n        while n % 4 == 0 : n /= 4                    # [3] well, it\\'s maths, namely,\\n        if    n % 8 != 7 : return 3                  #     the Legendre\\'s theorem\\n        \\n        return 4                                     # [4] the only remaining option\\n```\\n\\nFor those who are not satisified with using math tricks...\\n\\n**Python #2.** Straightforward DP. Here we use a trick with `dp` being a variable that is initialized just once for all tests (thx **@md2030** for the hint that I modified a bit).\\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    \\n    def numSquares(self, n: int, dp = [0]) -> int:\\n\\n        for k in range(len(dp), n+1):\\n            if k == len(dp) : dp.append(inf)\\n            for i in range(1, isqrt(k)+1):\\n                dp[k] = min(dp[k], 1 + dp[k - (i*i)])\\n                \\n        return dp[n]\\n```\\n\\nFirst solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/GMVFzZkR/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #3.** This one-liner uses the same approach with `dp` being a shared map for all tests. Please note the trick with memoization of values and their extraction right inside the one-liner.\\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self, n: int, dp={}) -> int:\\n        return min((dp.update({s:self.numSquares(s)}) is None) * dp[s]\\n                   if (s:=n-k**2) not in dp else dp[s]\\n                   for k in range(1,isqrt(n)+1)) + 1 if n != isqrt(n)**2 else 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self , n):\\n        \\n        if isqrt(n)**2 == n : return 1               # [1] already a square\\n        \\n        for i in range(1,isqrt(n)+1):                # [2] check pairs of squares\\n            if (j := n - i**2) == isqrt(j)**2:\\n                return 2\\n            \\n        while n % 4 == 0 : n /= 4                    # [3] well, it\\'s maths, namely,\\n        if    n % 8 != 7 : return 3                  #     the Legendre\\'s theorem\\n        \\n        return 4                                     # [4] the only remaining option\\n```\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    \\n    def numSquares(self, n: int, dp = [0]) -> int:\\n\\n        for k in range(len(dp), n+1):\\n            if k == len(dp) : dp.append(inf)\\n            for i in range(1, isqrt(k)+1):\\n                dp[k] = min(dp[k], 1 + dp[k - (i*i)])\\n                \\n        return dp[n]\\n```\n```\\nfrom math import isqrt\\n\\nclass Solution:\\n    def numSquares(self, n: int, dp={}) -> int:\\n        return min((dp.update({s:self.numSquares(s)}) is None) * dp[s]\\n                   if (s:=n-k**2) not in dp else dp[s]\\n                   for k in range(1,isqrt(n)+1)) + 1 if n != isqrt(n)**2 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71505,
                "title": "simple-java-dp-solution",
                "content": "Just regular DP. Time Complexity: n * sqrt(n)   Space: O(n)\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n           int[] dp = new int[n + 1];\\n           Arrays.fill(dp, Integer.MAX_VALUE);\\n           dp[0] = 0;\\n           for(int i = 0; i <= n; i++){\\n               for(int j = 1; i + j * j <= n; j++){\\n                   dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);\\n                }\\n           }\\n           return dp[n];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n           int[] dp = new int[n + 1];\\n           Arrays.fill(dp, Integer.MAX_VALUE);\\n           dp[0] = 0;\\n           for(int i = 0; i <= n; i++){\\n               for(int j = 1; i + j * j <= n; j++){\\n                   dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2837770,
                "title": "python3-dp-with-detailed-explanations-o-n-sqrt-n-not-tle",
                "content": "DP is the best solution I can comeup with, there is a [mathematics solution](https://leetcode.com/problems/perfect-squares/discuss/2837639/Python-3-oror-no-dp-just-mathematics-wbrief-explanation-oror-TM%3A-10084), I\\'m not sure what the interviewer is expecting, anyone has any ideas?\\n\\n**naive DP (TLE)**\\n(1) ```dp[i]``` means the least number of perfect squares that sum to ```i```, so return ```dp[n]``` at the end.\\n(2) ```dp[i] = 1``` if ```i``` is a perfect square.\\n(3) ```dp[i] = min(dp[i], dp[i-j] + dp[j] )```, where 0<=j<i. \\nThis is because:\\n - the least number of perfect squares that sum to ```i``` **=** the least number of perfect squares that sum to ```i-j``` **+** the least number of perfect squares that sum to ```j```.\\n - since j<i, we already know the least number of perfect squares that sum to ```j``` and ```i-j``` in our ```dp``` array.\\n\\n(4) return dp[n]\\n\\n**TC: O(n^2)** Since for each ```i``` 1<=i<=n, we need to check all j, where 0<=j<i.\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for j in range(i):\\n                dp[i] = min(dp[i],dp[i-j]+dp[j])\\n\\n        return dp[n]\\n```\\n\\n**Better DP (sometimes TLE)**\\nThe most time comsuming process from the last solution is to check all j, where 0<=j<i.\\nA better solution would be not checking all ```j```, but only check ```j``` if ```j``` is a prefect square. The reason behind this are:\\n - Let\\'s say the two numbers which sum up to ```i``` are ```j``` and ```i-j```, but none of them is prefect square, then there has to be at least one perfect square which was used to construct ```j```. Same thing for ```i-j```.\\n - The number of perfect squares in ```dp[j] = a non zero + 1``` and ```dp[i-j] = a non zero + 1```. There is a non zero number because ```j``` and ```i-j``` are not perfect squares (if they are, they will be 1).\\n - Then, ```dp[j] + dp[i-j] = a non zero + 1  +  a non zero + 1 = a non zero + 2``` which will be larger than if either ```j``` or ```i-j``` is a perfect square.\\n - e.g., if ```j``` is a perfect square, then dp[j] = 1, and ```dp[j] + dp[i-j] = a non zero + 1```\\n This lead to the next dp algorithm, which we will only check ```j``` if ```j``` is a perfect square.\\n \\n The dp equation becomes\\n ```dp[i] = min(dp[i], dp[i-j] + dp[j] )```, where 0<=j<i. **```j``` is a perfect square**.\\n\\n note that since j is a perfect square, then dp[j]=1, the equation becomes:\\n ```dp[i] = min(dp[i], dp[i-j] + 1 )```, where 0<=j<i. **```j``` is a perfect square**.\\n\\n**TC: O(n sqrt(n))** Since for each ```i``` 0<=i<=n, we only check ```j``` if ```j``` is a perfect square and there are at most sqrt(n) perfect squares smaller than n.\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Store all perfect square <= n.\\n        perfectSq = []\\n        \\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            # if i_sq is smaller than or equal to n, we store it, for the dp equation.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                perfectSq.append(i_sq)\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n            \\t# i has to be smaller than the perfect square number that is used to construct i\\n                if i<ps: break\\n                \\n                dp[i] = min(dp[i],1+dp[i-ps])\\n                # it is the same as dp[i] = min(dp[i],dp[ps]+dp[i-ps]) because dp[ps]=1\\n\\n        return dp[n]\\n```\\n\\n**Not Time Limit Exceeded:** You may get TLE using the previous one, here is an interesting modification: **Make ```dp``` a class variable**, so that it will not rebuild ```dp``` from 0 for different testing cases.\\n\\n```python\\nclass Solution:\\n    \\n    # Make dp a class variable :)\\n    dp = [0]\\n\\n    def numSquares(self, n: int) -> int:\\n\\n        dp = self.dp\\n        \\n        # Precompute the perfect squares.\\n        perfectSq = [pow(i,2) for i in range(1, int(sqrt(n))+1)]\\n        \\n        # We are building dp up to length n+1.\\n        while len(dp) < n+1:\\n            \\n            # Will add this new element to dp\\n            dpI = inf\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n                if len(dp)<ps: break\\n                dpI = min(dpI,1+dp[-ps])\\n            \\n            dp.append(dpI)\\n        \\n        return dp[n]\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```dp[i]```\n```i```\n```dp[n]```\n```dp[i] = 1```\n```i```\n```dp[i] = min(dp[i], dp[i-j] + dp[j] )```\n```i```\n```i-j```\n```j```\n```j```\n```i-j```\n```dp```\n```i```\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for j in range(i):\\n                dp[i] = min(dp[i],dp[i-j]+dp[j])\\n\\n        return dp[n]\\n```\n```j```\n```j```\n```j```\n```i```\n```j```\n```i-j```\n```j```\n```i-j```\n```dp[j] = a non zero + 1```\n```dp[i-j] = a non zero + 1```\n```j```\n```i-j```\n```dp[j] + dp[i-j] = a non zero + 1  +  a non zero + 1 = a non zero + 2```\n```j```\n```i-j```\n```j```\n```dp[j] + dp[i-j] = a non zero + 1```\n```j```\n```j```\n```dp[i] = min(dp[i], dp[i-j] + dp[j] )```\n```j```\n```dp[i] = min(dp[i], dp[i-j] + 1 )```\n```j```\n```i```\n```j```\n```j```\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Store all perfect square <= n.\\n        perfectSq = []\\n        \\n        # The dp array.\\n        dp = [inf] * (n+1)\\n        \\n        for i in range(1,n+1):\\n            \\n            # calculate the square of i, dp[i_sq] to 1.\\n            # if i_sq is smaller than or equal to n, we store it, for the dp equation.\\n            i_sq = pow(i,2)\\n            if i_sq <= n:\\n                perfectSq.append(i_sq)\\n                dp[i_sq] = 1\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n            \\t# i has to be smaller than the perfect square number that is used to construct i\\n                if i<ps: break\\n                \\n                dp[i] = min(dp[i],1+dp[i-ps])\\n                # it is the same as dp[i] = min(dp[i],dp[ps]+dp[i-ps]) because dp[ps]=1\\n\\n        return dp[n]\\n```\n```dp```\n```dp```\n```python\\nclass Solution:\\n    \\n    # Make dp a class variable :)\\n    dp = [0]\\n\\n    def numSquares(self, n: int) -> int:\\n\\n        dp = self.dp\\n        \\n        # Precompute the perfect squares.\\n        perfectSq = [pow(i,2) for i in range(1, int(sqrt(n))+1)]\\n        \\n        # We are building dp up to length n+1.\\n        while len(dp) < n+1:\\n            \\n            # Will add this new element to dp\\n            dpI = inf\\n            \\n            # dp equation\\n            for ps in perfectSq:\\n                if len(dp)<ps: break\\n                dpI = min(dpI,1+dp[-ps])\\n            \\n            dp.append(dpI)\\n        \\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513258,
                "title": "very-easy-to-understand-with-picture-python-recursion-memoization",
                "content": "**279. Perfect Squares**\\n\\nHey Everyone I will try to explain the solution through some pictures. **How each piece of code is working**!!!\\nWas going through DISCUSS Section but coudn\\'t wrap my head around why certain lines were written, so after figuring out I tried to share it out here to save someone\\'s else time.This question has been tagged under **AMAZON** in some places..LET\\'S BEGIN.\\n\\n **RECURSIVE CODE** [ TLE ]\\n________________________________\\n\\n````\\ndef solve(n):\\n\\n    if n==0:                                                     # part 1\\n        return 0\\n\\t\\t\\n    if n<0:                                                      # part 2\\n        return float(\"inf\")\\n\\t\\t\\n    mini = n                                                     # part 3 \\n\\t\\n    i = 1\\n    while i*i<=n:                                                # part 4\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n\\t\\t\\n    return mini+1                                                # part 5\\n\\nsolve(n)\\n````\\n\\n**Edit ( TC )** - First we have to pay attention on while loop. It takes O( sqrt(n) ). Next we have to pay attention on the recursive call ```min( mini,  solve( n- ( i * i )))```. In case when our ```i == 1``` we are able to create the longest way. Because of that we can come to a conclusion that the maximum number of levels in a decision tree will be n. Taking all of this into consideration and knowing the width of a tree level and the height of the whole tree we can say that the overall TC of brute recusion is **O( sqrt(n) ^ n - 1 )**  . \\n**Credit** -  [Maxim](https://leetcode.com/_Maximus_/)\\n\\n--------\\n\\n\\nLet\\'s First Have A Look Over How Our DECISION TREE Looks Like !! \\n\\n\\n![image](https://assets.leetcode.com/users/images/4bda9ee4-a4d3-41bc-9180-5f1f931bab23_1633835670.4654868.jpeg)\\n\\n\\n__________________________\\n--> **PART 1 [ BASE CASE  ]**\\n____________________________\\n\\nWhen our call hits base case and n becomes 0 we know there is a possible way to split our target.\\nSince in ques we have to find the **min** possible way.\\nThere is no case where mini becomes less than 0 . So we return 0 that indicates we found a **Possible Set Of Candidates.**\\n______________________________\\n--> **PART 2**\\n_______________\\nSame logic as above if our n becomes less than 0 we know there is no possible way to split our target.\\n\\n___________________________________________________\\n--> **PART 3 [  WHY ```mini = n ??``` THIS PART WAS HARD FOR ME TO UNDERSTAND :( ]**\\n_______________________\\n\\nSuppose we are at a point in our recursion call where n = 12 !!\\nwhat could be the max count to split 12 so that each element is a perfect square??\\n\\nYES u are right :)  **12 = 1 + 1+ 1+ 1+1+ 1+ 1+1 +1+1+1 +1 ( 12 times 1 )**\\nwe cant get any maximum value than 12 for 12  thats why mini = n which is 12 in this case.\\n___________________________________\\n--> **PART 4 [ WHILE LOOP PART ]**\\n_______________________________\\n\\nWhat is ***least possible perfect Square candidate*** for our ans??\\nYES It is 1 so we start our loop from ```i=1```\\n\\nNow upto what value of ```i``` our loop should execute???\\nYES till  ```n >= i^2``` ( in short upto that value when n - i^2 is +ve )\\n\\nWHY??\\nbecause after that we will call at value < 0  which anyhow our function will **return infinity** since n<0 **remember base case  PART 2. but will lead to infinite looping**\\n____________________\\n--> **PART 5  [ WHY ```mini+1```?? ]**\\n_________________\\n\\nWe are counting the steps isnt it??\\n\\nWhen we hit the base case ```n==0``` we return **0**.  \\n\\nAlso one path for 5 = 1+1+1+1+1 .\\n**Last 1 will get 0** (BASE CASE)  and  **it will be returning 0+1**\\n\\nso ```step count = 0 + 1 + 1 + 1 + 1 + 1 = 5```\\n\\nsee the picture for better understanding\\n\\n![image](https://assets.leetcode.com/users/images/7f856800-999e-4aea-99b1-1c3e74622761_1633835643.2424138.jpeg)\\n\\n\\n**MEMOIZATION [ ACCEPTED ]**\\n____________________________\\n```\\ndef solve(n):\\n    if n==0:\\n        return 0\\n    if n<0:\\n        return float(\"inf\")\\n    if memo[n]!=-1:\\n        return memo[n]\\n    mini = n\\n    i = 1\\n    while i*i<=n:\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n    memo[n] = mini+1\\n    return memo[n]\\n    \\nmemo = [-1]*(n+1)\\nsolve(n)\\n```\\n\\nthank you!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\ndef solve(n):\\n\\n    if n==0:                                                     # part 1\\n        return 0\\n\\t\\t\\n    if n<0:                                                      # part 2\\n        return float(\"inf\")\\n\\t\\t\\n    mini = n                                                     # part 3 \\n\\t\\n    i = 1\\n    while i*i<=n:                                                # part 4\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n\\t\\t\\n    return mini+1                                                # part 5\\n\\nsolve(n)\\n```\n```min( mini,  solve( n- ( i * i )))```\n```i == 1```\n```mini = n ??```\n```i=1```\n```i```\n```n >= i^2```\n```mini+1```\n```n==0```\n```step count = 0 + 1 + 1 + 1 + 1 + 1 = 5```\n```\\ndef solve(n):\\n    if n==0:\\n        return 0\\n    if n<0:\\n        return float(\"inf\")\\n    if memo[n]!=-1:\\n        return memo[n]\\n    mini = n\\n    i = 1\\n    while i*i<=n:\\n        mini = min(mini, solve(n-(i*i)))\\n        i+=1\\n    memo[n] = mini+1\\n    return memo[n]\\n    \\nmemo = [-1]*(n+1)\\nsolve(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71618,
                "title": "4ms-c-code-solve-it-mathematically",
                "content": "    class Solution {  \\n    public:  \\n        int is_square(int n){  \\n            int temp = (int) sqrt(n);  \\n            return temp * temp == n;  \\n        }  \\n        int numSquares(int n) {  \\n            while ((n & 3) == 0) //n%4 == 0  \\n                n >>= 2;  \\n            if ((n & 7) == 7) return 4; //n % 8 == 7  \\n            if(is_square(n)) return 1;  \\n            int sqrt_n = (int) sqrt(n);  \\n            for(int i = 1; i<= sqrt_n; i++){  \\n                if (is_square(n-i*i)) return 2;  \\n            }  \\n            return 3;  \\n        }  \\n    };  \\n\\nUPDATE: in order to understand, I suggest u read:\\n\\nhere is the Lagrange's Four Square theorem - Limit the result to <= 4:\\n[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem)\\n\\nAnd this article, in which you can also find the way to present a number as a sum of four squares:\\n[http://www.alpertron.com.ar/4SQUARES.HTM](http://www.alpertron.com.ar/4SQUARES.HTM)",
                "solutionTags": [],
                "code": "class Solution {  \\n    public:  \\n        int is_square(int n){  \\n            int temp = (int) sqrt(n);  \\n            return temp * temp == n;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2837639,
                "title": "python-3-no-dp-just-mathematics-w-brief-explanation-t-m-100-82",
                "content": "(*Updated March 2023*)\\n\\nThe following theorems allow a straight-forward path to the solution for any positive integer:\\n*  k = 1:     *Spaulding\\'s One-Square Theorem*\\n*  k = 2: *Fermat\\'s Two-Square Theorem*\\n*   k = 3: *Legendre\\'s Three-Square Theorem*\\n*    k = 4: *Lagrange\\'s Four-Square Theorem*\\n    \\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        def CheckTwo(c):                       \\n            while c%2==0: c=c//2\\n            while c%5==0: c=c//5\\n            while c%9==0: c=c//9\\n\\n            if c%3==0: return False\\n\\n            if c in (0,1,13,17): return True\\n\\n            i, j = 0, isqrt(c)\\n\\n            while i <= j:\\n                if i*i + j*j == c: return True\\n                if i*i + j*j < c: i += 1\\n                if i*i + j*j > c: j -= 1\\n\\n            return  False\\n\\n        if n == isqrt(n)**2:return 1                # case k = 1       \\n\\n        if CheckTwo(n): return 2                    # case k = 2\\n\\n        while n%4 ==0: n//=4                        # case k = 3  \\n        if n%8 != 7: return 3 \\n        \\n        return 4                                    # case k = 4\\n```\\n[https://leetcode.com/problems/perfect-squares/submissions/928021429/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        def CheckTwo(c):                       \\n            while c%2==0: c=c//2\\n            while c%5==0: c=c//5\\n            while c%9==0: c=c//9\\n\\n            if c%3==0: return False\\n\\n            if c in (0,1,13,17): return True\\n\\n            i, j = 0, isqrt(c)\\n\\n            while i <= j:\\n                if i*i + j*j == c: return True\\n                if i*i + j*j < c: i += 1\\n                if i*i + j*j > c: j -= 1\\n\\n            return  False\\n\\n        if n == isqrt(n)**2:return 1                # case k = 1       \\n\\n        if CheckTwo(n): return 2                    # case k = 2\\n\\n        while n%4 ==0: n//=4                        # case k = 3  \\n        if n%8 != 7: return 3 \\n        \\n        return 4                                    # case k = 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837605,
                "title": "complete-intuition-explained-recursion-memo-dp",
                "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\n**Take the given target, subtract perfect squares to make it \"0\".**\\n\\n#We need to subtract perfect squares optimally to make the target 0\\n#We need to keep perfect squares as minimum as possible\\n#But we have **many options** of perfect squares to subtract \\n->**For target = 18**\\n->**we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]**\\n#If you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n  18 - (4^2) = 2\\n  2 - (1^2) = 1   //Future    \\n  1 - (1^2) = 0   //Future   **[3 STEPS]**\\n\\n#But actually picking (9) at first step would prove to be optimal here\\n  18 - (3^3) = 9\\n  9 - (3^3) = 0 //Future **[2 STEPS]**\\n\\n\\n\\n#We are **\"NOT SURE\"** if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\n#So whenever you are not sure which step would be optimal, **no need to stress on guessing** the optimal one, just =>\\n**\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"**\\n#So for any given target, just try all the perfect squares you can subtract \\n\\n    target(18) => [18 - (1^2) = 17] =>target(17)\\n\\ttarget(18) => [18 - (2^2) = 14] => target(14)\\n    target(18) => [18 - (3^2) = 9] => target(9)\\n    target(18) => [18 - (4^2) = 2] => target(2)\\n                \\n#Now we have a smaller subproblem, which could be solved using recursion \\n#so \\n  for **target(18) = 1 + min (target(17), target(14), target(9), target(2))**\\n#Let recursion do it\\'s work and you just use those hardworked results in you favour :)\\n//========================================================================================================\\n#### RECURSION ==> \\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        if (n == 0) return 0;\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n//==========================================================================================================================\\n#### MEMOIZATION ==>\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>&dp)\\n    {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum, dp);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return dp[n] = mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        vector<int>dp(n + 1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```\\n//====================================================================================================================\\n#### DP ==>\\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0; \\n        for (int target = 1; target <= n; target++)\\n        {\\n            int mnCount = INT_MAX;\\n            for (int num = 1; num <= sqrt(target); num++)\\n            {\\n                int sqNum = num * num;\\n                int currCount = 1 + dp[target - sqNum];\\n                mnCount = min(mnCount, currCount);\\n            }\\n            dp[target] = mnCount;\\n        }\\n        return dp[n];\\n    } \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        if (n == 0) return 0;\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>&dp)\\n    {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        \\n        int mnCount = INT_MAX;\\n        for (int num = 1; num <= sqrt(n); num++)\\n        {\\n            int sqNum = num * num;\\n            int currCount = 1 + solve(n - sqNum, dp);\\n            mnCount = min(mnCount, currCount);\\n        }\\n        return dp[n] = mnCount;\\n    }\\n    int numSquares(int n) \\n    {\\n        vector<int>dp(n + 1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n)\\n    {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0; \\n        for (int target = 1; target <= n; target++)\\n        {\\n            int mnCount = INT_MAX;\\n            for (int num = 1; num <= sqrt(target); num++)\\n            {\\n                int sqNum = num * num;\\n                int currCount = 1 + dp[target - sqNum];\\n                mnCount = min(mnCount, currCount);\\n            }\\n            dp[target] = mnCount;\\n        }\\n        return dp[n];\\n    } \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71632,
                "title": "beautiful-8-lines-java-solution",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n            int[] record = new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                record[i] = i;\\n                for(int j=1;j*j<=i;j++){\\n                    record[i] = Math.min(record[i-j*j]+1,record[i]);\\n                }\\n            }\\n            return record[n];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int[] record = new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                record[i] = i;\\n                for(int j=1;j*j<=i;j++){\\n                    record[i] = Math.min(record[i-j*j]+1,record[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71587,
                "title": "explanation-of-the-dp-solution",
                "content": "The most common solution for this problem is using DP, BFS or Number theory. Here I will give a brief explanation of the DP solution. The solution is as following:\\n\\n    public int NumSquares(int n) {\\n           int[] DP = new int[n + 1];\\n            for (int i = 1; i <= n; i++)\\n            {\\n                int min= int.MaxValue;\\n                for (int j = 1; j * j <= i; j++)\\n                {\\n                    min= Math.Min(min, DP[i - j * j] + 1);\\n                }\\n                DP[i] = min;\\n            }\\n            return DP[n];\\n    }\\n\\nFirst of all, we created the DP array as usual. This DP array stands for the least number of perfect square numbers for its index. For example DP[13]=2 stands for if you want to decompose 13 into some perfect square numbers, it will contains at least two terms which are 3*3 and 2*2. \\n\\nAfter the initialization of the DP array. We want to iterate through the array to fill all indices. During each iteration we're actually doing this: `dp[i] = 1 + min (dp[i-j*j] for j*j<=i)`. The formula itself is a little bit hard to understand. Here's an example of how it works: (C#)\\n\\nSuppose we want to get DP[13] and we already have the previous indices filled. \\n\\nDP[13] = DP[13-1x1]+DP[1] = DP[12]+1 = 3;\\n\\n\\nDP[13] = DP[13-2x2]+DP[2x2] = DP[9]+1 = 2;\\n\\n\\nDP[13] = DP[13-3x3] + DP[3x3] = DP[4] + 1 = 2;\\n\\nWe pick the smallest one which is 2 so DP[13] = 2. Hope it helps.",
                "solutionTags": [],
                "code": "The most common solution for this problem is using DP, BFS or Number theory. Here I will give a brief explanation of the DP solution. The solution is as following:\\n\\n    public int NumSquares(int n) {\\n           int[] DP = new int[n + 1];\\n            for (int i = 1; i <= n; i++)\\n            {\\n                int min= int.MaxValue;\\n                for (int j = 1; j * j <= i; j++)\\n                {\\n                    min= Math.Min(min, DP[i - j * j] + 1);\\n                }\\n                DP[i] = min;\\n            }\\n            return DP[n];\\n    }\\n\\nFirst of all, we created the DP array as usual. This DP array stands for the least number of perfect square numbers for its index. For example DP[13]=2 stands for if you want to decompose 13 into some perfect square numbers, it will contains at least two terms which are 3*3 and 2*2. \\n\\nAfter the initialization of the DP array. We want to iterate through the array to fill all indices. During each iteration we're actually doing this: `dp[i] = 1 + min (dp[i-j*j] for j*j<=i)`. The formula itself is a little bit hard to understand. Here's an example of how it works: (C#)\\n\\nSuppose we want to get DP[13] and we already have the previous indices filled. \\n\\nDP[13] = DP[13-1x1]+DP[1] = DP[12]+1 = 3;\\n\\n\\nDP[13] = DP[13-2x2]+DP[2x2] = DP[9]+1 = 2;\\n\\n\\nDP[13] = DP[13-3x3] + DP[3x3] = DP[4] + 1 = 2;\\n\\nWe pick the smallest one which is 2 so DP[13] = 2. Hope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 707517,
                "title": "python-no-dp-o-n",
                "content": "You don\\'t need more than 4 summands ([Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem#:~:text=Lagrange\\'s%20four%2Dsquare%20theorem%2C%20also,sum%20of%20four%20integer%20squares.))\\n\\n\\nIf you cannot find a solution with at most 3 elements, return 4.\\n\\nFor 3 elements this is equivalent to a 3-sum problem. Since the length of the array is `sqrt(N)` and 3-sum can be implemented with quadratic complexity, the overall cost is `O(N)`.\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        arr, i = [], 1\\n        while i**2 <= n:\\n            arr.append(i**2)\\n            i += 1\\n        \\n        #one-sum O(N^(1/2))\\n        if n in arr:\\n            return 1\\n        \\n        #two-sum O(N)\\n        for e in arr:\\n            if n-e in arr:\\n                return 2\\n        \\n        #three-sum O(N)\\n        arr_set = set(arr)\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if n-arr[i]-arr[j] in arr_set:\\n                    return 3\\n        \\n        #four-sum O(1)\\n        return 4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        arr, i = [], 1\\n        while i**2 <= n:\\n            arr.append(i**2)\\n            i += 1\\n        \\n        #one-sum O(N^(1/2))\\n        if n in arr:\\n            return 1\\n        \\n        #two-sum O(N)\\n        for e in arr:\\n            if n-e in arr:\\n                return 2\\n        \\n        #three-sum O(N)\\n        arr_set = set(arr)\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if n-arr[i]-arr[j] in arr_set:\\n                    return 3\\n        \\n        #four-sum O(1)\\n        return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317378,
                "title": "java-3-solutions-bfs-dp-maths-with-explanation",
                "content": "**BFS**\\n\\n```\\n   public int numSquares(int n) {\\n       Queue<Integer> queue = new LinkedList<>();\\n       Set<Integer> reviewedSet = new HashSet<>();\\n         \\n       if(n >0) queue.offer(n);  \\n       int level = 0;\\n       while(!queue.isEmpty()){\\n           level++; \\n           int size = queue.size();\\n           for(int i=0; i<size; i++) {\\n               int val = queue.poll();\\n               if(!reviewedSet.add(val)) continue;\\n               \\n               for(int j=1; j<=Math.sqrt(val); j++){\\n                   if(val-(j*j) == 0) return level;\\n                   queue.offer(val-(j*j));\\n               }\\n           }\\n       }  \\n        \\n       return level;\\n    }\\n```\\n\\n**DP**\\n\\ndp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n```\\ndp[0] = 0 \\ndp[1] = dp[0]+1 = 1\\ndp[2] = dp[1]+1 = 2\\ndp[3] = dp[2]+1 = 3\\ndp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n      = Min{ dp[3]+1, dp[0]+1 } \\n      = 1\\t\\t\\t\\t\\ndp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n      = Min{ dp[4]+1, dp[1]+1 } \\n      = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n       = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n       = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\nand the sample code is like below:\\n```\\n\\n```\\npublic int numSquares(int n) {\\n       int[] dp = new int[n+1];\\n       \\n       Arrays.fill(dp, Integer.MAX_VALUE);\\n       dp[0] = 0;\\n        \\n       for(int i=1; i<=n; i++){\\n               \\n           for(int j=1; j<=Math.sqrt(i); j++){\\n               dp[i] = Math.min(dp[i], (dp[i-(j*j)]+1));\\n           }    \\n       } \\n        \\n        return dp[n];\\n    }\\n```\\nHope it can help to understand the DP solution.\\n\\n**Mathemetics**\\n\\n```\\npublic int numSquares(int n) {\\n\\n// Lagrange\\'s Four Square theorem : every positive integer can be written as the sum of at most four squares\\n       // answer to this question can be 1 or 2 or 3 or 4 only.\\n\\t   \\n\\t   \\n        if(n == 0) return 0;\\n        \\n\\t\\t// case 1:\\n        if(isSqrt(n)) return 1;\\n        \\n\\t\\t   // case 2 :If answer is 2 => one factor has to be (int)square_root and remaining other number has to be a perfect square\\n        for(int i=1; i<=Math.sqrt(n); i++){\\n            if(isSqrt(n-(i*i))) return 2;\\n        }\\n        \\n\\t\\t // case 4: a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for some int k and m see \"not of\" in above line\\n\\t\\t \\n        // in order to pass 28 as 4\\n        while(n%4 ==0)\\n            n=n/4;\\n        \\n        if(n%8 == 7){\\n            return 4;    // handling 4^k\\n        }\\n        \\n\\t\\t // case 3\\n        return 3;\\n    }\\n    \\n    private boolean isSqrt(int n){\\n        int sqrt = (int)Math.sqrt(n);\\n        \\n        return n-(sqrt*sqrt)==0;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n   public int numSquares(int n) {\\n       Queue<Integer> queue = new LinkedList<>();\\n       Set<Integer> reviewedSet = new HashSet<>();\\n         \\n       if(n >0) queue.offer(n);  \\n       int level = 0;\\n       while(!queue.isEmpty()){\\n           level++; \\n           int size = queue.size();\\n           for(int i=0; i<size; i++) {\\n               int val = queue.poll();\\n               if(!reviewedSet.add(val)) continue;\\n               \\n               for(int j=1; j<=Math.sqrt(val); j++){\\n                   if(val-(j*j) == 0) return level;\\n                   queue.offer(val-(j*j));\\n               }\\n           }\\n       }  \\n        \\n       return level;\\n    }\\n```\n```\\ndp[0] = 0 \\ndp[1] = dp[0]+1 = 1\\ndp[2] = dp[1]+1 = 2\\ndp[3] = dp[2]+1 = 3\\ndp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n      = Min{ dp[3]+1, dp[0]+1 } \\n      = 1\\t\\t\\t\\t\\ndp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n      = Min{ dp[4]+1, dp[1]+1 } \\n      = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n       = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n       = 2\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t.\\ndp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\nand the sample code is like below:\\n```\n```\\npublic int numSquares(int n) {\\n       int[] dp = new int[n+1];\\n       \\n       Arrays.fill(dp, Integer.MAX_VALUE);\\n       dp[0] = 0;\\n        \\n       for(int i=1; i<=n; i++){\\n               \\n           for(int j=1; j<=Math.sqrt(i); j++){\\n               dp[i] = Math.min(dp[i], (dp[i-(j*j)]+1));\\n           }    \\n       } \\n        \\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1173545,
                "title": "java-all-3-solutions-recursive-memoized-dp",
                "content": "**Recursive(TLE):**\\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        return helper(n);\\n    }\\n    \\n    public int helper(int n){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i)));\\n        }\\n        return min+1;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        int arr[]=new int[n+1];\\n        return helper(n,arr);\\n    }\\n    \\n    public int helper(int n,int arr[]){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        if(arr[n]>0) return arr[n];\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i),arr));\\n        }\\n        arr[n]=min+1;\\n        return min+1;\\n    }\\n}\\n```\\n\\n**Dynamic Programming:**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int [n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<dp.length;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                min=Math.min(min,dp[i-j*j]);\\n            }\\n            dp[i]=min+1;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n){\\n        return helper(n);\\n    }\\n    \\n    public int helper(int n){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i)));\\n        }\\n        return min+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n){\\n        int arr[]=new int[n+1];\\n        return helper(n,arr);\\n    }\\n    \\n    public int helper(int n,int arr[]){\\n        if(n<0) return Integer.MAX_VALUE;  //Taking min later on\\n        if(n==0) return 0;\\n        \\n        if(arr[n]>0) return arr[n];\\n        \\n        int min=n;\\n        \\n        for(int i=1;i*i<=n;i++){\\n            min=Math.min(min,helper(n-(i*i),arr));\\n        }\\n        arr[n]=min+1;\\n        return min+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int [n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<dp.length;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                min=Math.min(min,dp[i-j*j]);\\n            }\\n            dp[i]=min+1;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725325,
                "title": "c-bottom-up-top-down-dynamic-programming",
                "content": "The concept is similar to Coin Change Problem.\\nexcept the coins array, we can use all the squares until `n` (example for n=18, your coins will be `[1,4,9,16]`)\\n\\nSpace : `O(n)`\\nTime : `O(n*sqrt(n))`\\n### Top Down Method\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int> &dp) {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        dp[n] = INT_MAX;\\n        for(int i=1; i*i<=n; i++) {\\n            dp[n] = min(dp[n], solve(n-(i*i), dp)+1);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, -1);\\n        int ans = solve(n, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\n### Bottom Up Method\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, INT_MAX);\\n        dp[0] = 0;\\n        for(int sq=1; sq<=n; sq++) {\\n            // sq is the current number to be checked\\n            for(int i=1; i*i<=sq; i++) {\\n                dp[sq] = min(dp[sq], dp[sq-(i*i)]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int> &dp) {\\n        if (n == 0) return 0;\\n        if (dp[n] != -1) return dp[n];\\n        dp[n] = INT_MAX;\\n        for(int i=1; i*i<=n; i++) {\\n            dp[n] = min(dp[n], solve(n-(i*i), dp)+1);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, -1);\\n        int ans = solve(n, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector <int> dp(n+1, INT_MAX);\\n        dp[0] = 0;\\n        for(int sq=1; sq<=n; sq++) {\\n            // sq is the current number to be checked\\n            for(int i=1; i*i<=sq; i++) {\\n                dp[sq] = min(dp[sq], dp[sq-(i*i)]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71648,
                "title": "sharing-simple-bfs-python-solution",
                "content": "def minSquare(n):\\n\\n\\ts = [i*i for i in range(1,int(math.sqrt(n))+1)] # Square numbers <= n\\n\\tl = 0  # BFS level\\n\\tcurrentLevel = [0]  # List of numbers in BFS level l\\n\\n\\twhile True:\\n\\t\\tnextLevel = []\\n\\t\\tfor a in currentLevel:\\n\\t\\t\\tfor b in s:\\n\\t\\t\\t\\tif a+b == n: return l+1  # Found n\\n\\t\\t\\t\\tif a+b < n:  nextLevel.append(a+b)\\n\\t\\tcurrentLevel = list(set(nextLevel))  # Remove duplicates\\n\\t\\tl += 1",
                "solutionTags": [],
                "code": "def minSquare(n):\\n\\n\\ts = [i*i for i in range(1,int(math.sqrt(n))+1)] # Square numbers <= n\\n\\tl = 0  # BFS level\\n\\tcurrentLevel = [0]  # List of numbers in BFS level l\\n\\n\\twhile True:\\n\\t\\tnextLevel = []\\n\\t\\tfor a in currentLevel:\\n\\t\\t\\tfor b in s:\\n\\t\\t\\t\\tif a+b == n: return l+1  # Found n\\n\\t\\t\\t\\tif a+b < n:  nextLevel.append(a+b)\\n\\t\\tcurrentLevel = list(set(nextLevel))  # Remove duplicates\\n\\t\\tl += 1",
                "codeTag": "Python3"
            },
            {
                "id": 71662,
                "title": "very-straightforward-c-dp-solution",
                "content": "For each i , the max # of perfect square is always i (when square = 1*1). So the boundary of each dp[i] = i.\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) {\\n            if (n == 0) return 0;\\n            \\n            vector<int> dp(n+1, 0);\\n            \\n            for (int i=0; i<=n; ++i) {\\n                dp[i] = i;\\n                for (int j = 2; j<=sqrt(i); ++j) {\\n                    dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n                }\\n            }\\n            \\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n            if (n == 0) return 0;\\n            \\n            vector<int> dp(n+1, 0);\\n            \\n            for (int i=0; i<=n; ++i) {\\n                dp[i] = i;\\n                for (int j = 2; j<=sqrt(i); ++j) {\\n                    dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 476318,
                "title": "math-solution-explained-beats-100-javascript-whiteboard",
                "content": "*Lagrange\\'s theorem* for four squares states:\\n**Every number can be written as the sum of four squares of integers**\\n so my potential answers are **0,1,2,3,4**\\n*  **0** never happens because there\\'s always an answer\\n*  **1** happens when the number itself is a valid square \\n\\nSo **2,3,4** are the only available solutions.\\n *Legendre\\'s* three square theorem states: \\n**A number  n can be written as the sum of  at most three squares if n  =/= 4^a (8*b+7)**\\n\\nSo I can immediately deduce if it can be  written as a sum of 4 if  n==4^a (8*b+7), by contradicting the above Theorem.\\nAll  I have to do is divide n by 4 as many times as possible and mod8 the final result, to test if result%8==7\\nIf result%8==7, Legendre\\'s theorem is contradicted and my number cannot be written as a sum of (at most) three squares. Therefore utilizing Lagrange\\'s theorem, my solution is immediately 4.\\n\\n\\nOtherwise, having ruled out the option 4, I have 2 and 3 remaining as the potential solutions.\\n\\nI can manually check If It\\'s a sum of 2 numbers:\\nsay that n=a^2 +b^2 then I can easily find a^2 If i search for every number less than n.\\nIf i happen to find any number x, such that n-x*x is a valid square, then i m done, because\\nn =x^2 + (n-x^2)^2  (a sum of 2 squares)\\n\\nHaving ruled out the solution 2, only 3 remains as the only solution\\n\\nHere\\'s a whiteboard recap:\\n![image](https://assets.leetcode.com/users/georgechryso/image_1578682701.png)\\n\\n\\n```\\nvar numSquares=n=>{\\n\\n    //returns if the number x is a valid square root ( can be represented as the square of an integer)\\n    let isSquare=x=>Math.floor(Math.sqrt(x))**2===x\\n\\n    if(isSquare(n))\\n\\t\\treturn 1 // that would be the fact that its equal to itself\\n\\n    // Legendre\\'s three square theorem: A natural number n can be represented as \\n\\t// the sum of AT MOST three squares of integers if and only if : n!= 4^x ( 8*m+7)\\n    while(n%4===0)\\n\\t\\tn/=4\\n\\t//Try contradicting Legendre\\n    if(n%8===7) \\n\\t\\treturn 4 \\n\\t\\t\\n    // Manually checking for result 2, because Legendre states  AT MOST 3, \\n\\t// so 2 is possible aswell\\n    for (let i = 0; i <=n ; i++) \\n        // if x=n-i*i   and x is a valid square then OBVIOUSLY\\n        // n=i^2 +sqrt(x)^2  ,so n is a square of two numbers   \\n        if(isSquare(n-i*i))\\n\\t\\t\\treturn 2\\n    \\n\\t// Legendre applies\\n    return 3\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar numSquares=n=>{\\n\\n    //returns if the number x is a valid square root ( can be represented as the square of an integer)\\n    let isSquare=x=>Math.floor(Math.sqrt(x))**2===x\\n\\n    if(isSquare(n))\\n\\t\\treturn 1 // that would be the fact that its equal to itself\\n\\n    // Legendre\\'s three square theorem: A natural number n can be represented as \\n\\t// the sum of AT MOST three squares of integers if and only if : n!= 4^x ( 8*m+7)\\n    while(n%4===0)\\n\\t\\tn/=4\\n\\t//Try contradicting Legendre\\n    if(n%8===7) \\n\\t\\treturn 4 \\n\\t\\t\\n    // Manually checking for result 2, because Legendre states  AT MOST 3, \\n\\t// so 2 is possible aswell\\n    for (let i = 0; i <=n ; i++) \\n        // if x=n-i*i   and x is a valid square then OBVIOUSLY\\n        // n=i^2 +sqrt(x)^2  ,so n is a square of two numbers   \\n        if(isSquare(n-i*i))\\n\\t\\t\\treturn 2\\n    \\n\\t// Legendre applies\\n    return 3\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71628,
                "title": "python-accepted-solution",
                "content": "I've seen that the dp solution is not accepted in Python. Some use static *dp* in order to use it. And we can also solve it using number theory knowledge. But **what if in a competition we don't know that theory? What if we are not allowed to use static dp?** Here is an accepted solution using BFS:\\n\\n    class Solution(object):\\n        def numSquares(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n           \\n            q1 = [0]\\n            q2 = []\\n            level = 0\\n            visited = [False] * (n+1)\\n            while True:\\n                level += 1\\n                for v in q1:\\n                    i = 0\\n                    while True:\\n                        i += 1\\n                        t = v + i * i\\n                        if t == n: return level\\n                        if t > n: break\\n                        if visited[t]: continue\\n                        q2.append(t)\\n                        visited[t] = True\\n                q1 = q2\\n                q2 = []\\n                    \\n            return 0",
                "solutionTags": [],
                "code": "I've seen that the dp solution is not accepted in Python. Some use static *dp* in order to use it. And we can also solve it using number theory knowledge. But **what if in a competition we don't know that theory? What if we are not allowed to use static dp?** Here is an accepted solution using BFS:\\n\\n    class Solution(object):\\n        def numSquares(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n           \\n            q1 = [0]\\n            q2 = []\\n            level = 0\\n            visited = [False] * (n+1)\\n            while True:\\n                level += 1\\n                for v in q1:\\n                    i = 0\\n                    while True:\\n                        i += 1\\n                        t = v + i * i\\n                        if t == n: return level\\n                        if t > n: break\\n                        if visited[t]: continue\\n                        q2.append(t)\\n                        visited[t] = True\\n                q1 = q2\\n                q2 = []\\n                    \\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 1520667,
                "title": "c-simple-and-easy-dp-solution",
                "content": "**Idea:**\\nThis question is very similar to coin change https://leetcode.com/problems/coin-change/discuss/1104203/C%2B%2B-Super-Simple-and-Short-Dynamic-Programming-Solution.\\nThe only difference is that in coin change we get a vector of coins and here we know that the coins are all the perfect squares.\\nSo our first step will be to construct a \"coin\" vector.\\nThen, we do it the same way as coin change.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        int p = 1, curr = 1;\\n        \\n        while (curr <= n) {\\n            curr = pow(p++, 2);\\n            squares.push_back(curr);\\n        }\\n        \\n        vector<int> dp(n+1, n+1);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (auto s : squares)\\n                if (s <= i) dp[i] = min(dp[i], dp[i-s]+1);\\n\\n        return dp[n];\\n    }\\n};\\n\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        int p = 1, curr = 1;\\n        \\n        while (curr <= n) {\\n            curr = pow(p++, 2);\\n            squares.push_back(curr);\\n        }\\n        \\n        vector<int> dp(n+1, n+1);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++)\\n            for (auto s : squares)\\n                if (s <= i) dp[i] = min(dp[i], dp[i-s]+1);\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065202,
                "title": "python-bfs-with-tree-illustration-and-explanation",
                "content": "Why use Breadth-First Search (BFS)? \\n\\nRefer to the below tree (not complete), I draw this tree where the root is n and the difference between two nodes is a perfect square number. We want to get the least number of perfect square numbers that sum to ```n```. This **is equivalent to** find the shortest path from node ```n``` to node ```0```.\\n\\nHow I code:\\n1. Use list comprehension to generate all perfect squares that are less than the target n.\\n2. Use queue to store ```[n, d]``` (node and current depth).\\n3. Use a set ```seen``` to record the node we have seen to avoid duplicated calculation.\\n4. BFS the queue, when the node is a perfect square, return the current depth ```d```; Otherwise, if we haven\\'t calculate ```node-s```, add ```node-s``` to the ```seen``` and the ```(node-s, d+1)``` to the ```queue```.\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        sq = [x*x for x in range(1,n) if x*x <= n]\\n        queue = deque([(n,1)])\\n        seen = set()\\n        seen.add(n)\\n        while queue:\\n            node, d = queue.popleft()\\n            if node in sq:\\n                return d\\n            for s in sq:\\n                if node <= s:\\n                    break\\n                if node - s not in seen:\\n                    seen.add(node - s)\\n                    queue.append((node - s, d + 1))\\n        return n\\n```\\nHope this helps. Feel free to comment if you have any questions.\\n![image](https://assets.leetcode.com/users/images/d3a0f3ce-38fc-4a9e-9144-3126789cc3d8_1653267079.7320004.png)\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```n```\n```n```\n```0```\n```[n, d]```\n```seen```\n```d```\n```node-s```\n```node-s```\n```seen```\n```(node-s, d+1)```\n```queue```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        sq = [x*x for x in range(1,n) if x*x <= n]\\n        queue = deque([(n,1)])\\n        seen = set()\\n        seen.add(n)\\n        while queue:\\n            node, d = queue.popleft()\\n            if node in sq:\\n                return d\\n            for s in sq:\\n                if node <= s:\\n                    break\\n                if node - s not in seen:\\n                    seen.add(node - s)\\n                    queue.append((node - s, d + 1))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238340,
                "title": "easy-understanding-solutions-recursion-memoization-dp",
                "content": "**IF YOU LIKE THE SOLUTION PLEASE UPVOTE IT.**\\n\\n**Recursive solution:(TLE)**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n       if(n==0){\\n           return 0;\\n       } \\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=numSquares(n-i*i);\\n            minvalue=min(minvalue,minperfectsquarepro);\\n        }\\n        minvalue+=1;\\n    return minvalue;   \\n    }\\n};\\n```\\n**Memoization:**\\n**Time complexity:O(n\\u221An);**\\n```\\nclass Solution {\\npublic:\\n    int memodp(int n,vector<int> &dp){\\n\\t//we have to pass the vector by reference otherwise it gives TLE because it use different memory at every call stack.\\n        if(n==0){\\n           dp[0]=0;\\n           return 0;\\n       } \\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=memodp(n-i*i,dp);\\n            minvalue=min(minvalue,minperfectsquarepro+1);\\n        }\\n        // minvalue+=1;\\n        dp[n]=minvalue;\\n    return minvalue;  \\n    }\\n    int numSquares(int n) {\\n       vector<int>dp(n+1,-1);\\n        return memodp(n,dp);\\n    }\\n};\\n```\\n**Dynamic Programming:**\\n**Time complexity:O(n\\u221An);**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        dp[0]=0;\\n        for(int problem=1;problem<=n;problem++){\\n        int minvalue=INT_MAX;\\n            for(int i=1;i*i<=problem;i++){\\n                int sub=dp[problem-i*i];\\n                minvalue=min(minvalue,sub+1);\\n            }\\n            dp[problem]=minvalue;\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**IF YOU LIKE THE SOLUTION PLEASE UPVOTE IT.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n       if(n==0){\\n           return 0;\\n       } \\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=numSquares(n-i*i);\\n            minvalue=min(minvalue,minperfectsquarepro);\\n        }\\n        minvalue+=1;\\n    return minvalue;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int memodp(int n,vector<int> &dp){\\n\\t//we have to pass the vector by reference otherwise it gives TLE because it use different memory at every call stack.\\n        if(n==0){\\n           dp[0]=0;\\n           return 0;\\n       } \\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int minvalue=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int minperfectsquarepro=memodp(n-i*i,dp);\\n            minvalue=min(minvalue,minperfectsquarepro+1);\\n        }\\n        // minvalue+=1;\\n        dp[n]=minvalue;\\n    return minvalue;  \\n    }\\n    int numSquares(int n) {\\n       vector<int>dp(n+1,-1);\\n        return memodp(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        dp[0]=0;\\n        for(int problem=1;problem<=n;problem++){\\n        int minvalue=INT_MAX;\\n            for(int i=1;i*i<=problem;i++){\\n                int sub=dp[problem-i*i];\\n                minvalue=min(minvalue,sub+1);\\n            }\\n            dp[problem]=minvalue;\\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006278,
                "title": "easy-python-dp-solution-with-explanation-dry-run",
                "content": "Simple python solution using DP.\\nLets concider n = 9\\n1. Create an array of size n+1, and fill the array with respective index.\\nex. [0,1,2,3,4,5,6]\\n2. Iterate over \"dp\" array.\\n3. For each index \"i\" in \"dp\" array check how many time do we have to reduce the value at index \"i\" to reach 0.\\n3.1 We start checking from 1 upto sqrt(n)\\n3.2 We find a way that can take us even lesser amount of steps to reach 0.\\nex. \\ndp = [0,1,2,3,4,5,6,7,8,9]   for i = 0,1,2,3\\ndp = [0,1,2,3, min(4,1) ,5,6,7,8,9]   for i = 4      \\ndp = [0,1,2,3,4, min(5, 2) ,6,7,8,9]   for i = 5\\ndp = [0,1,2,3,4,5, min(6, 3) ,7,8,9]   for i = 6    \\ndp = [0,1,2,3,4,5,6, min(7, 4) ,8,9]   for i = 7    \\ndp = [0,1,2,3,4,5,6,7, min(8, 2) ,9]   for i = 8    \\ndp = [0,1,2,3,4,5,6,7,8, min(9, 3, 1) ]   for i = 9    \\n\\nfinal dp arrar = [0,1,2,3,1,2,3,4,2,1]\\n\\nHence we are taking (step)*(number of step)  towards 0 when\\nj = 1 we take (1^2)*9 = 9 steps\\nj = 2 we take (2^2)*2 + (1^2)*1 = 3 steps\\nj = 3 we take (3^2)*3 = 1 step\\n\\nand then select the minimum step as answer\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# step 1\\n        dp = [i for i in range(n+1)]\\n        \\n\\t\\t# step 2\\n        for i in range(n+1):\\n\\t        j = 1\\n\\t\\t\\t# step 3\\n\\t        while j*j <= i:\\n\\t            dp[i] = min(dp[i], dp[i-(j*j)] + 1)\\n\\t            j += 1\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# step 1\\n        dp = [i for i in range(n+1)]\\n        \\n\\t\\t# step 2\\n        for i in range(n+1):\\n\\t        j = 1\\n\\t\\t\\t# step 3\\n\\t        while j*j <= i:\\n\\t            dp[i] = min(dp[i], dp[i-(j*j)] + 1)\\n\\t            j += 1\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71478,
                "title": "why-is-python-dp-solution-tle",
                "content": " I made these two lists static however still TLE\\n   \\n       class Solution(object):\\n            def numSquares(self, n):\\n                \"\"\"\\n                :type n: int\\n                :rtype: int\\n                \"\"\"\\n                self.dp = [i for i in range(n+1)]\\n                self.squares = [i*i for i in range(1, int(n**0.5) + 1)]\\n                \\n                for i in range(1, n+1):\\n                    for sq in self.squares:\\n                        if i - sq < 0:\\n                            break \\n                        self.dp[i] = min(self.dp[i], self.dp[i - sq] + 1)\\n                        \\n                return self.dp[-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": " I made these two lists static however still TLE\\n   \\n       class Solution(object):\\n            def numSquares(self, n):\\n                \"\"\"\\n                :type n: int\\n                :rtype: int\\n                \"\"\"\\n                self.dp = [i for i in range(n+1)]\\n                self.squares = [i*i for i in range(1, int(n**0.5) + 1)]\\n                \\n                for i in range(1, n+1):\\n                    for sq in self.squares:\\n                        if i - sq < 0:\\n                            break \\n                        self.dp[i] = min(self.dp[i], self.dp[i - sq] + 1)\\n                        \\n                return self.dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 71612,
                "title": "58ms-java-dp-solution-beating-over-90",
                "content": "    public class Solution {\\n    /**\\n     * s[i] denotes the least number of square numbers that add up to n\\n     * initial s[i] as maximum integer\\n     * for i from 1 to n, \\n     *      if i is perfect square, s[i]=1, \\n     *      otherwise get the square root of the maximum perfect square smaller than i\\n     * for j from 1 to square root, \\n     *      if(s[i-j*j]+1<s[i]) update s[i] as s[i-j*j]+1\\n     * \\n     * */\\n    public int numSquares(int n) {\\n        int[] s = new int[n+1];\\n        for(int i=0;i<n+1;i++) s[i] = Integer.MAX_VALUE;\\n        //note to me: no need to store a list of perfect squares, knowing the square root of the largest perfect square is sufficient\\n        //List<Integer> squares = new ArrayList<Integer>();\\n        for(int i = 1;i<n+1;i++){\\n            int sqrt = (int) Math.sqrt(i);\\n            if(i == sqrt*sqrt){s[i] = 1;continue;}\\n            for(int j = 1;j<=sqrt;j++){\\n                if(s[i-j*j]+1<s[i]) s[i] = s[i-j*j]+1;\\n            }\\n        }\\n        return s[n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    /**\\n     * s[i] denotes the least number of square numbers that add up to n\\n     * initial s[i] as maximum integer\\n     * for i from 1 to n, \\n     *      if i is perfect square, s[i]=1, \\n     *      otherwise get the square root of the maximum perfect square smaller than i\\n     * for j from 1 to square root, \\n     *      if(s[i-j*j]+1<s[i]) update s[i] as s[i-j*j]+1\\n     * \\n     * */\\n    public int numSquares(int n) {\\n        int[] s = new int[n+1];\\n        for(int i=0;i<n+1;i++) s[i] = Integer.MAX_VALUE;\\n        //note to me: no need to store a list of perfect squares, knowing the square root of the largest perfect square is sufficient\\n        //List<Integer> squares = new ArrayList<Integer>();\\n        for(int i = 1;i<n+1;i++){\\n            int sqrt = (int) Math.sqrt(i);\\n            if(i == sqrt*sqrt){s[i] = 1;continue;}",
                "codeTag": "Java"
            },
            {
                "id": 3455332,
                "title": "all-three-main-approaches-using-dp-in-c",
                "content": "# recursive soln\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0)\\n            return 0;\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp));\\n        }\\n        return ans;\\n    }\\n    int numSquares(int n) {\\n        return solve( n);\\n    }\\n};\\n```\\n# rec+mem\\n```\\nclass Solution {\\npublic:\\n    int solve(int n , vector<int>&dp){\\n        if(n==0)\\n            return 0;\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve( n,dp);\\n    }\\n};\\n```\\n# tabulation\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        for(int j=1;j*j<=n;j++){\\n            int temp=j*j;\\n            if(i-temp>=0)\\n            dp[i]=min(dp[i],1+dp[i-temp]);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        \\n        return solve( n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e729b48b-a4d8-47de-b4da-a9f14e4a6232_1682461504.3277745.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0)\\n            return 0;\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp));\\n        }\\n        return ans;\\n    }\\n    int numSquares(int n) {\\n        return solve( n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n , vector<int>&dp){\\n        if(n==0)\\n            return 0;\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i*i<=n;i++){\\n            int temp=i*i;\\n            ans=min(ans,1+solve(n-temp,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve( n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        for(int j=1;j*j<=n;j++){\\n            int temp=j*j;\\n            if(i-temp>=0)\\n            dp[i]=min(dp[i],1+dp[i-temp]);\\n        }\\n        return dp[n];\\n    }\\n    int numSquares(int n) {\\n        \\n        return solve( n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709113,
                "title": "c-without-dp-lagrange-s-four-square-theorem-faster-than-90-solutions",
                "content": "Upvote if you find it useful!\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\t//using Lagrange\\'s four-square theorem, also known as Bachet\\'s conjecture, states that every natural \\n\\t\\t\\t//number can be represented as the sum of four integer squares. \\n\\n\\t\\t\\tvector<int> sqr;\\n\\t\\t\\tint x=1;\\n\\t\\t\\twhile(x*x<=n){ //saving all squares till n\\n\\t\\t\\t\\tsqr.push_back(x*x);\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}\\n\\t\\t\\tint size= sqr.size();\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){ //for one\\n\\t\\t\\t\\tif(sqr[i]==n)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){\\n\\t\\t\\t\\tfor(int j=i; j<size; j++){ //for two\\n\\t\\t\\t\\t\\tif(sqr[i]+sqr[j]==n)\\n\\t\\t\\t\\t\\t\\treturn 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<size; i++){ //for three\\n\\t\\t\\t\\tfor(int j=i; j<size; j++){\\n\\t\\t\\t\\t\\tfor(int k=j; k<size; k++){\\n\\t\\t\\t\\t\\t\\tif(sqr[i]+sqr[j]+sqr[k]==n)\\n\\t\\t\\t\\t\\t\\t\\treturn 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 4; //if not 1,2,3 then definitely 4\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\t//using Lagrange\\'s four-square theorem, also known as Bachet\\'s conjecture, states that every natural \\n\\t\\t\\t//number can be represented as the sum of four integer squares. \\n\\n\\t\\t\\tvector<int> sqr;\\n\\t\\t\\tint x=1;\\n\\t\\t\\twhile(x*x<=n){ //saving all squares till n\\n\\t\\t\\t\\tsqr.push_back(x*x);\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2838514,
                "title": "c-2-line-most-easy-dp-solution-must-read",
                "content": "dp\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n    vector<int> dp(n+1,1000000);\\n    dp[0]=0;\\n    for(int i=1;i<=n;i++){\\n        for(int j=0;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n    }\\n    return dp[n];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n    vector<int> dp(n+1,1000000);\\n    dp[0]=0;\\n    for(int i=1;i<=n;i++){\\n        for(int j=0;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n    }\\n    return dp[n];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71584,
                "title": "simple-java-solution",
                "content": "    public int numSquares(int n) {\\n        int[] min = new int[n+1];\\n        min[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            int tmp = Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                tmp = Math.min(tmp,min[i-j*j]+1);\\n            }\\n            min[i] = tmp;\\n        }\\n        return min[n];\\n    }",
                "solutionTags": [],
                "code": "    public int numSquares(int n) {\\n        int[] min = new int[n+1];\\n        min[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            int tmp = Integer.MAX_VALUE;\\n            for(int j=1;j*j<=i;j++){\\n                tmp = Math.min(tmp,min[i-j*j]+1);\\n            }\\n            min[i] = tmp;\\n        }\\n        return min[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 540782,
                "title": "the-question-is-coin-problem-in-disguise",
                "content": "The above question is similar to leetcode 322 ( Coin Problem ).\\n\\nIn the coin problem we are given set of coins and we need to determine the minimum combination of coin to achive the give amount.\\n\\nThis is exactly what has been asked in the given problem, we need to determine the number of squares which could be used to form the amount ( n ). The list of valid square number would all the squares starting from 0 till square root of give number (n)\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# The list of squareNumber is equivalent to the list of available coins in the Coin-Problem\\n        \\n\\t\\tsquareNumber =[ i**2 for i in range(0, int(n**(1/2)) + 1)] \\n\\t\\t\\n\\t\\tdp = [float(\\'inf\\')]*(n+1)\\n        dp[0] = 0\\n        for num in squareNumber:\\n            for amt in range(1,n+1):\\n                if amt >= num:\\n                    dp[amt] = min(dp[amt],dp[amt-num] + 1)\\n               \\n        return dp[-1]\\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "The above question is similar to leetcode 322 ( Coin Problem ).\\n\\nIn the coin problem we are given set of coins and we need to determine the minimum combination of coin to achive the give amount.\\n\\nThis is exactly what has been asked in the given problem, we need to determine the number of squares which could be used to form the amount ( n ). The list of valid square number would all the squares starting from 0 till square root of give number (n)\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\t\\t# The list of squareNumber is equivalent to the list of available coins in the Coin-Problem\\n        \\n\\t\\tsquareNumber =[ i**2 for i in range(0, int(n**(1/2)) + 1)] \\n\\t\\t\\n\\t\\tdp = [float(\\'inf\\')]*(n+1)\\n        dp[0] = 0\\n        for num in squareNumber:\\n            for amt in range(1,n+1):\\n                if amt >= num:\\n                    dp[amt] = min(dp[amt],dp[amt-num] + 1)\\n               \\n        return dp[-1]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 71660,
                "title": "javascript-solution",
                "content": "```js\\nfunction numSquares(n) {\\n  const dp = [0];\\n  \\n  for (let i = 1; i <= n; i++) {\\n    dp[i] = Number.MAX_VALUE;\\n    for (let j = 1; j*j <= i; j++) {\\n      dp[i] = Math.min(dp[i], dp[i-j*j]+1);\\n    } \\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction numSquares(n) {\\n  const dp = [0];\\n  \\n  for (let i = 1; i <= n; i++) {\\n    dp[i] = Number.MAX_VALUE;\\n    for (let j = 1; j*j <= i; j++) {\\n      dp[i] = Math.min(dp[i], dp[i-j*j]+1);\\n    } \\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522308,
                "title": "java-8-methods-reuse-lc-322",
                "content": "##### 1: Solve using the popular [Change making problem](https://en.wikipedia.org/wiki/Change-making_problem)\\n**Method 1:** Enlist all squares \\u2264 n, followed by [LC 322. Coin Change](https://leetcode.com/problems/coin-change/discuss/334483/Java-or-Iterative-or-Bottom-up-DP)\\n**T/S:** O(n ^ \\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn numSquares(0, squares, n);\\n}\\n\\nprivate int numSquares(int idxSquare, List<Integer> squares, int n) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < 0 || idxSquare >= squares.size())\\n\\t\\treturn -1;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\n\\tfor (int i = 0, maxSquares = n / squares.get(idxSquare); i <= maxSquares; i++)\\n\\t\\tif (n >= i * squares.get(idxSquare)) {\\n\\t\\t\\tvar nCoins = numSquares(idxSquare + 1, squares, n - (i * squares.get(idxSquare)));\\n\\t\\t\\tif (nCoins != -1)\\n\\t\\t\\t\\tminSquares = Math.min(minSquares, nCoins + i);\\n\\t\\t}\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? -1 : minSquares;\\n}\\n```\\n\\n**Method 2:** Top Down DP. Inject memoization in method 1\\n>**T/S:** O(n\\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn (n < 1) ? 0 : numSquares(squares, n, new HashMap<>());\\n}\\n\\nprivate int numSquares(List<Integer> squares, int remainder, Map<Integer, Integer> map) {\\n\\tif (remainder < 0)\\n\\t\\treturn -1; // not valid\\n\\tif (remainder == 0)\\n\\t\\treturn 0; // completed\\n\\tif (map.containsKey(remainder - 1))\\n\\t\\treturn map.get(remainder - 1);\\n\\n\\tvar minCoins = Integer.MAX_VALUE;\\n\\tfor (var square : squares) {\\n\\t\\tvar res = numSquares(squares, remainder - square, map);\\n\\t\\tif (0 <= res && res < minCoins)\\n\\t\\t\\tminCoins = 1 + res;\\n\\t}\\n\\n\\tmap.put(remainder - 1, (minCoins == Integer.MAX_VALUE) ? -1 : minCoins);\\n\\treturn map.get(remainder - 1);\\n}\\n```\\n\\n**Method 3:** Bottom Up DP\\n>**T/S:** O(n\\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, n + 1);\\n\\n\\tfor (var sum = 1; sum <= n; sum++) {\\n\\t\\tfor (var square : squares) {\\n\\t\\t\\tif (square > sum)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdp[sum] = Math.min(dp[sum], 1 + dp[sum - square]);\\n\\t\\t}\\n\\t}\\n\\treturn (dp[n] > n) ? -1 : dp[n];\\n}\\n```\\n---\\n##### 2. Typical DP Approaches. Draw decision tree and optimize\\n\\n**Method 4:** DFS\\n>**T/S:** O(n ^ \\u221An)/O(\\u221An)\\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1);\\n}\\n\\nprivate int numSquares(int n, int i) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j));\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1;\\n}\\n```\\n\\n**Method 5:** DFS with memoization aka Top Down DP. Inject memoization in method 4\\n> **T/S:** O(n\\u221An)/O(n)\\n ```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1, new HashMap<>());\\n}\\n\\nprivate int numSquares(int n, int i, Map<Integer, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j, map));\\n\\n\\tmap.put(n, (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1);\\n\\treturn map.get(n);\\n}\\n```\\n\\n**Method 6:** Bottom Up DP\\n> **T/S:** O(n\\u221An)/O(n)\\n```\\npublic int numSquares(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, Integer.MAX_VALUE);\\n\\n\\tfor (var i = 1; i < dp.length; i++)\\n\\t\\tfor (var j = 1; j * j <= i; j++)\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n\\n\\treturn dp[n];\\n}\\n```\\n\\n**Method 7:** BFS. The first level at which n becomes 0 is the number of perfect squares required.\\n>**T/S:** O(\\u221An ^ h)/O(\\u221An), where h = height of the n-ary tree\\n![image](https://assets.leetcode.com/users/images/d98d646d-b4d3-460a-9eb8-2224bae5100b_1634280581.9635005.png)\\n```\\npublic int numSquares(int n) {\\n\\tvar q = new ArrayDeque<>(List.of(n));\\n\\tvar visited = new HashSet<Integer>();\\n\\tvar level = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlevel++;\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\t\\t\\tfor (var j = 1; j * j <= head; j++) {\\n\\t\\t\\t\\tvar remainder = head - j * j;\\n\\n\\t\\t\\t\\tif (remainder == 0)\\n\\t\\t\\t\\t\\treturn level;\\n\\t\\t\\t\\tif (visited.add(remainder))\\n\\t\\t\\t\\t\\tq.add(remainder);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n;\\n}\\n```\\n\\n**Method 8:** Maths\\n* [Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) states that every natural number can be represented as the sum of four integer squares. This can also be stated as it requires upto 4 squares to sum up to a number, which means the answer to this problem \\u2208 {1, 2, 3, 4}\\n* If n is a perfect square, then answer is 1\\n* If n = a\\xB2 + b\\xB2, then answer is 2\\n* [Legendre\\'s three-square theorem](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) states that a natural number can be represented as the sum of three squares of integers n=x\\xB2+y\\xB2+z\\xB2, iff n is not of the form n= (4^a) (8b+7) for whole numbers a and b. So, if n satisfies the form, then answer is 4 else 3.\\n* This method is just for knowledge purpose and no interviewer will expect it. BFS is the best method for interviews.\\n>**T/S:** O(\\u221An)/O(1)\\n```\\npublic int numSquares(int n) {\\n\\tif (isPerfectSquare(n))\\n\\t\\treturn 1;\\n\\n\\tfor (var i = 1; i * i <= n; i++) {\\n\\t\\tvar sqrt = (int) Math.sqrt(n - i * i);\\n\\t\\tif (sqrt * sqrt == n - i * i)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn satisfiesForm(n) ? 4 : 3;\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n\\tvar sqrt = Math.sqrt(n);\\n\\treturn Math.ceil(sqrt) == Math.floor(sqrt);\\n}\\n\\nprivate boolean satisfiesForm(int n) {\\n\\twhile (n % 4 == 0)\\n\\t\\tn /= 4;\\n\\treturn n % 8 == 7;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn numSquares(0, squares, n);\\n}\\n\\nprivate int numSquares(int idxSquare, List<Integer> squares, int n) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < 0 || idxSquare >= squares.size())\\n\\t\\treturn -1;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\n\\tfor (int i = 0, maxSquares = n / squares.get(idxSquare); i <= maxSquares; i++)\\n\\t\\tif (n >= i * squares.get(idxSquare)) {\\n\\t\\t\\tvar nCoins = numSquares(idxSquare + 1, squares, n - (i * squares.get(idxSquare)));\\n\\t\\t\\tif (nCoins != -1)\\n\\t\\t\\t\\tminSquares = Math.min(minSquares, nCoins + i);\\n\\t\\t}\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? -1 : minSquares;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\treturn (n < 1) ? 0 : numSquares(squares, n, new HashMap<>());\\n}\\n\\nprivate int numSquares(List<Integer> squares, int remainder, Map<Integer, Integer> map) {\\n\\tif (remainder < 0)\\n\\t\\treturn -1; // not valid\\n\\tif (remainder == 0)\\n\\t\\treturn 0; // completed\\n\\tif (map.containsKey(remainder - 1))\\n\\t\\treturn map.get(remainder - 1);\\n\\n\\tvar minCoins = Integer.MAX_VALUE;\\n\\tfor (var square : squares) {\\n\\t\\tvar res = numSquares(squares, remainder - square, map);\\n\\t\\tif (0 <= res && res < minCoins)\\n\\t\\t\\tminCoins = 1 + res;\\n\\t}\\n\\n\\tmap.put(remainder - 1, (minCoins == Integer.MAX_VALUE) ? -1 : minCoins);\\n\\treturn map.get(remainder - 1);\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar squares = new ArrayList<Integer>();\\n\\tfor (var i = 1; i * i <= n; i++)\\n\\t\\tsquares.add(i * i);\\n\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, n + 1);\\n\\n\\tfor (var sum = 1; sum <= n; sum++) {\\n\\t\\tfor (var square : squares) {\\n\\t\\t\\tif (square > sum)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdp[sum] = Math.min(dp[sum], 1 + dp[sum - square]);\\n\\t\\t}\\n\\t}\\n\\treturn (dp[n] > n) ? -1 : dp[n];\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1);\\n}\\n\\nprivate int numSquares(int n, int i) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j));\\n\\n\\treturn (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\treturn numSquares(n, 1, new HashMap<>());\\n}\\n\\nprivate int numSquares(int n, int i, Map<Integer, Integer> map) {\\n\\tif (n == 0)\\n\\t\\treturn 0;\\n\\tif (n < i * i)\\n\\t\\treturn Integer.MAX_VALUE;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar minSquares = Integer.MAX_VALUE;\\n\\tfor (var j = i; j * j <= n; j++)\\n\\t\\tminSquares = Math.min(minSquares, numSquares(n - j * j, j, map));\\n\\n\\tmap.put(n, (minSquares == Integer.MAX_VALUE) ? Integer.MAX_VALUE : minSquares + 1);\\n\\treturn map.get(n);\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tArrays.fill(dp, 1, dp.length, Integer.MAX_VALUE);\\n\\n\\tfor (var i = 1; i < dp.length; i++)\\n\\t\\tfor (var j = 1; j * j <= i; j++)\\n\\t\\t\\tdp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n\\n\\treturn dp[n];\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tvar q = new ArrayDeque<>(List.of(n));\\n\\tvar visited = new HashSet<Integer>();\\n\\tvar level = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlevel++;\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar head = q.poll();\\n\\t\\t\\tfor (var j = 1; j * j <= head; j++) {\\n\\t\\t\\t\\tvar remainder = head - j * j;\\n\\n\\t\\t\\t\\tif (remainder == 0)\\n\\t\\t\\t\\t\\treturn level;\\n\\t\\t\\t\\tif (visited.add(remainder))\\n\\t\\t\\t\\t\\tq.add(remainder);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n;\\n}\\n```\n```\\npublic int numSquares(int n) {\\n\\tif (isPerfectSquare(n))\\n\\t\\treturn 1;\\n\\n\\tfor (var i = 1; i * i <= n; i++) {\\n\\t\\tvar sqrt = (int) Math.sqrt(n - i * i);\\n\\t\\tif (sqrt * sqrt == n - i * i)\\n\\t\\t\\treturn 2;\\n\\t}\\n\\n\\treturn satisfiesForm(n) ? 4 : 3;\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n\\tvar sqrt = Math.sqrt(n);\\n\\treturn Math.ceil(sqrt) == Math.floor(sqrt);\\n}\\n\\nprivate boolean satisfiesForm(int n) {\\n\\twhile (n % 4 == 0)\\n\\t\\tn /= 4;\\n\\treturn n % 8 == 7;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376795,
                "title": "100-o-log-n-python3-solution-lagrange-s-four-square-theorem",
                "content": "**Explanation**: Lagrange\\'s four-square theorem states every natural number can be represented by four integer squares. The default answer is then 4 and we check if 1,2 or 3 is possible. If the input is a perfect square, output 1. If the number can be broken down into two squares, output 2. If the input can\\'t be written in the form 4^k(8m+7) output 3 (*Lagendre proved that a positive integer can be expressed as the sum of three squares if and only if it is not of the form 4^k(8m+7) for integers k and m.*) https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem\\n\\n```\\nclass Solution:\\n    def isSquare(self, n: int) -> bool:\\n        sq = int(math.sqrt(n))\\n        return sq*sq == n\\n        \\n    def numSquares(self, n: int) -> int:\\n        # Lagrange\\'s four-square theorem\\n        if self.isSquare(n):\\n            return 1\\n        while (n & 3) == 0:\\n            n >>= 2\\n        if (n & 7) == 7:\\n            return 4\\n        sq = int(math.sqrt(n)) + 1\\n        for i in range(1,sq):\\n            if self.isSquare(n - i*i):\\n                return 2\\n        return 3\\n```\\nCredit to algorithm blog: http://www.zrzahid.com/least-number-of-perfect-squares-that-sums-to-n/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSquare(self, n: int) -> bool:\\n        sq = int(math.sqrt(n))\\n        return sq*sq == n\\n        \\n    def numSquares(self, n: int) -> int:\\n        # Lagrange\\'s four-square theorem\\n        if self.isSquare(n):\\n            return 1\\n        while (n & 3) == 0:\\n            n >>= 2\\n        if (n & 7) == 7:\\n            return 4\\n        sq = int(math.sqrt(n)) + 1\\n        for i in range(1,sq):\\n            if self.isSquare(n - i*i):\\n                return 2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71553,
                "title": "evolve-from-brute-force",
                "content": "The most intuitive way is to try every square less than n and then solve the same subproblem. Time complexity is much better than O(2^n) but I am not sure how to come up a tighter bound.\\n```\\n    int numSquares(int n) {\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mn+1;\\n    }\\n```\\nLike all dp problems, we can immediately optimize it with memoization and dp. Time complexity is O(n^3/2)\\n```\\n    int numSquares(int n) {\\n        vector<int> mem(n+1);\\n        return numSquares(n,mem);\\n    }\\n    int numSquares(int n, vector<int> &mem) {\\n        if(mem[n]) return mem[n];\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return mem[n] = 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mem[n] = mn+1;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,n);\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) \\n            for(int j=1;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n        return dp[n];\\n    } \\n```\\nFor problems asking for mininum number, BFS may be a good option because it generates the shortest path from the root. Time complexity is similar to dp O(n^3/2). Test cases show BFS is faster than dp. I think it is because BFS only visits numbers that are sum of some squares while dp visits all n numbers.\\n```\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        for(int i=1;i*i<=n;i++) squares.push_back(i*i);\\n        queue<int> q({0});\\n        int level = 0;\\n        vector<bool> vstd(n+1);\\n        while(!q.empty()) {\\n            int s=q.size();\\n            level++;\\n            for(int i=0;i<s;i++) {\\n                int cur=q.front();\\n                q.pop();\\n                if(vstd[cur]) continue;\\n                vstd[cur]=true;\\n                for(auto sq:squares) {\\n                    int nxt = sq+cur;\\n                    if(nxt==n) return level;\\n                    else if(nxt>n) break;\\n                    else q.push(nxt);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n```\\nEventually, the optimal solution is actually O(n^1/2) using math theory. See [details](https://discuss.leetcode.com/topic/23808/o-sqrt-n-in-ruby-c-c)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int numSquares(int n) {\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mn+1;\\n    }\\n```\n```\\n    int numSquares(int n) {\\n        vector<int> mem(n+1);\\n        return numSquares(n,mem);\\n    }\\n    int numSquares(int n, vector<int> &mem) {\\n        if(mem[n]) return mem[n];\\n        int sr = sqrt(n);\\n        if(sr*sr == n) return mem[n] = 1;\\n        int mn = n;\\n        for(int i=1;i<=sr;i++) mn = min(mn, numSquares(n-i*i));\\n        return mem[n] = mn+1;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,n);\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++) \\n            for(int j=1;j*j<=i;j++) dp[i]=min(dp[i],1+dp[i-j*j]);\\n        return dp[n];\\n    } \\n```\n```\\n    int numSquares(int n) {\\n        vector<int> squares;\\n        for(int i=1;i*i<=n;i++) squares.push_back(i*i);\\n        queue<int> q({0});\\n        int level = 0;\\n        vector<bool> vstd(n+1);\\n        while(!q.empty()) {\\n            int s=q.size();\\n            level++;\\n            for(int i=0;i<s;i++) {\\n                int cur=q.front();\\n                q.pop();\\n                if(vstd[cur]) continue;\\n                vstd[cur]=true;\\n                for(auto sq:squares) {\\n                    int nxt = sq+cur;\\n                    if(nxt==n) return level;\\n                    else if(nxt>n) break;\\n                    else q.push(nxt);\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71637,
                "title": "java-solution-o-n-1-2-time-and-o-1-space",
                "content": "public class Solution {\\n\\n        public int numSquares(int n) {\\n            int m = n;\\n            while( m % 4 == 0 )\\n                m = m>>2;\\n            if(m % 8 == 7)\\n                return 4;\\n            \\n            int sqrtOfn = (int) Math.sqrt(n);\\n            if(sqrtOfn * sqrtOfn == n)//Is it a Perfect square?\\n                return 1;\\n            else{\\n                    for(int i = 1; i <= sqrtOfn; ++i){\\n                        int remainder = n - i*i;\\n                        int sqrtOfNum = (int) Math.sqrt(remainder);\\n                        if(sqrtOfNum * sqrtOfNum == remainder)\\n                            return 2;\\n                    }\\n                }\\n             return 3;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n        public int numSquares(int n) {\\n            int m = n;\\n            while( m % 4 == 0 )\\n                m = m>>2;\\n            if(m % 8 == 7)\\n                return 4;\\n            \\n            int sqrtOfn = (int) Math.sqrt(n);\\n            if(sqrtOfn * sqrtOfn == n)//Is it a Perfect square?\\n                return 1;\\n            else{\\n                    for(int i = 1; i <= sqrtOfn; ++i){\\n                        int remainder = n - i*i;\\n                        int sqrtOfNum = (int) Math.sqrt(remainder);\\n                        if(sqrtOfNum * sqrtOfNum == remainder)\\n                            return 2;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2838462,
                "title": "python-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        q=deque()\\n        visited=set()\\n        q.append((0,0))\\n        while q:\\n            s,count=q.popleft()\\n            count+=1\\n            for i in range(1,n+1):\\n                temp=s+i*i\\n                if temp>n:\\n                    break\\n                if temp==n:\\n                    return count\\n                if temp not in visited:\\n                    visited.add(temp)\\n                    q.append((temp,count))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        q=deque()\\n        visited=set()\\n        q.append((0,0))\\n        while q:\\n            s,count=q.popleft()\\n            count+=1\\n            for i in range(1,n+1):\\n                temp=s+i*i\\n                if temp>n:\\n                    break\\n                if temp==n:\\n                    return count\\n                if temp not in visited:\\n                    visited.add(temp)\\n                    q.append((temp,count))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832376,
                "title": "java-dp-o-sqrt-n-solution",
                "content": "# Explanation\\n\\nFor every perfect square we go on find the number of steps required to form number **n**.\\nWe take an array dp of length **n+1** and start iterating from **i=1 and  i\\\\*i <= n**.\\n\\nrecursive formula :- **dp[i] = min( dp[j-square] + 1 , dp[j] );**\\n\\nconsider for sample testcase 1 :-\\n\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0  max max max max max max max max max max max max\\n```\\n\\n**consider 1st Perfect square as 1 with square root ind = 1**\\n\\n**while(ind*ind <= n)**\\n\\nsquare = ind*ind;\\n\\nNow for every square iterate the dp array from **square to n** and use the recurssive formula \\n\\n**For square = 1**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\n```\\n\\n**For square = 4**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   1   2   3   4   2   3   4   5   3\\n```\\n\\n**For square = 9**\\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   1   2   3   3\\n ```\\n \\n Here, when j=12\\n \\n dp[j] = 3;\\n dp[j-square]+1 = 4;\\n hence we keep it as it is;\\n\\nAnd we get our final ans as dp[n] = 3;\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int [] dp = new int[n+1];\\n        \\n        for(int i=0;i<=n;i++)dp[i] = Integer.MAX_VALUE;\\n        \\n        dp[0]=0;\\n        int ind=1;\\n        \\n        while(ind*ind <= n){\\n            int square = ind*ind;\\n            \\n            for(int i=square;i<=n;i++){\\n                dp[i] = Math.min(dp[i-square]+1,dp[i]);\\n            }\\n            ind++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0  max max max max max max max max max max max max\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   1   2   3   4   2   3   4   5   3\\n```\n```\\nindex :-   0   1   2   3   4   5   6   7   8   9  10  11  12\\ndp    :-   0   1   2   3   4   5   6   7   8   1   2   3   3\\n ```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int [] dp = new int[n+1];\\n        \\n        for(int i=0;i<=n;i++)dp[i] = Integer.MAX_VALUE;\\n        \\n        dp[0]=0;\\n        int ind=1;\\n        \\n        while(ind*ind <= n){\\n            int square = ind*ind;\\n            \\n            for(int i=square;i<=n;i++){\\n                dp[i] = Math.min(dp[i-square]+1,dp[i]);\\n            }\\n            ind++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444851,
                "title": "python-solution-of-dp-bfs",
                "content": "Solution one: DP\\n \\ndp[i] represents how many squares number i needs at least \\ntransmisson is dp[i] = min(dp[i],dp[i-j*j]+1)\\n```\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [i for i in range(n+1)]\\n        for i in range(2,n+1):\\n            for j in range(1,int(i ** 0.5) + 1):\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[n]\\n```\\nSolution Two: BFS\\nIf we use BFS directly, (I mean in my method without have_been_put  array), the memory limit will exceeds. This is becasue some values we have already visited and if it has been visited before, it must have fewer steps to reach there.\\n\\nHere is my solution:\\n1) Create a queue to record the current num and have many steps have been already taken\\n2) While the queue is not empty, pop the value and put all the possible values = num- j*j (j is square samller than num)\\n3) If the current num is equal to 0, we got the correct answer! Otherwise keep looking.\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque([[n,0]])\\n        have_been_put = [0 for i in range(n+1)]\\n        while q:\\n            num,res = q.popleft()\\n            if num==0:\\n                break\\n            for j in range(1,int(num**0.5)+1):\\n                if(have_been_put[num-j*j] !=1):\\n                    q.append([num-j*j,res+1])\\n                have_been_put[num-j*j] = 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [i for i in range(n+1)]\\n        for i in range(2,n+1):\\n            for j in range(1,int(i ** 0.5) + 1):\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[n]\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        q=deque([[n,0]])\\n        have_been_put = [0 for i in range(n+1)]\\n        while q:\\n            num,res = q.popleft()\\n            if num==0:\\n                break\\n            for j in range(1,int(num**0.5)+1):\\n                if(have_been_put[num-j*j] !=1):\\n                    q.append([num-j*j,res+1])\\n                have_been_put[num-j*j] = 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 71559,
                "title": "consise-java-dp-solution-beats-94-67",
                "content": "I had originally tried this problem in Python but I kept getting a time limit exceeded error. The same exact algorithm in Java outperforms ~95% of other submissions, so I think Python is simply too slow for this problem.\\n\\nAnyway, the algorithm here is pretty much exactly the same as in the \"coin change\" problem (#322), except the \"coins\" are just the set of perfect squares from 1 to n. If you're having trouble with this problem then I'd recommend first researching the coin change problem and understanding its solution, as almost exactly the same logic applies here.\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            int[] memo = new int[n + 1];\\n            Arrays.fill(memo, Integer.MAX_VALUE);\\n            memo[0] = 0;\\n            int i = 0;\\n            while (++i * i <= n) {\\n                for (int j = i * i; j < memo.length; j++) {\\n                    memo[j] = Math.min(memo[j], memo[j - (i * i)] + 1);\\n                }\\n            }\\n            return memo[n];\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int[] memo = new int[n + 1];\\n            Arrays.fill(memo, Integer.MAX_VALUE);\\n            memo[0] = 0;\\n            int i = 0;\\n            while (++i * i <= n) {\\n                for (int j = i * i; j < memo.length; j++) {\\n                    memo[j] = Math.min(memo[j], memo[j - (i * i)] + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1475854,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Solution 1: Top down DP**\\n- Let `dp(target)` donotes the least number of perfect square numbers that sum to `target`.\\n```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        ps = []\\n        i = 1\\n        while i * i <= n:\\n            ps.append(i * i)\\n            i += 1\\n\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 0\\n\\n            ans = math.inf\\n            for num in ps:\\n                if target >= num:\\n                    ans = min(ans, dp(target - num) + 1)\\n            return ans\\n\\n        return dp(n)\\n```\\nComplexity:\\n- Time: `O(sqrt(N) * N)`, where `N <= 10^4`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        ps = []\\n        i = 1\\n        while i * i <= n:\\n            ps.append(i * i)\\n            i += 1\\n\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 0\\n\\n            ans = math.inf\\n            for num in ps:\\n                if target >= num:\\n                    ans = min(ans, dp(target - num) + 1)\\n            return ans\\n\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310668,
                "title": "heavily-commented-javascript-dynamic-programming-solution",
                "content": "```\\nfunction numSquares(n) {\\n    \\n    // General strategy is to build up a memoization array with the smallest amount of squares needed to make the number at each index\\n    // since the only square in the beginning is 1, until we see 4, it\\'s very boring:\\n    // to make 1, we use 1, to make 2 we use two 1\\'s, to make 3, we use three 1\\'s\\n    // mem[1] = 1, d[2] = 2, mem[3] = 3\\n    // initially, mem[4] will also use 1s and end up at 4\\n    // but now we can consider 2^2 too since the inner loop now allows it\\n    // we then compare, is what we have calculated so far better? or using this new square?\\n    // To answer that, we subtract the current square (4) from i (4) and look up in our mem lookup to see how many steps that took\\n    // mem[0] is zero of course, so we end up with Math.min(4, 0 + 1). The 2nd is less of course, so we set mem[4] to 1\\n    \\n    // Our memory lookup. Others often name this \\'dp\\'\\n    let mem = [0];\\n    let i, j;\\n    \\n    // Outer loop, where we build up till we reach n\\n    for (i = 1; i <= n; i++) {\\n        \\n        // Initially, we have no idea how many steps it will take\\n        mem[i] = Infinity;\\n        \\n        // Now loop over all squares that are smaller or equal to the current i.\\n        for (j = 1; j * j <= i; j++) {\\n                        \\n            // The smalles amount of squares is either what we already have, or what we can build with a new square and remainder\\n            mem[i] = Math.min(mem[i], mem[i - j*j] + 1)   \\n        }\\n        \\n        \\n    }\\n    return mem[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction numSquares(n) {\\n    \\n    // General strategy is to build up a memoization array with the smallest amount of squares needed to make the number at each index\\n    // since the only square in the beginning is 1, until we see 4, it\\'s very boring:\\n    // to make 1, we use 1, to make 2 we use two 1\\'s, to make 3, we use three 1\\'s\\n    // mem[1] = 1, d[2] = 2, mem[3] = 3\\n    // initially, mem[4] will also use 1s and end up at 4\\n    // but now we can consider 2^2 too since the inner loop now allows it\\n    // we then compare, is what we have calculated so far better? or using this new square?\\n    // To answer that, we subtract the current square (4) from i (4) and look up in our mem lookup to see how many steps that took\\n    // mem[0] is zero of course, so we end up with Math.min(4, 0 + 1). The 2nd is less of course, so we set mem[4] to 1\\n    \\n    // Our memory lookup. Others often name this \\'dp\\'\\n    let mem = [0];\\n    let i, j;\\n    \\n    // Outer loop, where we build up till we reach n\\n    for (i = 1; i <= n; i++) {\\n        \\n        // Initially, we have no idea how many steps it will take\\n        mem[i] = Infinity;\\n        \\n        // Now loop over all squares that are smaller or equal to the current i.\\n        for (j = 1; j * j <= i; j++) {\\n                        \\n            // The smalles amount of squares is either what we already have, or what we can build with a new square and remainder\\n            mem[i] = Math.min(mem[i], mem[i - j*j] + 1)   \\n        }\\n        \\n        \\n    }\\n    return mem[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176948,
                "title": "java-bfs-solution",
                "content": "Traverse every possibilities that squires number add squares number.\\nRecord the numbers of the squares number elements.\\nWhile traversing, if node - n.squares == 0, return deapth.\\n        //\\n```\\n        //Step 1. Build up HashSet to store the squares number\\n        Set<Integer> seen = new HashSet<>();\\n\\n        //Step 2. Initialize depth\\n        int depth = 0;\\n\\n        //Step 3. Build up Queue to store the sequence of (input - squares)\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n\\n        //Step 4. Begin BFS\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (!seen.add(node)) continue;\\n                for (int j = 1; j <= Math.sqrt(node); j++) {\\n                    int les = node - j * j;\\n                    if (les == 0) {\\n                        return depth;\\n                    }\\n                    queue.offer(les);\\n                }\\n            }\\n        }\\n\\n        return 0;\\n```",
                "solutionTags": [],
                "code": "```\\n        //Step 1. Build up HashSet to store the squares number\\n        Set<Integer> seen = new HashSet<>();\\n\\n        //Step 2. Initialize depth\\n        int depth = 0;\\n\\n        //Step 3. Build up Queue to store the sequence of (input - squares)\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n\\n        //Step 4. Begin BFS\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            depth++;\\n            for (int i = 0; i < size; i++) {\\n                int node = queue.poll();\\n                if (!seen.add(node)) continue;\\n                for (int j = 1; j <= Math.sqrt(node); j++) {\\n                    int les = node - j * j;\\n                    if (les == 0) {\\n                        return depth;\\n                    }\\n                    queue.offer(les);\\n                }\\n            }\\n        }\\n\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486915,
                "title": "c-279-perfect-squares-bfs-solution",
                "content": "```\\n/* =========================*/\\n/* https://jasonchiucc.com  */\\n/* =========================*/\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        // Init\\n        unordered_set<int>  visited;\\n        queue<int>          q;\\n        vector<int>         vec; \\n        int                 step = 1;\\n        \\n        for(int i = 1; i*i <= n; i++ )\\n        {\\n            if( i*i == n) return step;\\n            q.push(i*i);\\n            visited.insert(i*i); \\n            vec.push_back(i*i);\\n        }                \\n           \\n        while( !q.empty() )\\n        {\\n            step += 1;\\n            int size = q.size();\\n            for (int i = 0 ; i < size; i++) \\n            {            \\n                int num = q.front();                 \\n                for (auto key : vec) \\n                { \\n                    int sum = num + key;\\n                    if( sum == n) return step;\\n                    if( sum < n && !visited.count(sum) )\\n                    {                        \\n                        q.push(sum);\\n                        visited.insert(sum);                         \\n                    }\\n                } \\n                q.pop();\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/* =========================*/\\n/* https://jasonchiucc.com  */\\n/* =========================*/\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        // Init\\n        unordered_set<int>  visited;\\n        queue<int>          q;\\n        vector<int>         vec; \\n        int                 step = 1;\\n        \\n        for(int i = 1; i*i <= n; i++ )\\n        {\\n            if( i*i == n) return step;\\n            q.push(i*i);\\n            visited.insert(i*i); \\n            vec.push_back(i*i);\\n        }                \\n           \\n        while( !q.empty() )\\n        {\\n            step += 1;\\n            int size = q.size();\\n            for (int i = 0 ; i < size; i++) \\n            {            \\n                int num = q.front();                 \\n                for (auto key : vec) \\n                { \\n                    int sum = num + key;\\n                    if( sum == n) return step;\\n                    if( sum < n && !visited.count(sum) )\\n                    {                        \\n                        q.push(sum);\\n                        visited.insert(sum);                         \\n                    }\\n                } \\n                q.pop();\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71567,
                "title": "simple-math-solution-4ms-in-c-explained-now",
                "content": "If you don't know Lagrange's four-square theorem, please check [wiki](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) first and if you want to prove it, check [here](http://planetmath.org/proofoflagrangesfoursquaretheorem). In a summary, it's all about that the maximum will be 4 and in that case  it will follow the following equation, otherwise it will be 1, 2, 3.\\n\\n>  4^k(8m+7)\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) \\n        {\\n            while(!(n&3)) n /= 4;\\n            if(n%8 == 7) return 4;\\n            for(int a = sqrt(n); a > 0; --a)\\n            {\\n                int b = sqrt(n-a*a);\\n                if(a*a+b*b == n) return !b? 1 : 2;\\n            }\\n            return 3;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) \\n        {\\n            while(!(n&3)) n /= 4;\\n            if(n%8 == 7) return 4;\\n            for(int a = sqrt(n); a > 0; --a)\\n            {\\n                int b = sqrt(n-a*a);\\n                if(a*a+b*b == n) return !b? 1 : 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71597,
                "title": "12ms-recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "AT first, we all use the dp-method but the calculation exist many duplicate parts.\\n\\nSo we can avoid it by using a static-array to store the result .\\n\\n    class Solution {\\n    public:\\n        int numSquares(int n) {\\n            /*** first: you must initialize the dp-array ***/\\n            static vector<int> dp({0});\\n            /*** the-array-start-from-1 ***/\\n            if(dp.size() >= n+1)  return dp[n];\\n            /*** dp[n] means the dp.size()=n+1 ***/\\n            while(dp.size()<=n+1){\\n                /*** the-j-should-start-from-1 ***/\\n                int temp=INT_MAX;\\n                for(int j=1; j*j<=dp.size(); j++)\\n                    temp=min(temp, dp[dp.size()-j*j]+1);\\n                dp.push_back(temp);\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n            /*** first: you must initialize the dp-array ***/\\n            static vector<int> dp({0}",
                "codeTag": "Java"
            },
            {
                "id": 71661,
                "title": "o-sqrt-n-2-applying-fermat-s-theorm-with-brahmagupta-u2013fibonacci-identity",
                "content": "First I check if number if perfect square, next I check if number fits Legendre's condition for 4 squares 4^a(8b+7) .\\nI check if number is prime and is prime I check that n%4==1. See h[ttps://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares][1]\\nIf number is not a prime I check if the numbers it's composed of numbers that match Fermat's theorem.\\nBy Brahmagupta\\u2013Fibonacci identity\\n[https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity][2]\\nif all factors(or subfactors) are prime and match condtion n%4==1 I am guaranteed that my number is sum of 2 squares. Otherwise it's sum of 3 squares by Legendre's theorem .\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            if (Math.pow((int)Math.sqrt(n), 2) == n){\\n        \\t    return 1;\\n        \\t}\\n            while (n%4 == 0){\\n                n = n/4;\\n        \\t}\\n            if (n%8 == 7){\\n                return 4;\\n            }\\n            if (n%2 == 0){\\n                n = n/2; //OK to divide by 2. If N/2 has is sum of 2 squares so will be N.\\n            }\\n            if (isMod41PrimeOrSubP(n)){\\n                return 2;\\n            }\\n        \\treturn 3;\\n        }\\n        private boolean isMod41PrimeOrSubP(int num) {\\n            if (num%4 != 1){\\n                return false;\\n            }\\n            for (int i=3; i*i<num; i=i+2){\\n                if (num%i == 0) {\\n                    if (num%(i*i) == 0){\\n             \\t        return isMod41PrimeOrSubP(num/(i*i));\\n                    } \\n                    return isMod41PrimeOrSubP(i)&&isMod41PrimeOrSubP(num/i);\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n\\n  [1]: https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n  [2]: https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            if (Math.pow((int)Math.sqrt(n), 2) == n){\\n        \\t    return 1;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2584242,
                "title": "java-easiest-solution-bottom-up-dp",
                "content": "please do upvote if it helps\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,n);\\n        dp[0]=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=1;j<i+1;j++){\\n                int square=j*j;\\n                if(i-square<0){\\n                    break;\\n                }else{\\n                    dp[i]=Math.min(dp[i],1+dp[i-square]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,n);\\n        dp[0]=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=1;j<i+1;j++){\\n                int square=j*j;\\n                if(i-square<0){\\n                    break;\\n                }else{\\n                    dp[i]=Math.min(dp[i],1+dp[i-square]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512708,
                "title": "java-recursion-memoization-dp-solutions",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        if(n <= 3)return n;\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1 + numSquares(n - (i*i)));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Memoization : \\nRuntime: 75 ms, faster than 35.20% of Java online submissions for Perfect Squares.\\nMemory Usage: 39.4 MB, less than 46.60% of Java online submissions for Perfect Squares.**\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,dp);\\n    }\\n    public int helper(int n,int dp[]){\\n        if(n <= 3)return dp[n] = n;\\n        if(dp[n] != -1)return dp[n];\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1+helper(n-(i*i),dp));\\n        }\\n        return dp[n] = ans;\\n    }\\n}\\n```\\n**DP :\\nRuntime: 32 ms, faster than 73.82% of Java online submissions for Perfect Squares.\\nMemory Usage: 37.9 MB, less than 89.36% of Java online submissions for Perfect Squares.**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        for(int i = 1;i<=n;i++){\\n            dp[i] = i;\\n            for(int j = 1;j*j<=i;j++){\\n                dp[i] = Math.min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        if(n <= 3)return n;\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1 + numSquares(n - (i*i)));\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,dp);\\n    }\\n    public int helper(int n,int dp[]){\\n        if(n <= 3)return dp[n] = n;\\n        if(dp[n] != -1)return dp[n];\\n        for(int i = 1;i*i<=n;i++){\\n            ans = Math.min(ans,1+helper(n-(i*i),dp));\\n        }\\n        return dp[n] = ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n+1];\\n        for(int i = 1;i<=n;i++){\\n            dp[i] = i;\\n            for(int j = 1;j*j<=i;j++){\\n                dp[i] = Math.min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420219,
                "title": "simple-python-dp-or-bfs",
                "content": "**Dynamic Programming:**\\nLet dp[i] record the least number of perfect square numbers that sum to i. If i itself is a perfect square, dp[i] is simply 1. Otherwise, we go through all the i-j^2 and look for the smallest.\\n```Python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [float(\"inf\")]*(n+1)\\n        for i in range(len(dp)):\\n            if int(sqrt(i)) == sqrt(i):\\n                dp[i] = 1\\n            else:\\n                for j in range(int(sqrt(i))+1):\\n                    dp[i] = min(dp[i], dp[i-j*j]+1)\\n        return dp[-1]\\n```\\n\\n**BFS:**\\nWe can also see this problem as looking for the smallest number of steps between 0 and n. A standard BFS can find the shortest distance because edges are uniformly weighted (i.e. both 1^2, 2^2, 3^2... counts as 1 step).\\n```Python\\nfrom collections import deque\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        queue = deque([(n, 0)])\\n        while queue:\\n            cur_n, cur_steps = queue.popleft()\\n            if cur_n**0.5 == int(cur_n**0.5):\\n                return cur_steps+1\\n            for i in range(1, int(cur_n**0.5)+1):\\n                queue.append((cur_n-i*i, cur_steps+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [float(\"inf\")]*(n+1)\\n        for i in range(len(dp)):\\n            if int(sqrt(i)) == sqrt(i):\\n                dp[i] = 1\\n            else:\\n                for j in range(int(sqrt(i))+1):\\n                    dp[i] = min(dp[i], dp[i-j*j]+1)\\n        return dp[-1]\\n```\n```Python\\nfrom collections import deque\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        queue = deque([(n, 0)])\\n        while queue:\\n            cur_n, cur_steps = queue.popleft()\\n            if cur_n**0.5 == int(cur_n**0.5):\\n                return cur_steps+1\\n            for i in range(1, int(cur_n**0.5)+1):\\n                queue.append((cur_n-i*i, cur_steps+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356758,
                "title": "unbounded-knapsack-memoization-top-down-dp",
                "content": "```\\nclass Solution {\\npublic: \\n    \\n    int dp[102][10002];\\n\\n    int UKS (vector<int> &nums, int n, int sum) { \\n    \\n        if (sum == 0) { \\n            return dp[n][sum] = 0;\\n        } \\n        \\n        else if (n <= 0) { \\n            return dp[n][sum] = 1e8;\\n        } \\n         \\n        else if (dp[n][sum] != -1) { \\n            return dp[n][sum];\\n        }\\n        else if (nums[n-1] > sum) { \\n            return dp[n][sum] = UKS (nums, n-1, sum);\\n        } \\n        \\n        return dp[n][sum] = min(1 + UKS(nums, n, sum-nums[n-1]), UKS (nums, n-1, sum));\\n    \\n    } \\n\\n    int numSquares(int n) {  \\n        \\n        vector<int> nums;  \\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for (int i = 1; i <= n; i++) { \\n            \\n            if (i * i <= n) { \\n                \\n                nums.push_back(i*i);\\n            \\n            }\\n        \\n        }  \\n            \\n       return UKS (nums, nums.size(), n);\\n    }\\n}; \\n\\n\\n \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    int dp[102][10002];\\n\\n    int UKS (vector<int> &nums, int n, int sum) { \\n    \\n        if (sum == 0) { \\n            return dp[n][sum] = 0;\\n        } \\n        \\n        else if (n <= 0) { \\n            return dp[n][sum] = 1e8;\\n        } \\n         \\n        else if (dp[n][sum] != -1) { \\n            return dp[n][sum];\\n        }\\n        else if (nums[n-1] > sum) { \\n            return dp[n][sum] = UKS (nums, n-1, sum);\\n        } \\n        \\n        return dp[n][sum] = min(1 + UKS(nums, n, sum-nums[n-1]), UKS (nums, n-1, sum));\\n    \\n    } \\n\\n    int numSquares(int n) {  \\n        \\n        vector<int> nums;  \\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for (int i = 1; i <= n; i++) { \\n            \\n            if (i * i <= n) { \\n                \\n                nums.push_back(i*i);\\n            \\n            }\\n        \\n        }  \\n            \\n       return UKS (nums, nums.size(), n);\\n    }\\n}; \\n\\n\\n \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707718,
                "title": "c-easy-understanding-time-100-faster-memory-85",
                "content": "***Please upvote if you found it helpful :)***\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n<0)return 0;\\n        static vector<int> hg({0});\\n        while(hg.size()<=n){\\n            int temp=INT_MAX;\\n            int m=hg.size();\\n            for(int i=1;i*i<=m;i++){\\n                temp=min(temp,hg[m-i*i]+1);\\n            }\\n            hg.push_back(temp);\\n        }\\n        return hg[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n<0)return 0;\\n        static vector<int> hg({0});\\n        while(hg.size()<=n){\\n            int temp=INT_MAX;\\n            int m=hg.size();\\n            for(int i=1;i*i<=m;i++){\\n                temp=min(temp,hg[m-i*i]+1);\\n            }\\n            hg.push_back(temp);\\n        }\\n        return hg[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301341,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int NumSquares(int n) {\\n        var dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = int.MaxValue;\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSquares(int n) {\\n        var dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = int.MaxValue;\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71527,
                "title": "my-recursive-solution-java",
                "content": "Hi all, here's my Java solution.\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n            int result=n, num= 2;\\n            while(num*num<=n){\\n                int temp1= n/(num*num), temp2= n%(num*num);\\n                result= Math.min(result,temp1+numSquares(temp2));\\n                num++;\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            int result=n, num= 2;\\n            while(num*num<=n){\\n                int temp1= n/(num*num), temp2= n%(num*num);\\n                result= Math.min(result,temp1+numSquares(temp2));\\n                num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71685,
                "title": "concise-and-easy-to-understand-java-solution-with-detailed-explanation",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }\\n        Set<Integer> squareSet = buildSet(n); // This set contains all perfect square numbers (1, 4, 9, 16, ...) <= n \\n        int[] dp = new int[n + 1]; // dp[i] means the least number of perfect suqare numbers sum to n.\\n        for (int i = 1; i <= n; i++) {\\n            if (squareSet.contains(i)) { // If this number is a perfect square number\\n                dp[i] = 1; // Set itself to 1\\n            }\\n            for (int j: squareSet) { // For each perfect square number j, \"the least number for i + j\" will be \"the number for i\" + 1.\\n                if (i + j > n) {\\n                    break;\\n                } else { \\n                    dp[i + j] = dp[i + j] == 0 ? dp[i] + 1 : Math.min(dp[i] + 1, dp[i + j]); // choose the smaller one if it isn't 0.\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n    \\n    private Set<Integer> buildSet(int n) { // Build the set of perfect square number\\n        Set<Integer> set = new TreeSet<Integer>();\\n        for (int i = 1; i * i <= n; i++) {\\n            set.add(i * i);\\n        }\\n        return set;\\n      }\\n    }\\n\\nThe basic idea is that for each number i less than n, it updates the least number sum to i + j after adding **one** perfect square number j. \\n\\nFor example, if n = 10, it builds the set containing all perfect square number less than 10, which are 1, 4, 9. Then for the first iteration, it updates the least number sum to 1, 1 + 1, 1 + 4 and 1 + 9. Then 2 + 1, 2 + 4, 2 + 9 (out of scope will break).\\n\\nThe time complexity is O(n * sqrt(n)) and space complexity is O(sqrt(n)). **If anyone has a better solution or has some ways to optimize this code, please write a comment on it. Thanks!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3236383,
                "title": "279-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first initialize a list dp with n+1 elements, where dp[i] represents the least number of perfect square numbers that sum to the index i. We set dp[0] = 0, since zero is not a perfect square and does not require any perfect squares to be summed up to it. We set all other elements to infinity initially.\\n\\n2. We iterate through all numbers from 1 to n. For each number i, we iterate through all possible perfect square numbers that are less than or equal to i. We use the square root function int(i ** 0.5) to get the largest perfect square number less than or equal to i. We start the inner loop from 1 to include the perfect square number 1.\\n\\n3. For each jth perfect square number less than or equal to i, we update the least number of perfect square numbers that sum to i as dp[i] = min(dp[i], dp[i - j*j] + 1). Here, dp[i - j*j] + 1 represents the number of perfect square numbers required to sum up to i-j*j, and we add 1 to account for the current perfect square number j*j.\\n\\n4. Finally, we return the least number of perfect square numbers that sum to n, which is stored in dp[n].\\n\\nThis solution uses dynamic programming to solve the problem, and is optimized by iterating through all perfect square numbers less than or equal to i, rather than all numbers less than or equal to i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Initialize a list to store the least number of perfect square numbers that sum to the index i\\n        dp = [0] + [float(\\'inf\\')] * n\\n        \\n        # Iterate through all numbers from 1 to n\\n        for i in range(1, n + 1):\\n            # Iterate through all possible perfect square numbers that are less than or equal to i\\n            for j in range(1, int(i ** 0.5) + 1):\\n                # Update the least number of perfect square numbers that sum to i\\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\\n        \\n        # Return the least number of perfect square numbers that sum to n\\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Initialize a list to store the least number of perfect square numbers that sum to the index i\\n        dp = [0] + [float(\\'inf\\')] * n\\n        \\n        # Iterate through all numbers from 1 to n\\n        for i in range(1, n + 1):\\n            # Iterate through all possible perfect square numbers that are less than or equal to i\\n            for j in range(1, int(i ** 0.5) + 1):\\n                # Update the least number of perfect square numbers that sum to i\\n                dp[i] = min(dp[i], dp[i - j*j] + 1)\\n        \\n        # Return the least number of perfect square numbers that sum to n\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171453,
                "title": "maths-solution-beats-98-88-in-runtime-clean-simple-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Nice Approach 2nd fastest\\n        # if n <= 0:\\n        #     return 0\\n        #\\n        # cnt_perfect_square = [0]\\n        #\\n        # while len(cnt_perfect_square) <= n:\\n        #     m = len(cnt_perfect_square)\\n        #     cnt_square = sys.maxsize\\n        #     for i in range(1, int(math.sqrt(m)) + 1):\\n        #         cnt_square = min(cnt_square, cnt_perfect_square[m - i * i] + 1)\\n        #     cnt_perfect_square.append(cnt_square)\\n        # return cnt_perfect_square[n]\\n\\n        # We can Use Langrage\\'s 4 Square theorem to do this in very efficient manner\\n        def is_perfect_square(n):\\n            square_root = int(math.sqrt(n))\\n            return square_root**2 == n\\n        \\n        cpy_n = n\\n        if is_perfect_square(n):\\n            return 1\\n        # 4^k(8m + 7) if in this way a num. can be represented then it\\'s a sum of 4 square nums.\\n        while n & 3 == 0:    # divisible by 4\\n            n >>= 2           # divide by 4\\n        if n & 7 == 7:       # n & 7 ---> n % 8 == 0  and n & 7 == 7 means n % 8 == 7\\n            return 4\\n        n = cpy_n\\n        for i in range(1, int(math.sqrt(n)) + 1):\\n            if is_perfect_square(n - i*i):\\n                return 2\\n        return 3\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        # Nice Approach 2nd fastest\\n        # if n <= 0:\\n        #     return 0\\n        #\\n        # cnt_perfect_square = [0]\\n        #\\n        # while len(cnt_perfect_square) <= n:\\n        #     m = len(cnt_perfect_square)\\n        #     cnt_square = sys.maxsize\\n        #     for i in range(1, int(math.sqrt(m)) + 1):\\n        #         cnt_square = min(cnt_square, cnt_perfect_square[m - i * i] + 1)\\n        #     cnt_perfect_square.append(cnt_square)\\n        # return cnt_perfect_square[n]\\n\\n        # We can Use Langrage\\'s 4 Square theorem to do this in very efficient manner\\n        def is_perfect_square(n):\\n            square_root = int(math.sqrt(n))\\n            return square_root**2 == n\\n        \\n        cpy_n = n\\n        if is_perfect_square(n):\\n            return 1\\n        # 4^k(8m + 7) if in this way a num. can be represented then it\\'s a sum of 4 square nums.\\n        while n & 3 == 0:    # divisible by 4\\n            n >>= 2           # divide by 4\\n        if n & 7 == 7:       # n & 7 ---> n % 8 == 0  and n & 7 == 7 means n % 8 == 7\\n            return 4\\n        n = cpy_n\\n        for i in range(1, int(math.sqrt(n)) + 1):\\n            if is_perfect_square(n - i*i):\\n                return 2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837698,
                "title": "recursion-memoization-approach",
                "content": "# Intuition\\nWe have to check all possible paths to our sum and then find the smallest one to it.\\n\\n# Approach\\nUsing a dfs type apporach we generate all the sum possible at a level and add it to our sum and we only itrate till root of n as beyond it the sum would only increase\\n\\n# Complexity\\n- Time complexity: O(n * root(n)) n is the target value\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) n is the target value\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int sum , int target , vector<int>& dp){\\n        if(sum == target) return 0;\\n        if(sum > target) return 1e6;\\n        if(dp[sum] != -1) return dp[sum];\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= sqrt(target) ; i++){\\n            int val = i * i;\\n            ans = min(ans , 1 + dfs(sum + val , target , dp));\\n        }\\n        return dp[sum] = ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1 , -1);\\n        return dfs(0 , n , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int sum , int target , vector<int>& dp){\\n        if(sum == target) return 0;\\n        if(sum > target) return 1e6;\\n        if(dp[sum] != -1) return dp[sum];\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i <= sqrt(target) ; i++){\\n            int val = i * i;\\n            ans = min(ans , 1 + dfs(sum + val , target , dp));\\n        }\\n        return dp[sum] = ans;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1 , -1);\\n        return dfs(0 , n , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520562,
                "title": "c-mathematical-solution-0ms-faster-than-100-explained",
                "content": "Te main concept behind this is Lagaranges\\'s four square theorem. It states that every positive integer can be written as the sum of at most four squares.  In this problem since we need to find the minimum no of numbers required to make a perfect square the highest number of sum we need to find is 4.  A number can be expressed as a sum of 4 square if it satisfies the equation 4^a(8k+7).\\n```\\nclass Solution {\\npublic:\\n    int is_sq(int a)//Check whether given number is a perfect square or not\\n    {\\n        int r=(int)sqrt(a);\\n        if(r*r==a)\\n            return 1;\\n        return 0;\\n    }\\n    int numSquares(int n) {\\n      int count=0;\\n       while(n%4==0)\\n       {\\n           n/=4; \\n       }\\n        if(n%8==7)\\n            return 4;// TOcheck whether number satisfies 4^a(8k+7).\\n        if(is_sq(n))\\n            return 1;//if number is a perfect square\\n        for(int i=1;i*i<=n;i++ )\\n        {\\n            if(is_sq(n-i*i))\\n                return 2;//if number is a sum of two square\\n        }\\n        return 3;//if none of the conditions are satisfied\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_sq(int a)//Check whether given number is a perfect square or not\\n    {\\n        int r=(int)sqrt(a);\\n        if(r*r==a)\\n            return 1;\\n        return 0;\\n    }\\n    int numSquares(int n) {\\n      int count=0;\\n       while(n%4==0)\\n       {\\n           n/=4; \\n       }\\n        if(n%8==7)\\n            return 4;// TOcheck whether number satisfies 4^a(8k+7).\\n        if(is_sq(n))\\n            return 1;//if number is a perfect square\\n        for(int i=1;i*i<=n;i++ )\\n        {\\n            if(is_sq(n-i*i))\\n                return 2;//if number is a sum of two square\\n        }\\n        return 3;//if none of the conditions are satisfied\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369732,
                "title": "c-iterative-dp",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int numSquares(int n)\\n    {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j * j <= i; j++)\\n            {\\n                if (i - j >= 0)\\n                    dp[i] = min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int numSquares(int n)\\n    {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j * j <= i; j++)\\n            {\\n                if (i - j >= 0)\\n                    dp[i] = min(dp[i], dp[i - j * j] + 1);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927387,
                "title": "dfs-dp-progression-with-explanation-o-n-2-o-n",
                "content": "In this problem, we are looking for the smallest combination of square numbers that sum up to a given number.  Therefore, we can solve this problem by looking through all combinations of square numbers that sum up to `n`, and return the smallest combination.  DFS is a great tool for this, as we can imagine an instance of the function as the current state, and each recursive call as a possible action to a future state.\\n```\\ndef dfs(n):\\n\\tif not n:\\n\\t\\treturn 0\\n\\tsquares = [i**2 for i in range(1, int(math.floor(math.sqrt(n))) + 1)]\\n\\tshortest = float(\"inf\")\\n\\tfor i in range(len(squares)):\\n\\t\\tshortest = min(shortest, 1 + dfs(n - squares[i]))\\n\\treturn shortest\\nreturn dfs(n)\\n```\\nLet\\'s take a look at the DFS tree this creates.\\n![image](https://assets.leetcode.com/users/images/ffe44e14-05ac-4d85-9892-ff43245fe1b5_1604794579.0745683.png)\\nThis is a very common pattern in DFS problems, where we traverse the DFS tree and acquire some `cost` at each node.  For this problem, since we are looking for the amount of square numbers of that add up to `n`, the cost would simply be 1.  Therefore, the solution to this problem would be to find the shortest root -> leaf path created in the DFS tree.\\nHowever, this method is far too slow and times out.  Why is that?  If we take a look at the DFS tree, notice the amount of redundant calculations there are.  For instance, we see `8` twice.  From 8 onwards, the calculation will always return the same value, but our implementation of DFS is not aware of that and will spend time recalculating it.  This becomes exponentially worse as the input becomes large and the DFS tree grows taller.  This is where the DP solution comes in.\\nThe DFS approach solves the problem from the top down, meaning it needs to recurse all the way down to the base case `(if not n: return 0` to have any idea of how long a path is.  Instead, let\\'s solve this problem from the bottom up, saving the solution to a given subproblem at every step.  Therefore if we come across a subproblem multiple times, we can simply reference the solution yielded from the first time it was calculated.\\n```\\ndef dp(n):\\n\\tA = [float(\"inf\") for _ in range(n + 1)]\\n\\tA[0] = 0\\n\\tfor j in range(1, n + 1):\\n\\t\\tfor i in range(1, int(math.floor(math.sqrt(j))) + 1):\\n\\t\\t\\tA[j] = min(A[j], 1 + A[j - i**2])\\n\\treturn A[-1]\\nreturn dp(n)\\n```\\nNotice the recursion relation is exactly the same as in the DFS approach, however now we are simply referencing the cached answer.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(n):\\n\\tif not n:\\n\\t\\treturn 0\\n\\tsquares = [i**2 for i in range(1, int(math.floor(math.sqrt(n))) + 1)]\\n\\tshortest = float(\"inf\")\\n\\tfor i in range(len(squares)):\\n\\t\\tshortest = min(shortest, 1 + dfs(n - squares[i]))\\n\\treturn shortest\\nreturn dfs(n)\\n```\n```\\ndef dp(n):\\n\\tA = [float(\"inf\") for _ in range(n + 1)]\\n\\tA[0] = 0\\n\\tfor j in range(1, n + 1):\\n\\t\\tfor i in range(1, int(math.floor(math.sqrt(j))) + 1):\\n\\t\\t\\tA[j] = min(A[j], 1 + A[j - i**2])\\n\\treturn A[-1]\\nreturn dp(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 707666,
                "title": "tired-of-dp-solutions-check-this-different-approach-beats-96-of-python-solution",
                "content": "Tried this different approach in which I have used concept of 2sum and 3sum problem.\\n\\nAny  number can be represented by maximun 4 number which are perfect square  by minimizing no of perfect Squares.\\n\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        nums = set()\\n        \\n        if n == 0:\\n            return 0 #Base case\\n        \\n        #Find all the Squares les than equal to n\\n        \\n        for i in range(n+1):\\n            if i**2 <= n:\\n                nums.add(i**2)\\n                if i**2 == n : #if N is perfect square\\n                    return 1\\n            else:\\n                break\\n                \\n        res = 4 #N can be represented by maximun 4 numbers \\n        \\n        #check for 2 and 3 using 2sum and 3sum problem  \\n        \\n        for i in nums:\\n            \\n            if (n-i) in nums:\\n                res = min(res,2) #check for 2 Sum problem\\n                return res           # min is 2\\n            for j in nums :\\n                \\n                if (n-i-j) in nums :\\n                    \\n                    res = min(res,3) #check for 3 Sum problem\\n        \\n        return res\\n```\\n\\nPlease Upvote : )",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        nums = set()\\n        \\n        if n == 0:\\n            return 0 #Base case\\n        \\n        #Find all the Squares les than equal to n\\n        \\n        for i in range(n+1):\\n            if i**2 <= n:\\n                nums.add(i**2)\\n                if i**2 == n : #if N is perfect square\\n                    return 1\\n            else:\\n                break\\n                \\n        res = 4 #N can be represented by maximun 4 numbers \\n        \\n        #check for 2 and 3 using 2sum and 3sum problem  \\n        \\n        for i in nums:\\n            \\n            if (n-i) in nums:\\n                res = min(res,2) #check for 2 Sum problem\\n                return res           # min is 2\\n            for j in nums :\\n                \\n                if (n-i-j) in nums :\\n                    \\n                    res = min(res,3) #check for 3 Sum problem\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570758,
                "title": "28ms-99-4-python-simple-loop-solution",
                "content": "According to Lagrange\\'s four-square theorem\\nWe can solve this problem like this(Time complexity is O(n)):\\n\\n```python\\nclass Solution:\\n    def numSquares(self, n):\\n        sqr = sqrt(n)\\n        pool = {i**2 for i in range(int(sqr)+1)}\\n        test = [i**2 for i in range(int(sqr*0.71)+1)]\\n        \\n        for i in test:\\n            for j in test:\\n                if n-i-j in pool:\\n                    return 3-(i==0)-(j==0)\\n        return 4\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numSquares(self, n):\\n        sqr = sqrt(n)\\n        pool = {i**2 for i in range(int(sqr)+1)}\\n        test = [i**2 for i in range(int(sqr*0.71)+1)]\\n        \\n        for i in test:\\n            for j in test:\\n                if n-i-j in pool:\\n                    return 3-(i==0)-(j==0)\\n        return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462694,
                "title": "python3-simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if n == 0: return 0\\n        dp = [i for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,i*i):\\n                if i - j*j < 0:\\n                    break\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if n == 0: return 0\\n        dp = [i for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,i*i):\\n                if i - j*j < 0:\\n                    break\\n                dp[i] = min(dp[i],dp[i-j*j]+1)\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71530,
                "title": "straightforward-java-bfs-beats-93-69",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n    \\n            ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n            queue.add(n);\\n            int depth = 1, m = 1, tmp = 0;\\n            \\n            while(true){\\n                if(m == 0){\\n                    depth++;\\n                    m = tmp;\\n                    tmp = 0;\\n                }\\n                \\n                int cur = queue.remove();\\n                m--;\\n                \\n                int l = (int) Math.sqrt(cur);\\n                for(int i=l; i>0; i--){\\n                    int sq = i*i;\\n                    int delta = cur - sq;\\n                    if(delta == 0)\\n                        return depth;\\n                    queue.add(delta);\\n                    tmp++;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n    \\n            ArrayDeque<Integer> queue = new ArrayDeque<Integer>();\\n            queue.add(n);\\n            int depth = 1, m = 1, tmp = 0;\\n            \\n            while(true){\\n                if(m == 0){\\n                    depth++;\\n                    m = tmp;\\n                    tmp = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71602,
                "title": "my-simple-dfs-method-c",
                "content": "    class Solution {\\n    public:\\n        int numSquares(int n) {\\n           // int ret=INT_MAX;\\n            if(n==0)return 0;\\n            return  numSquares( n,1,INT_MAX); \\n        }\\n        \\n        \\n         int numSquares(int n,int deep,int min) {\\n            if(deep>=min)return min;\\n            int sq=sqrt(n);\\n            if(sq*sq==n) { return 1;}\\n            for(int i=sq;i>=1;i--)\\n            {\\n                int temp=1+numSquares(n-i*i,deep+1,min);\\n                if( temp<min)min=temp;\\n            }\\n            return  min;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numSquares(int n) {\\n           // int ret=INT_MAX;\\n            if(n==0)return 0;\\n            return  numSquares( n,1,INT_MAX); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2838778,
                "title": "java-intuitive-dp-explained",
                "content": "# Intuition\\nFirst we need to build the squares array that represent the possible square values that we can have **upto** the given number n.\\n\\nThen it becomes a coin-change problem. We need to pick the least amount of values that can form our number n.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        List<Integer> squares = new ArrayList<>();\\n\\n        int cur = 1;\\n        // Build the squares array\\n        while (Math.pow(cur, 2) <= n) {\\n            squares.add((int) Math.pow(cur++, 2));\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // Base case\\n        dp[0] = 0;\\n        for (int i = 1; i < n+1; i++ ) {\\n            // DP transition\\n            for (int j = 0; j < squares.size() && squares.get(j) <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i-squares.get(j)]);\\n            }\\n        }\\n        return dp[n];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        List<Integer> squares = new ArrayList<>();\\n\\n        int cur = 1;\\n        // Build the squares array\\n        while (Math.pow(cur, 2) <= n) {\\n            squares.add((int) Math.pow(cur++, 2));\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // Base case\\n        dp[0] = 0;\\n        for (int i = 1; i < n+1; i++ ) {\\n            // DP transition\\n            for (int j = 0; j < squares.size() && squares.get(j) <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i-squares.get(j)]);\\n            }\\n        }\\n        return dp[n];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838235,
                "title": "golang-math-100-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Golang Math \\uD83D\\uDD25 || 100%  || Simple Fast and Easy || with Explanation\\n\\n```go\\nfunc numSquares(n int) int {\\n\\t// Four-square and three-square theorems.\\n\\tif isSquare(n) {\\n\\t\\treturn 1\\n\\t}\\n\\tfor n&3 == 0 { // n % 4 == 0\\n\\t\\tn >>= 2 // n /= 4\\n\\t}\\n\\tif n&7 == 7 { // n % 8 == 7\\n\\t\\treturn 4\\n\\t}\\n\\n\\t// Check if the number can be decomposed into sum of two squares.\\n\\tfor i := 1; i*i <= n; i++ {\\n\\t\\tif isSquare(n - i*i) {\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t}\\n\\t// Bottom case of three-square theorem.\\n\\treturn 3\\n}\\n\\nfunc isSquare(n int) bool {\\n\\tvar squareRootN int = (int)(math.Sqrt(float64(n)))\\n\\treturn squareRootN*squareRootN == n\\n}\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```go\\nfunc numSquares(n int) int {\\n\\t// Four-square and three-square theorems.\\n\\tif isSquare(n) {\\n\\t\\treturn 1\\n\\t}\\n\\tfor n&3 == 0 { // n % 4 == 0\\n\\t\\tn >>= 2 // n /= 4\\n\\t}\\n\\tif n&7 == 7 { // n % 8 == 7\\n\\t\\treturn 4\\n\\t}\\n\\n\\t// Check if the number can be decomposed into sum of two squares.\\n\\tfor i := 1; i*i <= n; i++ {\\n\\t\\tif isSquare(n - i*i) {\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t}\\n\\t// Bottom case of three-square theorem.\\n\\treturn 3\\n}\\n\\nfunc isSquare(n int) bool {\\n\\tvar squareRootN int = (int)(math.Sqrt(float64(n)))\\n\\treturn squareRootN*squareRootN == n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652004,
                "title": "c-recursion-to-dp-explained-beginner-friendly",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\tIf it helps, please UPVOTE :)\\n**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int solve(int target)\\n    {\\n        if(target == 0)     //original target fulfilled, no need of any other integer now\\n            return 0;\\n        if(target < 0)      //target can\\'t be fulfilled so in min(mini, 1 + solve) we should have solve = INT_MAX - 1 so that we don\\'t consider solve way\\n            return INT_MAX - 1;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)                  //traverse i until (square of i) <= target as we need to subtract it from target\\n            mini = min(mini, 1 + solve(target - i*i));  // + 1 as we are taking this integer so it counts 1\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\\n**Memoization:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int solve(int target)\\n    {\\n        if(target == 0)    \\n            return 0;\\n        if(target < 0)      \\n            return INT_MAX - 1;\\n        \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)\\n            mini = min(mini, 1 + solve(target - i*i));\\n        \\n        return dp[target] = mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        dp.resize(n+1, -1);\\n        return solve(n);\\n    }\\n};\\n```\\n\\n**Bottom up tabulation (DP):**\\n```\\n int numSquares(int n) \\n    {\\n        dp.resize(n+1, 0);                        //base case target = 0 is 0 so no need to mention again just run for loop from i = 1 till target\\n        \\n        for(int j=1; j<=n; j++)\\n        {\\n            int mini = INT_MAX;                    //copy recursive part\\n            for(int i=1; i*i<=j; i++)\\n                mini = min(mini, 1 + dp[j - i*i]);\\n            \\n            dp[j] = mini;                          //min no. of integers when target = j\\n        }\\n        return dp[n];                              //min no. of integers when target = n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int target)\\n    {\\n        if(target == 0)     //original target fulfilled, no need of any other integer now\\n            return 0;\\n        if(target < 0)      //target can\\'t be fulfilled so in min(mini, 1 + solve) we should have solve = INT_MAX - 1 so that we don\\'t consider solve way\\n            return INT_MAX - 1;\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)                  //traverse i until (square of i) <= target as we need to subtract it from target\\n            mini = min(mini, 1 + solve(target - i*i));  // + 1 as we are taking this integer so it counts 1\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int solve(int target)\\n    {\\n        if(target == 0)    \\n            return 0;\\n        if(target < 0)      \\n            return INT_MAX - 1;\\n        \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int mini = INT_MAX;\\n        for(int i=1; i*i<=target; i++)\\n            mini = min(mini, 1 + solve(target - i*i));\\n        \\n        return dp[target] = mini;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        dp.resize(n+1, -1);\\n        return solve(n);\\n    }\\n};\\n```\n```\\n int numSquares(int n) \\n    {\\n        dp.resize(n+1, 0);                        //base case target = 0 is 0 so no need to mention again just run for loop from i = 1 till target\\n        \\n        for(int j=1; j<=n; j++)\\n        {\\n            int mini = INT_MAX;                    //copy recursive part\\n            for(int i=1; i*i<=j; i++)\\n                mini = min(mini, 1 + dp[j - i*i]);\\n            \\n            dp[j] = mini;                          //min no. of integers when target = j\\n        }\\n        return dp[n];                              //min no. of integers when target = n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162016,
                "title": "c-perfect-squares-2-solutions",
                "content": "Lagranges Theorem \\nTime Complexity: O(N^1/2)\\nFastest Approach\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n     \\n        // Lagranges 3-Square Theorem\\n        // Every natural no can be represented as sum of 4 squares\\n        // So ans lies in range (1-4) -> 4 conditions\\n        // Time Complexity: O(N^1/2)\\n        \\n        // For value 1\\n        // Check if n is a perfect square\\n        \\n        int a = sqrt(n);\\n        if(a * a == n)\\n            return 1;\\n        \\n        // For value 4\\n        // Check if n is of form 4^a(8b + 7)\\n        \\n        while(n % 4 == 0)     // Removing 4^a terms\\n            n /= 4;\\n        if(n % 8 == 7)\\n            return 4;\\n        \\n        // For value 2\\n        // Break point which divides it into two perfect squares\\n        \\n        for(int i=1; i*i <= n; i++){\\n            \\n            int base = sqrt(n - i*i);   // other half\\n            if(base*base == (n - i*i))\\n                return 2;\\n        }\\n        \\n        // For value 3 (when all 3 are checked)\\n        \\n        return 3;\\n    }\\n};\\n```\\n\\n\\nDP Apporach\\nTime Complexity: O(N x N^1/2)\\n\\n\\n```\\nclass Solution{\\n\\tpublic:\\n\\tint MinSquares(int n)\\n\\t{\\n\\t    // DP Approach Tabulation Method\\n        // start from no. itself and check value at each break points\\n        // Time Complexity: O(N*N^1/2)\\n        \\n        vector<int> dp(n+1);\\n        \\n        if(n <= 3)       // Minimum Condition\\n            return n; \\n        \\n        int i = 0;\\n        while(i <= n){\\n            dp[i] = i;   // for 1^2 break points, eg: 3 = 1^2 + 1^2 + 1^2\\n            \\n            for(int j=1; j*j <= i; j++)    // for 2^2 and above break points\\n                dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n            \\n            i++;\\n        }\\n         \\n        return dp[n];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n     \\n        // Lagranges 3-Square Theorem\\n        // Every natural no can be represented as sum of 4 squares\\n        // So ans lies in range (1-4) -> 4 conditions\\n        // Time Complexity: O(N^1/2)\\n        \\n        // For value 1\\n        // Check if n is a perfect square\\n        \\n        int a = sqrt(n);\\n        if(a * a == n)\\n            return 1;\\n        \\n        // For value 4\\n        // Check if n is of form 4^a(8b + 7)\\n        \\n        while(n % 4 == 0)     // Removing 4^a terms\\n            n /= 4;\\n        if(n % 8 == 7)\\n            return 4;\\n        \\n        // For value 2\\n        // Break point which divides it into two perfect squares\\n        \\n        for(int i=1; i*i <= n; i++){\\n            \\n            int base = sqrt(n - i*i);   // other half\\n            if(base*base == (n - i*i))\\n                return 2;\\n        }\\n        \\n        // For value 3 (when all 3 are checked)\\n        \\n        return 3;\\n    }\\n};\\n```\n```\\nclass Solution{\\n\\tpublic:\\n\\tint MinSquares(int n)\\n\\t{\\n\\t    // DP Approach Tabulation Method\\n        // start from no. itself and check value at each break points\\n        // Time Complexity: O(N*N^1/2)\\n        \\n        vector<int> dp(n+1);\\n        \\n        if(n <= 3)       // Minimum Condition\\n            return n; \\n        \\n        int i = 0;\\n        while(i <= n){\\n            dp[i] = i;   // for 1^2 break points, eg: 3 = 1^2 + 1^2 + 1^2\\n            \\n            for(int j=1; j*j <= i; j++)    // for 2^2 and above break points\\n                dp[i] = min(dp[i], 1 + dp[i - j*j]);\\n            \\n            i++;\\n        }\\n         \\n        return dp[n];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148455,
                "title": "java-recursive-memoization-tabulation-easy-to-understand-with-explanation",
                "content": "**1. Simple recursive approach. This will throw a TLE.**\\n* First store all the perfect square until n in a list.\\n* Now from the list we need to find the numbers that form a sum = n.\\n* At every index in the list, we can either pick the number or skip(notPick) the number.\\n* Also, we can only pick a number if the target(or remaining sum) is less than the number.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        return getMinNos(list, list.size() - 1, n);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target; //Since we need to form the target with only the number 1 (the number at the 0th index of the list)\\n        \\n        int notPick = getMinNos(list, index-1, target);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index));\\n        \\n        return Math.min(notPick, pick);\\n    }\\n}\\n```\\n\\n**2. Memoized the above code**\\nIn the simple recursive approach, there are many overlapping subproblems and we\\'re solving all of them. We can use a cache to store the result of a subproblem and return it from the cache if it\\'s already solved. Since only target and index changes, I have taken a 2-D array to store the solution for each target and index combination.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int i = 0; i < list.size(); i++)\\n            Arrays.fill(memo[i], -1);\\n        \\n        return getMinNos(list, list.size() - 1, n, memo);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target, int[][] memo) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target;\\n        \\n        if(memo[index][target] != -1)\\n            return memo[index][target];\\n        \\n        int notPick = getMinNos(list, index-1, target, memo);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index), memo);\\n        \\n        memo[index][target] = Math.min(notPick, pick);\\n        return memo[index][target];\\n    }\\n}\\n```\\n\\n**3. Tabulation Method**\\nFirst store all the base cases of the above recursive code in the matrix. Now do a bottom up and calculate for each and every index, target combination.\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int target = 0; target <= n; target++) {\\n            memo[0][target] = target;\\n        }\\n        \\n        for(int index = 1; index < list.size(); index++) {\\n            for(int target = 1; target <= n; target++) {\\n                int notPick = memo[index-1][target];\\n                int pick = Integer.MAX_VALUE;\\n                if(target >= list.get(index))\\n                    pick = 1 + memo[index][target-list.get(index)];\\n                \\n                memo[index][target] = Math.min(pick, notPick);\\n            }\\n        }\\n        \\n        return memo[list.size()-1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        return getMinNos(list, list.size() - 1, n);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target; //Since we need to form the target with only the number 1 (the number at the 0th index of the list)\\n        \\n        int notPick = getMinNos(list, index-1, target);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index));\\n        \\n        return Math.min(notPick, pick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int i = 0; i < list.size(); i++)\\n            Arrays.fill(memo[i], -1);\\n        \\n        return getMinNos(list, list.size() - 1, n, memo);\\n    }\\n    \\n    private int getMinNos(List<Integer> list, int index, int target, int[][] memo) {\\n        if(target == 0)\\n            return 0;\\n        if(index == 0)\\n            return target;\\n        \\n        if(memo[index][target] != -1)\\n            return memo[index][target];\\n        \\n        int notPick = getMinNos(list, index-1, target, memo);\\n        \\n        int pick = Integer.MAX_VALUE;\\n        if(target >= list.get(index))\\n            pick = 1 + getMinNos(list, index, target - list.get(index), memo);\\n        \\n        memo[index][target] = Math.min(notPick, pick);\\n        return memo[index][target];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n <= 1)\\n            return n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i*i <= n; i++) {\\n            list.add(i*i);\\n        }\\n        \\n        int[][] memo = new int[list.size()][n+1];\\n        for(int target = 0; target <= n; target++) {\\n            memo[0][target] = target;\\n        }\\n        \\n        for(int index = 1; index < list.size(); index++) {\\n            for(int target = 1; target <= n; target++) {\\n                int notPick = memo[index-1][target];\\n                int pick = Integer.MAX_VALUE;\\n                if(target >= list.get(index))\\n                    pick = 1 + memo[index][target-list.get(index)];\\n                \\n                memo[index][target] = Math.min(pick, notPick);\\n            }\\n        }\\n        \\n        return memo[list.size()-1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715281,
                "title": "dp-easy-solution-c",
                "content": "# Perfect Squares\\n```\\nclass Solution {\\n\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 0);\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            int sqroot = sqrt(i);\\n            if(sqroot*sqroot==i) dp[i]=1;\\n            else\\n            {\\n                int m=INT_MAX;\\n                for(int j=sqroot; j>0; j--)\\n                    m=min(m, dp[i-j*j]);\\n                dp[i]=m+1;\\n            }           \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 0);\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            int sqroot = sqrt(i);\\n            if(sqroot*sqroot==i) dp[i]=1;\\n            else\\n            {\\n                int m=INT_MAX;\\n                for(int j=sqroot; j>0; j--)\\n                    m=min(m, dp[i-j*j]);\\n                dp[i]=m+1;\\n            }           \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704124,
                "title": "bfs-using-java-easy-visual-explanation",
                "content": "Key Idea with an example (below screenshot):\\n- Top-Down and Left-Right (BFS on k-ary tree) approach.\\n- Each input number `N` is considered a node, the number of children for each node = `[number of perfect squares upto N]`\\n- The children are the subtracted values from the parent. Each child\\'s value = `(parentValue - perfectSquare)`\\n- At each level, the queue holds the current level nodes. (Only unique values are pushed into the queue)\\n- From implementation perspective, you can append null at the end of every level.\\n\\t- During this course, at any point of time you find a node with value 0 - you have found the perfect sum, return the parent\\'s level (or current level based on how you implement - in my case, I update the level after parsing all the nodes of that *current* level).\\n\\t- The levels are ultimately how many numbers are involved in the perfect square sum.\\n\\t- Else at some point of time, the queue will be left with `null` after parsing through all possible unique values (`<= N`)\\n- The below screenshot is a visual representation:\\n![image](https://assets.leetcode.com/users/images/e1c87d13-98e4-4bd2-85e3-1e726a979965_1642663756.65276.png)\\n**Note:** The orange nodes indicate duplicate or negative values which are invalid. The green is the actual path that led to the required sum.\\n\\n**Time Complexity:** `O(sqrt(n) * n)`\\n**Space Complexity:** `O(k^(l-1))` (maximum number of nodes at a certain level in a queue), where  `k = sqrt(n)` and `l = level`\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int level = 1;\\n        \\n        //Perfect squares uptil n - O(sqrt(n))\\n        List<Integer> perfectSquares = new LinkedList<>();\\n        for(int num = 1; num * num <= n; ++num)\\n            perfectSquares.add(num * num);\\n        \\n        Set<Integer> visitedNumbers = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        queue.offer(null);\\n        \\n\\t\\t// O(sqrt(n) * n)\\n        while(queue.size() > 1) {\\n            Integer element = queue.poll();\\n            \\n            if(element != null) {\\n                for(Integer perfectSquare: perfectSquares) {\\n                    int remain = element - perfectSquare;\\n                    \\n                    if(remain < 0)\\n                        break;\\n                    else if(remain == 0)\\n                        return level;\\n                    else if(visitedNumbers.add(remain))\\n                        queue.offer(remain);\\n                }\\n            } else { // parsed all the nodes in the current level. Update the variable to current level\\n                level++;\\n                queue.offer(null);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int level = 1;\\n        \\n        //Perfect squares uptil n - O(sqrt(n))\\n        List<Integer> perfectSquares = new LinkedList<>();\\n        for(int num = 1; num * num <= n; ++num)\\n            perfectSquares.add(num * num);\\n        \\n        Set<Integer> visitedNumbers = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(n);\\n        queue.offer(null);\\n        \\n\\t\\t// O(sqrt(n) * n)\\n        while(queue.size() > 1) {\\n            Integer element = queue.poll();\\n            \\n            if(element != null) {\\n                for(Integer perfectSquare: perfectSquares) {\\n                    int remain = element - perfectSquare;\\n                    \\n                    if(remain < 0)\\n                        break;\\n                    else if(remain == 0)\\n                        return level;\\n                    else if(visitedNumbers.add(remain))\\n                        queue.offer(remain);\\n                }\\n            } else { // parsed all the nodes in the current level. Update the variable to current level\\n                level++;\\n                queue.offer(null);\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520544,
                "title": "javascript-solution-dp",
                "content": "```\\nfunction numSquares(n) {\\n    let dp = Array(n+1).fill(Infinity);\\n    dp[0] = 0; // number of perfect square to get here;\\n    for(let g=1; g<=n; g++){\\n        for(let k=1; k*k<=g; k++){\\n            dp[g] = Math.min(dp[g], dp[g - (k*k)] + 1) \\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction numSquares(n) {\\n    let dp = Array(n+1).fill(Infinity);\\n    dp[0] = 0; // number of perfect square to get here;\\n    for(let g=1; g<=n; g++){\\n        for(let k=1; k*k<=g; k++){\\n            dp[g] = Math.min(dp[g], dp[g - (k*k)] + 1) \\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520487,
                "title": "easy-java-solution-dp-bfs-multiple-approaches",
                "content": "```\\n// Dynamic Programming - Bottom up\\n// Space Complexity: O(n)\\n// Time Complexity: O(n * k) where k is the number of integers whose square is less than n\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        dp[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\n**BFS**\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n\\t    // Compute all the squares which is less than or equal to n\\n        List<Integer> squares = new ArrayList<>();\\n        for(int j = 1; j * j <= n; j++) {\\n            squares.add(j * j);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int count = 1, N = squares.size();\\n        while(queue.size() > 0) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int num = queue.remove();\\n                for(int i = N - 1; i >= 0; i--) {\\n                    int newNum = num + squares.get(i);\\n                    if(newNum == n)\\n                        return count;\\n\\t\\t\\t\\t\\telse if(newNum > n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n                    if(!set.contains(newNum)) {\\n                        set.add(newNum);\\n                        queue.add(newNum);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Dynamic Programming - Bottom up\\n// Space Complexity: O(n)\\n// Time Complexity: O(n * k) where k is the number of integers whose square is less than n\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        int dp[] = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        \\n        dp[0] = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j * j <= i; j++) {\\n                dp[i] = Math.min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n\\t    // Compute all the squares which is less than or equal to n\\n        List<Integer> squares = new ArrayList<>();\\n        for(int j = 1; j * j <= n; j++) {\\n            squares.add(j * j);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int count = 1, N = squares.size();\\n        while(queue.size() > 0) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int num = queue.remove();\\n                for(int i = N - 1; i >= 0; i--) {\\n                    int newNum = num + squares.get(i);\\n                    if(newNum == n)\\n                        return count;\\n\\t\\t\\t\\t\\telse if(newNum > n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n                    if(!set.contains(newNum)) {\\n                        set.add(newNum);\\n                        queue.add(newNum);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343889,
                "title": "legendre-s-4-square-theorem-fastest-way-to-solve-this-o-rootn",
                "content": "If you find this helpful please upvote and like this :)\\n```\\n public int numSquares(int n) {\\n    if (isPerfectSquare(n))\\n        return 1;\\n\\n    /////// checking for possibility of 4 ---> 4^a(8b+7)///////\\n    while (n % 4 == 0) {\\n        n = n / 4;\\n    }\\n\\n    if (n % 8 == 7) {\\n        return 4;\\n    }\\n    ///////////////////////////////////////////////////////////\\n\\n    ////// possibility of 2 ---> where 2 numbers can be perfect squares///////\\n    for (int i = 1; i * i <= n; i++) {\\n        int otherHalf = n - (i * i);\\n\\n        if (isPerfectSquare(otherHalf))\\n            return 2;\\n    }\\n    /////////////////////////////////////////////////////////////////////////\\n\\n    return 3;\\n    // Since, our solution lies between 1-4, for anything else return 3\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n    double sq = Math.sqrt(n);\\n\\n    return Math.ceil(sq) == Math.floor(sq);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numSquares(int n) {\\n    if (isPerfectSquare(n))\\n        return 1;\\n\\n    /////// checking for possibility of 4 ---> 4^a(8b+7)///////\\n    while (n % 4 == 0) {\\n        n = n / 4;\\n    }\\n\\n    if (n % 8 == 7) {\\n        return 4;\\n    }\\n    ///////////////////////////////////////////////////////////\\n\\n    ////// possibility of 2 ---> where 2 numbers can be perfect squares///////\\n    for (int i = 1; i * i <= n; i++) {\\n        int otherHalf = n - (i * i);\\n\\n        if (isPerfectSquare(otherHalf))\\n            return 2;\\n    }\\n    /////////////////////////////////////////////////////////////////////////\\n\\n    return 3;\\n    // Since, our solution lies between 1-4, for anything else return 3\\n}\\n\\nprivate boolean isPerfectSquare(int n) {\\n    double sq = Math.sqrt(n);\\n\\n    return Math.ceil(sq) == Math.floor(sq);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201091,
                "title": "same-as-coin-change-problem",
                "content": "The only difference is you have to build your coins array yourself and amount is given as n.\\nAfter this the whole problem is same as [https://leetcode.com/problems/coin-change/]this.\\n\\n**Here is my code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int amount) {\\n       // similiar to coin change problem\\n       // now you have to find the coins too, this is the only diff\\n       \\n       vector<int>coins;\\n       int i=1;\\n       while(i*i<=amount){\\n           coins.push_back(i*i);    // build coins array\\n           i++;\\n       }\\n        \\n        int n=coins.size();\\n        int dp[n+1][amount+1];\\n        \\n        for(int i=0;i<=n;i++) dp[i][0]=0;\\n        for(int i=1;i<=amount;i++) dp[0][i]=INT_MAX-1;\\n        \\n        for(int i=1;i<=amount;i++){\\n            if(i%coins[0]==0) dp[1][i]=(i/coins[0]);\\n            else dp[1][i]=INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n             for(int j=1;j<=amount;j++){\\n                 if(coins[i-1]<=j) dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j]);\\n                 else dp[i][j]=dp[i-1][j];\\n             }\\n        }\\n       return dp[n][amount];\\n   }\\n};\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int amount) {\\n       // similiar to coin change problem\\n       // now you have to find the coins too, this is the only diff\\n       \\n       vector<int>coins;\\n       int i=1;\\n       while(i*i<=amount){\\n           coins.push_back(i*i);    // build coins array\\n           i++;\\n       }\\n        \\n        int n=coins.size();\\n        int dp[n+1][amount+1];\\n        \\n        for(int i=0;i<=n;i++) dp[i][0]=0;\\n        for(int i=1;i<=amount;i++) dp[0][i]=INT_MAX-1;\\n        \\n        for(int i=1;i<=amount;i++){\\n            if(i%coins[0]==0) dp[1][i]=(i/coins[0]);\\n            else dp[1][i]=INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<=n;i++){\\n             for(int j=1;j<=amount;j++){\\n                 if(coins[i-1]<=j) dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j]);\\n                 else dp[i][j]=dp[i-1][j];\\n             }\\n        }\\n       return dp[n][amount];\\n   }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760046,
                "title": "runtime-4-ms-faster-than-96-37-of-c-online-submissions",
                "content": "\\n\\n//Legendre\\'s three-square theorem\\n//states that a natural number can be represented as the sum of three squares of integers\\n//if and only if n is not of the form {\\\\displaystyle n=4^{a}(8b+7)}n = 4^a(8b + 7) for nonnegative integers a and b.\\n//The first numbers that cannot be expressed as the sum of three squares\\n//The first numbers that cannot be expressed as the sum of three squares\\n\\n    int numSquares(int n) {\\n       if(ceil(sqrt(n)==floor(sqrt(n)))){\\n          return 1;\\n       }\\n\\t   \\n      int x=n;\\n      while(x%4==0)\\n          x/=4;\\n\\t  \\n      if(x%8==7){\\n          return 4;\\n      }\\n\\t  \\n     for(int i=1;i*i<=n;i++){\\n         int base=sqrt(n-i*i);\\n         if(base*base==(n-i*i))\\n         return 2;\\n     }\\n    return 3;\\n    }\\n\\n//https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem****\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)\\n**",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n//Legendre\\'s three-square theorem\\n//states that a natural number can be represented as the sum of three squares of integers\\n//if and only if n is not of the form {\\\\displaystyle n=4^{a}(8b+7)}n = 4^a(8b + 7) for nonnegative integers a and b.\\n//The first numbers that cannot be expressed as the sum of three squares\\n//The first numbers that cannot be expressed as the sum of three squares\\n\\n    int numSquares(int n) {\\n       if(ceil(sqrt(n)==floor(sqrt(n)))){\\n          return 1;\\n       }\\n\\t   \\n      int x=n;\\n      while(x%4==0)\\n          x/=4;\\n\\t  \\n      if(x%8==7){\\n          return 4;\\n      }\\n\\t  \\n     for(int i=1;i*i<=n;i++){\\n         int base=sqrt(n-i*i);\\n         if(base*base==(n-i*i))\\n         return 2;\\n     }\\n    return 3;\\n    }\\n\\n//https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem****\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 695856,
                "title": "java-recursion-memoization",
                "content": "Personally I find it easier to get  to the answer if we  can solve  it  recursively before tabulating.\\n\\n```\\nclass Solution {\\n    int[] mem;\\n    public int numSquares(int n) {\\n        mem = new int[n+1];\\n        Arrays.fill(mem, -1);\\n        \\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if (n < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (mem[n] != -1) return mem[n];\\n        int min = n+1;\\n        for (int i=1;i*i<=n;i++) {\\n            min = Math.min(dfs(n-(i*i)), min);\\n        }\\n        mem[n] = min+1;\\n        return min+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] mem;\\n    public int numSquares(int n) {\\n        mem = new int[n+1];\\n        Arrays.fill(mem, -1);\\n        \\n        return dfs(n);\\n    }\\n    \\n    int dfs(int n) {\\n        if (n < 0) return Integer.MAX_VALUE;\\n        if (n == 0) return 0;\\n        if (mem[n] != -1) return mem[n];\\n        int min = n+1;\\n        for (int i=1;i*i<=n;i++) {\\n            min = Math.min(dfs(n-(i*i)), min);\\n        }\\n        mem[n] = min+1;\\n        return min+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71481,
                "title": "c-6ms-static-dp",
                "content": "Non-static DP, 89ms.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        return dp[n];\\n    }\\n};\\n```\\n***\\nStatic DP, 6ms.\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        static vector<int>dp(1, 0);\\n        for(int i = dp.size(); i <= n; i++){\\n            dp.push_back(INT_MAX);\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        static vector<int>dp(1, 0);\\n        for(int i = dp.size(); i <= n; i++){\\n            dp.push_back(INT_MAX);\\n            for(int j = 1; j * j <= i; j++)\\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71613,
                "title": "4ms-c-solution-without-dp-or-bfs",
                "content": "    class Solution {\\n        public:\\n        int numSquares(int n) {\\n            while (n % 4 == 0)    n /= 4;\\n            if (n % 8 == 7)    return 4;\\n            int m = sqrt(n);\\n            if (m * m == n)    return 1;\\n            if (n % 2 == 0)    n >>= 1;\\n            if (n % 4 == 3)    return 3;\\n            for (int i = 3; i * i < n; i += 4)\\n                if (n % i == 0) {\\n                    bool odd = true;\\n                    n /= i;\\n                    while (n % i == 0) {\\n                        odd = !odd;\\n                        n /= i;\\n                    }\\n                    if (odd)    return 3;\\n                }\\n            return 2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        int numSquares(int n) {\\n            while (n % 4 == 0)    n /= 4;\\n            if (n % 8 == 7)    return 4;\\n            int m = sqrt(n);\\n            if (m * m == n)    return 1;\\n            if (n % 2 == 0)    n >>= 1;\\n            if (n % 4 == 3)    return 3;\\n            for (int i = 3; i * i < n; i += 4)\\n                if (n % i == 0) {\\n                    bool odd = true;\\n                    n /= i;\\n                    while (n % i == 0) {\\n                        odd = !odd;\\n                        n /= i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 71631,
                "title": "10-lines-c-solution-dp-with-explanation",
                "content": "class Solution {\\n\\npublic:\\n\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        for(int i=0;i<=n;++i){\\n            dp[i]=i; //upper bound: sum up i 1's\\n            for(int j=1;i-j*j>=0;++j){\\n                if(dp[i-j*j]+1<dp[i]) dp[i]=dp[i-j*j]+1; //dp[i]=min(dp[i-j*j]+1 for all j from 1 to sqrt(i))\\n            }\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        for(int i=0;i<=n;++i){\\n            dp[i]=i; //upper bound: sum up i 1's\\n            for(int j=1;i-j*j>=0;++j){\\n                if(dp[i-j*j]+1<dp[i]) dp[i]=dp[i-j*j]+1; //dp[i]=min(dp[i-j*j]+1 for all j from 1 to sqrt(i))\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71635,
                "title": "python-common-bfs-with-fewer-lines",
                "content": "[Inspired by this][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/57218/python-accepted-solution\\n\\n    def numSquares(self, n):\\n        queue = collections.deque([(0, 0)])\\n        visited = set()\\n        while queue:\\n            i, step = queue.popleft()\\n            step += 1\\n            for j in xrange(1, n + 1):\\n                k = i + j * j\\n                if k > n:\\n                    break\\n                if k == n:\\n                    return step\\n                if k not in visited:\\n                    visited.add(k)\\n                    queue.append((k, step))",
                "solutionTags": [],
                "code": "[Inspired by this][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/57218/python-accepted-solution\\n\\n    def numSquares(self, n):\\n        queue = collections.deque([(0, 0)])\\n        visited = set()\\n        while queue:\\n            i, step = queue.popleft()\\n            step += 1\\n            for j in xrange(1, n + 1):\\n                k = i + j * j\\n                if k > n:\\n                    break\\n                if k == n:\\n                    return step\\n                if k not in visited:\\n                    visited.add(k)\\n                    queue.append((k, step))",
                "codeTag": "Python3"
            },
            {
                "id": 3728424,
                "title": "recursion-memoization-dp-tabulation-dp-c",
                "content": "# 1. Naive Recursive approach (TLE)\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n){\\n        if(n==0) return 0;\\n\\n        if(i*i <= n){\\n            return min(1+helper(i, n-i*i), helper(i+1, n));\\n        }\\n        return 1e5;\\n    }\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n, vector<int>&dp){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        if(i*i <= n){\\n            return dp[n]=min(1+helper(i, n-i*i, dp), helper(i+1, n, dp));\\n        }\\n        return dp[n]=1e5;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, -1);\\n        return helper(1, n, dp);\\n    }\\n};\\n```\\n\\n# 3. Tabulation(DP)\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 1e5);\\n        dp[0]=0;\\n        int j=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=min(1+dp[i-j*j], dp[i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int n){\\n        if(n==0) return 0;\\n\\n        if(i*i <= n){\\n            return min(1+helper(i, n-i*i), helper(i+1, n));\\n        }\\n        return 1e5;\\n    }\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int n, vector<int>&dp){\\n        if(n==0) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        if(i*i <= n){\\n            return dp[n]=min(1+helper(i, n-i*i, dp), helper(i+1, n, dp));\\n        }\\n        return dp[n]=1e5;\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, -1);\\n        return helper(1, n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1, 1e5);\\n        dp[0]=0;\\n        int j=1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=min(1+dp[i-j*j], dp[i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839975,
                "title": "c-straightforward-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper (vector<int> &sq, int n, vector<int>&dp){\\n        if (n == 0)\\n            return 0;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];        \\n        \\n        int val = INT_MAX;\\n        \\n        for (int j =0; j < sq.size (); j++){\\n            if(sq[j] > n)\\n                continue;\\n                      \\n            val = min (val,1+helper (sq,n-sq[j],dp));\\n        }\\n        \\n        return dp[n]=val;\\n    }\\n    int numSquares(int n) {\\n        vector<int> sq;\\n        \\n        int i = 1;\\n        int new_sq = 1;\\n        \\n        while (new_sq<=n){\\n            i++;\\n            sq.push_back (new_sq);\\n            new_sq = i*i;\\n        }\\n        \\n        vector<int> dp (n+1,-1);\\n        return helper (sq,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper (vector<int> &sq, int n, vector<int>&dp){\\n        if (n == 0)\\n            return 0;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];        \\n        \\n        int val = INT_MAX;\\n        \\n        for (int j =0; j < sq.size (); j++){\\n            if(sq[j] > n)\\n                continue;\\n                      \\n            val = min (val,1+helper (sq,n-sq[j],dp));\\n        }\\n        \\n        return dp[n]=val;\\n    }\\n    int numSquares(int n) {\\n        vector<int> sq;\\n        \\n        int i = 1;\\n        int new_sq = 1;\\n        \\n        while (new_sq<=n){\\n            i++;\\n            sq.push_back (new_sq);\\n            new_sq = i*i;\\n        }\\n        \\n        vector<int> dp (n+1,-1);\\n        return helper (sq,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837882,
                "title": "c-solution-dynamic-programming",
                "content": "Here is the solution using dynamic programming:\\n``` C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>     dp(n + 1, (int) 1e9);\\n        int             i, j;\\n\\n        i = 0;\\n        dp[0] = 0;\\n        while (++i < n + 1)\\n        {\\n            j = 1;\\n            while (j * j < i + 1)\\n                dp[i] = min(dp[i], dp[i - j * j++] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n*Upvote if you liked it*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>     dp(n + 1, (int) 1e9);\\n        int             i, j;\\n\\n        i = 0;\\n        dp[0] = 0;\\n        while (++i < n + 1)\\n        {\\n            j = 1;\\n            while (j * j < i + 1)\\n                dp[i] = min(dp[i], dp[i - j * j++] + 1);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520690,
                "title": "recursion-memoization-bottom-up-dp-bfs-queue",
                "content": "The intution of the problem can be derived by looking at top-down solution structure.\\n\\nStart from the given n which is the input.\\n\\n*Expectation:* To give the minimum possible count of perfect squares that sum upto n\\n\\n*Faith:* F(n)= 1 + F(n-sq) where sq is the perfect square no.\\n\\n*Base case:* Two base cases when F(N)==0 and F(N) < 0\\n\\n*Meeting Expectation with Faith:* Iterate over all possible square numbers uptil sqrt(N) and recursively find the answer result.\\n\\n\\n**Recursion + Memoization** \\n\\n```\\nint dp[10002];\\n        int solve(int n){\\n\\t\\t\\t//Base condition\\n            if(n==0){\\n                return 0;\\n            }\\n            if(n<0){\\n                return INT_MAX-1;\\n            }\\n            if(dp[n]!=-1){\\n                return dp[n];\\n            }\\n            int mx=INT_MAX;\\n            for(int i=1;i*i<=n;i++){\\n                int res=1+solve(n-(i*i));\\n                mx=min(res,mx);\\n            }\\n\\t\\t\\t//Memoization\\n            dp[n]=mx;\\n            return mx;\\n        }\\n        int numSquares(int n){\\n            memset(dp,-1,sizeof(dp));\\n            return solve(n);\\n        }\\n```\\n **Bottom-up DP**\\n```\\nint numSquares(int n){\\n\\t   int dp[10002]={0};\\n\\t   for(int i=1;i<=n;i++){\\n\\t\\t   int mn=INT_MAX;\\n\\t\\t   for(int j=1;j*j<=i;j++){\\n\\t\\t\\t   mn=min(mn,dp[i-(j*j)]);\\n\\t\\t\\t   dp[i]=1+mn;\\n\\t\\t   }\\n\\t   }\\n\\t   return dp[n];\\n   }\\n```\\n\\n**Breadth-First Search:**\\n\\nThis is the most optimal solution as we return once we encounter the base condition since we traverse breadth wise using queue.\\n\\n```\\nint numSquares(int n) {\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(n);\\n\\t\\tint count=0;\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint size=q.size();\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tint temp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tfor(int i=1;i*i<=temp;i++){\\n\\t\\t\\t\\t\\tif(temp-(i*i)>0){\\n\\t\\t\\t\\t\\t\\tq.push(temp-(i*i));\\n\\t\\t\\t\\t\\t}else if(temp-(i*i)==0){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n```\\n\\n*# Please upvote the solution you found this useful. Any comments would be encouraged.*",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[10002];\\n        int solve(int n){\\n\\t\\t\\t//Base condition\\n            if(n==0){\\n                return 0;\\n            }\\n            if(n<0){\\n                return INT_MAX-1;\\n            }\\n            if(dp[n]!=-1){\\n                return dp[n];\\n            }\\n            int mx=INT_MAX;\\n            for(int i=1;i*i<=n;i++){\\n                int res=1+solve(n-(i*i));\\n                mx=min(res,mx);\\n            }\\n\\t\\t\\t//Memoization\\n            dp[n]=mx;\\n            return mx;\\n        }\\n        int numSquares(int n){\\n            memset(dp,-1,sizeof(dp));\\n            return solve(n);\\n        }\\n```\n```\\nint numSquares(int n){\\n\\t   int dp[10002]={0};\\n\\t   for(int i=1;i<=n;i++){\\n\\t\\t   int mn=INT_MAX;\\n\\t\\t   for(int j=1;j*j<=i;j++){\\n\\t\\t\\t   mn=min(mn,dp[i-(j*j)]);\\n\\t\\t\\t   dp[i]=1+mn;\\n\\t\\t   }\\n\\t   }\\n\\t   return dp[n];\\n   }\\n```\n```\\nint numSquares(int n) {\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(n);\\n\\t\\tint count=0;\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint size=q.size();\\n\\t\\t\\twhile(size--){\\n\\t\\t\\t\\tint temp=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tfor(int i=1;i*i<=temp;i++){\\n\\t\\t\\t\\t\\tif(temp-(i*i)>0){\\n\\t\\t\\t\\t\\t\\tq.push(temp-(i*i));\\n\\t\\t\\t\\t\\t}else if(temp-(i*i)==0){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520589,
                "title": "c-memoization-tabulation-o-n-sqrt-n-time-and-space-dp",
                "content": "*IT\\'S THE PROBLEM OF UNBOUNDED KNAPSACK AND IT\\'S ALMOST SIMILAR TO [MINIMUM COIN CHANGE PROBLEM](https://leetcode.com/problems/coin-change/)*.\\n\\n**RECURSIVE+MEMOIZED APPROACH -**\\n```\\nclass Solution {\\npublic: \\n    int dp[101][10001];\\n    int knapsack(int W, int n){\\n        if(W==0 || n==0)\\n            return INT_MAX;\\n        if(dp[n][W]!=-1)\\n            return dp[n][W];\\n        int ps=n*n;\\n        if(ps<=W){\\n            int temp=knapsack(W-ps, n);\\n            return dp[n][W]=min(1+(temp==INT_MAX?0:temp),knapsack(W,n-1));\\n        }\\n        else\\n            return dp[n][W]=knapsack(W,n-1);\\n    }\\n    int numSquares(int n){\\n        memset(dp, -1, sizeof(dp));\\n        return knapsack(n,(int)sqrt(n));\\n    }\\n};\\n```\\n\\n**TABULATION APPROACH -**\\n```\\nclass Solution {\\npublic: \\n    int numSquares(int n){\\n        int sq_root=(int)sqrt(n);\\n        int dp[sq_root+1][n+1];\\n        \\n        for(int i=0;i<=sq_root;i++)\\n            for(int j=0;j<=n;j++)\\n                if(i==0 || j==0)\\n                    dp[i][j]=INT_MAX;\\n        \\n        for(int i=1;i<=sq_root;i++){\\n            for(int j=1;j<=n;j++){\\n                int ps=i*i;\\n                if(ps<=j)\\n                    dp[i][j]=min(1+(dp[i][j-ps]==INT_MAX?0:dp[i][j-ps]), dp[i-1][j]);\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }       \\n        return dp[sq_root][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[101][10001];\\n    int knapsack(int W, int n){\\n        if(W==0 || n==0)\\n            return INT_MAX;\\n        if(dp[n][W]!=-1)\\n            return dp[n][W];\\n        int ps=n*n;\\n        if(ps<=W){\\n            int temp=knapsack(W-ps, n);\\n            return dp[n][W]=min(1+(temp==INT_MAX?0:temp),knapsack(W,n-1));\\n        }\\n        else\\n            return dp[n][W]=knapsack(W,n-1);\\n    }\\n    int numSquares(int n){\\n        memset(dp, -1, sizeof(dp));\\n        return knapsack(n,(int)sqrt(n));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    int numSquares(int n){\\n        int sq_root=(int)sqrt(n);\\n        int dp[sq_root+1][n+1];\\n        \\n        for(int i=0;i<=sq_root;i++)\\n            for(int j=0;j<=n;j++)\\n                if(i==0 || j==0)\\n                    dp[i][j]=INT_MAX;\\n        \\n        for(int i=1;i<=sq_root;i++){\\n            for(int j=1;j<=n;j++){\\n                int ps=i*i;\\n                if(ps<=j)\\n                    dp[i][j]=min(1+(dp[i][j-ps]==INT_MAX?0:dp[i][j-ps]), dp[i-1][j]);\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }       \\n        return dp[sq_root][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147600,
                "title": "c-recursion-memonization-bottom-up-solutions-with-explanation",
                "content": "```\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be n subproblems for each problem i.e.., for each remainder amount, each\\n     * perfect square will be substracted and it goes on until the remainder is 0 or 1 or 2\\n     * or 3, the loop can be run till i * i <= n\\n     * Eg:\\n     *  1 -> 1^2 => only one perfect square is needed in order to make the sum 1\\n     *  2 -> 1^2 + 1^2  => only 2 perfect squares are needed in order to make the sum 2\\n     *  3 -> 1^2 + 1^2 + 1^2 => only 3 perfect squares are needed to make the sum 3\\n     *\\n     * Eg: n = 12, we can see that i can only go from 1 ... 3, bcz 4*4 > 12, no need to check\\n     *             for it\\n     *                                        12\\n     *                                        |\\n     *                       ------------------------------------\\n     *                      |                  |                 |\\n     *                  11(12-1^2)        8(12-2^2)           3(12-3^2)\\n     *                     |\\n     *             -------------------------\\n     *            |           |             |\\n     *        10(11-1^2)   7(11-2^2)      2(11-3^2)\\n     *\\n     * From above it is clear that for each iteration, there will n loop where n is no of\\n     * numbers where i * i < n\\n     *\\n     *    for (int i = 1; i * i < n; i++) {\\n     *       minNumber = min(minNumber, 1+ numSquares(n - i*i));\\n     *    }\\n     *\\n     * Base cases:\\n     * If n is <= 3 then we have solution for that problem, return n\\n     *\\n     */\\n    int numSquares(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares(n - i * i));\\n        }\\n\\n        return minNo;\\n    }\\n\\t/*\\n     * TopDown with Memonization\\n     *\\n     * As there are many duplicate subproblems and the solution to the problem can be\\n     * achieved if we have the solution to subproblems, dynamic programming can be\\n     * applied where intermediate solutions for the subproblems are stored in a map.\\n     * map points to num of perfect squares required that sum to n\\n    */\\n    std::vector<int> mp;\\n    int numSquares_memo(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // check if this subproblem is already evaluated\\n        if (mp[n] != -1) {\\n            // Subproblem is already evaluated, return the solution of it\\n            return mp[n];\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares_memo(n - i * i));\\n        }\\n\\n        // store the value in dp and return\\n        return mp[n] = minNo;\\n    }\\n\\n    int numSquares(int n) {\\n        // resize the vector to size n +1, +1 is for index 0 with default value of\\n        // -1\\n        mp.resize(n+1, -1);\\n\\n        return numSquares_memo(n);\\n    }\\n    /*\\n     * PerfectSquare BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top \\n     * solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght amount + 1 where +1 is for to have the case when n is zero, and each\\n     * index i hods the min number of perfect squares that sum to i\\n      *\\n     * As the min no of perfect squares required to make up the remainder amount, initialize the dp\\n     * array with a maximum value i.e.., INT_MAX or n + 1\\n     *\\n     * Eg: n = 12;\\n     *   Loop for each value of i ranges from 4 ... n\\n     *    Loop for each value of j ranges from 1 to j*j <= i\\n     *       dp[i] = std::min (dp[i] - dp[j*j] + 1) only when i >= coins[j]\\n\\n     * Base cases:\\n     * When n is <=3\\n     */\\n    int numSquares(int n) {\\n        if (n <= 3) {\\n            return n;\\n        }\\n        \\n        // dp array to store the intermediate solutions\\n        vector<int> dp(n + 1, INT_MAX);\\n\\n        // Base cases\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 3;\\n\\n        for (int i = 4; i <= n; i++) {\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * TopDown Approach or Recursive Solution\\n     *\\n     * There will be n subproblems for each problem i.e.., for each remainder amount, each\\n     * perfect square will be substracted and it goes on until the remainder is 0 or 1 or 2\\n     * or 3, the loop can be run till i * i <= n\\n     * Eg:\\n     *  1 -> 1^2 => only one perfect square is needed in order to make the sum 1\\n     *  2 -> 1^2 + 1^2  => only 2 perfect squares are needed in order to make the sum 2\\n     *  3 -> 1^2 + 1^2 + 1^2 => only 3 perfect squares are needed to make the sum 3\\n     *\\n     * Eg: n = 12, we can see that i can only go from 1 ... 3, bcz 4*4 > 12, no need to check\\n     *             for it\\n     *                                        12\\n     *                                        |\\n     *                       ------------------------------------\\n     *                      |                  |                 |\\n     *                  11(12-1^2)        8(12-2^2)           3(12-3^2)\\n     *                     |\\n     *             -------------------------\\n     *            |           |             |\\n     *        10(11-1^2)   7(11-2^2)      2(11-3^2)\\n     *\\n     * From above it is clear that for each iteration, there will n loop where n is no of\\n     * numbers where i * i < n\\n     *\\n     *    for (int i = 1; i * i < n; i++) {\\n     *       minNumber = min(minNumber, 1+ numSquares(n - i*i));\\n     *    }\\n     *\\n     * Base cases:\\n     * If n is <= 3 then we have solution for that problem, return n\\n     *\\n     */\\n    int numSquares(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares(n - i * i));\\n        }\\n\\n        return minNo;\\n    }\\n\\t/*\\n     * TopDown with Memonization\\n     *\\n     * As there are many duplicate subproblems and the solution to the problem can be\\n     * achieved if we have the solution to subproblems, dynamic programming can be\\n     * applied where intermediate solutions for the subproblems are stored in a map.\\n     * map points to num of perfect squares required that sum to n\\n    */\\n    std::vector<int> mp;\\n    int numSquares_memo(int n) {\\n        // Check if n is lessthan or equal to 3\\n        if (n <= 3) {\\n            return n;\\n        }\\n\\n        // check if this subproblem is already evaluated\\n        if (mp[n] != -1) {\\n            // Subproblem is already evaluated, return the solution of it\\n            return mp[n];\\n        }\\n\\n        // Value to store the result. As min value is needed, intialize with INT_MAX\\n        int minNo = INT_MAX;\\n\\n        // Loop for all elements whose squares are less than n\\n        for (int i = 1; i * i <= n; i++) {\\n            minNo = min(minNo, 1 + numSquares_memo(n - i * i));\\n        }\\n\\n        // store the value in dp and return\\n        return mp[n] = minNo;\\n    }\\n\\n    int numSquares(int n) {\\n        // resize the vector to size n +1, +1 is for index 0 with default value of\\n        // -1\\n        mp.resize(n+1, -1);\\n\\n        return numSquares_memo(n);\\n    }\\n    /*\\n     * PerfectSquare BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top \\n     * solution i.e.., solution of the problem\\n     *\\n     * The Dp table is of lenght amount + 1 where +1 is for to have the case when n is zero, and each\\n     * index i hods the min number of perfect squares that sum to i\\n      *\\n     * As the min no of perfect squares required to make up the remainder amount, initialize the dp\\n     * array with a maximum value i.e.., INT_MAX or n + 1\\n     *\\n     * Eg: n = 12;\\n     *   Loop for each value of i ranges from 4 ... n\\n     *    Loop for each value of j ranges from 1 to j*j <= i\\n     *       dp[i] = std::min (dp[i] - dp[j*j] + 1) only when i >= coins[j]\\n\\n     * Base cases:\\n     * When n is <=3\\n     */\\n    int numSquares(int n) {\\n        if (n <= 3) {\\n            return n;\\n        }\\n        \\n        // dp array to store the intermediate solutions\\n        vector<int> dp(n + 1, INT_MAX);\\n\\n        // Base cases\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        dp[3] = 3;\\n\\n        for (int i = 4; i <= n; i++) {\\n            for (int j = 1; j * j <= i; j++) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805994,
                "title": "4-approaches-java",
                "content": "\\n**Recursion -**\\n(Time limit exceeded)\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3){\\n            return n;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, numSquares(n-i*i)+1);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n**Recursion using Memoization -** \\n(An array can also be used instead of hashmap)\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        return find(n, map);\\n    }\\n    public int find(int n, HashMap<Integer, Integer> map){\\n        if(n<=3){\\n            return n;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, find(n-i*i,map)+1);\\n        }\\n        map.put(n,min);\\n        return min;\\n    }\\n}\\n```\\n\\n**Dynamic Programming -**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        //int sq_root = Math.sqrt(n);\\n        int[] dp = new int[n+1];\\n        for(int i = 1; i<=n; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j=1; j*j<=i; j++){\\n                dp[i] = Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Lagrange\\'s four-square theorem**\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        while(n%4==0){\\n            n/=4;\\n        }\\n        if(n%8==7){\\n            return 4;\\n        }\\n        int sq_root = (int)Math.sqrt(n);\\n        if(sq_root*sq_root==n){\\n            return 1;\\n        }\\n        for(int i = 1; i*i<=n; i++){\\n            sq_root=(int)Math.sqrt(n-i*i);\\n            if(sq_root*sq_root==(n-i*i)){\\n                return 2;\\n            }\\n        }\\n        return 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3){\\n            return n;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, numSquares(n-i*i)+1);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        return find(n, map);\\n    }\\n    public int find(int n, HashMap<Integer, Integer> map){\\n        if(n<=3){\\n            return n;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1; i*i<=n; i++){\\n            min = Math.min(min, find(n-i*i,map)+1);\\n        }\\n        map.put(n,min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        //int sq_root = Math.sqrt(n);\\n        int[] dp = new int[n+1];\\n        for(int i = 1; i<=n; i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j=1; j*j<=i; j++){\\n                dp[i] = Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<=3)\\n            return n;\\n        while(n%4==0){\\n            n/=4;\\n        }\\n        if(n%8==7){\\n            return 4;\\n        }\\n        int sq_root = (int)Math.sqrt(n);\\n        if(sq_root*sq_root==n){\\n            return 1;\\n        }\\n        for(int i = 1; i*i<=n; i++){\\n            sq_root=(int)Math.sqrt(n-i*i);\\n            if(sq_root*sq_root==(n-i*i)){\\n                return 2;\\n            }\\n        }\\n        return 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796164,
                "title": "java-simple-dp-solution-similar-to-coin-change-problem-o-n",
                "content": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] squares = getPerfectSquares(n);        \\n        \\n        int[] dp = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = n + 1;\\n            for(int square : squares) {\\n                if(square <= i) {\\n                    dp[i] = Math.min(dp[i], dp[i - square] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int[] getPerfectSquares(int n) {\\n        int totalSquares = (int) Math.sqrt(n);\\n        int[] squares = new int[totalSquares];\\n        \\n        for(int i = 1; i <= totalSquares; i++) {\\n            squares[i-1] = i * i;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] squares = getPerfectSquares(n);        \\n        \\n        int[] dp = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = n + 1;\\n            for(int square : squares) {\\n                if(square <= i) {\\n                    dp[i] = Math.min(dp[i], dp[i - square] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    int[] getPerfectSquares(int n) {\\n        int totalSquares = (int) Math.sqrt(n);\\n        int[] squares = new int[totalSquares];\\n        \\n        for(int i = 1; i <= totalSquares; i++) {\\n            squares[i-1] = i * i;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709099,
                "title": "java-dp-solution-o-nsqrt-n-easy",
                "content": "<hr>\\n\\n***upvote if you like the solution***\\n<hr>\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<4)\\n            return n;\\n        int dp[] = new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i]=i;\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        if(n<4)\\n            return n;\\n        int dp[] = new int[n+1];\\n        \\n        for(int i=1;i<=n;i++){\\n            dp[i]=i;\\n            for(int j=1;j*j<=i;j++){\\n                dp[i]=Math.min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622567,
                "title": "python-sol-by-math-90-w-comment",
                "content": "Python sol by math. ( [Lagrange\\'s four-square theorem](https://www.alpertron.com.ar/4SQUARES.HTM) )\\n\\n---\\n\\n**Implementation** by math:\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        while( n % 4 == 0 ):\\n            # Reduction by factor of 4\\n            n //= 4\\n            \\n        if n % 8 == 7:\\n            # Quick response for n = 8k + 7\\n            return 4\\n        \\n        # Check whether n = a^2 + b^2\\n        for a in range( int(sqrt(n))+1 ):\\n            \\n            b = int( sqrt( n - a*a ) )\\n            \\n            if ( a**2 + b ** 2 ) == n :\\n                return (a>0) + (b>0)\\n            \\n        # n = a^2 + b^2 + c^2\\n        return 3\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange\\'s_four-square_theorem)\\n\\n[2] [Proof of four-square theorem by Dario Alpern\\'s Web site](https://www.alpertron.com.ar/ENGLISH.HTM)\\n\\n[3] [Proof of four-square theorem by PlanetMath](https://planetmath.org/proofoflagrangesfoursquaretheorem)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        while( n % 4 == 0 ):\\n            # Reduction by factor of 4\\n            n //= 4\\n            \\n        if n % 8 == 7:\\n            # Quick response for n = 8k + 7\\n            return 4\\n        \\n        # Check whether n = a^2 + b^2\\n        for a in range( int(sqrt(n))+1 ):\\n            \\n            b = int( sqrt( n - a*a ) )\\n            \\n            if ( a**2 + b ** 2 ) == n :\\n                return (a>0) + (b>0)\\n            \\n        # n = a^2 + b^2 + c^2\\n        return 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346249,
                "title": "simple-javascript-dp-solution",
                "content": "```\\nvar numSquares = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[1] = 1;\\n    for(let sqr = 1; sqr * sqr <= n; sqr++) {\\n        for(let i = sqr * sqr; i < arr.length; i++) {\\n            if(arr[i] == 0) {\\n                arr[i] = arr[i - (sqr * sqr)] + 1;\\n            } else {\\n                arr[i] = Math.min(arr[i - (sqr * sqr)] + 1, arr[i]);\\n            }\\n        }\\n    }\\n    return arr[n];\\n};\\n```\\n\\n# Idea to Approach\\nThe first I did was that I had to visual what the solutions would have been from something as small `1` and onwards:\\n\\n`1` --> `1 (1)`\\n`2` --> `2 (1 + 1)`\\n`3` --> `3 (1 + 1 + 1)`\\n`4` --> `1 (4)`\\n`5` --> `2 (4 + 1)`\\n\\nLooking at this pattern, I knew this was a dynamic programming question because all we had to do was look at the previous one and add one.\\n\\nI know that the outer loop has to be such that `sqr * sqr` has to be less than or equal to `n`. We can\\'t make a sum where `sqr * sqr` is greater than `n`.\\n\\nSo with the first iteration where `sqr = 1`, we have the following array for `n`:\\n\\n`[0, 1, 2, 3, 4, 5, 6, 7, ... , n]`\\n\\nNext, we move onto `sqr = 2` where `sqr * sqr = 2 * 2 = 4`.\\n\\nWe noticed that everything that could use a `4` can also use a `1`, so we see which is smaller: `Math.min(arr[i - (sqr * sqr)] + 1, arr[i])`. This basically says, is the current amount that is in the array smaller if I simply added `1` or would it be smaller if I kept it the way it is. This example becomes apparent when `n = 12` where you have a choice between `12 = 9 + 1 + 1 + 1` or `12 = 4 + 4 + 4`. \\n\\nWe do this and we should return `arr[n]`.\\n\\nTime Complexity: `O(sqrt(n) * n)`\\nSpace Complexity: `O(n)`.",
                "solutionTags": [],
                "code": "```\\nvar numSquares = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[1] = 1;\\n    for(let sqr = 1; sqr * sqr <= n; sqr++) {\\n        for(let i = sqr * sqr; i < arr.length; i++) {\\n            if(arr[i] == 0) {\\n                arr[i] = arr[i - (sqr * sqr)] + 1;\\n            } else {\\n                arr[i] = Math.min(arr[i - (sqr * sqr)] + 1, arr[i]);\\n            }\\n        }\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165688,
                "title": "bfs-and-dp",
                "content": "* **BFS**\\nThe least number of perfect square numbers which sum to n can be regarded as the **Shortest-path** problem.\\n\\n```\\n    public int numSquares(int n) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\t\\t\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int sz = 0; sz < size; sz++) {\\n                int cur = queue.poll();\\n                if (cur > n) {\\n                    continue;\\n                }\\n                if (cur == n) {\\n                    return count;\\n                }\\n                for (int i = 1; cur + i * i <= n; i++) {\\n                    if (visited.contains(cur + i * i)) {\\n                        continue;\\n                    }\\n                    queue.add(cur + i * i);\\n                    visited.add(cur + i * i);\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n* **DP**\\n**state definition**\\nperfect square numbers sum\\n**state function**\\n\\t\\t`state[i]`, min number of perfect square numbers sum to i\\n**goal state**\\n\\t\\tstate[n]\\n**base case**\\n\\t\\tstate[0] = 0\\n**state transition**\\n\\t\\t`min(state[i - j * j] + 1) = state[i]`\\n**filling direction** \\n\\t\\ti, j increasing\\n\\n```\\n    public int numSquares01(int n) {\\n\\n        int[] state = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            state[i] = i;\\n            for (int j = 1; j <= i; j++) {\\n                if (j * j > i) {\\n                    break;\\n                }\\n                state[i] = Math.min(state[i - j * j] + 1, state[i]);\\n            }\\n        }\\n\\n        return state[n];\\n    }\\n```\\nThanks for **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\n    public int numSquares(int n) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n\\t\\t\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int sz = 0; sz < size; sz++) {\\n                int cur = queue.poll();\\n                if (cur > n) {\\n                    continue;\\n                }\\n                if (cur == n) {\\n                    return count;\\n                }\\n                for (int i = 1; cur + i * i <= n; i++) {\\n                    if (visited.contains(cur + i * i)) {\\n                        continue;\\n                    }\\n                    queue.add(cur + i * i);\\n                    visited.add(cur + i * i);\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return -1;\\n    }\\n```\n```\\n    public int numSquares01(int n) {\\n\\n        int[] state = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            state[i] = i;\\n            for (int j = 1; j <= i; j++) {\\n                if (j * j > i) {\\n                    break;\\n                }\\n                state[i] = Math.min(state[i - j * j] + 1, state[i]);\\n            }\\n        }\\n\\n        return state[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71500,
                "title": "simple-python-dp-solution",
                "content": "\\n    def numSquares(self, n):\\n  \\n        dp = [float(\"inf\") for i in range(n+1)]\\n        dp[1] = 1\\n        perfect = [1]\\n        for i in range(2,n+1) :\\n            if not i**0.5 - int(i**0.5) :\\n                dp[i] = 1\\n                perfect.append(i)\\n            else :            \\n                for j in perfect :\\n                    dp[i] = min(dp[i], dp[i-j] + 1)\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    def numSquares(self, n):\\n  \\n        dp = [float(\"inf\") for i in range(n+1)]\\n        dp[1] = 1\\n        perfect = [1]\\n        for i in range(2,n+1) :\\n            if not i**0.5 - int(i**0.5) :\\n                dp[i] = 1\\n                perfect.append(i)\\n            else :            \\n                for j in perfect :\\n                    dp[i] = min(dp[i], dp[i-j] + 1)\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3824644,
                "title": "c-beginner-friendly-rec-memo-tabulation",
                "content": "\\n# Recursive Approach\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n\\n    int helper(int i, int tar) {\\n        if (tar == 0) return 0;\\n\\n        if (tar < (i * i)) return 1e8;\\n\\n        int a = helper(i + 1, tar);\\n\\n        int b = 1e9;\\n\\n        if ((i * i) <= tar) {\\n            b = 1 + helper(i, tar - (i * i));\\n        }\\n\\n        return min(a, b);\\n    }\\n};\\n\\n```\\n\\n# Memoization Approach\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> memo(n + 1, -1);\\n        return helper(n, memo);\\n    }\\n\\n    int helper(int tar, vector<int>& memo) {\\n        if (tar == 0) return 0;\\n\\n        if (memo[tar] != -1) return memo[tar];\\n\\n        int res = 1e9;\\n        for (int i = 1; i * i <= tar; ++i) {\\n            res = min(res, 1 + helper(tar - i * i, memo));\\n        }\\n\\n        return memo[tar] = res;\\n    }\\n};\\n\\n```\\n\\n\\n# Tabulation Approach\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j * j <= i; ++j) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        return helper(1, n);\\n    }\\n\\n    int helper(int i, int tar) {\\n        if (tar == 0) return 0;\\n\\n        if (tar < (i * i)) return 1e8;\\n\\n        int a = helper(i + 1, tar);\\n\\n        int b = 1e9;\\n\\n        if ((i * i) <= tar) {\\n            b = 1 + helper(i, tar - (i * i));\\n        }\\n\\n        return min(a, b);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> memo(n + 1, -1);\\n        return helper(n, memo);\\n    }\\n\\n    int helper(int tar, vector<int>& memo) {\\n        if (tar == 0) return 0;\\n\\n        if (memo[tar] != -1) return memo[tar];\\n\\n        int res = 1e9;\\n        for (int i = 1; i * i <= tar; ++i) {\\n            res = min(res, 1 + helper(tar - i * i, memo));\\n        }\\n\\n        return memo[tar] = res;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j * j <= i; ++j) {\\n                dp[i] = min(dp[i], 1 + dp[i - j * j]);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745996,
                "title": "recursive-approach-dp-c",
                "content": "Using a ```for``` loop, iterate over all the perfect squares which are less than or equal to ```n```\\n![image](https://assets.leetcode.com/users/images/8f16bf4f-9db0-4bed-bc50-3e5cd6bcf028_1689001268.4572203.jpeg)\\n\\nRecursive solution\\n```\\nclass Solution {\\n    int solve(int n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int ans = 1e9;\\n        \\n        for(int i = 1; i*i <= n; i++){\\n            ans = min(ans, 1 + solve(n - i*i));\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int numSquares(int n) {\\n        return solve(n);\\n    }\\n};\\n```\\n\\n\\nOptimization using Dynamic Programming, Tabulation\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            int ans = 1e9;\\n            for(int j = 1; j*j <= i; j++){\\n                ans = min(ans, 1 + dp[i - j*j]);\\n            }\\n            \\n            dp[i] = ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```for```\n```n```\n```\\nclass Solution {\\n    int solve(int n){\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int ans = 1e9;\\n        \\n        for(int i = 1; i*i <= n; i++){\\n            ans = min(ans, 1 + solve(n - i*i));\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    int numSquares(int n) {\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            int ans = 1e9;\\n            for(int j = 1; j*j <= i; j++){\\n                ans = min(ans, 1 + dp[i - j*j]);\\n            }\\n            \\n            dp[i] = ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692440,
                "title": "easy-solution-1d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check for every n - t (where t is every square less than n) for minimum . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a vector to store the minimum number of squares to every number \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; int ml = -1; \\n    int numSquares(int n) {\\n        if(n == 0) return 0; \\n        if(ml == -1){\\n            vector<int> temp(n+1, -1); \\n            dp = temp; ml++; \\n        }\\n\\n        int temp = 1; int count = INT_MAX; \\n        while(temp* temp <= n){\\n            if(dp[n - temp*temp] == -1) dp[n - temp*temp] = numSquares(n - temp*temp) ; \\n            int t = dp[ n - temp*temp]; \\n            if(count > t + 1) count = t+1; temp++; \\n        }\\n\\n        if(count == INT_MAX) return 0 ;\\n        return count; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp; int ml = -1; \\n    int numSquares(int n) {\\n        if(n == 0) return 0; \\n        if(ml == -1){\\n            vector<int> temp(n+1, -1); \\n            dp = temp; ml++; \\n        }\\n\\n        int temp = 1; int count = INT_MAX; \\n        while(temp* temp <= n){\\n            if(dp[n - temp*temp] == -1) dp[n - temp*temp] = numSquares(n - temp*temp) ; \\n            int t = dp[ n - temp*temp]; \\n            if(count > t + 1) count = t+1; temp++; \\n        }\\n\\n        if(count == INT_MAX) return 0 ;\\n        return count; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108298,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int n,vector<int>&v,vector<vector<int>>&dp){\\n        if(i==0){\\n            if(n%v[0]==0) return n/v[0];\\n            else return 1e9;\\n        }\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        int nt=0+f(i-1,n,v,dp);\\n        int tt=1e9;\\n        if(v[i]<=n){\\n            tt=1+f(i,n-v[i],v,dp);\\n        }\\n        return dp[i][n]=min(nt,tt);\\n    }\\n    int numSquares(int n) {\\n        \\n        vector<int>v;\\n        for(int i=1;i<=100;i++){\\n            v.push_back(i*i);\\n        }\\n        vector<vector<int>>dp(v.size(),vector<int>(n+1,-1));\\n        return f(99,n,v,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int n,vector<int>&v,vector<vector<int>>&dp){\\n        if(i==0){\\n            if(n%v[0]==0) return n/v[0];\\n            else return 1e9;\\n        }\\n        if(dp[i][n]!=-1) return dp[i][n];\\n        int nt=0+f(i-1,n,v,dp);\\n        int tt=1e9;\\n        if(v[i]<=n){\\n            tt=1+f(i,n-v[i],v,dp);\\n        }\\n        return dp[i][n]=min(nt,tt);\\n    }\\n    int numSquares(int n) {\\n        \\n        vector<int>v;\\n        for(int i=1;i<=100;i++){\\n            v.push_back(i*i);\\n        }\\n        vector<vector<int>>dp(v.size(),vector<int>(n+1,-1));\\n        return f(99,n,v,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937660,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n         vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n)\\n        {\\n            int sq = count*count;\\n            for(int i = sq; i < n+1; i++) {\\n                dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n         vector<int> dp(n+1,INT_MAX);\\n        //base case\\n        dp[0]=0;\\n        int count = 1;\\n        while(count*count <= n)\\n        {\\n            int sq = count*count;\\n            for(int i = sq; i < n+1; i++) {\\n                dp[i] = min(dp[i-sq] + 1,dp[i]);\\n        }\\n        count++;\\n    }\\n    return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838509,
                "title": "c-clean-code-recursion-memoization-tabulation-easy-dp-approach-self-explanatory",
                "content": "**Upvote If It Helps**\\n\\n*Ask me in comments if you have any doubts*\\n\\n**Recursion Approach**\\n\\n*Getting TLE \\u26A0\\uFE0F\\u26A0\\uFE0F*\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i){\\n        if(i==0) return 0;\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num));\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        return helper(n);\\n    }\\n};\\n```\\n\\n**Memoization Approach**\\n\\n*Accepted \\u2705\\u2705*\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int>&dp){\\n        if(i==0) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num),dp);\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return dp[i]=minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return helper(n,dp);\\n    }\\n};\\n```\\n\\n**Tabulation Approach**\\n\\n*Accepted \\u2705\\u2705*\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int nums=1;nums<=n;++nums){\\n            int minCnt = INT_MAX;\\n            for (int num = 1; num <= sqrt(nums); num++)\\n            {\\n                int curCnt = 1 + dp[nums - (num*num)];\\n                minCnt = min(minCnt, curCnt);\\n            }\\n            dp[nums] = minCnt;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i){\\n        if(i==0) return 0;\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num));\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        return helper(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int>&dp){\\n        if(i==0) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minCnt=INT_MAX;\\n        for(int num=1;num<=sqrt(i);++num){\\n            int curCnt=1+helper(i-(num*num),dp);\\n            minCnt=min(curCnt,minCnt);\\n        }\\n        return dp[i]=minCnt;\\n    }\\n    \\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        return helper(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int nums=1;nums<=n;++nums){\\n            int minCnt = INT_MAX;\\n            for (int num = 1; num <= sqrt(nums); num++)\\n            {\\n                int curCnt = 1 + dp[nums - (num*num)];\\n                minCnt = min(minCnt, curCnt);\\n            }\\n            dp[nums] = minCnt;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838341,
                "title": "c-recursion-dp-comments-added",
                "content": "**\\u2705Please Upvote, If It Helps**\\n\\n**Approach 1 : USING RECURSION (TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(int n)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        for(int i=1;i<=sqrt(n);i++)\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return find(n);\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 : DP (MEMOIZATION)**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(int n,vector<int>& dp)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        \\n        for(int i=1;i<=sqrt(n);i++)               // go till square root of n because if we substract bigger value from n then it will become minus so don\\'t do that\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr,dp);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return dp[n] = mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n+1,-1);\\n        return find(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int n)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        for(int i=1;i<=sqrt(n);i++)\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        return find(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int n,vector<int>& dp)\\n    {\\n        // out of bound \\n        if(n==0) return 0;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        // trying to substract all possible perfect squares and take min one\\n        int mn = INT_MAX;\\n        \\n        for(int i=1;i<=sqrt(n);i++)               // go till square root of n because if we substract bigger value from n then it will become minus so don\\'t do that\\n        {\\n            int curr = i*i;                      // current perfect square\\n            int steps = 1 + find(n-curr,dp);       // substract curr square and go for next one\\n            \\n            mn = min(mn,steps);\\n        }\\n        \\n        return dp[n] = mn;\\n    }\\n    \\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n+1,-1);\\n        return find(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838107,
                "title": "c-solution-dp",
                "content": "```\\npublic int NumSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    for (int i = 1; i <= n; i++)\\n    {\\n        dp[i] = i;\\n        for (int j = 1; j * j <= i; j++)\\n        {\\n            dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int NumSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    for (int i = 1; i <= n; i++)\\n    {\\n        dp[i] = i;\\n        for (int j = 1; j * j <= i; j++)\\n        {\\n            dp[i] = Math.Min(dp[i], dp[i - j * j] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837942,
                "title": "c-very-easy-bfs-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        queue<int>q;\\n        unordered_set<int>seen;\\n        for(int i = 1;i * i <= n;i++){\\n            q.push(i * i);\\n            seen.insert(i * i);\\n        }\\n        int res = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == n){\\n                    return res;\\n                }\\n                for(int i = 1;i * i <= n;i++){\\n                    int newCur = cur + i * i;\\n                    if(newCur <= n and seen.find(newCur) == seen.end()){\\n                        q.push(newCur);\\n                        seen.insert(newCur);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        queue<int>q;\\n        unordered_set<int>seen;\\n        for(int i = 1;i * i <= n;i++){\\n            q.push(i * i);\\n            seen.insert(i * i);\\n        }\\n        int res = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == n){\\n                    return res;\\n                }\\n                for(int i = 1;i * i <= n;i++){\\n                    int newCur = cur + i * i;\\n                    if(newCur <= n and seen.find(newCur) == seen.end()){\\n                        q.push(newCur);\\n                        seen.insert(newCur);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837850,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "Solution:\\n```\\nclass Solution {\\n    func numSquares(_ n: Int) -> Int {\\n        var dp = Array(0...n)\\n        \\n        for i in 1...n {\\n            var j = 1\\n            \\n            while j * j <= i {\\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\\n                j += 1\\n            }\\n        }\\n        \\n        return dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func numSquares(_ n: Int) -> Int {\\n        var dp = Array(0...n)\\n        \\n        for i in 1...n {\\n            var j = 1\\n            \\n            while j * j <= i {\\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\\n                j += 1\\n            }\\n        }\\n        \\n        return dp[n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837555,
                "title": "daily-leetcoding-challenge-november-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/perfect-squares/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute-force Enumeration [Time Limit Exceeded]\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Greedy Enumeration\n\n  \n**Approach 4:** Greedy + BFS (Breadth-First Search)\n\n  \n**Approach 5:** Mathematics \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/perfect-squares/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 4:** Greedy + BFS (Breadth-First Search)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2713405,
                "title": "python-js-java-c-by-dp-coin-change-demo-visualization",
                "content": "[My tutorial of DP problem solving framework to Perfect Square [ English ]](https://medium.com/@cutesciuridae/dive-into-dp-take-perfect-squares-for-example-9f2cade1aa0d)\\n\\n[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://youtu.be/fg8EpbagC6Y)\\n\\n---\\n\\n**Hint**:\\n\\nThis is a variant of [Coin Change (Leetcode #322 )](https://leetcode.com/problems/coin-change/)\\n\\n**Absact transform model**\\n\\n**Coins** = {1, 4, 9, 16, 25, ..., closet square number up to n }\\n\\n**Value** = n, which is given from input\\n\\nSo, **minimal decomposition of n by square number** \\n<=> **minimal number of coin change to n by speical coins**, \\nmade up by a sequence of square number 1 , 4 , 9 ....\\n\\n---\\n\\nObserve the decomposition and derive DP state transfer function as below\\n\\n```\\nBase case:\\n\\nDP[ 0 ] = 0 \\n\\n0 cannot decomposed by positive perfect square\\n```\\n\\n```\\nGeneral case:\\n\\nDP[ i ] = min( DP[ i] , DP[ i - square number] + 1 )\\nwhere square number = 1, 4, 9, 16, 25, ... and so on\\n```\\n\\n\\n**Demo & Visualization**\\n\\n<img src=\"https://i.imgur.com/ezIjSuf.png\">\\n\\n---\\n\\n**Implementation** by Python\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        INF = sys.maxsize\\n        dp = [ INF for _ in range(n+1) ]\\n        dp[0] = 0\\n        \\n        root = 1\\n        square = root*root\\n        \\n        # for each square number 1, 4, 9, 16, 25...\\n        while( square <= n ) :\\n            \\n            # update dp value for number from square to n\\n            for i in range(square, n+1) :\\n                \\n                dp[i] = min( dp[i], dp[i-square]+1 )\\n            \\n            # go to next square number\\n            root += 1\\n            square = root*root\\n        \\n        \\n        return dp[n]\\n```\\n\\n---\\n\\n**Implementation** by Javascript\\n\\n```\\nvar numSquares = function(n) {\\n    \\n    // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n    let dp = new Array( n+1 ).fill( Number.MAX_SAFE_INTEGER );\\n        \\n    // Base case\\n    dp[0] = 0;\\n    \\n\\n    let root = 1;\\n    let square = root * root;\\n\\n    // for each square 1, 4, 9, 16, 25...\\n    while( square <= n ){\\n\\n        //  update dp value for number from square to n\\n        for( let i = square ; i <= n ; i++ ){\\n\\n            dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n        }\\n\\n        // go to next square number\\n        root ++;\\n        square = root * root;\\n    }\\n\\n    return dp[n];        \\n};\\n```\\n\\n---\\n\\n**Implementation** by Java\\n\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }\\n\\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n---\\n\\nShare top-down DP solution\\n\\nPython\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        coins = [x**2 for x in range(1, 101) ]\\n\\n        dp = {0:0 }\\n        def coinChange( i ):\\n\\n            if i in dp:\\n                return dp[i]\\n            \\n            best = float(\\'inf\\')\\n            for coin in coins:\\n                if coin > i: break\\n                best = min(best, coinChange(i - coin) + 1 )\\n\\n            dp[i] = best\\n            return dp[i]\\n        \\n        # ------------------------------\\n        return coinChange(n)\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nBase case:\\n\\nDP[ 0 ] = 0 \\n\\n0 cannot decomposed by positive perfect square\\n```\n```\\nGeneral case:\\n\\nDP[ i ] = min( DP[ i] , DP[ i - square number] + 1 )\\nwhere square number = 1, 4, 9, 16, 25, ... and so on\\n```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        \\n        INF = sys.maxsize\\n        dp = [ INF for _ in range(n+1) ]\\n        dp[0] = 0\\n        \\n        root = 1\\n        square = root*root\\n        \\n        # for each square number 1, 4, 9, 16, 25...\\n        while( square <= n ) :\\n            \\n            # update dp value for number from square to n\\n            for i in range(square, n+1) :\\n                \\n                dp[i] = min( dp[i], dp[i-square]+1 )\\n            \\n            # go to next square number\\n            root += 1\\n            square = root*root\\n        \\n        \\n        return dp[n]\\n```\n```\\nvar numSquares = function(n) {\\n    \\n    // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n    let dp = new Array( n+1 ).fill( Number.MAX_SAFE_INTEGER );\\n        \\n    // Base case\\n    dp[0] = 0;\\n    \\n\\n    let root = 1;\\n    let square = root * root;\\n\\n    // for each square 1, 4, 9, 16, 25...\\n    while( square <= n ){\\n\\n        //  update dp value for number from square to n\\n        for( let i = square ; i <= n ; i++ ){\\n\\n            dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n        }\\n\\n        // go to next square number\\n        root ++;\\n        square = root * root;\\n    }\\n\\n    return dp[n];        \\n};\\n```\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }\\n\\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = Math.min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }\\n            \\n            // go to next square number\\n            root ++;\\n            square = root * root;\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n\\n        coins = [x**2 for x in range(1, 101) ]\\n\\n        dp = {0:0 }\\n        def coinChange( i ):\\n\\n            if i in dp:\\n                return dp[i]\\n            \\n            best = float(\\'inf\\')\\n            for coin in coins:\\n                if coin > i: break\\n                best = min(best, coinChange(i - coin) + 1 )\\n\\n            dp[i] = best\\n            return dp[i]\\n        \\n        # ------------------------------\\n        return coinChange(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623357,
                "title": "c-recursion-rec-memo-bottom-up-approach",
                "content": "**Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n<0)return INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i))+1) ;\\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) {        \\n        return solve(n);\\n    }\\n};\\n```\\n\\n**REC+MEMO**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,unordered_map<int,int>& dp){\\n        if(dp.find(n)!=dp.end())return dp[n];\\n        if(n<0)return dp[n]=INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i),dp)+1) ;\\n        }\\n        \\n        return dp[n]=mini;\\n    }\\n    \\n    int numSquares(int n) {      \\n        unordered_map<int,int> dp;\\n        dp[0]=0;\\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n**Bottom up approach**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {      \\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=n;j++){\\n                int temp=j*j;\\n                if(i-temp>=0)\\n                    dp[i]=min(dp[i],dp[i-temp]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n<0)return INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i))+1) ;\\n        }\\n        \\n        return mini;\\n    }\\n    \\n    int numSquares(int n) {        \\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int n,unordered_map<int,int>& dp){\\n        if(dp.find(n)!=dp.end())return dp[n];\\n        if(n<0)return dp[n]=INT_MAX-1;\\n        \\n        int mini=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;i++){\\n           mini=min(mini,solve(n-(i*i),dp)+1) ;\\n        }\\n        \\n        return dp[n]=mini;\\n    }\\n    \\n    int numSquares(int n) {      \\n        unordered_map<int,int> dp;\\n        dp[0]=0;\\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {      \\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j*j<=n;j++){\\n                int temp=j*j;\\n                if(i-temp>=0)\\n                    dp[i]=min(dp[i],dp[i-temp]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491871,
                "title": "python-elegant-short-three-lines-91-28-faster-top-down-dp-lru-cache",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*\\u221An)\\n\\t\\tMemory: O(log(n))\\n\\t\\t\"\"\"\\n\\n\\t\\tdef numSquares(self, n: int) -> int:\\n\\t\\t\\treturn self._decompose(n)\\n\\n\\t\\t@classmethod\\n\\t\\t@lru_cache(None)\\n\\t\\tdef _decompose(cls, n: int) -> int:\\n\\t\\t\\tif n < 2:\\n\\t\\t\\t\\treturn n\\n\\t\\t\\treturn 1 + min(cls._decompose(n - i * i) for i in range(1, isqrt(n) + 1))\\n\\n![image](https://assets.leetcode.com/users/images/55de7265-4db5-446a-8645-e70955d9850f_1661630018.4927058.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*\\u221An)\\n\\t\\tMemory: O(log(n))\\n\\t\\t\"\"\"\\n\\n\\t\\tdef numSquares(self, n: int) -> int:\\n\\t\\t\\treturn self._decompose(n)\\n\\n\\t\\t@classmethod\\n\\t\\t@lru_cache(None)\\n\\t\\tdef _decompose(cls, n: int) -> int:\\n\\t\\t\\tif n < 2:\\n\\t\\t\\t\\treturn n\\n\\t\\t\\treturn 1 + min(cls._decompose(n - i * i) for i in range(1, isqrt(n) + 1))\\n\\n![image](https://assets.leetcode.com/users/images/55de7265-4db5-446a-8645-e70955d9850f_1661630018.4927058.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2281800,
                "title": "3-simple-c-solution",
                "content": "# Recursion\\n\\tclass Solution {\\n    int rec(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=n;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i));\\n        return ans;\\n    }\\n\\tpublic:\\n    int numSquares(int n)\\n    {\\n        return rec(n);        \\n    }\\n};\\n\\n# memomization\\n\\t\\n\\tclass Solution {\\n    int rec(int n,vector<int>&dp)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int &ans=dp[n];\\n        \\n        if(ans!=-1)\\n            return ans;\\n        \\n        ans=INT_MAX;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i,dp));\\n        return ans;\\n    }\\n\\tpublic:\\n    int numSquares(int n)\\n    {\\n        vector<int>dp(n+1,-1);\\n        return rec(n,dp);        \\n    }\\n\\t};\\n# tabulation\\n\\n\\n    int numSquares(int n)\\n    {\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0]=0;\\n        for(int i=1;i<=n;++i)\\n        {\\n            for(int j=1;j*j<=n;++j)\\n            {\\n                if(i>=j*j)\\n                    dp[i]=min(dp[i],1+dp[i-(j*j)]);\\n            }\\n        }\\n        return dp[n];        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int rec(int n)\\n    {\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=n;\\n        \\n        for(int i=1;i*i<=n;++i)\\n            ans=min(ans,1+rec(n-i*i));\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2031998,
                "title": "java-dp-vs-bfs-easy-to-understand",
                "content": "##### DP\\nGiven `dp[i]` is number of squares for `i`,\\nWe find that `dp[i] = min(dp[i - sq])` where sq = j * j and j <= i\\n\\n- time: `O(n^(3/2))`\\n- space: `O(n)`\\n```java\\npublic int numSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j * j <= i; j++) {\\n            int sq = j * j;\\n            dp[i] = Math.min(dp[i], dp[i - sq] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```\\n\\n##### BFS\\n\\nStart with `0` as the root\\nGo through every valid branch  `num`, where num = square + parent <= n , square = i * i\\n\\nPrune:\\n1. prune the num already visited\\n2. prune the num > n\\n\\nGiven n = 12, the tree looks like this:\\n```\\n                     0\\n       /         /      \\\\        \\\\\\n      1\\t       2         4         9  \\n   /     \\\\    /   \\\\        \\\\\\n  2 3 5 10    6 11          8 \\n                    ...\\n```\\n\\n\\n- time: `O(n^(h/2))`, where `h` is the max number of recursion, `n^(1/2)` is the branch\\n- space: `O(n^(1/2))`, where `n^(1/2)` is the size of square numbers\\n```java\\npublic int numSquares(int n) {\\n    boolean[] visited = new boolean[n + 1];\\n    Queue<Integer> queue = new LinkedList<>();\\n    int count = 0;\\n\\n    queue.add(0);\\n\\n    while (!queue.isEmpty()) {\\n        Queue<Integer> temp = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int cur = queue.remove();\\n            if (cur == n) return count;\\n            for (int i = 1; cur + i * i <= n; i++) {\\n                int next = cur + i * i;\\n                if (!visited[next]) temp.add(next);\\n                visited[next] = true;\\n            }\\n        }\\n        queue = temp;\\n        count++;\\n    }\\n    return -1;\\n}\\n```\\n\\nPlease let me know if the explanation is helpful to you, thanks :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic int numSquares(int n) {\\n    int[] dp = new int[n + 1];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j * j <= i; j++) {\\n            int sq = j * j;\\n            dp[i] = Math.min(dp[i], dp[i - sq] + 1);\\n        }\\n    }\\n    return dp[n];\\n}\\n```\n```\\n                     0\\n       /         /      \\\\        \\\\\\n      1\\t       2         4         9  \\n   /     \\\\    /   \\\\        \\\\\\n  2 3 5 10    6 11          8 \\n                    ...\\n```\n```java\\npublic int numSquares(int n) {\\n    boolean[] visited = new boolean[n + 1];\\n    Queue<Integer> queue = new LinkedList<>();\\n    int count = 0;\\n\\n    queue.add(0);\\n\\n    while (!queue.isEmpty()) {\\n        Queue<Integer> temp = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int cur = queue.remove();\\n            if (cur == n) return count;\\n            for (int i = 1; cur + i * i <= n; i++) {\\n                int next = cur + i * i;\\n                if (!visited[next]) temp.add(next);\\n                visited[next] = true;\\n            }\\n        }\\n        queue = temp;\\n        count++;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1520694,
                "title": "legendre-s-theorem-solution-0-ms-faster-than-100-00",
                "content": "According to Legendre\\'s theorem, every natural number ```n``` can be represented as the sum of 3 squares of integer.\\nIf and only if ```n``` is not of the form ``4``<sup>``a``</sup>``(8b + 7)`` where ```a and b``` are nonnegative integers.\\n\\n```\\nint numSquares(int n)\\n    {\\n        if (ceil(sqrt(n))==floor(sqrt(n)))\\n            return 1;\\n        \\n        while (n%4==0)\\n            n/=4;\\n        if (n%8==7)\\n            return 4;\\n        \\n        for (int i=1;i*i<=n;i++)\\n        {\\n            int x=sqrt(n-(i*i));\\n            if ((x*x)==n-(i*i))\\n                return 2;\\n        }\\n        return 3;\\n    }\\n```\\n\\n```Time complexity :``` **O(sqrt(n))**\\n```Space complexity :``` **O(1)**",
                "solutionTags": [],
                "code": "```n```\n```n```\n```a and b```\n```\\nint numSquares(int n)\\n    {\\n        if (ceil(sqrt(n))==floor(sqrt(n)))\\n            return 1;\\n        \\n        while (n%4==0)\\n            n/=4;\\n        if (n%8==7)\\n            return 4;\\n        \\n        for (int i=1;i*i<=n;i++)\\n        {\\n            int x=sqrt(n-(i*i));\\n            if ((x*x)==n-(i*i))\\n                return 2;\\n        }\\n        return 3;\\n    }\\n```\n```Time complexity :```\n```Space complexity :```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385923,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int mi = INT_MAX;\\n            for(int j = 1 ; j*j <= i ; j++)\\n            {\\n                int rem = i - j*j;\\n                if(dp[rem] < mi)\\n                {\\n                    mi = dp[rem];\\n                }\\n            }\\n            dp[i] = mi + 1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) \\n    {\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int mi = INT_MAX;\\n            for(int j = 1 ; j*j <= i ; j++)\\n            {\\n                int rem = i - j*j;\\n                if(dp[rem] < mi)\\n                {\\n                    mi = dp[rem];\\n                }\\n            }\\n            dp[i] = mi + 1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069536,
                "title": "fastest-unique-method-using-python3",
                "content": "https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem\\nn = 4^a(8b + 7) for nonnegative integers a and b.\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if(isqrt(n) ** 2 == n):    # if its a perfect squre check\\n            return 1\\n        while( n % 4 ==0):  #Check if number is of the form 4^a(8b + 7) \\n            n /= 4        \\n        if(n %8 ==7): # check the 7 now\\n            return 4\\n        \\n        i=1\\n\\t\\t#Now just chekc for 2 if not 2 return 3\\n\\t\\t# now will find a break point which square is n- i*i\\n        while(i*i <=n):   \\n            b = int(sqrt(n - i*i))\\n            if(b*b == (n - i*i)):\\n                return 2\\n            i += 1\\n        return 3\\n        \\n   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        if(isqrt(n) ** 2 == n):    # if its a perfect squre check\\n            return 1\\n        while( n % 4 ==0):  #Check if number is of the form 4^a(8b + 7) \\n            n /= 4        \\n        if(n %8 ==7): # check the 7 now\\n            return 4\\n        \\n        i=1\\n\\t\\t#Now just chekc for 2 if not 2 return 3\\n\\t\\t# now will find a break point which square is n- i*i\\n        while(i*i <=n):   \\n            b = int(sqrt(n - i*i))\\n            if(b*b == (n - i*i)):\\n                return 2\\n            i += 1\\n        return 3\\n        \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892547,
                "title": "four-squares-theorem-python3",
                "content": "According to FOUR SQUARES THEOREM, any positive number can be expressed as a sum of 4 numbers including 0, so the answer is in 0,1,2,3,4. And when n % 8 = 7, the answer is 4.\\nWhen there exist a and b such that a^2 + b^2 = n, the answer is 1 or 2.\\nIn other cases, the answer is 3.\\nActually the answer can NOT be 0 since n is a positive number.\\nCode in PYTHON3:\\n\\n```\\n    def numSquares(self, n: int) -> int:\\n        while n % 4 == 0:\\n            n /= 4\\n        if n % 8 == 7:\\n            return 4\\n        a = 0\\n        while a**2 <= n:\\n            b = int((n-a**2)**0.5)\\n            if a**2 + b**2 == n:\\n                return bool(a) + bool(b)\\n            a += 1\\n        return 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def numSquares(self, n: int) -> int:\\n        while n % 4 == 0:\\n            n /= 4\\n        if n % 8 == 7:\\n            return 4\\n        a = 0\\n        while a**2 <= n:\\n            b = int((n-a**2)**0.5)\\n            if a**2 + b**2 == n:\\n                return bool(a) + bool(b)\\n            a += 1\\n        return 3\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 843569,
                "title": "c-dp-solution-same-coin-change-problem",
                "content": "**Keeping the perfect squares in an array, intuition of coin change problem**\\n\\n```\\nRuntime: 280 ms, faster than 40.15% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6.2 MB, less than 82.07% of C++ online submissions for Perfect Squares.\\n\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        int sqrt_n = sqrt(n);\\n        int perfectSquares[sqrt_n];\\n        for(int i=1;i<=sqrt_n;i++)\\n        {\\n            perfectSquares[i-1] = i*i;\\n        }\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int s : perfectSquares)\\n            {\\n                if(i-s<0)break;\\n                \\n                dp[i] = min(dp[i],dp[i-s]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n.\\n\\n**Not keeping the perfect squares in an array, simplification of above approach**\\n\\n.\\n```\\nRuntime: 220 ms, faster than 56.93% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6 MB, less than 92.56% of C++ online submissions for Perfect Squares.\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int j=1;j*j<=i;j++)\\n            {\\n                dp[i] = min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nRuntime: 280 ms, faster than 40.15% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6.2 MB, less than 82.07% of C++ online submissions for Perfect Squares.\\n\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        int sqrt_n = sqrt(n);\\n        int perfectSquares[sqrt_n];\\n        for(int i=1;i<=sqrt_n;i++)\\n        {\\n            perfectSquares[i-1] = i*i;\\n        }\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int s : perfectSquares)\\n            {\\n                if(i-s<0)break;\\n                \\n                dp[i] = min(dp[i],dp[i-s]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nRuntime: 220 ms, faster than 56.93% of C++ online submissions for Perfect Squares.\\nMemory Usage: 6 MB, less than 92.56% of C++ online submissions for Perfect Squares.\\n\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        if(n==0)return 0;\\n        \\n        int dp[n+1];\\n        dp[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = INT_MAX;\\n            for(int j=1;j*j<=i;j++)\\n            {\\n                dp[i] = min(dp[i],dp[i-j*j]+1);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707771,
                "title": "c-simple-dynamic-programming-solution",
                "content": "```csharp\\npublic int NumSquares(int n) \\n{\\n\\tint[] d = new int[n + 1];\\n\\n\\tfor(int i = 1; i <= n; i++)\\n\\t{\\n\\t\\td[i] = int.MaxValue;\\n\\n\\t\\tfor(int j = 1; j * j <= i; j++)\\n\\t\\t{\\n\\t\\t\\td[i] = Math.Min(d[i], d[i - j * j] + 1);\\n\\t\\t}            \\n\\t}\\n\\n\\treturn d[n];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```csharp\\npublic int NumSquares(int n) \\n{\\n\\tint[] d = new int[n + 1];\\n\\n\\tfor(int i = 1; i <= n; i++)\\n\\t{\\n\\t\\td[i] = int.MaxValue;\\n\\n\\t\\tfor(int j = 1; j * j <= i; j++)\\n\\t\\t{\\n\\t\\t\\td[i] = Math.Min(d[i], d[i - j * j] + 1);\\n\\t\\t}            \\n\\t}\\n\\n\\treturn d[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571528,
                "title": "c-fast-20ms-90-faster-solution-memoization-easy-to-understand-well-commented-solution",
                "content": "To understand concept of my code lets take an example of 12.\\nI will search for nearest square less than 12. Here it is 3^2=9. Let num=3=sqrt(n)\\nNow my value of num will chage from num to num/2, which can only give best answer.(its an observation)\\nLogic behind this is smaller values than num/2 can be used in next function call.\\n\\nI am writing cases on how function call will happen:-\\n3^2+1^2+1^2+1^2 \\n2^2+2^2+2^2    \\nans=3 steps\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minSteps(int n,int* memo){\\n        //Base Case\\n        if(n==0)\\n            return 0;\\n        \\n        if(memo[n]!=-1)return memo[n];\\n        //I will search for closest square to n\\n        int num=sqrt(n);\\n        int ans=INT_MAX;\\n        //I observed for minimum steps our num varies from sqrt(n) to sqrt(n)/2\\n        //As we can use numbers below sqrt(n)/2 in next function call\\n        while(num>=sqrt(n)/2){\\n            int op=minSteps(n-num*num,memo);\\n            ans=min(ans,op);\\n            if(op<=1)break; //If our op<=1 that will be always our minimum, we can observe that\\n            num--;\\n        }\\n        memo[n]=1+ans;\\n        return 1+ans;\\n    }\\n    int numSquares(int n) {\\n        int* memo=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            memo[i]=-1;\\n        }\\n        return minSteps(n,memo);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(int n,int* memo){\\n        //Base Case\\n        if(n==0)\\n            return 0;\\n        \\n        if(memo[n]!=-1)return memo[n];\\n        //I will search for closest square to n\\n        int num=sqrt(n);\\n        int ans=INT_MAX;\\n        //I observed for minimum steps our num varies from sqrt(n) to sqrt(n)/2\\n        //As we can use numbers below sqrt(n)/2 in next function call\\n        while(num>=sqrt(n)/2){\\n            int op=minSteps(n-num*num,memo);\\n            ans=min(ans,op);\\n            if(op<=1)break; //If our op<=1 that will be always our minimum, we can observe that\\n            num--;\\n        }\\n        memo[n]=1+ans;\\n        return 1+ans;\\n    }\\n    int numSquares(int n) {\\n        int* memo=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            memo[i]=-1;\\n        }\\n        return minSteps(n,memo);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406592,
                "title": "bfs-solution-python-easy-understand",
                "content": "```\\ndef numSquares(self, n: int) -> int:\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\tres, q, sub_q = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return res\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tsub_q.add(node-square)\\n\\t\\tq, sub_q, res = sub_q, set(), res+1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef numSquares(self, n: int) -> int:\\n\\tsquares = [i**2 for i in range(1, int(n**0.5)+1)]\\n\\tres, q, sub_q = 1, {n}, set()\\n\\twhile q:\\n\\t\\tfor node in q:\\n\\t\\t\\tfor square in squares:\\n\\t\\t\\t\\tif node == square: return res\\n\\t\\t\\t\\tif node < square: break\\n\\t\\t\\t\\tsub_q.add(node-square)\\n\\t\\tq, sub_q, res = sub_q, set(), res+1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395607,
                "title": "python-dp-solution-4-lines",
                "content": "```\\nclass Solution(object):\\n    def numSquares(self,n):\\n        dp = [0] * (n+1)\\n        for i in range(1,n+1):\\n            dp[i] = min([dp[i-j*j] for j in range(1,int(i**.5)+1)])+1\\n        return dp[n]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSquares(self,n):\\n        dp = [0] * (n+1)\\n        for i in range(1,n+1):\\n            dp[i] = min([dp[i-j*j] for j in range(1,int(i**.5)+1)])+1\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325717,
                "title": "pure-math-python3-solution",
                "content": "According to [Lagrange\\'s four-square theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem), the result must be one of [1,2,3,4] for any integer n. \\nQuick notes without proof:\\n1. the results for n and 4n are the same, so do n /= 4 until n%4 != 0.\\n2. if n%8 == 7, the result must be 4. Check the integer you get after step 1.\\n3. if 2 failed, use a for loop to check if n is sum of two perfect squares i and j. Note that i or j might be 0, in this situation, return 1. Otherwise, return 2. \\n\\nAll other situations return 3.\\nDiscussion regarding the mathematical proofs are welcomed. Credit to [Grandyang](https://www.cnblogs.com/grandyang/p/4800552.html)\\n\\n\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        while not (n%4):       #results are the same for n and 4n\\n            n /= 4\\n        if n%8 == 7:\\n            return 4\\n        x = math.ceil(math.sqrt(n))\\n        for i in range(x):\\n            j = math.floor(math.sqrt(n - i*i))\\n            if i*i + j*j == n:\\n                if i > 0 and j > 0:\\n                    return 2\\n                else:\\n                    return 1           \\n        return 3  \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        while not (n%4):       #results are the same for n and 4n\\n            n /= 4\\n        if n%8 == 7:\\n            return 4\\n        x = math.ceil(math.sqrt(n))\\n        for i in range(x):\\n            j = math.floor(math.sqrt(n - i*i))\\n            if i*i + j*j == n:\\n                if i > 0 and j > 0:\\n                    return 2\\n                else:\\n                    return 1           \\n        return 3  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 223357,
                "title": "c-0-s-100-math-solution",
                "content": "The idea is to use basic square-root check for 1, Lagrange\\'s 4 squares theorem for 4 (which is also the maximum, since theorem states every integer can be represented by sum of 4 squares). This only leaves case 2 and 3. To check case 2, all  we need is to iterate through to sqrt of n, and check if the difference between n and square of i is also a square. If this fails, then we know it must be 3.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == (int) sqrt((double) n) * sqrt((double) n)) return 1;\\n        while(n % 4 == 0)  n /= 4;\\n        if(n % 8 == 7) return 4;\\n        for(int i = 0; i*i < n; ++i) {\\n            int a = n - i*i;\\n            if(a == (int) sqrt((double) a) * sqrt((double) a)) return 2;\\n        }\\n        return 3;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == (int) sqrt((double) n) * sqrt((double) n)) return 1;\\n        while(n % 4 == 0)  n /= 4;\\n        if(n % 8 == 7) return 4;\\n        for(int i = 0; i*i < n; ++i) {\\n            int a = n - i*i;\\n            if(a == (int) sqrt((double) a) * sqrt((double) a)) return 2;\\n        }\\n        return 3;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 188250,
                "title": "python-bidirectional-bfs-72ms-beats-90-faster-than-some-of-the-math-theorem-solutions",
                "content": "```python\\ndef numSquares(self, n):\\n    front, back, pm = [0], [n], 1 # pm is \"plus minus\"\\n    depth = [0] + [None] * (n - 1) + [-1] # depth[0] == 0, depth[n] == -1, depth[everythingElse] == None\\n    while front:\\n        newFront = []\\n        for v in front:\\n            i = 1\\n            while True:\\n                w = v + pm * i * i # generate a neighbor\\n                if w < 0 or w > n: # all neighbors have been generated\\n                    break\\n                if depth[w] is None: # w has not been discovered\\n                    depth[w] = depth[v] + pm # mark it as discovered by assigning a depth to it\\n                    newFront.append(w)\\n                elif (depth[w] < 0) != (depth[v] < 0): # w has been discovered in the `back` tree, so we\\'re done\\n                    return abs(depth[w] - depth[v])\\n                i += 1\\n        front = newFront\\n        if len(front) > len(back):\\n            front, back, pm = back, front, -pm # always expand the tree with fewer leaves\\n```\\n### Explanation\\n\\nWe have a graph with `n + 1` vertices labeled `0` through `n`. There is an (unweighted) edge between vertices `i` and `j` if and only if `abs(i - j)` is a perfect square. The goal is to find the shortest path between `0` and `n`. This is a job for BFS.\\n\\nWe use bidirectional BFS starting from both `0` and `n` for efficiency. The 2 BFS trees rooted at `0` and `n` are called `front` and `back`; `front` always refers to the tree currently being expanded, which is always set to be the tree with fewer leaves. (This is a pretty standard trick for bidirectional BFS.)\\n\\nThe trick with `depth` is this: For the tree rooted at `0`, all its nodes have \"normal\" `depth`, i.e., `depth[0] == 0`, `depth[1] == 1`, `depth[4] == 1`, `depth[9] == 1`, etc. For the other tree rooted at `n`, all its nodes have negative depth; more precisely, their depths are recorded as the bitwise NOT of their \"normal\" depth, i.e., `depth[n] == ~0 == -1`, `depth[n-1] == ~1 == -2`, `depth[n-4] == ~1 == -2`, `depth[n-9] == ~1 == -2`, etc. Now if a node has non-negative depth, then we know it was discovered from the tree rooted at `0`; if a node has negative depth, then we know it was discovered from the tree rooted at `n`; **if it has both, then we have found the shortest path between `0` and `n`.**\\n\\n**More to come...**\\n\\n### Confession\\nAdmittedly, this algorithm is fast _because_ the theorem guarantees that no tree has to be searched beyond depth 2...",
                "solutionTags": [],
                "code": "```python\\ndef numSquares(self, n):\\n    front, back, pm = [0], [n], 1 # pm is \"plus minus\"\\n    depth = [0] + [None] * (n - 1) + [-1] # depth[0] == 0, depth[n] == -1, depth[everythingElse] == None\\n    while front:\\n        newFront = []\\n        for v in front:\\n            i = 1\\n            while True:\\n                w = v + pm * i * i # generate a neighbor\\n                if w < 0 or w > n: # all neighbors have been generated\\n                    break\\n                if depth[w] is None: # w has not been discovered\\n                    depth[w] = depth[v] + pm # mark it as discovered by assigning a depth to it\\n                    newFront.append(w)\\n                elif (depth[w] < 0) != (depth[v] < 0): # w has been discovered in the `back` tree, so we\\'re done\\n                    return abs(depth[w] - depth[v])\\n                i += 1\\n        front = newFront\\n        if len(front) > len(back):\\n            front, back, pm = back, front, -pm # always expand the tree with fewer leaves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 178862,
                "title": "why-is-this-dp-python-solution-having-time-limit-exceeded",
                "content": "Straight-forward DP solution but TLE???\\n```\\nclass Solution:\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=3:\\n            return n\\n        dp = [ 0,1,2,3 ]\\n        for i in range(4,n+1):\\n            minimum = float(\\'inf\\')\\n            j = 1\\n            while (i-j*j>=0):\\n                minimum = min(minimum,dp[i-j*j]+1)\\n                j+=1\\n            dp.append(minimum)\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n<=3:\\n            return n\\n        dp = [ 0,1,2,3 ]\\n        for i in range(4,n+1):\\n            minimum = float(\\'inf\\')\\n            j = 1\\n            while (i-j*j>=0):\\n                minimum = min(minimum,dp[i-j*j]+1)\\n                j+=1\\n            dp.append(minimum)\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71552,
                "title": "python-dp-accepted-the-secret-to-fix-the-python-tle-error",
                "content": "I just submitted a simple bottom-up DP solution in python and got a TLE. I searched through the discussions and saw many other people are struggling with TLE for their python code.\\n\\nAfter struggling with my code a little bit, I finally figure out the issue.\\nNote that in my accepted code below, my dp array is declared as a class variable. However, if you uncomment the __init__ function to turn it to an instance variable, then you get the TLE error. Thus it is pretty obvious that the test script is written in a bad way where a different instance is created every time a new number is tested.\\n\\nSo try to get your TLE'ed version of Python code, turn your dp array into a class variable, and try it again. It should be accepted. Note that you do not need any of the simple optimizations I made below to get the code accepted.\\n\\nTo the Admin of the site: Please fix the test script!\\n\\n\\n```\\nclass Solution(object):\\n    \\n    \"\"\"\\n    # making the dp array an instance variable would cause TLE\\n    def __init__(self):\\n        self.dp = [0]\\n    \"\"\"\\n        \\n    dp = [0] # so now dp is a class variable\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(self.dp), n+1):\\n            result = sys.maxsize\\n            k = int(math.sqrt(i))\\n            if k * k == i:\\n                self.dp.append(1)\\n                continue\\n            for j in range(1, int(math.sqrt(i)) + 1):\\n                result = min(result, self.dp[i - j * j] + 1)\\n                if result is 2:\\n                    break\\n            self.dp.append(result)\\n        return self.dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    \"\"\"\\n    # making the dp array an instance variable would cause TLE\\n    def __init__(self):\\n        self.dp = [0]\\n    \"\"\"\\n        \\n    dp = [0] # so now dp is a class variable\\n    def numSquares(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(self.dp), n+1):\\n            result = sys.maxsize\\n            k = int(math.sqrt(i))\\n            if k * k == i:\\n                self.dp.append(1)\\n                continue\\n            for j in range(1, int(math.sqrt(i)) + 1):\\n                result = min(result, self.dp[i - j * j] + 1)\\n                if result is 2:\\n                    break\\n            self.dp.append(result)\\n        return self.dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71595,
                "title": "java-use-lagrange-s-four-square-theorem",
                "content": "    public class Solution {\\n    public int numSquares(int n) {\\n        if(n <= 0)\\n            return 0;\\n        \\n        while(n % 4 == 0)\\n            n /= 4;\\n        \\n        //4condition\\n        if(n % 8 == 7)\\n            return 4;\\n        //1 or 2 condition\\n        for(int i = 0; i * i <= n; i++)\\n        {\\n            int j = (int)Math.sqrt(n - i * i);\\n            if(j * j + i * i == n)\\n            {\\n                return (i > 0 ? 1 : 0) + (j > 0 ? 1 : 0);\\n            }\\n        }\\n        //else 3\\n        return 3;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSquares(int n) {\\n        if(n <= 0)\\n            return 0;\\n        \\n        while(n % 4 == 0)\\n            n /= 4;\\n        \\n        //4condition\\n        if(n % 8 == 7)\\n            return 4;\\n        //1 or 2 condition\\n        for(int i = 0; i * i <= n; i++)\\n        {\\n            int j = (int)Math.sqrt(n - i * i);\\n            if(j * j + i * i == n)\\n            {\\n                return (i > 0 ? 1 : 0) + (j > 0 ? 1 : 0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71634,
                "title": "5-lines-python-static-dp-160ms",
                "content": "    class Solution(object):\\n        numSquaresDP = [0]\\n        def numSquares(self, n):\\n            if len(self.numSquaresDP) <= n:\\n                perfectSqr = [v**2 for v in xrange(1, int(math.sqrt(n)) + 1)]\\n                for i in xrange(len(self.numSquaresDP), n + 1):\\n                    self.numSquaresDP.append( min(1 + self.numSquaresDP[i - sqr] for sqr in perfectSqr if sqr <= i))\\n            return self.numSquaresDP[n]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        numSquaresDP = [0]\\n        def numSquares(self, n):\\n            if len(self.numSquaresDP) <= n:\\n                perfectSqr = [v**2 for v in xrange(1, int(math.sqrt(n)) + 1)]\\n                for i in xrange(len(self.numSquaresDP), n + 1):\\n                    self.numSquaresDP.append( min(1 + self.numSquaresDP[i - sqr] for sqr in perfectSqr if sqr <= i))\\n            return self.numSquaresDP[n]",
                "codeTag": "Java"
            },
            {
                "id": 71672,
                "title": "java-dp-solution-not-perfect-o-n-time-but-simple",
                "content": "    public class Solution {\\n        public int numSquares(int n) {\\n            if (n == 0) {\\n                return 0;\\n            }\\n            int[] table = new int[n];\\n            int count = 1;\\n            for (int i = 0; i < n; i++) {\\n                if ((i + 1) == count * count) {\\n                    table[i] = 1;\\n                    count++;\\n                } else {\\n                    table[i] = Integer.MAX_VALUE;\\n                    for (int j = count - 1; j > 0; j--) {\\n                        if (table[i - j * j] + 1 < table[i]) {\\n                            table[i] = table[i - j * j] + 1;\\n                        }\\n                    }\\n                }\\n            }\\n            return table[n - 1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numSquares(int n) {\\n            if (n == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3656846,
                "title": "ezzzzzzzzzzzzzzzz",
                "content": "# Intuition\\nso the intuition here is solving for subproblems as we can have large cases .\\n\\n# Approach\\nBasic approach basically i made a helper fucntion\\nthen we will start computing sqaures of numbers less than n and we will see which number needs the lowest count. i*I is used because the sqaure cant exceed the number for example if 15 is given you cant take 9 because its sqaure will exceed 15 and that is of no use . \\n\\n# Complexity\\n- Time complexity:\\n- time will be \\n\\n\\n- Space complexity:\\ndp array space + recursion call stack ( can be eliminated by tabulation)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int solve (int n,vector<int>&dp ){\\n         if(n==0) return 0;\\n         if(dp[n]!=-1) return dp[n];\\n           int ans =n;\\n         for( int i =1;i*i<=n;i++){\\n             int temp =i*i;\\n          ans =  min(ans,1+ solve(n-temp,dp));\\n         }\\n         return dp[n]= ans;\\n     }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n       return solve (n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve (int n,vector<int>&dp ){\\n         if(n==0) return 0;\\n         if(dp[n]!=-1) return dp[n];\\n           int ans =n;\\n         for( int i =1;i*i<=n;i++){\\n             int temp =i*i;\\n          ans =  min(ans,1+ solve(n-temp,dp));\\n         }\\n         return dp[n]= ans;\\n     }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n       return solve (n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411226,
                "title": "python3-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [20000 for _ in range(n + 1)]\\n        dp[0] = 0\\n        ps = []\\n\\n        for i in range(1,n + 1):\\n            if pow(i, 2) > n:\\n                break\\n            ps.append(i ** 2)\\n\\n        for i in range(n + 1):\\n            for j in ps:\\n                if i + j <= n:\\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\\n                else:\\n                    break\\n\\n        return dp[n]\\n```\\n# How it works\\nSo in the DP Array (Dynamic Programming Array) the rest except for the first one will be every big, why?, well because, you need to find the smallest value right? but if it samll like 0 and there is something bigger like x, it will need to be like this min(0,x) well 0 would be smaller and the answer will be 0. the for loop is basically finding all the perfect square what PS stands for, so I did it to make it faster, not anything else, and also the second for loop is calcualting, so we will find lots of possible results using Dynamic Programming and then, compare them. well thats it, you final answer will be at the end.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [20000 for _ in range(n + 1)]\\n        dp[0] = 0\\n        ps = []\\n\\n        for i in range(1,n + 1):\\n            if pow(i, 2) > n:\\n                break\\n            ps.append(i ** 2)\\n\\n        for i in range(n + 1):\\n            for j in ps:\\n                if i + j <= n:\\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\\n                else:\\n                    break\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221641,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n        int mini = INT_MAX;\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n        return dp[i][sum] = mini;\\n    }\\n    int numSquares(int n) {\\n        vector<int> arr;\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n        int mini = INT_MAX;\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n        return dp[i][sum] = mini;\\n    }\\n    int numSquares(int n) {\\n        vector<int> arr;\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840321,
                "title": "c-shortest-path-bfs-explanation",
                "content": "1. We can use shortest path algorithm to reach the nth position.\\n2. store all the valid perfect squares until they are less than equals to 10^4.\\n3. Then apply bfs algorithm to reach the indexes in the shortest possible steps.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == 10000)\\n            return 1;\\n        vector<int>dp;\\n        vector<int>sd(10001,INT_MAX);\\n        queue<int>q;\\n        for(int i=1;i<101;i++)\\n        {\\n            dp.push_back(i*i);\\n            sd[i*i] = 1;\\n            q.push(i*i);\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:dp)\\n            {\\n                int newnode = node + i;\\n                if(newnode <= n && sd[newnode] > sd[node] + 1)\\n                {\\n                    sd[newnode] = sd[node] + 1;\\n                    q.push(newnode);\\n                }\\n            }\\n        }\\n        return sd[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        if(n == 10000)\\n            return 1;\\n        vector<int>dp;\\n        vector<int>sd(10001,INT_MAX);\\n        queue<int>q;\\n        for(int i=1;i<101;i++)\\n        {\\n            dp.push_back(i*i);\\n            sd[i*i] = 1;\\n            q.push(i*i);\\n        }\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:dp)\\n            {\\n                int newnode = node + i;\\n                if(newnode <= n && sd[newnode] > sd[node] + 1)\\n                {\\n                    sd[newnode] = sd[node] + 1;\\n                    q.push(newnode);\\n                }\\n            }\\n        }\\n        return sd[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839419,
                "title": "dp-easy-explained-cpp",
                "content": "# Approach\\nif we create a fixed size vector, \\n        it will generate heap-buffer-overflow,\\n        because leetcode is reusing the vector, \\n        so we need to dynamically change its size to fit different testcases\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //padding ahead\\n        static vector<int> dp = {0};\\n        \\n        while(dp.size() <= n){\\n            int i = dp.size();\\n            int count = INT_MAX;\\n            for(int j = 1; j*j <= i; ++j){\\n                count = min(count, dp[i-j*j]+1);\\n            }\\n            dp.push_back(count);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        //padding ahead\\n        static vector<int> dp = {0};\\n        \\n        while(dp.size() <= n){\\n            int i = dp.size();\\n            int count = INT_MAX;\\n            for(int j = 1; j*j <= i; ++j){\\n                count = min(count, dp[i-j*j]+1);\\n            }\\n            dp.push_back(count);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838691,
                "title": "java-dynamic-programming-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            int min = Integer.MAX_VALUE;\\n\\n            for (int j = 1; j * j <= i; j++) {\\n                int remaining = i - j * j;\\n                min = Math.min(dp[remaining], min);\\n            }\\n\\n            dp[i] = min + 1;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n * sqrt(n)), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            int min = Integer.MAX_VALUE;\\n\\n            for (int j = 1; j * j <= i; j++) {\\n                int remaining = i - j * j;\\n                min = Math.min(dp[remaining], min);\\n            }\\n\\n            dp[i] = min + 1;\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n// TC: O(n * sqrt(n)), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838496,
                "title": "java-dp-solutions-bfs-and-dfs-readable-and-commented",
                "content": "```\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        // Shortest path stuff is generally breadth first search\\n        // Since we go one step at a time, the most efficient one is usually bfs\\n        // BFS is generally about going level by level, one step at a time, so first answer is the quickest\\n        \\n        // We perform the DFS step but one step at a time and for all :) [Refer Down]      \\n        Queue<Integer> queue= new LinkedList<>();\\n        HashSet <Integer> visit= new HashSet<>(); // To remove duplicate values in queue\\n        if (n>0)\\n            queue.add(n);\\n        int count=0;\\n        \\n        while (!queue.isEmpty())\\n        {\\n            count++;\\n            // Level Order Traversal\\n            int size= queue.size();\\n            for (int j=1; j<=size; j++)\\n           {  \\n                int value= queue.poll();\\n                int div= (int)Math.sqrt(value);\\n                \\n                for (int i=1; i<= div; i++)\\n                {   \\n                    if ((value-i*i)==0)\\n                        return count;\\n\\n                    else if(visit.add(value-i*i))\\n                        queue.add(value-i*i);\\n                }\\n           }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n/*\\nDFS Solution:\\n\\npublic int numSquares(int n) \\n    {\\n        Integer dp[]= new Integer[n+1];\\n        return solver(n, dp);        \\n    }\\n    \\n    public int solver(int value, Integer dp[])\\n    {\\n        if (value<=0)\\n            return 0;\\n        \\n        if (dp[value]!=null)\\n            return dp[value];\\n        \\n        int count=0, max=Integer.MAX_VALUE;\\n        int div= (int)Math.sqrt(value);\\n        \\n        for (int i=1; i<= div; i++)\\n        {\\n          count= 1+ solver(value-i*i, dp);\\n          max= Math.min(max, count);\\n        }\\n        \\n        return dp[value]=max;\\n    }\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numSquares(int n) {\\n        // Shortest path stuff is generally breadth first search\\n        // Since we go one step at a time, the most efficient one is usually bfs\\n        // BFS is generally about going level by level, one step at a time, so first answer is the quickest\\n        \\n        // We perform the DFS step but one step at a time and for all :) [Refer Down]      \\n        Queue<Integer> queue= new LinkedList<>();\\n        HashSet <Integer> visit= new HashSet<>(); // To remove duplicate values in queue\\n        if (n>0)\\n            queue.add(n);\\n        int count=0;\\n        \\n        while (!queue.isEmpty())\\n        {\\n            count++;\\n            // Level Order Traversal\\n            int size= queue.size();\\n            for (int j=1; j<=size; j++)\\n           {  \\n                int value= queue.poll();\\n                int div= (int)Math.sqrt(value);\\n                \\n                for (int i=1; i<= div; i++)\\n                {   \\n                    if ((value-i*i)==0)\\n                        return count;\\n\\n                    else if(visit.add(value-i*i))\\n                        queue.add(value-i*i);\\n                }\\n           }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n/*\\nDFS Solution:\\n\\npublic int numSquares(int n) \\n    {\\n        Integer dp[]= new Integer[n+1];\\n        return solver(n, dp);        \\n    }\\n    \\n    public int solver(int value, Integer dp[])\\n    {\\n        if (value<=0)\\n            return 0;\\n        \\n        if (dp[value]!=null)\\n            return dp[value];\\n        \\n        int count=0, max=Integer.MAX_VALUE;\\n        int div= (int)Math.sqrt(value);\\n        \\n        for (int i=1; i<= div; i++)\\n        {\\n          count= 1+ solver(value-i*i, dp);\\n          max= Math.min(max, count);\\n        }\\n        \\n        return dp[value]=max;\\n    }\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837814,
                "title": "python-4-lines-can-it-be-any-more-concise",
                "content": "```\\n@lru_cache(None)\\ndef dp(n: int) -> int:\\n    return 0 if n == 0 else min(dp(n-(x+1)**2) for x in range(floor(sqrt(n)))) + 1\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        return dp(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n@lru_cache(None)\\ndef dp(n: int) -> int:\\n    return 0 if n == 0 else min(dp(n-(x+1)**2) for x in range(floor(sqrt(n)))) + 1\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831156,
                "title": "easy-code-in-c-dp-memoization",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int calculate(int i,int n,vector<int>& dp){\\n        if(n==0)\\n            return 0;\\n        if(i*i>n)\\n            return INT_MAX-1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=min(1+calculate(i,n-i*i,dp),calculate(i+1,n,dp));\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calculate(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(int i,int n,vector<int>& dp){\\n        if(n==0)\\n            return 0;\\n        if(i*i>n)\\n            return INT_MAX-1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=min(1+calculate(i,n-i*i,dp),calculate(i+1,n,dp));\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calculate(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539881,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion]\\n\\n![image](https://assets.leetcode.com/users/images/69f13e6d-b66d-44d9-adef-1c3dd22417a8_1662464954.5946724.png)\\n\\n**T->O(Expo) && S->O(sqrt(n)) [Recursion stack sapce]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int target,int n){\\n\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i*i==n) return 1;\\n\\t\\t\\tint pick=1e9;\\n\\t\\t\\tif(target>=i*i) pick=1+f(i,target-i*i,n);\\n\\t\\t\\tint notpick=f(i+1,target,n);\\n\\t\\t\\treturn min(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\treturn f(1,n,n);\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 2 [Memoziation]\\n![image](https://assets.leetcode.com/users/images/cc0bd746-fc36-49bb-8dc2-137e9c7e2dbf_1662464673.2329597.png)\\n\\n**T->O(sqrt(n) X n) && S->O(sqrt(n) X n) + O(sqrt(n)) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int target,int n,vector<vector<int>>& dp){\\n\\t\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(i*i==n) return 1;\\n\\t\\t\\t\\tif(dp[i][target]!=-1) return dp[i][target];\\n\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\tif(target>=i*i) pick=1+f(i,target-i*i,n,dp);\\n\\t\\t\\t\\tint notpick=f(i+1,target,n,dp);\\n\\t\\t\\t\\treturn dp[i][target]=min(pick,notpick);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint numSquares(int n) {\\n\\t\\t\\t\\tvector<vector<int>> dp(sqrt(n)+1,vector<int>(n+1,-1));\\n\\t\\t\\t\\treturn f(1,n,n,dp);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/9c238ae8-c171-48c7-9437-f9bdcd1d94d1_1662466619.3093004.png)\\n\\n**m=sqrt(n)\\nT->O(mn) && S->O(mn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\tvector<int> nums;\\n\\t\\t\\tfor(int i=1;i*i<=n;i++) nums.push_back(i*i);\\n\\t\\t\\tint m=nums.size();\\n\\t\\t\\tvector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n\\t\\t\\tfor(int target=1;target<=n;target++) dp[m][target]=1e9;\\n\\t\\t\\tfor(int i=m-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int target=0;target<=n;target++){\\n\\t\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\t\\tif(target>=nums[i]) pick=1+dp[i][target-nums[i]];\\n\\t\\t\\t\\t\\tint notpick=dp[i+1][target];\\n\\t\\t\\t\\t\\tdp[i][target]=min(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][n];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 4 [SpaceOptimization]\\t\\n![image](https://assets.leetcode.com/users/images/83d17d18-14cc-4616-b55e-6baf67b80b1f_1662466813.0273802.png)\\n\\n**T->O(mn) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSquares(int n) {\\n\\t\\t\\tvector<int> nums;\\n\\t\\t\\tfor(int i=1;i*i<=n;i++) nums.push_back(i*i);\\n\\t\\t\\tint m=nums.size();\\n\\t\\t\\tvector<int> prev(n+1,0),curr(n+1,0);\\n\\t\\t\\tfor(int target=1;target<=n;target++) prev[target]=1e9;\\n\\t\\t\\tfor(int i=m-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int target=0;target<=n;target++){\\n\\t\\t\\t\\t\\tint pick=1e9;\\n\\t\\t\\t\\t\\tif(target>=nums[i]) pick=1+curr[target-nums[i]];\\n\\t\\t\\t\\t\\tint notpick=prev[target];\\n\\t\\t\\t\\t\\tcurr[target]=min(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int target,int n){\\n\\t\\t\\tif(i*i>n){\\n\\t\\t\\t\\tif(!target) return 0;\\n\\t\\t\\t\\treturn 1e9;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2534059,
                "title": "c-91-95-faster-dp-easy-and-short-code",
                "content": "**If you think the solution is helpful, a simple hit of upvote is highly appreciated.**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        memset(dp,0x3f3f3f,sizeof(dp));\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j*j<=i;j++)\\n                dp[i]=min(dp[i],dp[i-j*j]+1);\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        int dp[n+1];\\n        memset(dp,0x3f3f3f,sizeof(dp));\\n        dp[0]=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j*j<=i;j++)\\n                dp[i]=min(dp[i],dp[i-j*j]+1);\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375058,
                "title": "using-easy-01-knapsack",
                "content": "1. form a list of perfectsquares that are less then n.\\n2. now we need to pick minimum number of perfect squares from the list such that their sum is equal to n.\\n\\tproblem based on similar prinicple - https://leetcode.com/problems/coin-change/\\n\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector<int> perfectSq;\\n        \\n        for(int i = 1; i*i <= n; ++i){\\n            perfectSq.push_back(i*i);\\n        }\\n        \\n        int m = perfectSq.size();\\n        vector<vector<int>> dp( m+1, vector<int>(n+1, 0));\\n        \\n        dp[0][0] = 0;\\n        for( int i = 1; i <= n; ++i ) dp[0][i] = INT_MAX;\\n        \\n        for(int i = 1; i <= m; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                \\n                if( j < perfectSq[i-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = min( dp[i-1][j], dp[i][ j - perfectSq[i-1] ] + 1);\\n                }\\n                \\n            }\\n        }\\n   \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        \\n        vector<int> perfectSq;\\n        \\n        for(int i = 1; i*i <= n; ++i){\\n            perfectSq.push_back(i*i);\\n        }\\n        \\n        int m = perfectSq.size();\\n        vector<vector<int>> dp( m+1, vector<int>(n+1, 0));\\n        \\n        dp[0][0] = 0;\\n        for( int i = 1; i <= n; ++i ) dp[0][i] = INT_MAX;\\n        \\n        for(int i = 1; i <= m; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                \\n                if( j < perfectSq[i-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = min( dp[i-1][j], dp[i][ j - perfectSq[i-1] ] + 1);\\n                }\\n                \\n            }\\n        }\\n   \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347500,
                "title": "c-bfs",
                "content": "**Runtime: 43 ms\\nMemory Usage: 9 MB**\\n* **Explanation:**\\n\\tWe need to go through every single possible perfect square combination. To do that we can use **Breath-First Search (BFS)**. We will need two things: ***queue*** (to store the current number) and ***\"distance\"*** (to hold the count of how many squares we have used). We go through this BFS until our current number reaches 0 => and we found a perfect squares sequence, also we know this is the most optimal solution since our current number is strictly decreasing and reaching 0 will result in the least amount of perfect squares used.\\n* **Optimization:**\\n\\t\\t1. Since our number n can only consist of perfect squares, we will have to iterate only from ***1 till sqrt(n) since sqrt(n) * sqrt(n) = n*** => our number.\\n\\t\\t2. If we come across the same number as before, we will not need to add such a number to the queue, since we will already go through (or have gone through) that number\\'s perfect squares. We can do this using an array, which is filled with -1, when we come across a unique number, we can set that array element to any number besides -1, this marks it as visited.\\n* **NOTE: Please tell me if my explanation is poorly written or is hard to understand or isn\\'t understandable**\\n```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n \\xA0 \\xA0 \\xA0 \\xA0int visited[n + 1];\\n \\xA0 \\xA0 \\xA0 \\xA0fill_n(visited, n + 1, -1);\\n        queue<int> q;\\n        int ans = 1;\\n        for (int i = 1; i * i <= n; ++i) {\\n            q.push(n - i * i); \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[n - i * i] = 69; // funny internet number\\n        }\\n        while (q.size()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; ++i) {\\n                int curr = q.front();\\n                if (curr == 0) return ans;\\n                q.pop();\\n                for (int j = 1; j * j <= curr; ++j) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (visited[curr - j * j] == -1) {\\n                        q.push(curr - j * j);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[curr - j * j] = 420; // another funny internet number\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        // useless, since we will always reach 0 (the sequence could consist of only 1\\'s => n <= 3)\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n \\xA0 \\xA0 \\xA0 \\xA0int visited[n + 1];\\n \\xA0 \\xA0 \\xA0 \\xA0fill_n(visited, n + 1, -1);\\n        queue<int> q;\\n        int ans = 1;\\n        for (int i = 1; i * i <= n; ++i) {\\n            q.push(n - i * i); \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[n - i * i] = 69; // funny internet number\\n        }\\n        while (q.size()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; ++i) {\\n                int curr = q.front();\\n                if (curr == 0) return ans;\\n                q.pop();\\n                for (int j = 1; j * j <= curr; ++j) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (visited[curr - j * j] == -1) {\\n                        q.push(curr - j * j);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0visited[curr - j * j] = 420; // another funny internet number\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        // useless, since we will always reach 0 (the sequence could consist of only 1\\'s => n <= 3)\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1692932,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1565279,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1572861,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1575503,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1576285,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1570172,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1567242,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569209,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692632,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569437,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692932,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1565279,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1572861,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1575503,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1576285,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1570172,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1567242,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569209,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1692632,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1569437,
                "content": [
                    {
                        "username": "karna001",
                        "content": "It is similar to coin change problem. just put all the perfect squares less than or equal to n in a vector and now its the same problem as the coin change, You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money., You may assume that you have an infinite number of each kind of coin."
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "kyu bataya yaar\\n"
                    },
                    {
                        "username": "karna001",
                        "content": "[@saklanishubham15](/saklanishubham15) yeah there are many better solutions based on number theory but i guess if in contest it\\'s asked one of the first intuition i will get is of this approach only."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "This solution is not optimized I think. I have done the same and it beats only 9%."
                    },
                    {
                        "username": "pushazhiniao",
                        "content": "Hi, I have done lots of questions of LC and noticed that with exactly the same algorithm and implementation, Java code is accepted while Python is LTE. Is it possible to adjust the time you allow Python to run?"
                    },
                    {
                        "username": "sidney3",
                        "content": "[@vikasboss6855](/vikasboss6855) @cache typically isn't allowed in coding interviews or OA's, so I wouldn't recommend this. With standard bottom up 1d DP (no @cache) I was able to solve this problem without TLE in Python\n\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://ibb.co/Cz8m3BV"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "What I noticed is whatever is for some DP Questions I am getting TLE in C++ whenever I use @cache in python for same solution  I am able to avoid TLE.\nProbably you gotta use @cache because that is faster than maps or vectors.\n"
                    },
                    {
                        "username": "pratikbhagwat4",
                        "content": "Why is it happening that all the python DP solutions are giving TLE ."
                    },
                    {
                        "username": "werfree",
                        "content": "Just add the condition first to check if the number is a perfect square, this might solve the TLE problem in Python\nif sqrt(n) == int(sqrt(n)):\n            return 1"
                    },
                    {
                        "username": "sandesh4vivek",
                        "content": "**Question is** : Given an integer n, return the least number of perfect square numbers that sum to n\\nPerfect square before 43 are 36, 25, 16, 9, 4, 1\\n\\n//43 = 36 + 4   + 1 + 1 +1,   number of perfect square numbers 5\\n//43 = 25 + 16 + 1 + 1, number of perfect square numbers 4\\n// **43 = 25 + 9 + 9,  number of perfect square numbers 3**\\n//43 = 16 + 16 + 9 + 1 + 1, number of perfect square numbers 5\\n\\n\\n\\n"
                    },
                    {
                        "username": "bhagesh",
                        "content": "Can someone please explain the time complexity of the BFS approach in terms of Vertices and Edges.\\n\\n[Please upvote for better reach]\\n\\n\\n"
                    },
                    {
                        "username": "joschroe",
                        "content": "If i understand the time complexity of BFS (coded correctly), it should be O(Nsqrt(N)). Here\\'s why. There are exactly N=n nodes, one for each number 1 through n, and there are O(Nsqrt(N)) edges (as each node has edges to other nodes that differ by perfect squares). If you\\'ve implemented a BFS with a queue, the runtime complexity will be O(V+E), which in this case will be O(N + Nsqrt(N)) = O(Nsqrt(N))"
                    },
                    {
                        "username": "sidyeti",
                        "content": "I am curious to know why is this problem listed under Queue and BFS while the solution seems to be a DP problem."
                    },
                    {
                        "username": "joschroe",
                        "content": "BFS is an O(Nsqrt(N)) solution while DP is, at best, an O(Nsqrt(N)) solution as well. It's not clear why everyone is herding to DP but they are equally fast from a big O perspective."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Appreciate your answer, helped me get on the right path without giving away too much information so I could still grow"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "assume the number to be 10000 (1e4) which is a sum of 1 square only i.e 100\nIf you use DP, it will check for all the possible ways of finding the answer to this number 1e4.\nThen you will pick the best one out of all possibilities.\n\nBut for BFS(Level Order Traversal) the situation is a little different. In the first iteration only you will get to know that this number(1e4) is the square of 100, and then we can directly run out of the loop returning the answer as 1.\n\nUsing BFS we can directly return the no. of steps as soon as we come to the solution. Hence it reduces the excessive computation time, and returns the ans right away when it first encounters the base condition."
                    },
                    {
                        "username": "grvchik",
                        "content": "I could pass 576 test cases out of 600 and got stuck on 577the test case\\n\\n\\nIn my opinion there should be description of  why a certain test case failed\\n\\nInput is 43 then output is 4  \\n5sqr +4sqr +1sqr+1sqr\\n\\nHow come it is 3??\\nEven if we go with 6 answer is 5\\n6sqr +2sqr +1sqr+1sqr+1sqr\\n\\nOther option by 4 also yields 5\\n4sqr +4sqr+3sqr +1sqr+1sqr\\n\\n\\nIf we go by 3 definitely number would be much bugger and we can't go by 7\\n\\nI challenge this test case"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "5sqr +3sqr +3sqr = 25 + 9 + 9 = 43 \\u2714"
                    },
                    {
                        "username": "itsaakashjain119",
                        "content": "25 + 9 + 9\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "deepika_8586",
                        "content": "25+9+9"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "try 5\\xB2 + 3\\xB2 + 3\\xB2"
                    },
                    {
                        "username": "droidgod",
                        "content": "This is kind of obnoxious. Same solution in C++  or Go gets top 80% but in Python it gets TLE.\\n\\nWhat is the purpose exactly? \\n\\nWhy restrict the solution which is asymtotically the exact same one?\\n\\nWhy prefer one language over the other. It is kind of annoying and a waste of time trying to fit my solution to the OJ.\\n\\nI am using the static dp solution by the way. Every other language(Java, C, C++, Go, etc use the exact same logic, but in Python it is TLE.)"
                    },
                    {
                        "username": "iaarzoo40",
                        "content": "Question states that add perfects squares to \"0\" to make it equal to the given target\\nOR\\nTake the given target, subtract perfect squares to make it \"0\".\\n\\nWe need to subtract perfect squares optimally to make the target 0\\nWe need to keep perfect squares as minimum as possible\\nBut we have many options of perfect squares to subtract\\n->For target = 18\\n->we can first subtract =>[1^2 = 1] or [ 2^2 = 4] or [3^2 = 9] or [4^2 = 16]\\nIf you are thinking that choosing the largest one (16) at the first step would work,\\nthen you just need to observe more carefully that\\n18 - (4^2) = 2\\n2 - (1^2) = 1 //Future\\n1 - (1^2) = 0 //Future [3 STEPS]\\n\\nBut actually picking (9) at first step would prove to be optimal here\\n18 - (3^3) = 9\\n9 - (3^3) = 0 //Future [2 STEPS]\\n\\nWe are \"NOT SURE\" if subtracting 1 or 4 or 9 or 16 first would be optimal as we don\\'t know the future results\\nSo whenever you are not sure which step would be optimal, no need to stress on guessing the optimal one just =>\\n\"TRY ALL OPTIONS, THEN CHOOSE THE OPTIMAL ONE\"\\nSo for any given target, just try all the perfect squares you can subtract"
                    },
                    {
                        "username": "zcj5918",
                        "content": "Take the first number as the source node and the followers as the destinations, once there is an square number away to the next number, just put a link weighed 1 to link them together, then it transforms into the dijikastra problem."
                    }
                ]
            },
            {
                "id": 1784651,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1703479,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1693527,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1692543,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2012804,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1574475,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1573022,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1571522,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2038889,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 2019875,
                "content": [
                    {
                        "username": "ayoubmanouz2015",
                        "content": "For those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.\\n\\nIt is called Lagrange\\u2019s Four-Square Theorem, which states:  `every natural number can be represented as the sum of four integer squares.`\\n\\nIt was proven by Lagrange in 1770.\\n\\nApplying to our problem NumSquares(n) can only be 1, 2, 3, or 4. Not more.\\n\\nIt turns into the problem of `identifying when NumSquares(n) returns 1, 2, 3, or 4.`\\n\\nHere are the cases.\\n\\n1- If n is a perfect square, NumSquares(n) = 1.\\n2- There is another theorem, Legendre\\u2019s Three-Square Theorem, which states that `NumSquares(n) cannot be 1, 2, or 3 if n can be expressed as n = 4^a * (8*b + 7), where a, b are nonnegative integers` . In other words, NumSquares(n) = 4 if n is of this form."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Its difficult to think of  BFS for this question. Generally recursion and then DP comes to the  mind."
                    },
                    {
                        "username": "clavicordio",
                        "content": "The time limit is too strict, in my opinion, at least in Python.\\nI had to do a handful of small optimization tricks to get it accepted, without changing the algorithm, which is usually unnecessary on leetcode. It was fun though."
                    },
                    {
                        "username": "uzia35",
                        "content": "you can think of this exactly like the coin change problem except the coins are perfect squares from 1 -100 (10^4)."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I didn\\'t get any idea how to solve this problem can any help me to solve this ? "
                    },
                    {
                        "username": "thrillobit",
                        "content": "There is a math solution - read about Lagrange\\'s Four Square theorem.\\n\\nThe other idea is to check every integer while its square is below the target. You may do that in cycle or with BS technique."
                    },
                    {
                        "username": "sachinrao1",
                        "content": "Yes Can Provide The Approach To solve this Question And I also provide the Code\n\n\n def solve(n ):\n            \n            # Base case\n            if n == 0:\n                return 0\n                \n            # RR case \n            # Loop for everyn value\n            ans = n\n            for i in range(1 , n+1):\n                if i*i <= n:\n                    ans = min(ans , 1+solve(n-i*i))\n            return ans\n\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "1. Text approach: https://leetcode.com/problems/perfect-squares/discuss/71495/An-easy-understanding-DP-solution-in-Java\\n2.Video approach:https://leetcode.com/problems/perfect-squares/discuss/854118/Detailed-Explanation-w-code"
                    },
                    {
                        "username": "kitadoom",
                        "content": "Seems like a bad idea for this quistion to use BFS. But what on earth is the time complexity of this question? O(n* n^1/2) or what? Thank you for help!"
                    },
                    {
                        "username": "LHearen",
                        "content": "There is an issue in this problem Perfect Squares\\nI think the OJ does not have a good checking program for test case `2000000`\\nI tried my solution using `Lagrange's four-square theorem`\\nit works fine but the OJ did not\\nBesides I think there is a need to add some more strict test cases here like the case above."
                    },
                    {
                        "username": "adityassingh",
                        "content": "for input n=43 mimimum permutaion is of 4 digit why answer is 3?\\n[36, 4, 1, 1, 1]\\n[25, 16, 1, 1]\\n[16, 16, 9, 1, 1]\\n[9, 9, 9, 9, 4, 1, 1, 1]\\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1]\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"
                    },
                    {
                        "username": "adityassingh",
                        "content": "[@sidney3](/sidney3) thanks"
                    },
                    {
                        "username": "sidney3",
                        "content": "25 + 9 + 9"
                    },
                    {
                        "username": "kratos462",
                        "content": "You can also solve this problem like the [Coin Change](https://leetcode.com/problems/coin-change/), if you use all the perfect square numbers up to `n` as coins"
                    }
                ]
            },
            {
                "id": 1989139,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1954581,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1901437,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1891431,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1855421,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1833059,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1824299,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1810630,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1800768,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1757136,
                "content": [
                    {
                        "username": "sachinrao1",
                        "content": "Don't confused read the this statement then create the Tree Recurstion tree\nN. For Example: If N = 100 , N can be expressed as (10Multi10) and also as (5 Multi 5 + 5Multi5 + 5Multi5 + 5Multi5) but the output will be 1 as minimum number of square is 1 , i.e (10*10). .`multi means simple multiply"
                    },
                    {
                        "username": "SHEKHAR61",
                        "content": "is this really BFS problem or dp ?\\nnot sure"
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I am solving the problem with recursive technique with memoization. I need help to fix the problem. The code has passed 569 out of 588 test cases. But giving wrong answer for n=19. It is giving 4 instead of 3. My code is here:\\ndef rec (i,s,min_sqrs,memo):\\n            if s == 0:\\n                return min_sqrs\\n            if i == 0 or s < 0:\\n                return float(\\'inf\\')\\n            if (i, s) in memo:\\n                return memo[(i, s)]\\n\\n            result = min(rec(i, s - i ** 2, min_sqrs + 1,memo),\\n                        rec(i - 1, s, min_sqrs,memo))\\nwhere,\\n    memo = {}\\n    i = int(m.floor(m.sqrt(n)))"
                    },
                    {
                        "username": "ravi939",
                        "content": "can anyone explain why answer is \\n1)3 for the input 19\\n2)4 for the input 23\\ni am getting 4(16+1+1+1) and 5(16+4+1+1+1) for the inputs"
                    },
                    {
                        "username": "kaladun",
                        "content": "9 + 9 + 1 = 19\\n9 + 9 + 4 + 1 = 23\\n\\nGreedy algorithms don\\'t always work for this kind of problem"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Run this test case to check if your solution will getting submitted or give TLE\\n\\nn = 55"
                    },
                    {
                        "username": "cenjian",
                        "content": "This is exactly the same question as  @322. Coin Change\\n"
                    },
                    {
                        "username": "dpaparis",
                        "content": "I\\'m getting Time Limit Exceeded for the last test case (588) however it seems like the last input is blank?"
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "Same here, have you resolved this issue?"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    int numSquares(int n){\\n\\n    int *dp = new int[n+1];\\n    \\n    for(int i=0;i<=n;i++)dp[i] = -1;\\n\\n    dp[0]=0;\\n\\n    for(int i=1;i<=n;i++){\\n        int minim = INT_MAX;\\n\\n        for(int j=1;j*j<=i;j++){\\n\\n            int ans = dp[i-j*j];\\n            minim = min(minim,ans);\\n        }\\n        dp[i] = 1+minim;\\n    }\\n    return dp[n];\\n}\\n};"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Can Anyone pointout the problem in my code why it is giving TLE only at the last testcase \\n\\n int solve(int n,vector<int>&dp){\\n        if(n<0)\\n        return INT_MAX;\\n        if(n==0||n==1)\\n        return n;\\n        if(dp[n]!= INT_MAX)\\n        return dp[n];\\n        for(int i=n;i>0;i--){\\n            int a = sqrt(i);\\n            if(a*a == i){\\n            dp[n] = min(dp[n],solve(n-i,dp)+1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,INT_MAX);\\n        return solve(n,dp);\\n    }"
                    },
                    {
                        "username": "sajunni",
                        "content": "can we try to use partitioning concept here?\\n"
                    }
                ]
            },
            {
                "id": 1756216,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1754781,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1742844,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1729922,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1702343,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1698844,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1693086,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1693085,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1692779,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            },
            {
                "id": 1692749,
                "content": [
                    {
                        "username": "sajunni",
                        "content": "CAN SOMEONE PLEASE HELP ME FIGURE OUT WHY IS MY CODE NOT GIVING THE DESIRED OUTPUT\\n\\nclass Solution\\n{\\n    static int min=Integer.MAX_VALUE;;\\n    public int numSquares(int n)\\n    {\\n        int a[]= new int[n];\\n        int dp[][]= new int[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=1;\\n        }\\n        return checker(a,dp,0,n-1);\\n\\n    }\\n    public boolean isSquare(int k)\\n    {\\n        int sr=(int)Math.sqrt(k);\\n        if(sr*sr==k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int checker(int a[],int t[][],int i, int j)\\n    {\\n        if(i>j)\\n        {\\n            return 0;\\n        }\\n        if(i==j)\\n        {\\n            return 1;\\n        }\\n        if(t[i][j]!=-1)\\n        {\\n            return t[i][j];\\n        }\\n        if(isSquare(j-i+1))\\n        {\\n            return 1;\\n        }\\n\\n        for(int k=i;k<=j-1;k++)\\n        {\\n            int left;\\n            if(t[i][k]!=-1)\\n            {\\n                left =t[i][k];\\n            }\\n            else\\n            {\\n                left =checker(a,t,i,k);\\n                t[i][k]=left;\\n            }\\n            int right;\\n            if(t[k+1][j]!=-1)\\n            {\\n                right=t[k+1][j];\\n            }\\n            else\\n            {\\n                right=checker(a,t,k+1,j);\\n                t[k+1][j]=right;\\n            }\\n\\n            int  temp=left+right+1;\\n\\n            if(min>temp)\\n            {\\n                min=temp;\\n            }\\n        }\\n        t[i][j]=min;\\n        return min;\\n\\n    }\\n//    public static void main(String[] args)\\n//    {\\n//        Solution obj = new Solution();\\n//        System.out.println(obj.numSquares(4)+\"  kk\");\\n//    }\\n\\n}"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "why is python recursion 6k+ ms and cpp recursion less than 200ms cpp is faster than python usually but this is a huge difference"
                    },
                    {
                        "username": "hoang_kim",
                        "content": "it\\'s quite weird because I went with dp and memorize table in ruby but not C++ like other solutions and it was keeping over timelimit :(  Still pass after some tries"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/279_perfect_squares.cpp"
                    },
                    {
                        "username": "saam_neu",
                        "content": "How is the answer of 48  3.\\nminimum it should be 4\\n4+4+4+36"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "16+16+16"
                    },
                    {
                        "username": "SujataP",
                        "content": "I a not able to  apply LINQ query in my code. I added namespace for LINQ query also but its giving compilation error. Pls someone suggest what should I do so that it accept the query.\\n\\nThankyou in advance"
                    },
                    {
                        "username": "lampuiho",
                        "content": "Look up Lagrange\\'s four-square theorem. Certainly not something you can come up in an interview unless you remember it lol\\nIf you want to solve it in the programming kind of brute force way, you can use BFS."
                    },
                    {
                        "username": "thrillobit",
                        "content": "The problem is that \\'brute force\\' is likely hit TE/out of memory problems. Legrendre\\'s theorem is a common simple thing, isn\\'t it?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def numSquares(self, n: int) -> int:\\n        from math import isqrt\\n        if n==0:\\n            return n\\n        dp=[0]\\n        for i in range(1,n+1):\\n            dp.append(inf)\\n            for num in range(1,i+1):\\n                if i-num*num>=0:\\n                    dp[i] = min(dp[i],1+dp[i-num*num])\\n                else:\\n                    break\\n        return dp[n]\\n\\nI dont know why this solutiongiving TLE.can anyone explain"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey there....somebody point out the error in login here.....im getting wrong answer....help!\\n\\nclass Solution {\\npublic:\\n    int rec(int i,vector<int>&ps,int t,int x,vector<int>&dp){ \\n        if(i>=100 or t<0){\\n            return INT_MAX;\\n        }\\n        if(t==0){\\n            return x;\\n        }\\n        if(dp[t]!=-1)\\n        return dp[t];\\n        dp[t]=min(rec(i,ps,t-ps[i],x+1,dp),rec(i+1,ps,t,x,dp));\\n        return dp[t];\\n    }\\n    int numSquares(int n) {\\n        vector<int>dp(n+1,-1);\\n        vector<int> ps;\\n        for(int i=1;i<=100;i++)\\n        ps.push_back(i*i);\\n        int a = rec(0,ps,n,0,dp);\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "ayush4anand",
                        "content": "Getting TLE for a particular testcase..but when I used the same testcase as custom input its showring the Accepted...Donno why?? \\n\\nbool isSquare(int n)\\n    {\\n        int root=sqrt(n);\\n        if((root*root)==n) return true;\\n        return false;\\n    }\\n    int nSquares(int n,vector<int> &dp)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int i;\\n        int mn=INT_MAX;\\n        for(i=n;i>0;i--)\\n        {\\n            if(isSquare(i)) \\n            {\\n                mn=min(mn,1+nSquares(n-i,dp));\\n            }\\n        }\\n        return dp[n]=mn;\\n    }\\n    int numSquares(int n) {\\n        vector<int> dp(10001,-1);\\n        return nSquares(n,dp);\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Comments",
        "question_content": "<p>Given a C++ program, remove comments from it. The program source is an array of strings <code>source</code> where <code>source[i]</code> is the <code>i<sup>th</sup></code> line of the source code. This represents the result of splitting the original source code string by the newline character <code>&#39;\\n&#39;</code>.</p>\n\n<p>In C++, there are two types of comments, line comments, and block comments.</p>\n\n<ul>\n\t<li>The string <code>&quot;//&quot;</code> denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.</li>\n\t<li>The string <code>&quot;/*&quot;</code> denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of <code>&quot;*/&quot;</code> should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string <code>&quot;/*/&quot;</code> does not yet end the block comment, as the ending would be overlapping the beginning.</li>\n</ul>\n\n<p>The first effective comment takes precedence over others.</p>\n\n<ul>\n\t<li>For example, if the string <code>&quot;//&quot;</code> occurs in a block comment, it is ignored.</li>\n\t<li>Similarly, if the string <code>&quot;/*&quot;</code> occurs in a line or block comment, it is also ignored.</li>\n</ul>\n\n<p>If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.</p>\n\n<p>There will be no control characters, single quote, or double quote characters.</p>\n\n<ul>\n\t<li>For example, <code>source = &quot;string s = &quot;/* Not a comment. */&quot;;&quot;</code> will not be a test case.</li>\n</ul>\n\n<p>Also, nothing else such as defines or macros will interfere with the comments.</p>\n\n<p>It is guaranteed that every open block comment will eventually be closed, so <code>&quot;/*&quot;</code> outside of a line or block comment always starts a new comment.</p>\n\n<p>Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.</p>\n\n<p>After removing the comments from the source code, return <em>the source code in the same format</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> source = [&quot;/*Test program */&quot;, &quot;int main()&quot;, &quot;{ &quot;, &quot;  // variable declaration &quot;, &quot;int a, b, c;&quot;, &quot;/* This is a test&quot;, &quot;   multiline  &quot;, &quot;   comment for &quot;, &quot;   testing */&quot;, &quot;a = b + c;&quot;, &quot;}&quot;]\n<strong>Output:</strong> [&quot;int main()&quot;,&quot;{ &quot;,&quot;  &quot;,&quot;int a, b, c;&quot;,&quot;a = b + c;&quot;,&quot;}&quot;]\n<strong>Explanation:</strong> The line by line code is visualized as below:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\nThe line by line output code is visualized as below:\nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> source = [&quot;a/*comment&quot;, &quot;line&quot;, &quot;more_comment*/b&quot;]\n<strong>Output:</strong> [&quot;ab&quot;]\n<strong>Explanation:</strong> The original source string is &quot;a/*comment\\nline\\nmore_comment*/b&quot;, where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string &quot;ab&quot;, which when delimited by newline characters becomes [&quot;ab&quot;].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= source.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= source[i].length &lt;= 80</code></li>\n\t<li><code>source[i]</code> consists of printable <strong>ASCII</strong> characters.</li>\n\t<li>Every open block comment is eventually closed.</li>\n\t<li>There are no single-quote or&nbsp;double-quote in the input.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 109197,
                "title": "one-pass-solution-in-java",
                "content": "We only need to check for two things:\\n1. If we see '//' we stop reading the current line, and add whatever characters we have seen to the result.\\n2. If we see '/\\\\*' then we start the multiline comment mode and we keep on ignoring characters until we see '\\\\*/'.\\n3. If the current character is neither of the above two and the multiline comment mode is off, then we add that character to the current line. \\n\\nOnce we parse one line (source[i]), then if the mode is off, we add the currently generated line (StringBuilder) to the result and repeat for source[i + 1].\\n\\nWe need to be careful not to insert empty lines in the result.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();     \\n        boolean mode = false;\\n        for (String s : source) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (mode) {\\n                    if (s.charAt(i) == '*' && i < s.length() - 1 && s.charAt(i + 1) == '/') {\\n                        mode = false;\\n                        i++;        //skip '/' on next iteration of i\\n                    }\\n                }\\n                else {\\n                    if (s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '/') {\\n                        break;      //ignore remaining characters on line s\\n                    }\\n                    else if (s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '*') {\\n                        mode = true;\\n                        i++;           //skip '*' on next iteration of i\\n                    }\\n                    else    sb.append(s.charAt(i));     //not a comment\\n                }\\n            }\\n            if (!mode && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();   //reset for next line of source code\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nThanks to @ihaveayaya for suggestion to remove some duplicate code.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();     \\n        boolean mode = false;\\n        for (String s : source) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (mode) {\\n                    if (s.charAt(i) == '*' && i < s.length() - 1 && s.charAt(i + 1) == '/') {\\n                        mode = false;\\n                        i++;        //skip '/' on next iteration of i\\n                    }\\n                }\\n                else {\\n                    if (s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '/') {\\n                        break;      //ignore remaining characters on line s\\n                    }\\n                    else if (s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '*') {\\n                        mode = true;\\n                        i++;           //skip '*' on next iteration of i\\n                    }\\n                    else    sb.append(s.charAt(i));     //not a comment\\n                }\\n            }\\n            if (!mode && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();   //reset for next line of source code\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109210,
                "title": "simple-python-one-pass-with-clear-inline-explanation",
                "content": "The main idea is simple - Go through each character, if we meet a special character, check whether the next character is one that is of interest to us (comment tokens) and then toggle some states that will determine whether we append the character to the final source.\\n\\nSome insights:\\n\\n1. There are three important tokens we want to identify within the source code `//`, `/*` and `*/`. \\n2. We use a variable called `buffer` that acts as a buffer to store the characters that will definitely go into the final source code. This buffer can contain characters from multiple lines because of block comments. \\n3. We use another variable `block_comments_open` to keep track of whether we are inside a block comment or not.\\n4. At the end of each source line, we simply have to check whether we are inside of a block comment or not (i.e. `block_comments_open` is `True`) to decide whether we want to flush the buffer and append it to the results.\\n\\nIn each loop, we have to check that:\\n\\n1. `//` - If it is a line comment and not part of a block comment, skip the rest of the line by shifting the pointer to the end of the line.\\n2. `/*` - If it is an opening block comment token and not part of a block comment, set `block_comments_open` to `True`.\\n3. `*/` - If it is a closing block comment token and part of a block comment, set `block_comments_open` to `False`.\\n4. Else append to `buffer` if not part of a block comment.\\n\\n**Bonus**\\n\\nThere are many parsing/compiler type questions in LeetCode, and here are some tips on handling them:\\n\\n1. Use a pointer to read each character so that you can skip characters if the current token is made by more than one character, such as `//`, `/*` and `*/`.\\n2. For Python, use a `while` loop. You can\\'t skip characters if you used `for i in range(...)` unlike in C++ or Java where you can have control of how you want to increment `i` at the end of each loop.\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res, buffer, block_comment_open = [], \\'\\', False\\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                char = line[i]\\n                # \"//\" -> Line comment.\\n                if char == \\'/\\' and (i + 1) < len(line) and line[i + 1] == \\'/\\' and not block_comment_open:\\n                    i = len(line) # Advance pointer to end of current line.\\n                # \"/*\" -> Start of block comment.\\n                elif char == \\'/\\' and (i + 1) < len(line) and line[i + 1] == \\'*\\' and not block_comment_open:\\n                    block_comment_open = True\\n                    i += 1\\n                # \"*/\" -> End of block comment.\\n                elif char == \\'*\\' and (i + 1) < len(line) and line[i + 1] == \\'/\\' and block_comment_open:\\n                    block_comment_open = False\\n                    i += 1\\n                # Normal character. Append to buffer if not in block comment.\\n                elif not block_comment_open:\\n                    buffer += char\\n                i += 1\\n            if buffer and not block_comment_open:\\n                res.append(buffer)\\n                buffer = \\'\\'\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res, buffer, block_comment_open = [], \\'\\', False\\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                char = line[i]\\n                # \"//\" -> Line comment.\\n                if char == \\'/\\' and (i + 1) < len(line) and line[i + 1] == \\'/\\' and not block_comment_open:\\n                    i = len(line) # Advance pointer to end of current line.\\n                # \"/*\" -> Start of block comment.\\n                elif char == \\'/\\' and (i + 1) < len(line) and line[i + 1] == \\'*\\' and not block_comment_open:\\n                    block_comment_open = True\\n                    i += 1\\n                # \"*/\" -> End of block comment.\\n                elif char == \\'*\\' and (i + 1) < len(line) and line[i + 1] == \\'/\\' and block_comment_open:\\n                    block_comment_open = False\\n                    i += 1\\n                # Normal character. Append to buffer if not in block comment.\\n                elif not block_comment_open:\\n                    buffer += char\\n                i += 1\\n            if buffer and not block_comment_open:\\n                res.append(buffer)\\n                buffer = \\'\\'\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109195,
                "title": "1-liners",
                "content": "This problem *begs* for a regular expression solution...\\n\\nRuby:\\n```\\ndef remove_comments(source)\\n  source.join($/).gsub(%r(//.*|/\\\\*(.|\\\\n)*?\\\\*/), '').split($/).reject(&:empty?)\\nend\\n```\\nPython:\\n\\n    def removeComments(self, source):\\n        return filter(None, re.sub('//.*|/\\\\*(.|\\\\n)*?\\\\*/', '', '\\\\n'.join(source)).split('\\\\n'))",
                "solutionTags": [],
                "code": "```\\ndef remove_comments(source)\\n  source.join($/).gsub(%r(//.*|/\\\\*(.|\\\\n)*?\\\\*/), '').split($/).reject(&:empty?)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 160382,
                "title": "just-kill-me",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool endOfSubstring(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j == last) {return true;}\\n        if (j == last - 1) {return false;}\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'*\\')) {\\n            return true;\\n        }\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startOfSubstring(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j < 2) {return false;}\\n        if ((source[i][j-2] == \\'*\\') && (source[i][j-1] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool foundSlashSlashAhead(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j >= last - 1) {return false;}\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool slashSlashAtStart(vector<string>& source, int i) {\\n        if (source[i].length() < 2) {return false;}\\n        if (source[i][0] == \\'/\\' && source[i][1] == \\'/\\') {return true;}\\n        return false;\\n    }\\n    \\n    bool slashStarAtStart(vector<string>& source, int i) {\\n        if (source[i].length() < 2) {return false;}\\n        if (source[i][0] == \\'/\\' && source[i][1] == \\'*\\') {return true;}\\n        return false;\\n    }\\n    \\n    bool starSlashAtEnd(vector<string>& source, int i) {\\n        int length = source[i].length();\\n        if (length < 2) {return false;}\\n        if (source[i][length - 2] == \\'*\\' && source[i][length - 1] == \\'/\\') {return true;}\\n        return false;\\n    }\\n    \\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        int startIndex = 0, startIndexCannotBe = -1;\\n        bool lookingForStart = false;\\n        string partialString = \"\";\\n        vector<string> result;\\n        for (int i = 0; i < source.size(); i++) {\\n            for (int j = 0; j < source[i].length(); j++) {\\n                if (partialString == \"*/cbcedae\") {\\n                    cout << \"stp here\" << endl;\\n                }\\n                if (j == 0) {\\n                    if (slashSlashAtStart(source, i)) {\\n                        break;\\n                    }\\n                    if (slashStarAtStart(source,i)) {\\n                        startIndexCannotBe = 3;\\n                        lookingForStart = true;\\n                    }\\n                }\\n                int last = source[i].length() - 1;\\n                if (!lookingForStart) {\\n                    if (endOfSubstring(source,i,j)) {\\n                        startIndexCannotBe = j + 4;\\n                        partialString += source[i].substr(startIndex, (j-startIndex) + 1);\\n                        if (j != last) {\\n                            lookingForStart = true;\\n                        }\\n                        if (foundSlashSlashAhead(source, i, j)) {\\n                            lookingForStart = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (lookingForStart && (j != startIndexCannotBe)) {\\n                    if (startOfSubstring(source,i,j)) {\\n                        startIndex = j;\\n                        lookingForStart = false;\\n                        if (foundSlashSlashAhead(source, i, j-1)) {\\n                            break;\\n                        }\\n                        if (endOfSubstring(source,i,j-1)) {\\n                            startIndexCannotBe = j + 3;\\n                            lookingForStart = true;\\n                        }\\n                        if (endOfSubstring(source,i,j)) {\\n                            partialString += source[i].substr(j,1);\\n                            if (foundSlashSlashAhead(source, i, j)) {\\n                                lookingForStart = false;\\n                                break;\\n                            }\\n                            if (j != (source[i].length() - 1)) {\\n                                lookingForStart = true;\\n                            }\\n                            startIndexCannotBe = j+ 4;\\n                        }\\n                    }\\n                }\\n            }\\n            startIndexCannotBe = -1;\\n            if (!lookingForStart) {\\n                if (partialString != \"\") {\\n                    result.push_back(partialString);\\n                    partialString = \"\";\\n                }\\n            }\\n            if (lookingForStart && starSlashAtEnd(source,i)) {\\n                lookingForStart = false;\\n                if (partialString != \"\") {\\n                    result.push_back(partialString);\\n                    partialString = \"\";\\n                }\\n            }\\n            startIndex = 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool endOfSubstring(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j == last) {return true;}\\n        if (j == last - 1) {return false;}\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'*\\')) {\\n            return true;\\n        }\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool startOfSubstring(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j < 2) {return false;}\\n        if ((source[i][j-2] == \\'*\\') && (source[i][j-1] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool foundSlashSlashAhead(vector<string>& source, int i, int j) {\\n        int last = source[i].length() - 1;\\n        if (j >= last - 1) {return false;}\\n        if ((source[i][j+1] == \\'/\\') && (source[i][j+2] == \\'/\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool slashSlashAtStart(vector<string>& source, int i) {\\n        if (source[i].length() < 2) {return false;}\\n        if (source[i][0] == \\'/\\' && source[i][1] == \\'/\\') {return true;}\\n        return false;\\n    }\\n    \\n    bool slashStarAtStart(vector<string>& source, int i) {\\n        if (source[i].length() < 2) {return false;}\\n        if (source[i][0] == \\'/\\' && source[i][1] == \\'*\\') {return true;}\\n        return false;\\n    }\\n    \\n    bool starSlashAtEnd(vector<string>& source, int i) {\\n        int length = source[i].length();\\n        if (length < 2) {return false;}\\n        if (source[i][length - 2] == \\'*\\' && source[i][length - 1] == \\'/\\') {return true;}\\n        return false;\\n    }\\n    \\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        int startIndex = 0, startIndexCannotBe = -1;\\n        bool lookingForStart = false;\\n        string partialString = \"\";\\n        vector<string> result;\\n        for (int i = 0; i < source.size(); i++) {\\n            for (int j = 0; j < source[i].length(); j++) {\\n                if (partialString == \"*/cbcedae\") {\\n                    cout << \"stp here\" << endl;\\n                }\\n                if (j == 0) {\\n                    if (slashSlashAtStart(source, i)) {\\n                        break;\\n                    }\\n                    if (slashStarAtStart(source,i)) {\\n                        startIndexCannotBe = 3;\\n                        lookingForStart = true;\\n                    }\\n                }\\n                int last = source[i].length() - 1;\\n                if (!lookingForStart) {\\n                    if (endOfSubstring(source,i,j)) {\\n                        startIndexCannotBe = j + 4;\\n                        partialString += source[i].substr(startIndex, (j-startIndex) + 1);\\n                        if (j != last) {\\n                            lookingForStart = true;\\n                        }\\n                        if (foundSlashSlashAhead(source, i, j)) {\\n                            lookingForStart = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (lookingForStart && (j != startIndexCannotBe)) {\\n                    if (startOfSubstring(source,i,j)) {\\n                        startIndex = j;\\n                        lookingForStart = false;\\n                        if (foundSlashSlashAhead(source, i, j-1)) {\\n                            break;\\n                        }\\n                        if (endOfSubstring(source,i,j-1)) {\\n                            startIndexCannotBe = j + 3;\\n                            lookingForStart = true;\\n                        }\\n                        if (endOfSubstring(source,i,j)) {\\n                            partialString += source[i].substr(j,1);\\n                            if (foundSlashSlashAhead(source, i, j)) {\\n                                lookingForStart = false;\\n                                break;\\n                            }\\n                            if (j != (source[i].length() - 1)) {\\n                                lookingForStart = true;\\n                            }\\n                            startIndexCannotBe = j+ 4;\\n                        }\\n                    }\\n                }\\n            }\\n            startIndexCannotBe = -1;\\n            if (!lookingForStart) {\\n                if (partialString != \"\") {\\n                    result.push_back(partialString);\\n                    partialString = \"\";\\n                }\\n            }\\n            if (lookingForStart && starSlashAtEnd(source,i)) {\\n                lookingForStart = false;\\n                if (partialString != \"\") {\\n                    result.push_back(partialString);\\n                    partialString = \"\";\\n                }\\n            }\\n            startIndex = 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 109216,
                "title": "simple-c-solution-one-pass-with-explanation",
                "content": "The idea is to just separate it into 4 cases.\\n1. If the current character and next one forms a \"//\" and we are not in a block comment.\\nIt means we ignore the current line and just move on to the next line.\\n2. If the current character and next one forms a new block comment and we are not currently in a block comment.\\nIt means we can ignore all the next characters until we find a closing block comment.\\n3. If the current character and next one forms a closing block comment and we are currently still in a block comment.\\nIt means we close the block comment and continue appending characters to string as usual.\\n4. Else this is just a normal character, append it to our string.\\nEverytime we hit a new line and we are not in a block comment currently, we can push the string into a vector of answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string s;\\n        bool comment = false;\\n        for(int i = 0; i < source.size(); i++) {\\n            for(int j = 0; j < source[i].size(); j++) {\\n                if(!comment && j + 1 < source[i].size() && source[i][j] == '/' && source[i][j+1]=='/') break;\\n                else if(!comment && j + 1 < source[i].size() && source[i][j] == '/' && source[i][j+1]=='*') comment = true, j++;\\n                else if(comment && j + 1 < source[i].size() && source[i][j] == '*' && source[i][j+1]=='/') comment = false, j++;\\n                else if(!comment) s.push_back(source[i][j]);\\n            }\\n            \\n            if(!comment && s.size()) ans.push_back(s), s.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string s;\\n        bool comment = false;\\n        for(int i = 0; i < source.size(); i++) {\\n            for(int j = 0; j < source[i].size(); j++) {\\n                if(!comment && j + 1 < source[i].size() && source[i][j] == '/' && source[i][j+1]=='/') break;\\n                else if(!comment && j + 1 < source[i].size() && source[i][j] == '/' && source[i][j+1]=='*') comment = true, j++;\\n                else if(comment && j + 1 < source[i].size() && source[i][j] == '*' && source[i][j+1]=='/') comment = false, j++;\\n                else if(!comment) s.push_back(source[i][j]);\\n            }\\n            \\n            if(!comment && s.size()) ans.push_back(s), s.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161789,
                "title": "logical-thinking-with-code-beats-99-68",
                "content": "**Logical Thinking**\\nWhen we handle with complicated string manipulation, we\\'d better figure out types of distinct section first.\\n```\\n* Types of section:\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t2. content behind line comment\\n\\t\\t3. content outside comment\\n\\t\\t        \\u2022 \\'/*\\'\\n\\t\\t        \\u2022 \\'//\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t\\t\\t\\t\\t\\n* Try to simplify types: \\n\\tsince we directly ignore the content following \\'//\\' within the same line, and content within block comment except \\'*/\\',\\n\\ttypes of section become:\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\'\\n\\t\\t2. content outside block comment\\n\\t\\t        \\u2022 \\'/*\\'\\n\\t\\t        \\u2022 \\'//\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t\\t\\t\\t\\t\\n* Measure:\\t\\n\\twe define isBlockComment = false; curSection;\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\': isBlockComment = false\\n\\t\\t2. content outside block comment \\n\\t\\t        \\u2022 \\'/*\\': isBlockComment = true\\n\\t\\t        \\u2022 \\'//\\': ignore its following within the same line\\n\\t\\t        \\u2022 normal: append to curSection\\n```\\n\\n**Clear Code**\\n```\\n    public List<String> removeComments(String[] source) {\\n\\n        boolean isBlockComment = false;\\n        char[] line = null;\\n        StringBuilder curSection = new StringBuilder();\\n        List<String> result = new ArrayList<>();\\n\\n        for (String src : source) {\\n            line = src.toCharArray();\\n            int i = 0;\\n            if (!isBlockComment) {\\n                curSection = new StringBuilder();\\n            }\\n            while (i < line.length) {\\n                if (!isBlockComment && !isBlockComment && i + 1 < line.length && line[i] == \\'/\\' && line[i + 1] == \\'*\\') {\\n                    isBlockComment = true;\\n                    i++;\\n                } else if (!isBlockComment && i + 1 < line.length && line[i] == \\'/\\' && line[i + 1] == \\'/\\') {\\n                    break;\\n                } else if (!isBlockComment) {\\n                    curSection.append(line[i]);\\n                } else if (isBlockComment && i + 1 < line.length && line[i] == \\'*\\' && line[i + 1] == \\'/\\') {\\n                    isBlockComment = false;\\n                    i++;\\n                }\\n                i++;\\n            }\\n            if (!isBlockComment && curSection.length() != 0)\\n                result.add(curSection.toString());\\n        }\\n\\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n* Types of section:\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t2. content behind line comment\\n\\t\\t3. content outside comment\\n\\t\\t        \\u2022 \\'/*\\'\\n\\t\\t        \\u2022 \\'//\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t\\t\\t\\t\\t\\n* Try to simplify types: \\n\\tsince we directly ignore the content following \\'//\\' within the same line, and content within block comment except \\'*/\\',\\n\\ttypes of section become:\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\'\\n\\t\\t2. content outside block comment\\n\\t\\t        \\u2022 \\'/*\\'\\n\\t\\t        \\u2022 \\'//\\'\\n\\t\\t        \\u2022 normal\\n\\t\\t\\t\\t\\t\\t\\n* Measure:\\t\\n\\twe define isBlockComment = false; curSection;\\n\\t\\t1. content within block comment \\n\\t\\t        \\u2022 \\'*/\\': isBlockComment = false\\n\\t\\t2. content outside block comment \\n\\t\\t        \\u2022 \\'/*\\': isBlockComment = true\\n\\t\\t        \\u2022 \\'//\\': ignore its following within the same line\\n\\t\\t        \\u2022 normal: append to curSection\\n```\n```\\n    public List<String> removeComments(String[] source) {\\n\\n        boolean isBlockComment = false;\\n        char[] line = null;\\n        StringBuilder curSection = new StringBuilder();\\n        List<String> result = new ArrayList<>();\\n\\n        for (String src : source) {\\n            line = src.toCharArray();\\n            int i = 0;\\n            if (!isBlockComment) {\\n                curSection = new StringBuilder();\\n            }\\n            while (i < line.length) {\\n                if (!isBlockComment && !isBlockComment && i + 1 < line.length && line[i] == \\'/\\' && line[i + 1] == \\'*\\') {\\n                    isBlockComment = true;\\n                    i++;\\n                } else if (!isBlockComment && i + 1 < line.length && line[i] == \\'/\\' && line[i + 1] == \\'/\\') {\\n                    break;\\n                } else if (!isBlockComment) {\\n                    curSection.append(line[i]);\\n                } else if (isBlockComment && i + 1 < line.length && line[i] == \\'*\\' && line[i + 1] == \\'/\\') {\\n                    isBlockComment = false;\\n                    i++;\\n                }\\n                i++;\\n            }\\n            if (!isBlockComment && curSection.length() != 0)\\n                result.add(curSection.toString());\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109217,
                "title": "c-o-n-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& s) {\\n        vector<string> ans;\\n        bool inBlock = false;\\n        string sf;\\n        for (auto &t:s) {\\n            for (int i = 0; i < t.size();) {\\n                if (!inBlock) {\\n                    if (i + 1 == t.size()) sf += t[i++];\\n                    else {\\n                        string m = t.substr(i,2);\\n                        if (m == \"/*\") inBlock = 1, i+=2;\\n                        else if (m == \"//\") break;\\n                        else sf += t[i++];\\n                    }\\n                }\\n                else {\\n                    if (i + 1 == t.size()) i++;\\n                    else {\\n                        string m = t.substr(i,2);\\n                        if (m == \"*/\") inBlock = 0, i+=2;\\n                        else i++;\\n                    }\\n                }\\n            }\\n            if (sf.size() && !inBlock) ans.push_back(sf), sf = \"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& s) {\\n        vector<string> ans;\\n        bool inBlock = false;\\n        string sf;\\n        for (auto &t:s) {\\n            for (int i = 0; i < t.size();) {\\n                if (!inBlock) {\\n                    if (i + 1 == t.size()) sf += t[i++];\\n                    else {\\n                        string m = t.substr(i,2);\\n                        if (m == \"/*\") inBlock = 1, i+=2;\\n                        else if (m == \"//\") break;\\n                        else sf += t[i++];\\n                    }\\n                }\\n                else {\\n                    if (i + 1 == t.size()) i++;\\n                    else {\\n                        string m = t.substr(i,2);\\n                        if (m == \"*/\") inBlock = 0, i+=2;\\n                        else i++;\\n                    }\\n                }\\n            }\\n            if (sf.size() && !inBlock) ans.push_back(sf), sf = \"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750241,
                "title": "easy-to-understand-python-solution",
                "content": "Making the parameter array into one line makes the problem easier.\\n\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        # add another \\\\n in the end in case of the last line is line comment\\n        s = \\'\\\\n\\'.join(source) + \\'\\\\n\\' \\n        i = 0\\n        res = \\'\\'\\n        while i < len(s):\\n            if i + 1 < len(s) and s[i] == s[i+1] == \\'/\\':\\n                idx = s.find(\\'\\\\n\\', i+2)\\n                i = idx\\n            elif i + 1 < len(s) and s[i] == \\'/\\' and s[i+1] == \\'*\\':\\n                idx = s.find(\\'*/\\', i+2)\\n                i = idx + 2\\n            else:\\n                res += s[i]\\n                i += 1\\n        arr = res.split(\\'\\\\n\\')\\n        return filter(len, arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        # add another \\\\n in the end in case of the last line is line comment\\n        s = \\'\\\\n\\'.join(source) + \\'\\\\n\\' \\n        i = 0\\n        res = \\'\\'\\n        while i < len(s):\\n            if i + 1 < len(s) and s[i] == s[i+1] == \\'/\\':\\n                idx = s.find(\\'\\\\n\\', i+2)\\n                i = idx\\n            elif i + 1 < len(s) and s[i] == \\'/\\' and s[i+1] == \\'*\\':\\n                idx = s.find(\\'*/\\', i+2)\\n                i = idx + 2\\n            else:\\n                res += s[i]\\n                i += 1\\n        arr = res.split(\\'\\\\n\\')\\n        return filter(len, arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109202,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n    private boolean incomment;\\n    private String unfinish;\\n    private List<String> res;\\n\\n    private void addLine(String line) {\\n        unfinish = \"\";\\n        if (!line.isEmpty())\\n            res.add(line);\\n    }\\n    \\n    private void processIncomment(String line) {\\n        int ind = line.indexOf(\"*/\");\\n        if (ind == -1)\\n            return;\\n        incomment = false;\\n        processNotIncomment(line.substring(ind + 2));\\n    }\\n\\n    private void processNotIncomment(String line) {\\n        int ind = line.indexOf(\"/*\");\\n        int ind1 = line.indexOf(\"//\");\\n        if (ind == -1 && ind1 == -1) {\\n            addLine(unfinish + line);\\n            return;\\n        }\\n        if (ind1 != -1 && (ind == -1 || ind1 < ind)) {\\n            addLine(unfinish + line.substring(0, ind1));\\n            return;\\n        } \\n        incomment = true;\\n        unfinish += line.substring(0, ind);\\n        processIncomment(line.substring(ind + 2));\\n    }\\n    \\n    public List<String> removeComments(String[] source) {\\n        incomment = false;\\n        unfinish = \"\";\\n        res = new ArrayList<>();\\n        for (String line: source)\\n            if (incomment)\\n                processIncomment(line);\\n            else\\n                processNotIncomment(line);\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    private boolean incomment;\\n    private String unfinish;\\n    private List<String> res;\\n\\n    private void addLine(String line) {\\n        unfinish = \"\";\\n        if (!line.isEmpty())\\n            res.add(line);\\n    }\\n    \\n    private void processIncomment(String line) {\\n        int ind = line.indexOf(\"*/\");\\n        if (ind == -1)\\n            return;\\n        incomment = false;\\n        processNotIncomment(line.substring(ind + 2));\\n    }\\n\\n    private void processNotIncomment(String line) {\\n        int ind = line.indexOf(\"/*\");\\n        int ind1 = line.indexOf(\"//\");\\n        if (ind == -1 && ind1 == -1) {\\n            addLine(unfinish + line);\\n            return;\\n        }\\n        if (ind1 != -1 && (ind == -1 || ind1 < ind)) {\\n            addLine(unfinish + line.substring(0, ind1));\\n            return;\\n        } \\n        incomment = true;\\n        unfinish += line.substring(0, ind);\\n        processIncomment(line.substring(ind + 2));\\n    }\\n    \\n    public List<String> removeComments(String[] source) {\\n        incomment = false;\\n        unfinish = \"\";\\n        res = new ArrayList<>();\\n        for (String line: source)\\n            if (incomment)\\n                processIncomment(line);\\n            else\\n                processNotIncomment(line);\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171131,
                "title": "clean-javascript-solution",
                "content": "```\\nvar removeComments = function(source) {\\n  const code = source.join(\\'\\\\n\\')\\n  const isBlockStart = (c, i) => c[i] === \\'/\\' && c[i + 1] === \\'*\\'\\n  const isBlockEnd = (c, i) => c[i] === \\'*\\' && c[i + 1] === \\'/\\'\\n  const isLineStart = (c, i) => c[i] === \\'/\\' && c[i + 1] === \\'/\\'\\n  const isNewLine = (c, i) => c[i] === \\'\\\\n\\'\\n  let i = 0, output = \\'\\'\\n\\n  while (i < code.length) {\\n    if (isBlockStart(code, i)) {\\n      i += 2\\n      while (!isBlockEnd(code, i) && i < code.length) i++\\n      i += 2\\n    } else if (isLineStart(code, i)) {\\n      i += 2\\n      while (!isNewLine(code, i) && i < code.length) i++\\n    } else {\\n      output += code[i++] \\n    }\\n  }\\n\\n  return output.split(\\'\\\\n\\').filter((l) => l.length)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeComments = function(source) {\\n  const code = source.join(\\'\\\\n\\')\\n  const isBlockStart = (c, i) => c[i] === \\'/\\' && c[i + 1] === \\'*\\'\\n  const isBlockEnd = (c, i) => c[i] === \\'*\\' && c[i + 1] === \\'/\\'\\n  const isLineStart = (c, i) => c[i] === \\'/\\' && c[i + 1] === \\'/\\'\\n  const isNewLine = (c, i) => c[i] === \\'\\\\n\\'\\n  let i = 0, output = \\'\\'\\n\\n  while (i < code.length) {\\n    if (isBlockStart(code, i)) {\\n      i += 2\\n      while (!isBlockEnd(code, i) && i < code.length) i++\\n      i += 2\\n    } else if (isLineStart(code, i)) {\\n      i += 2\\n      while (!isNewLine(code, i) && i < code.length) i++\\n    } else {\\n      output += code[i++] \\n    }\\n  }\\n\\n  return output.split(\\'\\\\n\\').filter((l) => l.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573873,
                "title": "python-regex-10-lines",
                "content": "```\\nimport re\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        s = \\'\\\\n\\'.join(source)\\n        regex_single = r\"\\\\/\\\\/.*\"\\n        regex_block_closed = r\"(?s:\\\\/\\\\*.*?\\\\*\\\\/)\"\\n        regex_block_not_closed = r\"\\\\/\\\\*.*\"    \\n        regex = \\'|\\'.join([regex_single, regex_block_closed, regex_block_not_closed])  # order matters\\n        s = re.sub(regex, \\'\\', s)\\n        return list(filter(None, s.split(\\'\\\\n\\')))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        s = \\'\\\\n\\'.join(source)\\n        regex_single = r\"\\\\/\\\\/.*\"\\n        regex_block_closed = r\"(?s:\\\\/\\\\*.*?\\\\*\\\\/)\"\\n        regex_block_not_closed = r\"\\\\/\\\\*.*\"    \\n        regex = \\'|\\'.join([regex_single, regex_block_closed, regex_block_not_closed])  # order matters\\n        s = re.sub(regex, \\'\\', s)\\n        return list(filter(None, s.split(\\'\\\\n\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184461,
                "title": "simple-java-solution-with-detailed-comments-at-each-step-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        boolean blockActive = false; //We keep track of whether or not we are within a block comment with the blockActive variable. \\n\\t\\t//It is initally set to false since we haven\\'t read anything until now. \\n\\n\\n        List<String> result = new ArrayList<String>();\\n        StringBuilder builder = new StringBuilder();\\n        \\n        //Read every line from the source input. \\n        \\n        for(String line: source){\\n// Each time we move on to reading a new line, we check if it is a part of a block comment. \\n//If it is already part of a block comment, it means we should skip the implicit newline characters as mentioned in the problem description. \\n//For example if Line 1 was  \"int a /*Block comment Started\" and Line 2 was \"Block comment ends here */ b;\", and Line 3 was \"int c;\" \\n//we want our output to be \"int ab\", \"int c\" instead of \"int a\", \"b;\", \"int c;\" \\n            if(!blockActive){ \\n                builder = new StringBuilder();\\n            }\\n            for(int i=0; i<line.length(); i++){ //Read every character of line\\n                char c = line.charAt(i);\\n                if(!blockActive){ //If we aren\\'t currently in a block\\n                    \\n                    if(c==\\'/\\'){ //We check if we encounter the start of a regular comment\\n                        //If so, then we need to check if the next character makes it a regular comment, a block comment, or neither of those two. \\n                        \\n                        if(i<line.length()-1 && line.charAt(i+1)==\\'/\\'){ //Checking if it\\'s a regular comment\\n                            break; //If it\\'s a regular comment, we can simply skip everything else \\n\\t\\t\\t\\t\\t\\t\\t//until the end of the line, so we break from the loop and move on to the next line.\\n                        } else if(i<line.length()-1 && line.charAt(i+1)==\\'*\\'){ //Or a block comment\\n                            i++; //Since we verified it\\'s a block comment, we simply increment i so that we don\\'t re-read the \\'*\\' again, \\n\\t\\t\\t\\t\\t\\t\\t//and mark that we are now part of a block comment. \\n                            blockActive = true;\\n                        } else{ // If the second character is neither a / or *, it indicates that a first character must be a valid operator \\n\\t\\t\\t\\t\\t\\t//(probably a mathematical operator such as multiplication or division, and not part of any comment, \\n\\t\\t\\t\\t\\t\\t//so simply append it to the builder)\\n                            builder.append(c);\\n                        }\\n                    } else  { //Append all other characters directly to the builder. \\n                        builder.append(c);\\n                    }\\n                } else {\\n                    //We skip all other characters in a block comment, and check for the closing block comment. \\n\\t\\t\\t\\t\\t//Once we find it, we mark the blockActive variable as false to indicate that it isn\\'t part of the block anymore.  \\n                    if(c==\\'*\\'){\\n                        if(i<line.length()-1 && line.charAt(i+1)==\\'/\\'){\\n                              blockActive = false;  \\n                              i++;\\n                        }\\n                    }\\n                } \\n            }\\n            //We append to the result when we aren\\'t part of a block any more, and the builder contains 1 or more characters. \\n            if(!blockActive && builder.length()!=0){\\n                result.add(builder.toString());\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\\n\\nTime and Space Complexity is O(N), where N is the total length of the source code. \\nPlease comment if you have any questions. Kindly upvote if the post was helpful to you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        boolean blockActive = false; //We keep track of whether or not we are within a block comment with the blockActive variable. \\n\\t\\t//It is initally set to false since we haven\\'t read anything until now. \\n\\n\\n        List<String> result = new ArrayList<String>();\\n        StringBuilder builder = new StringBuilder();\\n        \\n        //Read every line from the source input. \\n        \\n        for(String line: source){\\n// Each time we move on to reading a new line, we check if it is a part of a block comment. \\n//If it is already part of a block comment, it means we should skip the implicit newline characters as mentioned in the problem description. \\n//For example if Line 1 was  \"int a /*Block comment Started\" and Line 2 was \"Block comment ends here */ b;\", and Line 3 was \"int c;\" \\n//we want our output to be \"int ab\", \"int c\" instead of \"int a\", \"b;\", \"int c;\" \\n            if(!blockActive){ \\n                builder = new StringBuilder();\\n            }\\n            for(int i=0; i<line.length(); i++){ //Read every character of line\\n                char c = line.charAt(i);\\n                if(!blockActive){ //If we aren\\'t currently in a block\\n                    \\n                    if(c==\\'/\\'){ //We check if we encounter the start of a regular comment\\n                        //If so, then we need to check if the next character makes it a regular comment, a block comment, or neither of those two. \\n                        \\n                        if(i<line.length()-1 && line.charAt(i+1)==\\'/\\'){ //Checking if it\\'s a regular comment\\n                            break; //If it\\'s a regular comment, we can simply skip everything else \\n\\t\\t\\t\\t\\t\\t\\t//until the end of the line, so we break from the loop and move on to the next line.\\n                        } else if(i<line.length()-1 && line.charAt(i+1)==\\'*\\'){ //Or a block comment\\n                            i++; //Since we verified it\\'s a block comment, we simply increment i so that we don\\'t re-read the \\'*\\' again, \\n\\t\\t\\t\\t\\t\\t\\t//and mark that we are now part of a block comment. \\n                            blockActive = true;\\n                        } else{ // If the second character is neither a / or *, it indicates that a first character must be a valid operator \\n\\t\\t\\t\\t\\t\\t//(probably a mathematical operator such as multiplication or division, and not part of any comment, \\n\\t\\t\\t\\t\\t\\t//so simply append it to the builder)\\n                            builder.append(c);\\n                        }\\n                    } else  { //Append all other characters directly to the builder. \\n                        builder.append(c);\\n                    }\\n                } else {\\n                    //We skip all other characters in a block comment, and check for the closing block comment. \\n\\t\\t\\t\\t\\t//Once we find it, we mark the blockActive variable as false to indicate that it isn\\'t part of the block anymore.  \\n                    if(c==\\'*\\'){\\n                        if(i<line.length()-1 && line.charAt(i+1)==\\'/\\'){\\n                              blockActive = false;  \\n                              i++;\\n                        }\\n                    }\\n                } \\n            }\\n            //We append to the result when we aren\\'t part of a block any more, and the builder contains 1 or more characters. \\n            if(!blockActive && builder.length()!=0){\\n                result.add(builder.toString());\\n            }\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181291,
                "title": "c-18-line-solution-easy-to-understand",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        string s,cp;\\n        for(int i = 0; i < source.size(); i++) s += source[i] + \\'\\\\n\\';\\n        for(int i = 0; i < s.size(); ){\\n            if(i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'*\\'){\\n                int j = i+2;\\n                for(; j < s.size(); j++) if(s[j] == \\'*\\' && s[j+1] ==\\'/\\') break;\\n                i = j+2;\\n            }\\n            else if(i < s.size()-1 && s[i] ==\\'/\\' && s[i+1] ==\\'/\\'){\\n                int j = i+2;\\n                for(; j < s.size(); j++) if(s[j] == \\'\\\\n\\') break;\\n                i = j;\\n            }\\n            else cp += s[i++];\\n        }\\n        stringstream ss(cp); string line;\\n        vector<string> res;\\n        while(getline(ss, line)) if(!line.empty()) res.push_back(line);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        string s,cp;\\n        for(int i = 0; i < source.size(); i++) s += source[i] + \\'\\\\n\\';\\n        for(int i = 0; i < s.size(); ){\\n            if(i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'*\\'){\\n                int j = i+2;\\n                for(; j < s.size(); j++) if(s[j] == \\'*\\' && s[j+1] ==\\'/\\') break;\\n                i = j+2;\\n            }\\n            else if(i < s.size()-1 && s[i] ==\\'/\\' && s[i+1] ==\\'/\\'){\\n                int j = i+2;\\n                for(; j < s.size(); j++) if(s[j] == \\'\\\\n\\') break;\\n                i = j;\\n            }\\n            else cp += s[i++];\\n        }\\n        stringstream ss(cp); string line;\\n        vector<string> res;\\n        while(getline(ss, line)) if(!line.empty()) res.push_back(line);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944835,
                "title": "c-easy-to-understand-short-100-tc",
                "content": "Time: O(no. of lines * len of line)\\nSpace: O(1) //not considering ans vec\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool isComment = false;\\n        string cur = \"\";\\n        vector<string> ans;\\n        for(string s : source) {\\n            int n = s.length();\\n            int i = 0;\\n            while(i<n) {\\n                if(!isComment && i<n - 1 && s[i] == \\'/\\' && s[i + 1]==\\'*\\') {\\n                    isComment = true;\\n                    i++;\\n                } else if(isComment && i<n - 1 && s[i] == \\'*\\' && s[i + 1] == \\'/\\') {\\n                    isComment = false;\\n                    i++;\\n                } else if(!isComment && i<n - 1 && s[i] == \\'/\\' && s[i+1] == \\'/\\') {\\n                    break;\\n                } else if(!isComment) {\\n                    cur += s[i];\\n                }\\n                i++;\\n            }\\n            if(!isComment && cur.length() > 0) {\\n                ans.push_back(cur);\\n                cur = \"\";\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool isComment = false;\\n        string cur = \"\";\\n        vector<string> ans;\\n        for(string s : source) {\\n            int n = s.length();\\n            int i = 0;\\n            while(i<n) {\\n                if(!isComment && i<n - 1 && s[i] == \\'/\\' && s[i + 1]==\\'*\\') {\\n                    isComment = true;\\n                    i++;\\n                } else if(isComment && i<n - 1 && s[i] == \\'*\\' && s[i + 1] == \\'/\\') {\\n                    isComment = false;\\n                    i++;\\n                } else if(!isComment && i<n - 1 && s[i] == \\'/\\' && s[i+1] == \\'/\\') {\\n                    break;\\n                } else if(!isComment) {\\n                    cur += s[i];\\n                }\\n                i++;\\n            }\\n            if(!isComment && cur.length() > 0) {\\n                ans.push_back(cur);\\n                cur = \"\";\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755800,
                "title": "c-beats-100-o-n-time-and-o-1-space-linear-one-pass",
                "content": "\\n\\n**Suggestions and Comments are most welcome, please let me know whatever you feel about this solution:-**\\n\\n1. Just simply traverse the input vector of strings as mentioned in the hints also.\\n\\n2. I have used functions to make things more readable and easy to understand.\\n\\n\\n```\\n// O(Linear Traversal) Time and O(1) Space --> Linear Search Approach\\nclass Solution {\\n    bool isLineComment(const string& s, int col){\\n        if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n        else return false;\\n    }\\n    bool isMultilineCommentStart(const string& s, int col){\\n        if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'*\\') return true;\\n        else return false;\\n    }\\n    bool isMultilineCommentEnd(const string& s, int col){\\n        if(s[col] == \\'*\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n        else return false;\\n    }\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> result;\\n        for(int line = 0; line < source.size();){\\n            string currLine;\\n            for(int col = 0; col < source[line].size();){\\n                if(isLineComment(source[line], col)){break;}\\n                else if(isMultilineCommentStart(source[line], col)){\\n                    col += 2;\\n                    while(true){\\n                        if(col >= source[line].size()){line++; col = 0;}\\n                        if(isMultilineCommentEnd(source[line], col)){col += 2;break;}\\n                        else{col++;}\\n                    }\\n                }\\n                else{currLine.push_back(source[line][col++]);}\\n            }\\n            if(currLine.size()) result.push_back(currLine);\\n            line++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// O(Linear Traversal) Time and O(1) Space --> Linear Search Approach\\nclass Solution {\\n    bool isLineComment(const string& s, int col){\\n        if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n        else return false;\\n    }\\n    bool isMultilineCommentStart(const string& s, int col){\\n        if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'*\\') return true;\\n        else return false;\\n    }\\n    bool isMultilineCommentEnd(const string& s, int col){\\n        if(s[col] == \\'*\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n        else return false;\\n    }\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> result;\\n        for(int line = 0; line < source.size();){\\n            string currLine;\\n            for(int col = 0; col < source[line].size();){\\n                if(isLineComment(source[line], col)){break;}\\n                else if(isMultilineCommentStart(source[line], col)){\\n                    col += 2;\\n                    while(true){\\n                        if(col >= source[line].size()){line++; col = 0;}\\n                        if(isMultilineCommentEnd(source[line], col)){col += 2;break;}\\n                        else{col++;}\\n                    }\\n                }\\n                else{currLine.push_back(source[line][col++]);}\\n            }\\n            if(currLine.size()) result.push_back(currLine);\\n            line++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691561,
                "title": "java-intuituve-easy-and-with-comments",
                "content": "```\\nclass Solution {\\n      public List<String> removeComments(String[] source) {\\n            ArrayList<String> result = new ArrayList<>();\\n\\n            boolean block = false;\\n\\n            String temp = \"\";\\n\\n            for (String line : source) {\\n                  if (!block) {\\n                        temp = \"\";\\n                  }\\n\\n                  for (int i = 0; i < line.length(); i++) {\\n                        if (block) {\\n                              if (line.charAt(i) == \\'*\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'/\\') {\\n                                    //when we are inside line comment and finding its endpoint.\\n                                    block = false;\\n                                    i++;\\n                              }\\n                        } else {\\n                              if (line.charAt(i) == \\'/\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'/\\') {\\n                                    // encountered the block comment so just directly break out of this current line and\\n                                    // check for next line.\\n                                    break;\\n                              }\\n\\n                              if (line.charAt(i) == \\'/\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'*\\') {\\n                                    /* encountered the line comment and now jump to 1st if condition \\n                                    for finding the closing side of line comment*/\\n                                    block = true;\\n                                    i++;\\n                                    continue;\\n                              }\\n                              // if didnt encountered any comments just add answer in temp\\n                              temp += line.charAt(i);\\n\\n                        }\\n                  }\\n                  if (!block) {\\n                        // add stored temp answer in result. \\n                        if (temp.length() > 0) {\\n                              result.add(temp);\\n                        }\\n                  }\\n            }\\n\\n            return result;\\n      }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public List<String> removeComments(String[] source) {\\n            ArrayList<String> result = new ArrayList<>();\\n\\n            boolean block = false;\\n\\n            String temp = \"\";\\n\\n            for (String line : source) {\\n                  if (!block) {\\n                        temp = \"\";\\n                  }\\n\\n                  for (int i = 0; i < line.length(); i++) {\\n                        if (block) {\\n                              if (line.charAt(i) == \\'*\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'/\\') {\\n                                    //when we are inside line comment and finding its endpoint.\\n                                    block = false;\\n                                    i++;\\n                              }\\n                        } else {\\n                              if (line.charAt(i) == \\'/\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'/\\') {\\n                                    // encountered the block comment so just directly break out of this current line and\\n                                    // check for next line.\\n                                    break;\\n                              }\\n\\n                              if (line.charAt(i) == \\'/\\' && i + 1 < line.length() && line.charAt(i + 1) == \\'*\\') {\\n                                    /* encountered the line comment and now jump to 1st if condition \\n                                    for finding the closing side of line comment*/\\n                                    block = true;\\n                                    i++;\\n                                    continue;\\n                              }\\n                              // if didnt encountered any comments just add answer in temp\\n                              temp += line.charAt(i);\\n\\n                        }\\n                  }\\n                  if (!block) {\\n                        // add stored temp answer in result. \\n                        if (temp.length() > 0) {\\n                              result.add(temp);\\n                        }\\n                  }\\n            }\\n\\n            return result;\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928550,
                "title": "js-solution-with-explanation-76ms-83-7",
                "content": "```\\nvar removeComments = function(source) {\\n    let result = [];\\n    let multi_line_comment = false;\\n    let str = \"\";\\n\\n    source.forEach(line => {\\n        for(let idx=0; idx < line.length; ++idx) {\\n            // if /* is not ongoing, check for start of a comment or not\\n            if(!multi_line_comment) {\\n                // if comment is //, ignore the rest of the line\\n                if(line[idx] + line[idx+1] === \\'//\\') {\\n                    break;\\n                }\\n                // if comment if /*, set multi-line flag and move to next index\\n                else if(line[idx] + line[idx+1] === \\'/*\\') {\\n                    multi_line_comment = true;\\n                    ++idx;\\n                }\\n                // if not a comment start, add to string to be added to result\\n                else {\\n                    str += line[idx];\\n                }\\n            }\\n            // if /* comment is ongoing\\n            else {\\n                // if closing comment */ is encountered, set multi-line flag off and move to next index\\n                if(line[idx] + line[idx+1] === \\'*/\\') {\\n                    multi_line_comment = false;\\n                    ++idx;\\n                }\\n            }\\n        }\\n        // if /* comment is not ongoing and str is not empty, add to result as one code line\\n        if(str.length && !multi_line_comment) {\\n            result.push(str);\\n            str = \"\"; //reset the str\\n        }\\n    })\\n    return result;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeComments = function(source) {\\n    let result = [];\\n    let multi_line_comment = false;\\n    let str = \"\";\\n\\n    source.forEach(line => {\\n        for(let idx=0; idx < line.length; ++idx) {\\n            // if /* is not ongoing, check for start of a comment or not\\n            if(!multi_line_comment) {\\n                // if comment is //, ignore the rest of the line\\n                if(line[idx] + line[idx+1] === \\'//\\') {\\n                    break;\\n                }\\n                // if comment if /*, set multi-line flag and move to next index\\n                else if(line[idx] + line[idx+1] === \\'/*\\') {\\n                    multi_line_comment = true;\\n                    ++idx;\\n                }\\n                // if not a comment start, add to string to be added to result\\n                else {\\n                    str += line[idx];\\n                }\\n            }\\n            // if /* comment is ongoing\\n            else {\\n                // if closing comment */ is encountered, set multi-line flag off and move to next index\\n                if(line[idx] + line[idx+1] === \\'*/\\') {\\n                    multi_line_comment = false;\\n                    ++idx;\\n                }\\n            }\\n        }\\n        // if /* comment is not ongoing and str is not empty, add to result as one code line\\n        if(str.length && !multi_line_comment) {\\n            result.push(str);\\n            str = \"\"; //reset the str\\n        }\\n    })\\n    return result;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724682,
                "title": "java-o-n-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder builder = null;\\n        boolean commentMode = false;\\n        \\n        for (int i = 0; i < source.length; i++) {\\n            String line = source[i];\\n            \\n            if (commentMode) {\\n                int index = line.indexOf(\"*/\");\\n                \\n                if (index == -1) {\\n                    continue;\\n                }\\n                \\n                commentMode = false;\\n                line = line.substring(index + 2);\\n            } else {\\n                builder = new StringBuilder();\\n            }\\n            \\n            int lineComment = line.indexOf(\"//\");\\n            int blockComment = line.indexOf(\"/*\");\\n\\n            if (lineComment == -1 && blockComment == -1) {\\n                builder.append(line);\\n            } else if (blockComment == -1 || blockComment > lineComment && lineComment >= 0) {\\n                builder.append(line.substring(0, lineComment));\\n            } else if (lineComment == -1 || lineComment > blockComment && blockComment >= 0) {\\n                builder.append(line.substring(0, blockComment));\\n                source[i] = line.substring(blockComment + 2);\\n                commentMode = true;\\n                i--;\\n                continue;\\n            }\\n            \\n            if (builder.length() > 0) {\\n                result.add(builder.toString());\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder builder = null;\\n        boolean commentMode = false;\\n        \\n        for (int i = 0; i < source.length; i++) {\\n            String line = source[i];\\n            \\n            if (commentMode) {\\n                int index = line.indexOf(\"*/\");\\n                \\n                if (index == -1) {\\n                    continue;\\n                }\\n                \\n                commentMode = false;\\n                line = line.substring(index + 2);\\n            } else {\\n                builder = new StringBuilder();\\n            }\\n            \\n            int lineComment = line.indexOf(\"//\");\\n            int blockComment = line.indexOf(\"/*\");\\n\\n            if (lineComment == -1 && blockComment == -1) {\\n                builder.append(line);\\n            } else if (blockComment == -1 || blockComment > lineComment && lineComment >= 0) {\\n                builder.append(line.substring(0, lineComment));\\n            } else if (lineComment == -1 || lineComment > blockComment && blockComment >= 0) {\\n                builder.append(line.substring(0, blockComment));\\n                source[i] = line.substring(blockComment + 2);\\n                commentMode = true;\\n                i--;\\n                continue;\\n            }\\n            \\n            if (builder.length() > 0) {\\n                result.add(builder.toString());\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109199,
                "title": "c-regex",
                "content": "Inspired by the solution @StefanPochmann \\n1. we join the vector of string into one string using \\\\n\\n2. regex replace the comments using empty string\\n3. split the string into vector of string using \\\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        stringstream ss;\\n        const char* delim=\"\\\\n\";\\n        copy(source.begin(),source.end(),ostream_iterator<string>(ss,delim));\\n        string s=ss.str();\\n        //cout<<s;\\n        regex e(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\");\\n        string ns=regex_replace(s,e,\"\");\\n        //cout<<ns;\\n        //split the string into vector using tokened string\\n        ss.str(ns);\\n        vector<string> ans;\\n        while(ss.good())\\n        {\\n            string token;\\n            getline(ss,token,'\\\\n');\\n            if(!token.empty())\\n            ans.push_back(token);\\n        }\\n        //copy(ans.begin(),ans.end(),ostream_iterator<string>(cout,\"\\\\n\"));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        stringstream ss;\\n        const char* delim=\"\\\\n\";\\n        copy(source.begin(),source.end(),ostream_iterator<string>(ss,delim));\\n        string s=ss.str();\\n        //cout<<s;\\n        regex e(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\");\\n        string ns=regex_replace(s,e,\"\");\\n        //cout<<ns;\\n        //split the string into vector using tokened string\\n        ss.str(ns);\\n        vector<string> ans;\\n        while(ss.good())\\n        {\\n            string token;\\n            getline(ss,token,'\\\\n');\\n            if(!token.empty())\\n            ans.push_back(token);\\n        }\\n        //copy(ans.begin(),ans.end(),ostream_iterator<string>(cout,\"\\\\n\"));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1315514,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        string s;\\n        int j;\\n        bool comment=false;\\n        for(int i=0;i<source.size();i++){\\n          for( j=0;j<source[i].size();j++){\\n            if(comment==false & j+1<source[i].size() && source[i][j]==\\'/\\' && source[i][j+1]==\\'/\\') {\\n                    break;\\n                }\\n            else if(comment==false & j+1<source[i].size() & source[i][j]==\\'/\\' & source[i][j+1]==\\'*\\'){\\n                comment=true;\\n                j++;\\n            }\\n        else if(comment && j+1 < source[i].size() & source[i][j]==\\'*\\' & source[i][j+1]==\\'/\\') { \\n         comment = false, j++;\\n          }\\n        else if(comment==false){\\n                  s.push_back(source[i][j]);\\n        }\\n            }\\n            if(comment==false && s.size()){\\n                ans.push_back(s);\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nif you like the solution please upvote it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        string s;\\n        int j;\\n        bool comment=false;\\n        for(int i=0;i<source.size();i++){\\n          for( j=0;j<source[i].size();j++){\\n            if(comment==false & j+1<source[i].size() && source[i][j]==\\'/\\' && source[i][j+1]==\\'/\\') {\\n                    break;\\n                }\\n            else if(comment==false & j+1<source[i].size() & source[i][j]==\\'/\\' & source[i][j+1]==\\'*\\'){\\n                comment=true;\\n                j++;\\n            }\\n        else if(comment && j+1 < source[i].size() & source[i][j]==\\'*\\' & source[i][j+1]==\\'/\\') { \\n         comment = false, j++;\\n          }\\n        else if(comment==false){\\n                  s.push_back(source[i][j]);\\n        }\\n            }\\n            if(comment==false && s.size()){\\n                ans.push_back(s);\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407444,
                "title": "python-one-pass-stack-solution",
                "content": "The solution is straight-forward if you have the patience to go through it. \\n* First of all, we concatenate the lines into a long string `source`. Different lines are connected by the `\\\\n` character.\\n* Then we scan `source`. There are three possible states. \\n\\t1. The first state, when `flag_slash` is set to `True`, indidates that we are in a `//` comment area. We reset `flag_slash` to `False` once we encounter a return character `\\\\n`.\\n\\t1. The second state, when `flag_block` is set to `True`, indidates that we are in a `/*` block comment area. We reset `flag_block` to `False` once we encounter a `*/`.\\n\\t1. The third state, when both of the flags are `False`, indidates that we are not in a comment area. Therefore, we simple append the character to `stack`.\\n* After we scan the entire string `source`, we concatenate `stack` into a long string and split the long string into lines using delimiter `\\\\n`. Finally, we remove the empty lines.\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        source = \\'\\\\n\\'.join(source)\\n        stack = []\\n        flag_slash = False\\n        flag_block = False\\n        \\n        i = 0\\n        while i < len(source):\\n            if not flag_block:\\n                if flag_slash == True:\\n                    if source[i] == \\'\\\\n\\':\\n                        stack.append(\\'\\\\n\\')\\n                        flag_slash = False\\n                elif source[i:i + 2] == \\'//\\':\\n                    flag_slash = True\\n                    i += 1\\n                elif source[i:i + 2] == \\'/*\\':\\n                    flag_block = True\\n                    i += 1\\n                else:\\n                    stack.append(source[i])\\n            else:\\n                if source[i:i + 2] == \\'*/\\':\\n                    flag_block = False\\n                    i += 1\\n            i += 1\\n        source = \\'\\'.join(stack)\\n        res = source.split(\\'\\\\n\\')\\n        return [line for line in res if line]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        source = \\'\\\\n\\'.join(source)\\n        stack = []\\n        flag_slash = False\\n        flag_block = False\\n        \\n        i = 0\\n        while i < len(source):\\n            if not flag_block:\\n                if flag_slash == True:\\n                    if source[i] == \\'\\\\n\\':\\n                        stack.append(\\'\\\\n\\')\\n                        flag_slash = False\\n                elif source[i:i + 2] == \\'//\\':\\n                    flag_slash = True\\n                    i += 1\\n                elif source[i:i + 2] == \\'/*\\':\\n                    flag_block = True\\n                    i += 1\\n                else:\\n                    stack.append(source[i])\\n            else:\\n                if source[i:i + 2] == \\'*/\\':\\n                    flag_block = False\\n                    i += 1\\n            i += 1\\n        source = \\'\\'.join(stack)\\n        res = source.split(\\'\\\\n\\')\\n        return [line for line in res if line]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348542,
                "title": "straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        int size = source.size();\\n        bool insideComment = false;\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < size; i++) {\\n            int len = source[i].size();\\n            int start = 0;\\n            if(!insideComment) temp = \"\";\\n            \\n            for(int j = 0; j < len; j++) {\\n                if(!insideComment && j < len-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'/\\') {\\n                    if(j != 0) {\\n                        temp += source[i].substr(start, j-start);\\n                        if(temp != \"\") {\\n                            res.push_back(temp);\\n                        }\\n                    }\\n                    break;\\n                } else if(!insideComment && j < len-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'*\\') {\\n                    source[i][j+1] = \\'?\\';\\n                    if(j != 0) {\\n                        temp += source[i].substr(start, j-start);\\n                    }\\n                    insideComment = true;\\n                } else if(insideComment && j < len-1 && source[i][j] == \\'*\\' && source[i][j+1] == \\'/\\') {\\n                    source[i][j+1] = \\'?\\';\\n                    if(j+1 == len-1) {\\n                        // line end\\n                        if(temp != \"\") {\\n                            res.push_back(temp);\\n                        }\\n                        insideComment = false;\\n                        break;\\n                    } else {\\n                        start = j+2;\\n                        insideComment = false;\\n                    }\\n                } else if(!insideComment && j == len-1) {\\n                    // line end\\n                    temp += source[i].substr(start, j-start+1);\\n                    if(temp != \"\") {\\n                        res.push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        int size = source.size();\\n        bool insideComment = false;\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < size; i++) {\\n            int len = source[i].size();\\n            int start = 0;\\n            if(!insideComment) temp = \"\";\\n            \\n            for(int j = 0; j < len; j++) {\\n                if(!insideComment && j < len-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'/\\') {\\n                    if(j != 0) {\\n                        temp += source[i].substr(start, j-start);\\n                        if(temp != \"\") {\\n                            res.push_back(temp);\\n                        }\\n                    }\\n                    break;\\n                } else if(!insideComment && j < len-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'*\\') {\\n                    source[i][j+1] = \\'?\\';\\n                    if(j != 0) {\\n                        temp += source[i].substr(start, j-start);\\n                    }\\n                    insideComment = true;\\n                } else if(insideComment && j < len-1 && source[i][j] == \\'*\\' && source[i][j+1] == \\'/\\') {\\n                    source[i][j+1] = \\'?\\';\\n                    if(j+1 == len-1) {\\n                        // line end\\n                        if(temp != \"\") {\\n                            res.push_back(temp);\\n                        }\\n                        insideComment = false;\\n                        break;\\n                    } else {\\n                        start = j+2;\\n                        insideComment = false;\\n                    }\\n                } else if(!insideComment && j == len-1) {\\n                    // line end\\n                    temp += source[i].substr(start, j-start+1);\\n                    if(temp != \"\") {\\n                        res.push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283030,
                "title": "0ms-beats-100-java-solution-very-clean-readable-and-easy-to-understand",
                "content": "One Pass Java Solution Beats 100% 0ms\\n\\nThe idea is simple and clean:\\nWhen iterate through all lines, delete any comments found, only add non-empty lines to the result list. \\n\\nLogic flow in a nutshell:\\n1. When iterate through all lines\\n2. find the idex of \"//\" and \"/*\"\\n\\t1.1. if both not found, add the line if non-empty\\n\\t1.2. if \"//\" found first, just delete everything after \"//\", add the line if non-empty\\n\\t1.3. if \"/*\" found first, go find the matching \"*/\", delete everything in between. After deletion, the line is still NOT ready to be added since there could be more than one block comments in the same line.  Roll back the line iteration index so that the same line will be parsed again in the next iteration.\\n\\nThe most important fact and trick:\\n1. First comment always takes precedence so no messy logic needed. For more explanation please see below.\\n2. Line comments are easy to handle, just delete everything after.\\n2. Block comments is tricky to remove since they can appear multiple times in the same line. The trick is rolling back the line iteration index so that the same line will get parsed again and again until there is no comment found.\\n\\nAbout precedence: \\nIt is worth mentioning that we don\\'t really have to worry about nested comments since the question description explicitly tells us that the early comment always takes precedence. So when you find a line comment, just delete everything after the denoter \"//\"; and when you find a block comment \"/\\\\*\", just find the ending denoter \"\\\\*/\" and delete everything in between. This is perfectly safe since the first comment takes precedence!\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    String lc = \"//\"; // line comment\\n    String bcs = \"/*\"; // block comment start\\n    String bce = \"*/\"; // block comment end\\n    \\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        for (int i = 0; i < source.length; i++) {\\n            int idxLine = source[i].indexOf(lc); // get idex of line comment \\n            int idxBlock = source[i].indexOf(bcs); // get idex of block comment\\n            // if there is any comment in the current line\\n            if (idxLine != -1 || idxBlock != -1) {\\n                // case 1: line comment takes precedence\\n                if (idxLine != -1 && (idxLine < idxBlock || idxBlock == -1)) {\\n                    source[i] = source[i].substring(0, idxLine);\\n                } else {\\n                // case 2: block comment takes precedence\\n                    String s = source[i].substring(0, idxBlock);\\n                    int start = idxBlock + 2;\\n                    int idxBlockEnd = -1;\\n                    while (true) {\\n                        idxBlockEnd = source[i].indexOf(bce, start);\\n                        if (idxBlockEnd != - 1) {\\n                            break;  \\n                        }\\n                        i++;\\n                        start = 0;\\n                    }\\n                    s += source[i].substring(idxBlockEnd + 2, source[i].length());\\n                    source[i] = s;\\n                    // recurse here\\n                    i--;\\n                    continue;\\n                }\\n            }\\n            // only add non-empty line\\n            if (!source[i].isEmpty()) {\\n                res.add(source[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    String lc = \"//\"; // line comment\\n    String bcs = \"/*\"; // block comment start\\n    String bce = \"*/\"; // block comment end\\n    \\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        for (int i = 0; i < source.length; i++) {\\n            int idxLine = source[i].indexOf(lc); // get idex of line comment \\n            int idxBlock = source[i].indexOf(bcs); // get idex of block comment\\n            // if there is any comment in the current line\\n            if (idxLine != -1 || idxBlock != -1) {\\n                // case 1: line comment takes precedence\\n                if (idxLine != -1 && (idxLine < idxBlock || idxBlock == -1)) {\\n                    source[i] = source[i].substring(0, idxLine);\\n                } else {\\n                // case 2: block comment takes precedence\\n                    String s = source[i].substring(0, idxBlock);\\n                    int start = idxBlock + 2;\\n                    int idxBlockEnd = -1;\\n                    while (true) {\\n                        idxBlockEnd = source[i].indexOf(bce, start);\\n                        if (idxBlockEnd != - 1) {\\n                            break;  \\n                        }\\n                        i++;\\n                        start = 0;\\n                    }\\n                    s += source[i].substring(idxBlockEnd + 2, source[i].length());\\n                    source[i] = s;\\n                    // recurse here\\n                    i--;\\n                    continue;\\n                }\\n            }\\n            // only add non-empty line\\n            if (!source[i].isEmpty()) {\\n                res.add(source[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446606,
                "title": "easy-to-understand-using-python",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans, inComment = [], False\\n        new_str = \"\"\\n        for c in source:\\n            if not inComment: new_str = \"\"\\n            i, n = 0, len(c)\\n            # inComment, we find */\\n            while i < n:\\n                if inComment:\\n                    if c[i:i + 2] == \\'*/\\' and i + 1 < n:\\n                        i += 2\\n                        inComment = False\\n                        continue\\n                    i += 1\\n                # not in Comment, we find /* // and common character\\n                else:\\n                    if c[i:i + 2] == \\'/*\\' and i + 1 < n:\\n                        i += 2\\n                        inComment = True\\n                        continue\\n                    if c[i:i + 2] == \\'//\\' and i + 1 < n:\\n                        break\\n                    new_str += c[i]\\n                    i += 1\\n            if new_str and not inComment:\\n                ans.append(new_str)\\n                    \\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans, inComment = [], False\\n        new_str = \"\"\\n        for c in source:\\n            if not inComment: new_str = \"\"\\n            i, n = 0, len(c)\\n            # inComment, we find */\\n            while i < n:\\n                if inComment:\\n                    if c[i:i + 2] == \\'*/\\' and i + 1 < n:\\n                        i += 2\\n                        inComment = False\\n                        continue\\n                    i += 1\\n                # not in Comment, we find /* // and common character\\n                else:\\n                    if c[i:i + 2] == \\'/*\\' and i + 1 < n:\\n                        i += 2\\n                        inComment = True\\n                        continue\\n                    if c[i:i + 2] == \\'//\\' and i + 1 < n:\\n                        break\\n                    new_str += c[i]\\n                    i += 1\\n            if new_str and not inComment:\\n                ans.append(new_str)\\n                    \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998755,
                "title": "java-regex",
                "content": "```java\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        String program = String.join(\"\\\\n\", source);\\n        List<String> ans = new ArrayList<>(List.of(program.replaceAll(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\", \"\").split(\"\\\\n\")));\\n        ans.removeAll(Collections.singleton(\"\"));\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```\\nThe first part of the regex = \"//.*\" \\nwill remove all the single line comments // followed by anything other than \\\\n\\n```\\n```\\nThe second part of the regex =\"/*(.|\\\\n)*?*/\", \\nhere * is escaped using \\\\\\\\* since backslash is also escaped. \\nTill you find a */, you can skip lines and remove content\\n```\\n```\\nList.of converts array to list\\n```\\n```\\nCollections.singelton constructs a collection with one element\\n```\\n```\\nlist.removeAll(Collection) removes all the elements in the \\ncollection from the list (all occurrences)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        String program = String.join(\"\\\\n\", source);\\n        List<String> ans = new ArrayList<>(List.of(program.replaceAll(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\", \"\").split(\"\\\\n\")));\\n        ans.removeAll(Collections.singleton(\"\"));\\n        return ans;\\n    }\\n}\\n```\n```\\nThe first part of the regex = \"//.*\" \\nwill remove all the single line comments // followed by anything other than \\\\n\\n```\n```\\nThe second part of the regex =\"/*(.|\\\\n)*?*/\", \\nhere * is escaped using \\\\\\\\* since backslash is also escaped. \\nTill you find a */, you can skip lines and remove content\\n```\n```\\nList.of converts array to list\\n```\n```\\nCollections.singelton constructs a collection with one element\\n```\n```\\nlist.removeAll(Collection) removes all the elements in the \\ncollection from the list (all occurrences)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891037,
                "title": "python3-straightforward-solution-remove-comments",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans = []\\n        inblock = False\\n        for line in source:\\n            if not inblock:\\n                ans.append([])\\n            i = 0\\n            while i < len(line):\\n                if not inblock:\\n                    if line[i] == \\'/\\' and i + 1 < len(line) and line[i+1] in \\'/*\\':\\n                        if line[i+1] == \\'/\\':\\n                            break\\n                        i += 1    \\n                        inblock = True\\n                    else:\\n                        ans[-1].append(line[i])\\n                else:\\n                    if line[i] == \\'*\\' and i + 1 < len(line) and line[i+1] == \\'/\\':\\n                        i += 1\\n                        inblock = False\\n                i += 1\\n        return [\\'\\'.join(line) for line in ans if line]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans = []\\n        inblock = False\\n        for line in source:\\n            if not inblock:\\n                ans.append([])\\n            i = 0\\n            while i < len(line):\\n                if not inblock:\\n                    if line[i] == \\'/\\' and i + 1 < len(line) and line[i+1] in \\'/*\\':\\n                        if line[i+1] == \\'/\\':\\n                            break\\n                        i += 1    \\n                        inblock = True\\n                    else:\\n                        ans[-1].append(line[i])\\n                else:\\n                    if line[i] == \\'*\\' and i + 1 < len(line) and line[i+1] == \\'/\\':\\n                        i += 1\\n                        inblock = False\\n                i += 1\\n        return [\\'\\'.join(line) for line in ans if line]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630587,
                "title": "one-pass-c-solution",
                "content": "Parse the source string by string. If there is /* detected then ignore everything until */ is detected:\\nIf // is detected and /* has  not been detected then ignore the current string.\\nTime complexity O(S) where S is the length of source code.\\nSpacce complexity O(1): only using list of strings that need to be returned.\\n```\\npublic IList<string> RemoveComments(string[] source) {\\n        IList<string> res = new List<string>();\\n        if(source.Length == 0) return res;\\n        bool blockCommentStarted = false;\\n        string r  = \"\";\\n        foreach( string s in source)\\n        {\\n            for(int i = 0;i<s.Length;i++)\\n            {\\n                if(!blockCommentStarted)\\n                {\\n                    if(s[i] == \\'/\\' && i+1 < s.Length && s[i+1] == \\'*\\')\\n                    {\\n                        blockCommentStarted = true;\\n                        i++;\\n                        //Console.WriteLine(i + \" \" + s.Length);\\n                    }\\n                    else if(s[i] == \\'/\\' && i+1 < s.Length && s[i+1] == \\'/\\')\\n                    {\\n                        i++;\\n                        //while(i < s.Length )\\n                        break;\\n                    }\\n                    else{\\n                        r += s[i]; \\n                    }\\n                }\\n                else{\\n                    if(s[i] == \\'*\\' && i+1 < s.Length && s[i+1] == \\'/\\' )//&& i-1 >= 0 && s[i-1] != \\'/\\')\\n                    {\\n                        blockCommentStarted = false;\\n                        i++;\\n                        //Console.WriteLine(i + \" \" + s.Length);\\n                    }\\n                }\\n            }\\n            if(!blockCommentStarted && r != \"\")\\n            {\\n                res.Add(r);\\n                r = \"\";\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<string> RemoveComments(string[] source) {\\n        IList<string> res = new List<string>();\\n        if(source.Length == 0) return res;\\n        bool blockCommentStarted = false;\\n        string r  = \"\";\\n        foreach( string s in source)\\n        {\\n            for(int i = 0;i<s.Length;i++)\\n            {\\n                if(!blockCommentStarted)\\n                {\\n                    if(s[i] == \\'/\\' && i+1 < s.Length && s[i+1] == \\'*\\')\\n                    {\\n                        blockCommentStarted = true;\\n                        i++;\\n                        //Console.WriteLine(i + \" \" + s.Length);\\n                    }\\n                    else if(s[i] == \\'/\\' && i+1 < s.Length && s[i+1] == \\'/\\')\\n                    {\\n                        i++;\\n                        //while(i < s.Length )\\n                        break;\\n                    }\\n                    else{\\n                        r += s[i]; \\n                    }\\n                }\\n                else{\\n                    if(s[i] == \\'*\\' && i+1 < s.Length && s[i+1] == \\'/\\' )//&& i-1 >= 0 && s[i-1] != \\'/\\')\\n                    {\\n                        blockCommentStarted = false;\\n                        i++;\\n                        //Console.WriteLine(i + \" \" + s.Length);\\n                    }\\n                }\\n            }\\n            if(!blockCommentStarted && r != \"\")\\n            {\\n                res.Add(r);\\n                r = \"\";\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868818,
                "title": "python-one-pass",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n\\n        close, tmp = True, \"\"\\n        for idx,s in enumerate(source):\\n            i = 0\\n            while i < len(s):\\n                c = s[i]\\n                if c in \\'/*\\':\\n                    if i+1 < len(s) and s[i:i+2] == \\'//\\' and close:\\n                        break\\n                    elif i+1 < len(s) and s[i:i+2] == \\'/*\\' and close:\\n                        close = False\\n                        i += 2\\n                        continue\\n                    elif i+1 < len(s) and s[i: i+2] == \\'*/\\' and not close:\\n                        close = True\\n                        i += 2\\n                        continue\\n                if close:\\n                    tmp += c\\n                i += 1\\n            if tmp != \"\" and close:\\n                res.append(tmp) \\n                tmp = \"\"\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n\\n        close, tmp = True, \"\"\\n        for idx,s in enumerate(source):\\n            i = 0\\n            while i < len(s):\\n                c = s[i]\\n                if c in \\'/*\\':\\n                    if i+1 < len(s) and s[i:i+2] == \\'//\\' and close:\\n                        break\\n                    elif i+1 < len(s) and s[i:i+2] == \\'/*\\' and close:\\n                        close = False\\n                        i += 2\\n                        continue\\n                    elif i+1 < len(s) and s[i: i+2] == \\'*/\\' and not close:\\n                        close = True\\n                        i += 2\\n                        continue\\n                if close:\\n                    tmp += c\\n                i += 1\\n            if tmp != \"\" and close:\\n                res.append(tmp) \\n                tmp = \"\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389961,
                "title": "python-solution",
                "content": "```\\ndef removeComments(self, s: List[str]) -> List[str]:\\n\\ts = \\'\\\\n\\'.join(s)+\\'\\\\n\\'\\n\\ti, ans = 0, \\'\\'\\n\\twhile(i<len(s)):\\n\\t\\tif i<len(s)-1 and s[i]+s[i+1]==\\'//\\':\\n\\t\\t\\tidx = s.index(\\'\\\\n\\', i+2)\\n\\t\\t\\ti = idx\\n\\t\\telif i<len(s)-1 and s[i]+s[i+1]==\\'/*\\':\\n\\t\\t\\tidx = s.index(\\'*/\\', i+2)\\n\\t\\t\\ti = idx+2\\n\\t\\telse:\\n\\t\\t\\tans += s[i]\\n\\t\\t\\ti += 1\\n\\treturn [c for c in ans.split(\\'\\\\n\\') if c]\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeComments(self, s: List[str]) -> List[str]:\\n\\ts = \\'\\\\n\\'.join(s)+\\'\\\\n\\'\\n\\ti, ans = 0, \\'\\'\\n\\twhile(i<len(s)):\\n\\t\\tif i<len(s)-1 and s[i]+s[i+1]==\\'//\\':\\n\\t\\t\\tidx = s.index(\\'\\\\n\\', i+2)\\n\\t\\t\\ti = idx\\n\\t\\telif i<len(s)-1 and s[i]+s[i+1]==\\'/*\\':\\n\\t\\t\\tidx = s.index(\\'*/\\', i+2)\\n\\t\\t\\ti = idx+2\\n\\t\\telse:\\n\\t\\t\\tans += s[i]\\n\\t\\t\\ti += 1\\n\\treturn [c for c in ans.split(\\'\\\\n\\') if c]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2306511,
                "title": "java-straightforward-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<String> removeComments(String[] source) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tList<String> ansLst = new ArrayList<>();\\n\\n\\t\\t\\t// Make it to paragraph\\n\\t\\t\\tfor(String str: source) {\\n\\t\\t\\t\\tsb.append(str);\\n\\t\\t\\t\\tsb.append(\\'\\\\n\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\tString paragraph = sb.toString();\\n\\n\\t\\t\\tStringBuilder cleanedString = new StringBuilder();\\n\\n\\t\\t\\tfor(int i=0; i<paragraph.length(); i++) {\\n\\t\\t\\t\\t// \"//\" case\\n\\t\\t\\t\\tif(paragraph.charAt(i) == \\'/\\' && i+1 < paragraph.length() && paragraph.charAt(i+1) == \\'/\\') {\\n\\t\\t\\t\\t\\ti+=2;\\n\\t\\t\\t\\t\\twhile(i<paragraph.length() && paragraph.charAt(i) != \\'\\\\n\\') {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti--;\\n\\n\\t\\t\\t\\t} else if(paragraph.charAt(i) == \\'/\\' && i+1 < paragraph.length() && paragraph.charAt(i+1) == \\'*\\') {\\n\\t\\t\\t\\t\\t// \"/*\" case                 \\n\\t\\t\\t\\t\\ti+=2;\\n\\t\\t\\t\\t\\twhile(i<paragraph.length() && !(paragraph.charAt(i) == \\'*\\' && paragraph.charAt(i+1) == \\'/\\')) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcleanedString.append(paragraph.charAt(i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tString[] results = cleanedString.toString().split(\"\\\\n\");\\n\\n\\t\\t\\tfor(String result: results) {\\n\\t\\t\\t\\tif(result.length() > 0) {\\n\\t\\t\\t\\t\\tansLst.add(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ansLst;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<String> removeComments(String[] source) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tList<String> ansLst = new ArrayList<>();\\n\\n\\t\\t\\t// Make it to paragraph\\n\\t\\t\\tfor(String str: source) {\\n\\t\\t\\t\\tsb.append(str);\\n\\t\\t\\t\\tsb.append(\\'\\\\n\\');\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2212799,
                "title": "javascript-regex-solution",
                "content": "1. need to append a tailing `#` as separator, since we want to match `// ...... #` for each string, including the last one.\\n2. why not concat with `/n`? \\nbecause there is an edge case that: `abc/`, `ef` will be constructed to `abc//nef#`, then it will match a  `//` comment syntax, which cause error.\\nError case:\\n\\t```\\n\\t[\"void func(int k) {\", \"// this function does nothing /*\", \"   k = k*2/4;\", \"   k = k/2;*/\", \"}\"]\\n\\t```\\n3. Major 2 parts of Regex (without escaping):\\n    * one line comment: `//.*?`  but must judge with the tailing `#` sign here.\\n    * block comments: `/* any char */`\\n\\n**Solution:**\\n```js\\nvar removeComments = function(source) {\\n    let s = source.join(\\'#\\') + \\'#\\';\\n    s = s.replaceAll(/\\\\/\\\\/.*?(?=#)|\\\\/\\\\*.*?\\\\*\\\\//g, \\'\\').split(\\'#\\');\\n    s = s.filter(str=>str.length>0);\\n    return s;\\n};\\n```\\n\\nReference Regex solution from this post: https://leetcode.com/problems/remove-comments/discuss/397184/1-line-python-solution-by-re.-faster-than-94",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t[\"void func(int k) {\", \"// this function does nothing /*\", \"   k = k*2/4;\", \"   k = k/2;*/\", \"}\"]\\n\\t```\n```js\\nvar removeComments = function(source) {\\n    let s = source.join(\\'#\\') + \\'#\\';\\n    s = s.replaceAll(/\\\\/\\\\/.*?(?=#)|\\\\/\\\\*.*?\\\\*\\\\//g, \\'\\').split(\\'#\\');\\n    s = s.filter(str=>str.length>0);\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928155,
                "title": "commented-python-solution-with-two-booleans-for-tracking",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result: list[str] = []\\n        in_block = False\\n        multiline = False   \\n        \\n        for line in source:\\n            res_line: list[str] = [\\'\\']*len(line)\\n            \\n            # If the prev line was a block comment, we know we\\'re\\n            # in a multiline comment. The inverse is also true.\\n            # In other words, multiline trails in_block by one line.\\n            multiline = in_block\\n            \\n            # Input and result iterators\\n            i, r = 0, 0\\n            \\n            # Iterate over a line\\n            while i < len(line):\\n                cur = line[i]\\n                nex = line[i+1] if i+1 < len(line) else \\'\\'\\n                \\n                # Stop adding chars if we see a single line comment\\n                if cur == \\'/\\' and nex == \\'/\\' and not in_block:\\n                    break\\n                \\n                # Skip over the /* and set flag to stop including chars\\n                if cur == \\'/\\' and nex == \\'*\\' and not in_block:\\n                    in_block = True\\n                    i += 2\\n                    continue\\n                    \\n                # Skip over the */ and set flag to start including chars again\\n                if cur == \\'*\\' and nex == \\'/\\' and in_block:\\n                    in_block = False\\n                    i += 2                                        \\n                    continue\\n                \\n                # Add the character if we\\'re not in a block comment\\n                if not in_block and i < len(line):\\n                    res_line[r] = line[i]\\n                    r += 1\\n                i += 1\\n            \\n            res_line = \\'\\'.join([x for x in res_line])\\n            \\n            # Only append a result line if the result of removing comments result in spaces or chars.\\n            if res_line:\\n                # If we\\'re in a multiline comment, append the result line to the previous one.\\n                if multiline:\\n                    result[-1] += res_line\\n                else:\\n                    result.append(res_line)\\n                \\n        return result\\n```\\n\\nSpent a lot of time on this trying to make a more complicated state machine than this one,\\nbut it turns out what you really need to know is if you\\'re in a block comment.\\nWith this knowledge, you can iterate each character one by one and decide if it should be in the result.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result: list[str] = []\\n        in_block = False\\n        multiline = False   \\n        \\n        for line in source:\\n            res_line: list[str] = [\\'\\']*len(line)\\n            \\n            # If the prev line was a block comment, we know we\\'re\\n            # in a multiline comment. The inverse is also true.\\n            # In other words, multiline trails in_block by one line.\\n            multiline = in_block\\n            \\n            # Input and result iterators\\n            i, r = 0, 0\\n            \\n            # Iterate over a line\\n            while i < len(line):\\n                cur = line[i]\\n                nex = line[i+1] if i+1 < len(line) else \\'\\'\\n                \\n                # Stop adding chars if we see a single line comment\\n                if cur == \\'/\\' and nex == \\'/\\' and not in_block:\\n                    break\\n                \\n                # Skip over the /* and set flag to stop including chars\\n                if cur == \\'/\\' and nex == \\'*\\' and not in_block:\\n                    in_block = True\\n                    i += 2\\n                    continue\\n                    \\n                # Skip over the */ and set flag to start including chars again\\n                if cur == \\'*\\' and nex == \\'/\\' and in_block:\\n                    in_block = False\\n                    i += 2                                        \\n                    continue\\n                \\n                # Add the character if we\\'re not in a block comment\\n                if not in_block and i < len(line):\\n                    res_line[r] = line[i]\\n                    r += 1\\n                i += 1\\n            \\n            res_line = \\'\\'.join([x for x in res_line])\\n            \\n            # Only append a result line if the result of removing comments result in spaces or chars.\\n            if res_line:\\n                # If we\\'re in a multiline comment, append the result line to the previous one.\\n                if multiline:\\n                    result[-1] += res_line\\n                else:\\n                    result.append(res_line)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645035,
                "title": "java-100-2-characters-at-a-time",
                "content": "Idea is to process two-two characters if there\\'s possibility of start of comment (single/multi) or if possibility of end of comment (multi).\\n\\nToo many if-else to make approach straightforward for such type of question especially during the interview :-)\\n\\nThank you for dropping by...if it\\'s useful to you pls upvote it... Thanks !!\\n\\n```\\npublic List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean multiComment=false;\\n        \\n        for(String line:source) {\\n            int n=line.length();\\n            int index=0;\\n            \\n            while(index < n) {\\n                char ch = line.charAt(index);\\n                if(!multiComment && ch == \\'/\\') {   //possibility of starting of single/multi comment\\n                    index++;                       //check two characters together\\n                    if(index >= n) {\\n                        sb.append(ch);\\n                        continue;\\n                    }\\n                    if(line.charAt(index) == \\'/\\') \\n                        break;\\n                    else if(line.charAt(index) == \\'*\\')\\n                        multiComment=true;\\n                    else\\n                        sb.append(ch).append(line.charAt(index));   //possibility not found, capture both characters\\n                } else if(multiComment && ch == \\'*\\') {   //possibility of end of multi comment\\n                    index++;                            //check two characters together\\n                    if(index >= n)\\n                        continue;\\n                    \\n                     if(line.charAt(index) == \\'/\\')\\n                         multiComment=false;\\n                    else\\n                        index--;          //possibility not found, revert index\\n                } else if(!multiComment)      //at last if multi comment is not on, append this char\\n                    sb.append(ch);\\n                \\n                index++;\\n            }\\n            \\n            if(sb.length() > 0 && !multiComment) {  //if multi comment is not on, capture the result\\n                result.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean multiComment=false;\\n        \\n        for(String line:source) {\\n            int n=line.length();\\n            int index=0;\\n            \\n            while(index < n) {\\n                char ch = line.charAt(index);\\n                if(!multiComment && ch == \\'/\\') {   //possibility of starting of single/multi comment\\n                    index++;                       //check two characters together\\n                    if(index >= n) {\\n                        sb.append(ch);\\n                        continue;\\n                    }\\n                    if(line.charAt(index) == \\'/\\') \\n                        break;\\n                    else if(line.charAt(index) == \\'*\\')\\n                        multiComment=true;\\n                    else\\n                        sb.append(ch).append(line.charAt(index));   //possibility not found, capture both characters\\n                } else if(multiComment && ch == \\'*\\') {   //possibility of end of multi comment\\n                    index++;                            //check two characters together\\n                    if(index >= n)\\n                        continue;\\n                    \\n                     if(line.charAt(index) == \\'/\\')\\n                         multiComment=false;\\n                    else\\n                        index--;          //possibility not found, revert index\\n                } else if(!multiComment)      //at last if multi comment is not on, append this char\\n                    sb.append(ch);\\n                \\n                index++;\\n            }\\n            \\n            if(sb.length() > 0 && !multiComment) {  //if multi comment is not on, capture the result\\n                result.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521849,
                "title": "state-machine-based-solution",
                "content": "I know find and matching seems most strightforward to everyone,\\nbut once get used to state machine approach, then it\\'s more easier to rely on it\\n\\n![image](https://assets.leetcode.com/users/images/bee2f8a0-c6e8-4a23-80ff-459c2b780770_1634268919.2614245.jpeg)\\n\\nWe consume each character one by one fashion, only append each character when we\\'re in state 0 otherwise ignore it entierly\\n\\nTime complexity : O(N), Space complexity : O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        string line;\\n        int state = 0;\\n        \\n        for (auto& s : source) {\\n            int idx = 0;\\n            while (idx <= s.size()) {\\n                if (idx == s.size()) {\\n                    if (state == 2 || state == 1) \\n                        state = 0;\\n                    \\n                    if (state == 0) \\n                        append(res, line);\\n                    \\n                    break;\\n                }\\n                \\n                const char ch = s[idx++];\\n                \\n                if (state == 0) {\\n                    line += ch;\\n                    if (ch == \\'/\\') {\\n                        state = 1;\\n                    }\\n                } else if (state == 1) {\\n                    if (ch == \\'/\\') {\\n                        state = 2;\\n                        line.pop_back();\\n                    } else if (ch == \\'*\\') {\\n                        state = 3;\\n                        line.pop_back();\\n                    } else {\\n                        line += ch;\\n                        state = 0;\\n                    }\\n                } else if (state == 3) {\\n                    if (ch == \\'*\\') {\\n                        state = 4;\\n                    }\\n                } else if (state == 4) {\\n                    if (ch == \\'/\\') {\\n                        state = 0;\\n                    } else if (ch != \\'*\\') {\\n                        state = 3;\\n                    }\\n                }  // If\\n            }  // While\\n            \\n            if (state == 0)\\n                line.clear();\\n        }  // For\\n        \\n        return res;\\n    }\\n    \\n    void append(vector<string>& res, string& line) {\\n        if (not line.empty()) {\\n            res.emplace_back(line);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        string line;\\n        int state = 0;\\n        \\n        for (auto& s : source) {\\n            int idx = 0;\\n            while (idx <= s.size()) {\\n                if (idx == s.size()) {\\n                    if (state == 2 || state == 1) \\n                        state = 0;\\n                    \\n                    if (state == 0) \\n                        append(res, line);\\n                    \\n                    break;\\n                }\\n                \\n                const char ch = s[idx++];\\n                \\n                if (state == 0) {\\n                    line += ch;\\n                    if (ch == \\'/\\') {\\n                        state = 1;\\n                    }\\n                } else if (state == 1) {\\n                    if (ch == \\'/\\') {\\n                        state = 2;\\n                        line.pop_back();\\n                    } else if (ch == \\'*\\') {\\n                        state = 3;\\n                        line.pop_back();\\n                    } else {\\n                        line += ch;\\n                        state = 0;\\n                    }\\n                } else if (state == 3) {\\n                    if (ch == \\'*\\') {\\n                        state = 4;\\n                    }\\n                } else if (state == 4) {\\n                    if (ch == \\'/\\') {\\n                        state = 0;\\n                    } else if (ch != \\'*\\') {\\n                        state = 3;\\n                    }\\n                }  // If\\n            }  // While\\n            \\n            if (state == 0)\\n                line.clear();\\n        }  // For\\n        \\n        return res;\\n    }\\n    \\n    void append(vector<string>& res, string& line) {\\n        if (not line.empty()) {\\n            res.emplace_back(line);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354457,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        \\n        string s = \"\";\\n\\t\\t// converted the whole vector of string into a single string\\n        for(int i = 0; i < source.size(); i++)\\n        {\\n            for(int j = 0; j < source[i].length(); j++)\\n            {\\n                s += source[i][j];\\n            }\\n\\t\\t\\t// $ will denote that the line is completed\\n            s += \"$\";\\n        }\\n        \\n\\t\\t// vector of string which will store the final answer\\n        vector<string> ans;\\n\\t\\t\\n\\t\\t// auxiliary string to store the values in the \"ans\" string\\n        string x = \"\";\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n\\t\\t\\t// if we reach $ this denotes that the line is completed and we need to store some string the vector of strings\\n            if(s[i] == \\'$\\')\\n            {\\n\\t\\t\\t\\t// before adding the string we just need to check whether the string is empty or not\\n                if(x != \"\")\\n                ans.push_back(x);\\n\\t\\t\\t\\t// again change the string back to empty to store other results\\n                x = \"\";\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// when we emcounter \\'/\\' character then we may get \"//\" or \"/*\" \\n            if(s[i] == \\'/\\')\\n            {\\n\\t\\t\\t\\t// condition when we get \"//\"\\n                if(s[i + 1] == \\'/\\')\\n                {\\n\\t\\t\\t\\t\\t// found will contain the first appearance of \\'$\\'  from the current  \"//\"\\n                    size_t found = s.find(\"$\", i + 2);\\n\\t\\t\\t\\t\\t// we changed i in the below way because we need to store the elements appeared before \"//\" in the particular line.\\n\\t\\t\\t\\t\\t// for ex : \"ab// cdefe\" so here we need to store \"ab\" and ignore the rest line.\\n                    i = found - 1;\\n                }\\n                else if(s[i + 1] == \\'*\\')\\n                {\\n\\t\\t\\t\\t\\t// found will contain the first appearance of \\'*\\'  from the current  \"/*\"\\n                    size_t found = s.find(\"*/\", i + 2);\\n\\t\\t\\t\\t\\t// found + 1 for \\'/\\' character.\\n                    i = found + 1;\\n                }\\n\\t\\t\\t\\t// we need to include on more else because there may be possibility of string like \"a/b\"\\n\\t\\t\\t\\telse\\n                {\\n                    if(s[i] != \\'$\\')\\n                    x += s[i];\\n                }\\n            }else \\n            {\\n                if(s[i] != \\'$\\')\\n                x += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        \\n        string s = \"\";\\n\\t\\t// converted the whole vector of string into a single string\\n        for(int i = 0; i < source.size(); i++)\\n        {\\n            for(int j = 0; j < source[i].length(); j++)\\n            {\\n                s += source[i][j];\\n            }\\n\\t\\t\\t// $ will denote that the line is completed\\n            s += \"$\";\\n        }\\n        \\n\\t\\t// vector of string which will store the final answer\\n        vector<string> ans;\\n\\t\\t\\n\\t\\t// auxiliary string to store the values in the \"ans\" string\\n        string x = \"\";\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n\\t\\t\\t// if we reach $ this denotes that the line is completed and we need to store some string the vector of strings\\n            if(s[i] == \\'$\\')\\n            {\\n\\t\\t\\t\\t// before adding the string we just need to check whether the string is empty or not\\n                if(x != \"\")\\n                ans.push_back(x);\\n\\t\\t\\t\\t// again change the string back to empty to store other results\\n                x = \"\";\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// when we emcounter \\'/\\' character then we may get \"//\" or \"/*\" \\n            if(s[i] == \\'/\\')\\n            {\\n\\t\\t\\t\\t// condition when we get \"//\"\\n                if(s[i + 1] == \\'/\\')\\n                {\\n\\t\\t\\t\\t\\t// found will contain the first appearance of \\'$\\'  from the current  \"//\"\\n                    size_t found = s.find(\"$\", i + 2);\\n\\t\\t\\t\\t\\t// we changed i in the below way because we need to store the elements appeared before \"//\" in the particular line.\\n\\t\\t\\t\\t\\t// for ex : \"ab// cdefe\" so here we need to store \"ab\" and ignore the rest line.\\n                    i = found - 1;\\n                }\\n                else if(s[i + 1] == \\'*\\')\\n                {\\n\\t\\t\\t\\t\\t// found will contain the first appearance of \\'*\\'  from the current  \"/*\"\\n                    size_t found = s.find(\"*/\", i + 2);\\n\\t\\t\\t\\t\\t// found + 1 for \\'/\\' character.\\n                    i = found + 1;\\n                }\\n\\t\\t\\t\\t// we need to include on more else because there may be possibility of string like \"a/b\"\\n\\t\\t\\t\\telse\\n                {\\n                    if(s[i] != \\'$\\')\\n                    x += s[i];\\n                }\\n            }else \\n            {\\n                if(s[i] != \\'$\\')\\n                x += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212938,
                "title": "java-simple-answer",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        \\n        boolean multiLineComment = false;\\n        StringBuilder sb = new StringBuilder();\\n        for(String line : source)\\n        {\\n            char[] ch = line.toCharArray();\\n            \\n            for(int i = 0; i < ch.length; i++)\\n            {\\n                // Single line Comment Scenario\\n                if(!multiLineComment && ch[i] == \\'/\\'\\n                   && i+1 < ch.length && ch[i+1] == \\'/\\')\\n                {\\n                    break;\\n                } \\n                // Start of Multi line Comment \\n                else if( !multiLineComment && ch[i] == \\'/\\' \\n                         &&  i+1 < ch.length && ch[i+1] == \\'*\\')\\n                {\\n                    multiLineComment = true;\\n                    i++;\\n                }\\n                //End of multi line comment \\n                else  if( multiLineComment && ch[i] == \\'*\\' \\n                          &&  i+1 < ch.length && ch[i+1] == \\'/\\')\\n                {\\n                    multiLineComment = false;\\n                    i++;\\n                } \\n                // if multiline comment flag is true, cannot append \\n                else if(!multiLineComment)\\n                {\\n                    sb.append(ch[i]);  \\n                }\\n            }\\n            // At the end of each line of code check if multi line comment is false, we can add \\n            if(!multiLineComment && sb.length() != 0)\\n            { \\n                result.add(sb.toString()); \\n                sb = new StringBuilder();\\n            }\\n                \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList<>();\\n        \\n        boolean multiLineComment = false;\\n        StringBuilder sb = new StringBuilder();\\n        for(String line : source)\\n        {\\n            char[] ch = line.toCharArray();\\n            \\n            for(int i = 0; i < ch.length; i++)\\n            {\\n                // Single line Comment Scenario\\n                if(!multiLineComment && ch[i] == \\'/\\'\\n                   && i+1 < ch.length && ch[i+1] == \\'/\\')\\n                {\\n                    break;\\n                } \\n                // Start of Multi line Comment \\n                else if( !multiLineComment && ch[i] == \\'/\\' \\n                         &&  i+1 < ch.length && ch[i+1] == \\'*\\')\\n                {\\n                    multiLineComment = true;\\n                    i++;\\n                }\\n                //End of multi line comment \\n                else  if( multiLineComment && ch[i] == \\'*\\' \\n                          &&  i+1 < ch.length && ch[i+1] == \\'/\\')\\n                {\\n                    multiLineComment = false;\\n                    i++;\\n                } \\n                // if multiline comment flag is true, cannot append \\n                else if(!multiLineComment)\\n                {\\n                    sb.append(ch[i]);  \\n                }\\n            }\\n            // At the end of each line of code check if multi line comment is false, we can add \\n            if(!multiLineComment && sb.length() != 0)\\n            { \\n                result.add(sb.toString()); \\n                sb = new StringBuilder();\\n            }\\n                \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057235,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis problem is somewhat tedious to solve, but nonetheless it does teach us how we can parse characters.\\nBasically while parsing, keep a lookout for the `/*`, `*/`, and `//` character pairs. If we find them, we have to alter our parsing state somehow.\\nOtherwise we are free to copy over the character to our result.\\n\\n### Solution\\n```\\n    public List<String> removeComments(String[] source) {\\n        List<String> code = new ArrayList<>();\\n        boolean commentBlock = false;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String line : source) {\\n            int i = 0;\\n            char[] codeLine = line.toCharArray();\\n            if (!commentBlock) sb = new StringBuilder();\\n            while (i < codeLine.length) {\\n                if (!commentBlock && i+1 < codeLine.length && codeLine[i] == \\'/\\' && codeLine[i+1] == \\'*\\') {\\n                    commentBlock = true;\\n                    i+=2;\\n                } \\n                else if (commentBlock && i+1 < codeLine.length && codeLine[i] == \\'*\\' && codeLine[i+1] == \\'/\\') {\\n                    commentBlock = false;\\n                    i+=2;\\n                }\\n                else if (!commentBlock && i+1 < codeLine.length && codeLine[i] == \\'/\\' && codeLine[i+1] == \\'/\\') {\\n                    break;\\n                }\\n                else if (!commentBlock) {\\n                    sb.append(codeLine[i]);\\n                    i++;\\n                } \\n                else {\\n                    i++;\\n                } \\n            }\\n            \\n            if (!commentBlock && sb.length() > 0)\\n                code.add(sb.toString());\\n        }\\n        \\n        return code;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> removeComments(String[] source) {\\n        List<String> code = new ArrayList<>();\\n        boolean commentBlock = false;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String line : source) {\\n            int i = 0;\\n            char[] codeLine = line.toCharArray();\\n            if (!commentBlock) sb = new StringBuilder();\\n            while (i < codeLine.length) {\\n                if (!commentBlock && i+1 < codeLine.length && codeLine[i] == \\'/\\' && codeLine[i+1] == \\'*\\') {\\n                    commentBlock = true;\\n                    i+=2;\\n                } \\n                else if (commentBlock && i+1 < codeLine.length && codeLine[i] == \\'*\\' && codeLine[i+1] == \\'/\\') {\\n                    commentBlock = false;\\n                    i+=2;\\n                }\\n                else if (!commentBlock && i+1 < codeLine.length && codeLine[i] == \\'/\\' && codeLine[i+1] == \\'/\\') {\\n                    break;\\n                }\\n                else if (!commentBlock) {\\n                    sb.append(codeLine[i]);\\n                    i++;\\n                } \\n                else {\\n                    i++;\\n                } \\n            }\\n            \\n            if (!commentBlock && sb.length() > 0)\\n                code.add(sb.toString());\\n        }\\n        \\n        return code;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 977618,
                "title": "javascript-statemachine",
                "content": "```\\n/**\\n * @param {string[]} source\\n * @return {string[]}\\n */\\nvar removeComments = function (source) {\\n  let states = {\\n    inital: 0,\\n    slash: 1,\\n    oneline: 2,\\n    multiline: 3,\\n    multilineend: 4\\n  }, rtn = [], state = states.inital\\n\\n  let code = \\'\\'\\n  for (let line of source) {\\n    if (state != states.multiline) code = \\'\\'\\n    charloop:\\n    for (let char of line) {\\n      // if (code == \\'   k = k/2\\') debugger\\n      let append = true\\n      switch (state) {\\n        case states.inital:\\n          if (char == \\'/\\') {\\n            state = states.slash\\n            append = false\\n          }\\n          break\\n        case states.slash:\\n          if (char == \\'/\\') {\\n            // state = states.oneline\\n            state = states.inital\\n            // rtn.push(code)\\n            break charloop\\n          } else if (char == \\'*\\') {\\n            state = states.multiline\\n            append = false\\n          } else {\\n            state = states.inital\\n            code += \\'/\\'\\n          }\\n          break\\n        // case states.oneline:\\n        //   append = false\\n        //   break\\n        case states.multiline:\\n          append = false\\n          if (char == \\'*\\') state = states.multilineend\\n          break\\n        case states.multilineend:\\n          append = false\\n          if (char == \\'*\\') state = states.multilineend\\n          else if (char == \\'/\\') state = states.inital\\n          else state = states.multiline\\n          break\\n      }\\n      if (append) code += char\\n\\n    }\\n    if (state == states.slash) {\\n      state = states.inital\\n      code += \\'/\\'\\n    }\\n    if (state == states.multilineend) state = states.multiline\\n    if (state != states.multiline) rtn.push(code)\\n  }\\n  return rtn.filter(x => x.length)\\n};\\n\\n// console.log(removeComments(\\n//   [\"void func(int k) {\", \"// this function does nothing /*\", \"   k = k*2/4;\", \"   k = k/2;*/\", \"}\"]\\n\\n// ).join(\\'\\\\n\\'))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} source\\n * @return {string[]}\\n */\\nvar removeComments = function (source) {\\n  let states = {\\n    inital: 0,\\n    slash: 1,\\n    oneline: 2,\\n    multiline: 3,\\n    multilineend: 4\\n  }, rtn = [], state = states.inital\\n\\n  let code = \\'\\'\\n  for (let line of source) {\\n    if (state != states.multiline) code = \\'\\'\\n    charloop:\\n    for (let char of line) {\\n      // if (code == \\'   k = k/2\\') debugger\\n      let append = true\\n      switch (state) {\\n        case states.inital:\\n          if (char == \\'/\\') {\\n            state = states.slash\\n            append = false\\n          }\\n          break\\n        case states.slash:\\n          if (char == \\'/\\') {\\n            // state = states.oneline\\n            state = states.inital\\n            // rtn.push(code)\\n            break charloop\\n          } else if (char == \\'*\\') {\\n            state = states.multiline\\n            append = false\\n          } else {\\n            state = states.inital\\n            code += \\'/\\'\\n          }\\n          break\\n        // case states.oneline:\\n        //   append = false\\n        //   break\\n        case states.multiline:\\n          append = false\\n          if (char == \\'*\\') state = states.multilineend\\n          break\\n        case states.multilineend:\\n          append = false\\n          if (char == \\'*\\') state = states.multilineend\\n          else if (char == \\'/\\') state = states.inital\\n          else state = states.multiline\\n          break\\n      }\\n      if (append) code += char\\n\\n    }\\n    if (state == states.slash) {\\n      state = states.inital\\n      code += \\'/\\'\\n    }\\n    if (state == states.multilineend) state = states.multiline\\n    if (state != states.multiline) rtn.push(code)\\n  }\\n  return rtn.filter(x => x.length)\\n};\\n\\n// console.log(removeComments(\\n//   [\"void func(int k) {\", \"// this function does nothing /*\", \"   k = k*2/4;\", \"   k = k/2;*/\", \"}\"]\\n\\n// ).join(\\'\\\\n\\'))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925266,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        res = []\\n        in_block = False\\n        line = []\\n        for s in source:\\n            i = 0\\n            while i < len(s):\\n                if not in_block:\\n                    if s[i:i+2] != \\'//\\' and s[i:i+2] != \\'/*\\':\\n                        line.append(s[i])\\n                                       \\n                    elif s[i:i+2] == \\'//\\':\\n                        break\\n                    \\n                    elif s[i:i+2] == \\'/*\\':\\n                        i += 1\\n                        in_block = True\\n                else:\\n                    if s[i:i+2] == \\'*/\\':\\n                        i += 1\\n                        in_block = False\\n                i += 1\\n            print(line, in_block)\\n            if not in_block:\\n                line = \\'\\'.join(line)\\n                if line != \\'\\':\\n                    res.append(line)\\n                line = []\\n            \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        res = []\\n        in_block = False\\n        line = []\\n        for s in source:\\n            i = 0\\n            while i < len(s):\\n                if not in_block:\\n                    if s[i:i+2] != \\'//\\' and s[i:i+2] != \\'/*\\':\\n                        line.append(s[i])\\n                                       \\n                    elif s[i:i+2] == \\'//\\':\\n                        break\\n                    \\n                    elif s[i:i+2] == \\'/*\\':\\n                        i += 1\\n                        in_block = True\\n                else:\\n                    if s[i:i+2] == \\'*/\\':\\n                        i += 1\\n                        in_block = False\\n                i += 1\\n            print(line, in_block)\\n            if not in_block:\\n                line = \\'\\'.join(line)\\n                if line != \\'\\':\\n                    res.append(line)\\n                line = []\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905276,
                "title": "c-very-short-solution-o-s-size-beats-100-time-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool multiLineStarted = false;\\n        string tstr;\\n        for(auto s : source){\\n            if(!multiLineStarted) tstr = \"\";\\n            for(int i=0;i<s.size(); ++i){\\n                if(!multiLineStarted && s[i] == \\'/\\' && i < s.size() - 1 && s[i+1]==\\'/\\'){break;}\\n                else if(!multiLineStarted && s[i] == \\'/\\' && i < s.size() - 1 && s[i+1] == \\'*\\'){ multiLineStarted = true; i++;continue;}\\n                else if( multiLineStarted && s[i] == \\'*\\' && i < s.size() - 1 && s[i+1] == \\'/\\'){multiLineStarted = false; i++;}\\n                else if(!multiLineStarted && i < s.size())\\n                    tstr += s[i];\\n            }\\n            if(!multiLineStarted && tstr.size() > 0)\\n                ans.push_back(tstr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool multiLineStarted = false;\\n        string tstr;\\n        for(auto s : source){\\n            if(!multiLineStarted) tstr = \"\";\\n            for(int i=0;i<s.size(); ++i){\\n                if(!multiLineStarted && s[i] == \\'/\\' && i < s.size() - 1 && s[i+1]==\\'/\\'){break;}\\n                else if(!multiLineStarted && s[i] == \\'/\\' && i < s.size() - 1 && s[i+1] == \\'*\\'){ multiLineStarted = true; i++;continue;}\\n                else if( multiLineStarted && s[i] == \\'*\\' && i < s.size() - 1 && s[i+1] == \\'/\\'){multiLineStarted = false; i++;}\\n                else if(!multiLineStarted && i < s.size())\\n                    tstr += s[i];\\n            }\\n            if(!multiLineStarted && tstr.size() > 0)\\n                ans.push_back(tstr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830385,
                "title": "google-interview-modified-find-a-word-in-comments",
                "content": "Question:\\nGiven valid C++ source code as input find the word \"google\" in the code comments.\\n\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        op = []\\n        in_block = False\\n        count = 0\\n        \\n        for line in source:\\n            i = 0\\n            if not in_block:\\n                newline = \\'\\'\\n            while i < len(line):\\n                if not in_block and line[i:i+2]==\\'/*\\':\\n                    in_block=True\\n                    i+=1\\n                elif in_block and line[i:i+2]==\\'*/\\':\\n                    in_block=False\\n                    i+=1\\n                elif not in_block and line[i:i+2]==\\'//\\':\\n                    newline+=line[i+2:]\\n                    break\\n                elif in_block:\\n                    newline+=line[i]\\n                i+=1\\n            if not in_block:\\n                count+=newline.count(\\'google\\')\\n        return count\\n```\\n\\ntrying running this \\n```\\nsource = [\"a/*comment\", \"google\", \"more_ sdf google comment*/b\", \"{ \", \"  // variable declaration google \", \"int a, b, google c;\"]\\nc = Solution()\\nprint(c.removeComments(source))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        op = []\\n        in_block = False\\n        count = 0\\n        \\n        for line in source:\\n            i = 0\\n            if not in_block:\\n                newline = \\'\\'\\n            while i < len(line):\\n                if not in_block and line[i:i+2]==\\'/*\\':\\n                    in_block=True\\n                    i+=1\\n                elif in_block and line[i:i+2]==\\'*/\\':\\n                    in_block=False\\n                    i+=1\\n                elif not in_block and line[i:i+2]==\\'//\\':\\n                    newline+=line[i+2:]\\n                    break\\n                elif in_block:\\n                    newline+=line[i]\\n                i+=1\\n            if not in_block:\\n                count+=newline.count(\\'google\\')\\n        return count\\n```\n```\\nsource = [\"a/*comment\", \"google\", \"more_ sdf google comment*/b\", \"{ \", \"  // variable declaration google \", \"int a, b, google c;\"]\\nc = Solution()\\nprint(c.removeComments(source))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726147,
                "title": "ruby-regex-soluiton",
                "content": "```ruby\\ndef remove_comments(source)\\n  source.join(\"\\\\n\").\\n    gsub(/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/|\\\\/\\\\/.*$/, \\'\\').\\n    split(\"\\\\n\").\\n    select { |item| !item.empty? }\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef remove_comments(source)\\n  source.join(\"\\\\n\").\\n    gsub(/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/|\\\\/\\\\/.*$/, \\'\\').\\n    split(\"\\\\n\").\\n    select { |item| !item.empty? }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 580375,
                "title": "java-concise-solution-and-a-follow-up-from-gg-interview",
                "content": "Straighforward and concise solution.\\n```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        \\n        // 1. //  2, /* */\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean blockCommentOpen = false;\\n        \\n        for(String line : source) {\\n            \\n            int i = 0;\\n            while(i < line.length()) {\\n                \\n                if(blockCommentOpen) {\\n                    while(i + 1 < line.length() && (line.charAt(i) != \\'*\\' || line.charAt(i + 1) != \\'/\\')) i++;\\n                    if(i + 1 < line.length()) blockCommentOpen = false;\\n                    i = i + 2;\\n                } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i + 1) == \\'/\\') {\\n                    break;\\n                } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt((i + 1)) == \\'*\\') {\\n                    i = i + 2;\\n                    blockCommentOpen = true;\\n                } else {\\n                    sb.append(line.charAt(i++));\\n                }\\n            }\\n            \\n            if(sb.length() > 0 && !blockCommentOpen) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nAfter that, there is a follow up question from GG interview: rather than delete all comments, only delete \"Google\" from comments and return all remaining string including other comments. Implementation is not required, just talk about idea.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        \\n        // 1. //  2, /* */\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean blockCommentOpen = false;\\n        \\n        for(String line : source) {\\n            \\n            int i = 0;\\n            while(i < line.length()) {\\n                \\n                if(blockCommentOpen) {\\n                    while(i + 1 < line.length() && (line.charAt(i) != \\'*\\' || line.charAt(i + 1) != \\'/\\')) i++;\\n                    if(i + 1 < line.length()) blockCommentOpen = false;\\n                    i = i + 2;\\n                } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i + 1) == \\'/\\') {\\n                    break;\\n                } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt((i + 1)) == \\'*\\') {\\n                    i = i + 2;\\n                    blockCommentOpen = true;\\n                } else {\\n                    sb.append(line.charAt(i++));\\n                }\\n            }\\n            \\n            if(sb.length() > 0 && !blockCommentOpen) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539937,
                "title": "simple-java",
                "content": "```\\npublic List<String> removeComments(String[] source) {\\n        boolean block = false;\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : source) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (block) {\\n                    if (str.charAt(i) == \\'*\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'/\\' ) {\\n                        block = false;\\n                        i++;\\n                    }\\n                } else {\\n                    if (str.charAt(i) == \\'/\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'*\\' ) {\\n                        block = true;\\n                        i++;\\n                    } else if (str.charAt(i) == \\'/\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'/\\' ) {\\n                        break;\\n                    } else sb.append(str.charAt(i));\\n                }\\n            }\\n            if (!block && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n        }\\n        return res;\\n    }\\n```\\nRef:\\nhttps://leetcode.com/problems/remove-comments/discuss/109197/One-pass-solution-in-Java",
                "solutionTags": [],
                "code": "```\\npublic List<String> removeComments(String[] source) {\\n        boolean block = false;\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : source) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (block) {\\n                    if (str.charAt(i) == \\'*\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'/\\' ) {\\n                        block = false;\\n                        i++;\\n                    }\\n                } else {\\n                    if (str.charAt(i) == \\'/\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'*\\' ) {\\n                        block = true;\\n                        i++;\\n                    } else if (str.charAt(i) == \\'/\\' && i + 1 < str.length() && str.charAt(i + 1) == \\'/\\' ) {\\n                        break;\\n                    } else sb.append(str.charAt(i));\\n                }\\n            }\\n            if (!block && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 527443,
                "title": "c-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) \\n    {\\n        vector<string> result;\\n        bool comment = false; // for multiline comments\\n        string curr = \"\";\\n        for(auto V : source)\\n        {\\n            for(int i = 0; i < V.size(); ++i)\\n            {\\n                if(comment)\\n                {\\n                    if(i < V.size() - 1 and V[i] == \\'*\\' and V[i + 1] == \\'/\\')\\n                    {\\n                        comment = false;\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n                if(i < V.size() - 1 and V[i] == \\'/\\' and V[i + 1] == \\'/\\')\\n                    break;\\n                if(i < V.size() - 1 and V[i] == \\'/\\' and V[i + 1] == \\'*\\')\\n                {\\n                    ++i;\\n                    comment = true;\\n                    continue;\\n                }\\n                curr += V[i];\\n            }\\n            if(!curr.empty() and !comment)\\n            {\\n                result.push_back(curr);\\n                curr = \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) \\n    {\\n        vector<string> result;\\n        bool comment = false; // for multiline comments\\n        string curr = \"\";\\n        for(auto V : source)\\n        {\\n            for(int i = 0; i < V.size(); ++i)\\n            {\\n                if(comment)\\n                {\\n                    if(i < V.size() - 1 and V[i] == \\'*\\' and V[i + 1] == \\'/\\')\\n                    {\\n                        comment = false;\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n                if(i < V.size() - 1 and V[i] == \\'/\\' and V[i + 1] == \\'/\\')\\n                    break;\\n                if(i < V.size() - 1 and V[i] == \\'/\\' and V[i + 1] == \\'*\\')\\n                {\\n                    ++i;\\n                    comment = true;\\n                    continue;\\n                }\\n                curr += V[i];\\n            }\\n            if(!curr.empty() and !comment)\\n            {\\n                result.push_back(curr);\\n                curr = \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519173,
                "title": "java-easy-to-read-understand-fast-solution",
                "content": "Full explanation: https://medium.com/@hch.hkcontact/goldman-sachs-top-50-leetcode-questions-q5-remove-comments-879a91a482e2\\n\\nSteps:\\nIterate each line from the input document.\\nInside the line, iterate each character of this line, check below conditions one by one\\n1. if in scope & meet \\u201C/*\\u201D: you are not in scope from now\\n2. if in scope & meet \\u201C//\\u201D: add the string to list\\n3. if in scope: add character to the string, then if it is the end of the line, add the string to list\\n4. if NOT in scope & meet \\u201C*/\\u201D: you are in scope again, then if it is last 2 characters of line, add the string to list\\n\\nSummary:\\n1. If in scope, you have to beware if signs of \\u201C/*\\u201D or \\u201C//\\u201D first. Otherwise, you can collect the characters.\\n2. If not in scope, you have to beware if signs of \\u201C*/\\u201D to get you back to scope\\nJava Code Example:\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    private void addStToList(List<String> rl , StringBuilder sb){\\n        if(sb.length()>0){\\n            rl.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n    }\\n\\n    public List<String> removeComments(String[] source) {\\n        List<String> rl = new ArrayList<>();\\n\\n        boolean inScope = true;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String line : source) {\\n            char[] ar = line.toCharArray();\\n            int m = ar.length;\\n            int i = 0;\\n            while (i < m) {\\n                // System.out.println(\"char=\"+ar[i]);\\n                if(inScope&&(i +1<m)&&(\"/*\".equals(line.substring(i, i + 2)))){\\n                    inScope=false;\\n                    i+=2;\\n                }else if(inScope&&(i +1<m)&&(\"//\".equals(line.substring(i, i + 2)))){\\n                    addStToList(rl, sb);\\n                    break;\\n                }else if(inScope){\\n                    sb.append(ar[i]);\\n                    if(i==m-1) addStToList(rl, sb);\\n                    i++;\\n                }else if(!inScope&& (i +1<m) && (\"*/\".equals(line.substring(i, i + 2))) ){\\n                    inScope=true;\\n                    if(i==m-2) addStToList(rl, sb);\\n                    i+=2;\\n                }else{\\n                    i++;\\n                }\\n                \\n            }\\n\\n        }\\n\\n\\n        return rl;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    private void addStToList(List<String> rl , StringBuilder sb){\\n        if(sb.length()>0){\\n            rl.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n    }\\n\\n    public List<String> removeComments(String[] source) {\\n        List<String> rl = new ArrayList<>();\\n\\n        boolean inScope = true;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String line : source) {\\n            char[] ar = line.toCharArray();\\n            int m = ar.length;\\n            int i = 0;\\n            while (i < m) {\\n                // System.out.println(\"char=\"+ar[i]);\\n                if(inScope&&(i +1<m)&&(\"/*\".equals(line.substring(i, i + 2)))){\\n                    inScope=false;\\n                    i+=2;\\n                }else if(inScope&&(i +1<m)&&(\"//\".equals(line.substring(i, i + 2)))){\\n                    addStToList(rl, sb);\\n                    break;\\n                }else if(inScope){\\n                    sb.append(ar[i]);\\n                    if(i==m-1) addStToList(rl, sb);\\n                    i++;\\n                }else if(!inScope&& (i +1<m) && (\"*/\".equals(line.substring(i, i + 2))) ){\\n                    inScope=true;\\n                    if(i==m-2) addStToList(rl, sb);\\n                    i+=2;\\n                }else{\\n                    i++;\\n                }\\n                \\n            }\\n\\n        }\\n\\n\\n        return rl;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323278,
                "title": "clean-and-readable-python-solution-using-2-state-fsm",
                "content": "```\\nSTATE_NORMAL = 1\\nSTATE_MLCOMMENT = 2\\n\\n\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        out = []\\n        state = STATE_NORMAL\\n        \\n        outline = \\'\\'\\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if state == STATE_NORMAL:\\n                    if line[i:i+2] == \\'//\\':\\n                        break\\n                    elif line[i:i+2] == \\'/*\\':\\n                        state = STATE_MLCOMMENT\\n                        i += 2\\n                    else:\\n                        outline += line[i]\\n                        i += 1\\n                elif state == STATE_MLCOMMENT:\\n                    if line[i:i+2] == \\'*/\\':\\n                        state = STATE_NORMAL\\n                        i += 2\\n                    else:\\n                        i += 1\\n                        \\n            if state == STATE_MLCOMMENT:\\n                pass\\n            else:\\n                if outline:\\n                    out.append(outline)\\n                    outline = \\'\\'\\n                                \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nSTATE_NORMAL = 1\\nSTATE_MLCOMMENT = 2\\n\\n\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        out = []\\n        state = STATE_NORMAL\\n        \\n        outline = \\'\\'\\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if state == STATE_NORMAL:\\n                    if line[i:i+2] == \\'//\\':\\n                        break\\n                    elif line[i:i+2] == \\'/*\\':\\n                        state = STATE_MLCOMMENT\\n                        i += 2\\n                    else:\\n                        outline += line[i]\\n                        i += 1\\n                elif state == STATE_MLCOMMENT:\\n                    if line[i:i+2] == \\'*/\\':\\n                        state = STATE_NORMAL\\n                        i += 2\\n                    else:\\n                        i += 1\\n                        \\n            if state == STATE_MLCOMMENT:\\n                pass\\n            else:\\n                if outline:\\n                    out.append(outline)\\n                    outline = \\'\\'\\n                                \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281719,
                "title": "state-machine-c-100",
                "content": "States:\\n\\nQ0 = Not in comment\\nQ1 = Comment start look-ahead\\nQ2 = In Block-Comment\\nQ3 = In Line-Comment\\nQ4 = Block-Comment end look-ahead\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> removeComments(const vector<string>& source) {\\n      vector<string> ret;\\n      int state = 0;\\n      string buf;\\n      \\n      for (const string& code : source) {\\n        for (int i = 0; i < code.size(); i++) {\\n          switch (state) {\\n            case 0:\\n              if (code[i] == \\'/\\' && i != code.size() - 1) {\\n                state = 1;\\n              } else {\\n                buf += code[i];\\n              }\\n              break;\\n            case 1:\\n              if (code[i] == \\'*\\') {\\n                state = 2;\\n              } else if (code[i] == \\'/\\') {\\n                state = 3;\\n              } else {\\n                state = 0;\\n                buf += \\'/\\';\\n                buf += code[i];\\n              }\\n              break;\\n            case 2:\\n              if (code[i] == \\'*\\') state = 4;\\n              break;\\n            case 3:\\n              if (i == code.size() - 1) state = 0;\\n              break;\\n            case 4:\\n              if (code[i] == \\'/\\') state = 0;\\n              else if (code[i] != \\'*\\') state = 2;\\n              break;\\n          }\\n        }\\n\\n        if (buf.size() > 0 && state == 0) {\\n          ret.push_back(buf);\\n          buf = \"\";\\n        }\\n      }\\n      \\n      return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> removeComments(const vector<string>& source) {\\n      vector<string> ret;\\n      int state = 0;\\n      string buf;\\n      \\n      for (const string& code : source) {\\n        for (int i = 0; i < code.size(); i++) {\\n          switch (state) {\\n            case 0:\\n              if (code[i] == \\'/\\' && i != code.size() - 1) {\\n                state = 1;\\n              } else {\\n                buf += code[i];\\n              }\\n              break;\\n            case 1:\\n              if (code[i] == \\'*\\') {\\n                state = 2;\\n              } else if (code[i] == \\'/\\') {\\n                state = 3;\\n              } else {\\n                state = 0;\\n                buf += \\'/\\';\\n                buf += code[i];\\n              }\\n              break;\\n            case 2:\\n              if (code[i] == \\'*\\') state = 4;\\n              break;\\n            case 3:\\n              if (i == code.size() - 1) state = 0;\\n              break;\\n            case 4:\\n              if (code[i] == \\'/\\') state = 0;\\n              else if (code[i] != \\'*\\') state = 2;\\n              break;\\n          }\\n        }\\n\\n        if (buf.size() > 0 && state == 0) {\\n          ret.push_back(buf);\\n          buf = \"\";\\n        }\\n      }\\n      \\n      return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213807,
                "title": "c-solution-0ms-o-n-with-explanation",
                "content": "Here are the important notes:\\n\\u2022\\tif there is any single line comment the rest of current string should be ignored and we need to jump to next string (that is why we use break under this condition)\\n\\u2022\\tSingle line comment should be ignored if it is inside multi_line comment.\\n\\u2022\\tOpening the multi_line comment should be ignored if we have not already consumed the previously opened yet. In other words, in case of having something like \"/aaaaaaaaa//\" the second /* should not be considered as an open block for multi_line comment\\n\\u2022\\tIn case of having multi_line comment, starting in the middle of a string and ending in the middle of another string, these two strings should be concatenated to each other.\\n\\n\\n```\\n vector<string> removeComments(vector<string>& source) {\\n   int len = source.size();\\n   bool block = false;;\\n   vector<string> res;  \\n   string sol1;  \\n   \\n   for (auto s : source) { \\n      int it=0;\\n       if (!block)\\n          sol1=\"\"; \\n      \\n      while (it<s.length() ) {\\n            \\n          if (!block && line_comment(s, it) ) {                 \\n             break;           \\n          } else if (!block && block_comment_open(s,it)) {  \\n\\t\\t  /*!block Makes sure the previously open_mmulti_line is consumed before considering the new one*/                    \\n              block =true;\\n              it++;        /*we need to skip two characters at this point*/         \\n          } else if (block && it<s.length() && block_comment_close(s,it)) {                 \\n             block = false;\\n             it++;\\n          }  else {          \\n             if (!block && it<s.length())                    \\n                sol1= sol1 + s[it];\\n          }                              \\n          it++;\\n      }\\n      \\n       if (sol1!=\"\" && !block)\\n        res.push_back(sol1);\\n   }\\n     return res;\\n }\\n bool line_comment(string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'/\\' & s[idx+1]==\\'/\\') ;\\n}\\nbool block_comment_open (string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'/\\' & s[idx+1]==\\'*\\') ;\\n} \\nbool block_comment_close (string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'*\\' & s[idx+1]==\\'/\\') ;\\n} \\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> removeComments(vector<string>& source) {\\n   int len = source.size();\\n   bool block = false;;\\n   vector<string> res;  \\n   string sol1;  \\n   \\n   for (auto s : source) { \\n      int it=0;\\n       if (!block)\\n          sol1=\"\"; \\n      \\n      while (it<s.length() ) {\\n            \\n          if (!block && line_comment(s, it) ) {                 \\n             break;           \\n          } else if (!block && block_comment_open(s,it)) {  \\n\\t\\t  /*!block Makes sure the previously open_mmulti_line is consumed before considering the new one*/                    \\n              block =true;\\n              it++;        /*we need to skip two characters at this point*/         \\n          } else if (block && it<s.length() && block_comment_close(s,it)) {                 \\n             block = false;\\n             it++;\\n          }  else {          \\n             if (!block && it<s.length())                    \\n                sol1= sol1 + s[it];\\n          }                              \\n          it++;\\n      }\\n      \\n       if (sol1!=\"\" && !block)\\n        res.push_back(sol1);\\n   }\\n     return res;\\n }\\n bool line_comment(string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'/\\' & s[idx+1]==\\'/\\') ;\\n}\\nbool block_comment_open (string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'/\\' & s[idx+1]==\\'*\\') ;\\n} \\nbool block_comment_close (string s, int idx) {\\n    return (idx+1<s.length() && s[idx] ==\\'*\\' & s[idx+1]==\\'/\\') ;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210040,
                "title": "finite-state-machine",
                "content": "Easy to understand with test example ...\\n\\n```\\nint static fast = [](){\\n  ios::sync_with_stdio(false);\\n  cin.tie(0); cout.tie(0); return 0;\\n}();\\n\\ntemplate<typename T>\\nvoid print(vector<T>& v) {\\n  for(auto& vv: v) { cout << vv << \"\\\\n\"; }\\n  cout << endl;\\n}\\n\\nclass Solution {\\n  public:\\n    vector<string> removeComments(vector<string>& source) {\\n      vector<string> res;\\n\\n      string tmp;\\n      Type type = DEFAULT;\\n      for(auto& line: source) {\\n        int size = line.size();\\n        for(int i=0; i <= size; ++i) {\\n          char c = i==size ? \\'#\\' : line[i];\\n          switch(type) {\\n            case DEFAULT:\\n              switch(c) {\\n                case \\'/\\': type = FIRST_SLASH; break;\\n                case \\'#\\':\\n                          if(tmp.size()) {\\n                            res.emplace_back(tmp);\\n                            tmp.clear();\\n                          }\\n                          break;\\n                default: tmp.push_back(c); break;\\n              }\\n              break;\\n            case FIRST_SLASH:\\n              switch(c) {\\n                case \\'*\\': type = FIRST_START; break;\\n                case \\'/\\': type = SECOND_SLASH; break;\\n                default:\\n                          i -= 1;\\n                          tmp.push_back(\\'/\\');\\n                          type = DEFAULT; break;\\n              }\\n              break;\\n            case SECOND_SLASH:\\n              switch(c) {\\n                case \\'#\\': i -= 1; type = DEFAULT; break;\\n              }\\n              break;\\n            case FIRST_START:\\n              switch(c) {\\n                case \\'*\\': type = SECOND_START; break;\\n              }\\n              break;\\n            case SECOND_START:\\n              switch(c) {\\n                case \\'/\\': type = DEFAULT; break;\\n                case \\'*\\': type = SECOND_START; break;\\n                default: type = FIRST_START; break;\\n              }\\n              break;\\n          }\\n        }\\n      }\\n\\n      return res;\\n    }\\n\\n  private:\\n    enum Type {\\n      DEFAULT,\\n      FIRST_SLASH,\\n      SECOND_SLASH,\\n      FIRST_START,\\n      SECOND_START,\\n    };\\n};\\n\\nint main() {\\n  vector<string> source = {\\n    \"/*Test program */\",\\n    \"int main()\",\\n    \"{ \",\\n    \"  // variable declaration \",\\n    \"int a, b, c;\",\\n    \"/* This is a test\",\\n    \"   multiline  \",\\n    \"   comment for \",\\n    \"   testing */\",\\n    \"a = b + c;\",\\n    \"}\"\\n  };\\n  print(source);\\n  print(Solution().removeComments(source));\\n\\n  vector<string> source2 = {\\n    \"a/*comment\", \"line\", \"more_comment*/b\"\\n  };\\n  print(source2);\\n  print(Solution().removeComments(source2));\\n\\n  vector<string> source3 = {\\n    \"a/*/b//*c\", \"blank\", \"d/*/e*//f\"\\n  };\\n  print(source3);\\n  print(Solution().removeComments(source3));\\n\\n  vector<string> source4 = {\\n    \"struct Node{\",\\n    \"    /*/ declare members;/**/\",\\n    \"    int size;\",\\n    \"    /**/int val;\", \"};\"\\n  };\\n  print(source4);\\n  print(Solution().removeComments(source4));\\n\\n  vector<string> source5 = {\\n    \"void func(int k) {\",\\n    \"// this function does nothing /*\",\\n    \"   k = k*2/4;\",\\n    \"   k = k/2;*/\",\\n    \"}\"\\n  };\\n  print(source5);\\n  print(Solution().removeComments(source5));\\n\\n  return 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint static fast = [](){\\n  ios::sync_with_stdio(false);\\n  cin.tie(0); cout.tie(0); return 0;\\n}();\\n\\ntemplate<typename T>\\nvoid print(vector<T>& v) {\\n  for(auto& vv: v) { cout << vv << \"\\\\n\"; }\\n  cout << endl;\\n}\\n\\nclass Solution {\\n  public:\\n    vector<string> removeComments(vector<string>& source) {\\n      vector<string> res;\\n\\n      string tmp;\\n      Type type = DEFAULT;\\n      for(auto& line: source) {\\n        int size = line.size();\\n        for(int i=0; i <= size; ++i) {\\n          char c = i==size ? \\'#\\' : line[i];\\n          switch(type) {\\n            case DEFAULT:\\n              switch(c) {\\n                case \\'/\\': type = FIRST_SLASH; break;\\n                case \\'#\\':\\n                          if(tmp.size()) {\\n                            res.emplace_back(tmp);\\n                            tmp.clear();\\n                          }\\n                          break;\\n                default: tmp.push_back(c); break;\\n              }\\n              break;\\n            case FIRST_SLASH:\\n              switch(c) {\\n                case \\'*\\': type = FIRST_START; break;\\n                case \\'/\\': type = SECOND_SLASH; break;\\n                default:\\n                          i -= 1;\\n                          tmp.push_back(\\'/\\');\\n                          type = DEFAULT; break;\\n              }\\n              break;\\n            case SECOND_SLASH:\\n              switch(c) {\\n                case \\'#\\': i -= 1; type = DEFAULT; break;\\n              }\\n              break;\\n            case FIRST_START:\\n              switch(c) {\\n                case \\'*\\': type = SECOND_START; break;\\n              }\\n              break;\\n            case SECOND_START:\\n              switch(c) {\\n                case \\'/\\': type = DEFAULT; break;\\n                case \\'*\\': type = SECOND_START; break;\\n                default: type = FIRST_START; break;\\n              }\\n              break;\\n          }\\n        }\\n      }\\n\\n      return res;\\n    }\\n\\n  private:\\n    enum Type {\\n      DEFAULT,\\n      FIRST_SLASH,\\n      SECOND_SLASH,\\n      FIRST_START,\\n      SECOND_START,\\n    };\\n};\\n\\nint main() {\\n  vector<string> source = {\\n    \"/*Test program */\",\\n    \"int main()\",\\n    \"{ \",\\n    \"  // variable declaration \",\\n    \"int a, b, c;\",\\n    \"/* This is a test\",\\n    \"   multiline  \",\\n    \"   comment for \",\\n    \"   testing */\",\\n    \"a = b + c;\",\\n    \"}\"\\n  };\\n  print(source);\\n  print(Solution().removeComments(source));\\n\\n  vector<string> source2 = {\\n    \"a/*comment\", \"line\", \"more_comment*/b\"\\n  };\\n  print(source2);\\n  print(Solution().removeComments(source2));\\n\\n  vector<string> source3 = {\\n    \"a/*/b//*c\", \"blank\", \"d/*/e*//f\"\\n  };\\n  print(source3);\\n  print(Solution().removeComments(source3));\\n\\n  vector<string> source4 = {\\n    \"struct Node{\",\\n    \"    /*/ declare members;/**/\",\\n    \"    int size;\",\\n    \"    /**/int val;\", \"};\"\\n  };\\n  print(source4);\\n  print(Solution().removeComments(source4));\\n\\n  vector<string> source5 = {\\n    \"void func(int k) {\",\\n    \"// this function does nothing /*\",\\n    \"   k = k*2/4;\",\\n    \"   k = k/2;*/\",\\n    \"}\"\\n  };\\n  print(source5);\\n  print(Solution().removeComments(source5));\\n\\n  return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 109200,
                "title": "python-solution-with-join-trick",
                "content": "Python solution with \"join\" trick\\n\\n```\\nclass Solution:\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        # Easier to handle if everything is just one stream of character\\n        all_string = \"\\\\n\".join(source)\\n        i = 0\\n        result_string = \"\"\\n        while i < len(all_string):\\n            two = all_string[i:i+2]\\n            if two == \"//\":\\n                # If you find '//', move 2 chracters ahead and\\n                # keep moving until you find newline ('\\\\n') or EOF\\n                i += 2\\n                while i < len(all_string) and all_string[i] != \"\\\\n\":\\n                    i += 1\\n            elif two == \"/*\":\\n                # If you find '/*', move 2 characters ahead and start to search for '*/'\\n                # After you find one, move 2 characters ahead again.\\n                i += 2\\n                while all_string[i:i+2] != \"*/\":\\n                    i += 1\\n                i += 2\\n            else:\\n                # Append character to result_string if it is not a part of comment\\n                result_string += all_string[i]\\n                i += 1\\n        # If a certain line of code is empty after removing comments, \\n        # you must not output that line: each string in the answer list will be non-empty.\\n        return [line for line in result_string.split(\"\\\\n\") if line != \"\"]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        # Easier to handle if everything is just one stream of character\\n        all_string = \"\\\\n\".join(source)\\n        i = 0\\n        result_string = \"\"\\n        while i < len(all_string):\\n            two = all_string[i:i+2]\\n            if two == \"//\":\\n                # If you find '//', move 2 chracters ahead and\\n                # keep moving until you find newline ('\\\\n') or EOF\\n                i += 2\\n                while i < len(all_string) and all_string[i] != \"\\\\n\":\\n                    i += 1\\n            elif two == \"/*\":\\n                # If you find '/*', move 2 characters ahead and start to search for '*/'\\n                # After you find one, move 2 characters ahead again.\\n                i += 2\\n                while all_string[i:i+2] != \"*/\":\\n                    i += 1\\n                i += 2\\n            else:\\n                # Append character to result_string if it is not a part of comment\\n                result_string += all_string[i]\\n                i += 1\\n        # If a certain line of code is empty after removing comments, \\n        # you must not output that line: each string in the answer list will be non-empty.\\n        return [line for line in result_string.split(\"\\\\n\") if line != \"\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440607,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool isComment = false, needJoin = false;\\n        vector<string> res;\\n        for (auto& s : source) {\\n            string curr;\\n            for (int i = 0; i < s.size(); ++i) {\\n                if (s[i] == \\'/\\') {\\n                    if (!isComment) {\\n                        if (i == (s.size() - 1)) {\\n                            curr.push_back(s[i]);\\n                            break;\\n                        }\\n                        if (s[i + 1] == \\'/\\') break;\\n                        if (s[i + 1] == \\'*\\') {\\n                            isComment = true;\\n                            i++;\\n                        } else curr.push_back(s[i]);\\n                    } \\n                } else if (s[i] == \\'*\\') {\\n                    if (!isComment) {\\n                        curr.push_back(s[i]);\\n                    } else if (i != (s.size() - 1) && s[i + 1] == \\'/\\') {\\n                        isComment = false;\\n                        i++;\\n                    }\\n                } else if (!isComment) {\\n                    curr.push_back(s[i]);\\n                }\\n            }\\n            if (!curr.empty()) {\\n                if (needJoin) {\\n                    res.back() += curr;\\n                    needJoin = false;\\n                } else {\\n                    res.emplace_back(curr);\\n                }\\n                if (isComment) needJoin = true;\\n            } else if (needJoin && !isComment) {\\n                needJoin = false; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def removeComments(self, source):\\n        res = []\\n        multi = False\\n        line = \\'\\'\\n        for s in source:\\n            i = 0\\n            while i < len(s):\\n                if not multi:\\n                    if s[i] == \\'/\\' and i < len(s) - 1 and s[i + 1] == \\'/\\':\\n                        break\\n                    elif s[i] == \\'/\\' and i < len(s) - 1 and s[i + 1] == \\'*\\':\\n                        multi = True\\n                        i += 1\\n                    else:\\n                        line += s[i]\\n                else:\\n                    if s[i] == \\'*\\' and i < len(s) - 1 and s[i + 1] == \\'/\\':\\n                        multi = False\\n                        i += 1\\n                i += 1\\n            if not multi and line:\\n                res.append(line)\\n                line = \\'\\'\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    private static final char slash    = \\'/\\',\\n                              asterisk = \\'*\\'; \\n    public List<String> removeComments(String[] source) {\\n        List<String> uncommentedSource = new ArrayList<>();\\n        StringBuilder uncommentedLine = new StringBuilder();\\n        boolean isBlockCodeComment = false;\\n        for (String commentedLine : source) {\\n            char[] line = commentedLine.toCharArray();\\n            int length = line.length;\\n            for (int index = 0; index < length; ++index)\\n                if (!isBlockCodeComment && line[index] == slash && index + 1 < length && line[index + 1] == asterisk) {\\n                    isBlockCodeComment = true;\\n                    index++;\\n                }\\n                else if (isBlockCodeComment && line[index] == asterisk && index + 1 < length && line[index + 1] == slash) {\\n                    isBlockCodeComment = false;\\n                    index++;\\n                }\\n                else if (!isBlockCodeComment && line[index] == slash && index + 1 < length && line[index + 1] == slash) \\n                    break;\\n                else if (!isBlockCodeComment)\\n                    uncommentedLine.append(line[index]);\\n            \\n            if (!isBlockCodeComment && uncommentedLine.length() != 0) {\\n                uncommentedSource.add(uncommentedLine.toString());\\n                uncommentedLine.setLength(0);   \\n            }   \\n        }\\n        return uncommentedSource;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool isComment = false, needJoin = false;\\n        vector<string> res;\\n        for (auto& s : source) {\\n            string curr;\\n            for (int i = 0; i < s.size(); ++i) {\\n                if (s[i] == \\'/\\') {\\n                    if (!isComment) {\\n                        if (i == (s.size() - 1)) {\\n                            curr.push_back(s[i]);\\n                            break;\\n                        }\\n                        if (s[i + 1] == \\'/\\') break;\\n                        if (s[i + 1] == \\'*\\') {\\n                            isComment = true;\\n                            i++;\\n                        } else curr.push_back(s[i]);\\n                    } \\n                } else if (s[i] == \\'*\\') {\\n                    if (!isComment) {\\n                        curr.push_back(s[i]);\\n                    } else if (i != (s.size() - 1) && s[i + 1] == \\'/\\') {\\n                        isComment = false;\\n                        i++;\\n                    }\\n                } else if (!isComment) {\\n                    curr.push_back(s[i]);\\n                }\\n            }\\n            if (!curr.empty()) {\\n                if (needJoin) {\\n                    res.back() += curr;\\n                    needJoin = false;\\n                } else {\\n                    res.emplace_back(curr);\\n                }\\n                if (isComment) needJoin = true;\\n            } else if (needJoin && !isComment) {\\n                needJoin = false; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def removeComments(self, source):\\n        res = []\\n        multi = False\\n        line = \\'\\'\\n        for s in source:\\n            i = 0\\n            while i < len(s):\\n                if not multi:\\n                    if s[i] == \\'/\\' and i < len(s) - 1 and s[i + 1] == \\'/\\':\\n                        break\\n                    elif s[i] == \\'/\\' and i < len(s) - 1 and s[i + 1] == \\'*\\':\\n                        multi = True\\n                        i += 1\\n                    else:\\n                        line += s[i]\\n                else:\\n                    if s[i] == \\'*\\' and i < len(s) - 1 and s[i + 1] == \\'/\\':\\n                        multi = False\\n                        i += 1\\n                i += 1\\n            if not multi and line:\\n                res.append(line)\\n                line = \\'\\'\\n        return res\\n```\n```Java []\\nclass Solution {\\n    private static final char slash    = \\'/\\',\\n                              asterisk = \\'*\\'; \\n    public List<String> removeComments(String[] source) {\\n        List<String> uncommentedSource = new ArrayList<>();\\n        StringBuilder uncommentedLine = new StringBuilder();\\n        boolean isBlockCodeComment = false;\\n        for (String commentedLine : source) {\\n            char[] line = commentedLine.toCharArray();\\n            int length = line.length;\\n            for (int index = 0; index < length; ++index)\\n                if (!isBlockCodeComment && line[index] == slash && index + 1 < length && line[index + 1] == asterisk) {\\n                    isBlockCodeComment = true;\\n                    index++;\\n                }\\n                else if (isBlockCodeComment && line[index] == asterisk && index + 1 < length && line[index + 1] == slash) {\\n                    isBlockCodeComment = false;\\n                    index++;\\n                }\\n                else if (!isBlockCodeComment && line[index] == slash && index + 1 < length && line[index + 1] == slash) \\n                    break;\\n                else if (!isBlockCodeComment)\\n                    uncommentedLine.append(line[index]);\\n            \\n            if (!isBlockCodeComment && uncommentedLine.length() != 0) {\\n                uncommentedSource.add(uncommentedLine.toString());\\n                uncommentedLine.setLength(0);   \\n            }   \\n        }\\n        return uncommentedSource;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422317,
                "title": "c-solution-beats-100-runtime",
                "content": "# Intuition\\nThere\\'s no C solution so here is a straightforward solution.\\nI am not a C expert just a beginner so any suggestions are welcome.\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                } else if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'*\\') {\\n                    blockCommentOp = 1;\\n                    ++j;\\n                } else {\\n                    if (!srcCopy[line])\\n                        srcCopy[line] = malloc(sizeof(char)*2);\\n                    else\\n                        srcCopy[line] = realloc(srcCopy[line], (idx+2)*sizeof(char));\\n\\n                    srcCopy[line][idx++] = c;\\n                }\\n            } else if (c == \\'*\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                blockCommentOp = 0;\\n                ++j;\\n            }\\n            ++j;\\n        }\\n\\n        if (blockCommentOp == 0 && srcCopy[line]) {\\n            srcCopy[line++][idx] = \\'\\\\0\\';\\n            if (line < sourceSize)\\n                srcCopy[line] = NULL;\\n            idx = 0;\\n        }\\n    }\\n\\n    *returnSize = line;\\n    int id = 0;\\n    char ** targetCode = (char**) malloc(*(returnSize)*sizeof(char*));\\n    for (int i = 0; i < line; ++i) {\\n        targetCode[id] = malloc(sizeof(char)*(strlen(srcCopy[i]) + 1));\\n        strcpy(targetCode[id], srcCopy[i]);\\n        ++id;\\n        free(srcCopy[i]);\\n    }\\n\\n    return targetCode;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                } else if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'*\\') {\\n                    blockCommentOp = 1;\\n                    ++j;\\n                } else {\\n                    if (!srcCopy[line])\\n                        srcCopy[line] = malloc(sizeof(char)*2);\\n                    else\\n                        srcCopy[line] = realloc(srcCopy[line], (idx+2)*sizeof(char));\\n\\n                    srcCopy[line][idx++] = c;\\n                }\\n            } else if (c == \\'*\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                blockCommentOp = 0;\\n                ++j;\\n            }\\n            ++j;\\n        }\\n\\n        if (blockCommentOp == 0 && srcCopy[line]) {\\n            srcCopy[line++][idx] = \\'\\\\0\\';\\n            if (line < sourceSize)\\n                srcCopy[line] = NULL;\\n            idx = 0;\\n        }\\n    }\\n\\n    *returnSize = line;\\n    int id = 0;\\n    char ** targetCode = (char**) malloc(*(returnSize)*sizeof(char*));\\n    for (int i = 0; i < line; ++i) {\\n        targetCode[id] = malloc(sizeof(char)*(strlen(srcCopy[i]) + 1));\\n        strcpy(targetCode[id], srcCopy[i]);\\n        ++id;\\n        free(srcCopy[i]);\\n    }\\n\\n    return targetCode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065601,
                "title": "python3-easy-solution",
                "content": "\\n\\n\\n\\n    def removeComments(self, source: List[str]) -> List[str]:\\n            \\n            all_string = \"\\\\n\".join(source)\\n            result_string = \"\"\\n\\n            i = 0\\n            while i < len(all_string):\\n\\n                two = all_string[i:i+2]\\n                if two == \"//\":\\n\\n                    i += 2\\n                    while i < len(all_string) and all_string[i] != \"\\\\n\":\\n                        i += 1\\n\\n                elif two == \"/*\":\\n\\n                    i += 2\\n                    while all_string[i:i+2] != \"*/\":\\n                        i += 1\\n                    i += 2\\n\\n                else:\\n                    result_string += all_string[i]\\n                    i += 1\\n\\n            \\n            ans = []\\n\\n            for line in result_string.split(\"\\\\n\"):\\n                if line != \"\":\\n                    ans.append(line)\\n\\n\\n            return ans\\n    ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\n\\n\\n    def removeComments(self, source: List[str]) -> List[str]:\\n            \\n            all_string = \"\\\\n\".join(source)\\n            result_string = \"\"\\n\\n            i = 0\\n            while i < len(all_string):\\n\\n                two = all_string[i:i+2]\\n                if two == \"//\":\\n\\n                    i += 2\\n                    while i < len(all_string) and all_string[i] != \"\\\\n\":\\n                        i += 1\\n\\n                elif two == \"/*\":\\n\\n                    i += 2\\n                    while all_string[i:i+2] != \"*/\":\\n                        i += 1\\n                    i += 2\\n\\n                else:\\n                    result_string += all_string[i]\\n                    i += 1\\n\\n            \\n            ans = []\\n\\n            for line in result_string.split(\"\\\\n\"):\\n                if line != \"\":\\n                    ans.append(line)\\n\\n\\n            return ans\\n    ```",
                "codeTag": "Python3"
            },
            {
                "id": 2752433,
                "title": "databricks-go-solution-in-one-pass",
                "content": "# Intuition\\n\\nMy initial intuition made me approach problem with finding index of either `\\\\\\\\` or `\\\\*` and then implementing crude finite automata with that logic, but the complexity of if/else conditions exploses so fast that it becomes horrorsome (even if you do implement it in the end \\u2014 it will be very fugly).\\n\\nThat led me (after an hour) to think that some structure that would help getting rid of elements that are not needed could help, and that is very often stack. After trying with stack I realised that perhaps it is easier not to even add elements to stack if we don\\'t need to; the stack approach did lead me to think of the input as a stream or characters, rather then stream of strings, which made the solution much more approachable and the code simpler.\\n\\n# Approach\\n\\n## Step 1\\n\\nMerge input into a stream of runes (characters).\\n\\n## Step 2\\n\\nExamine input character by character, flipping the `ignoreLine` or `ignoreBlock` on if we see the only correct starting sequences for both.\\n\\nIf either of the switches is on \\u2014 ignore input as so far we don\\'t see the only legitimate end of ignore block.\\n\\nThat is `\\\\n` for `ignoreLine` and `*/` for `ignoreBlock`.\\n\\n## Step 3\\n\\nPretty print output.\\n\\n# Complexity\\n- Time complexity:\\n\\n$$O(n)$$ \\u2014 we walk the input once\\n\\n- Space complexity:\\n\\n$$O(n)$$ \\u2014 or merged input\\n\\n# Code\\n```\\nfunc removeComments(source []string) []string {\\n    // Step 1 Merge input into a stream of characters\\n    all := strings.Join(source, \"\\\\n\")\\n    runes := []rune(all)\\n\\n    // Step 2 Examine stream character by character flipping and respecting the states\\n    var st []rune\\n    var ignoreLine bool\\n    var ignoreBlock bool\\n    prev := \\'_\\'\\n    for _, v := range runes {\\n        if !ignoreLine && !ignoreBlock {\\n            st = append(st, v)\\n            if len(st) > 1 {\\n                // Started line comment\\n                if st[len(st)-2] == \\'/\\' && st[len(st)-1] == \\'*\\' {\\n                    st = st[:len(st)-2]\\n                    ignoreBlock = true\\n                    continue\\n                }\\n                // Started block comment\\n                if st[len(st)-2] == \\'/\\' && st[len(st)-1] == \\'/\\' {\\n                    st = st[:len(st)-2]\\n                    ignoreLine = true\\n                    continue\\n                }\\n            }\\n        } else {\\n            // Exit condition for line comment\\n            if ignoreLine && v == \\'\\\\n\\' {\\n                ignoreLine = false\\n                st = append(st, \\'\\\\n\\')\\n            }\\n            // Exit condition for block comment\\n            if ignoreBlock && prev == \\'*\\' && v == \\'/\\' {\\n                ignoreBlock = false\\n            }\\n        }\\n        prev = v\\n    }\\n\\n    // Step 3 Pretty print ouput\\n    all = string(st)\\n    var ans []string\\n    for _, v := range strings.Split(all, \"\\\\n\") {\\n        if len(v) > 0 {\\n            ans = append(ans, v)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeComments(source []string) []string {\\n    // Step 1 Merge input into a stream of characters\\n    all := strings.Join(source, \"\\\\n\")\\n    runes := []rune(all)\\n\\n    // Step 2 Examine stream character by character flipping and respecting the states\\n    var st []rune\\n    var ignoreLine bool\\n    var ignoreBlock bool\\n    prev := \\'_\\'\\n    for _, v := range runes {\\n        if !ignoreLine && !ignoreBlock {\\n            st = append(st, v)\\n            if len(st) > 1 {\\n                // Started line comment\\n                if st[len(st)-2] == \\'/\\' && st[len(st)-1] == \\'*\\' {\\n                    st = st[:len(st)-2]\\n                    ignoreBlock = true\\n                    continue\\n                }\\n                // Started block comment\\n                if st[len(st)-2] == \\'/\\' && st[len(st)-1] == \\'/\\' {\\n                    st = st[:len(st)-2]\\n                    ignoreLine = true\\n                    continue\\n                }\\n            }\\n        } else {\\n            // Exit condition for line comment\\n            if ignoreLine && v == \\'\\\\n\\' {\\n                ignoreLine = false\\n                st = append(st, \\'\\\\n\\')\\n            }\\n            // Exit condition for block comment\\n            if ignoreBlock && prev == \\'*\\' && v == \\'/\\' {\\n                ignoreBlock = false\\n            }\\n        }\\n        prev = v\\n    }\\n\\n    // Step 3 Pretty print ouput\\n    all = string(st)\\n    var ans []string\\n    for _, v := range strings.Split(all, \"\\\\n\") {\\n        if len(v) > 0 {\\n            ans = append(ans, v)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197565,
                "title": "i-just-wrote-the-most-disgusting-code-i-have-ever-written-one-pass-o-n",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]: \\n        row = 0 \\n        while row < len(source):\\n            col = 1\\n            while row < len(source) and col < len(source[row]):\\n                if source[row][col-1:col+1] == \\'//\\':\\n                    if col == 1:\\n                        source.pop(row)\\n                        row -= 1\\n                    else:\\n                        source[row] = source[row][:col-1]\\n                elif source[row][col-1:col+1] == \\'/*\\':\\n                    # print(source[row][col+1:])\\n                    end = source[row][col+1:].find(\\'*/\\')\\n                    end = col+1+end if end != -1 else -1\\n                    br = False\\n                    while end < 0:\\n                        br = True\\n                        if col == 1:\\n                            source.pop(row)\\n                        else:\\n                            source[row] = source[row][:col-1]\\n                            row += 1\\n                        end = source[row].find(\\'*/\\')\\n                        col = 1\\n                    if br:\\n                        source[row] = source[row][end+2:]\\n                        if row > 0:\\n                            source[row-1] += source[row]\\n                            source.pop(row)\\n                            row -=1\\n                    else:\\n                        source[row] = source[row][:col-1] + source[row][end+2:]\\n                        if not len(source[row]):\\n                            source.pop(row)\\n                    continue\\n                col += 1\\n            row += 1\\n        return source\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]: \\n        row = 0 \\n        while row < len(source):\\n            col = 1\\n            while row < len(source) and col < len(source[row]):\\n                if source[row][col-1:col+1] == \\'//\\':\\n                    if col == 1:\\n                        source.pop(row)\\n                        row -= 1\\n                    else:\\n                        source[row] = source[row][:col-1]\\n                elif source[row][col-1:col+1] == \\'/*\\':\\n                    # print(source[row][col+1:])\\n                    end = source[row][col+1:].find(\\'*/\\')\\n                    end = col+1+end if end != -1 else -1\\n                    br = False\\n                    while end < 0:\\n                        br = True\\n                        if col == 1:\\n                            source.pop(row)\\n                        else:\\n                            source[row] = source[row][:col-1]\\n                            row += 1\\n                        end = source[row].find(\\'*/\\')\\n                        col = 1\\n                    if br:\\n                        source[row] = source[row][end+2:]\\n                        if row > 0:\\n                            source[row-1] += source[row]\\n                            source.pop(row)\\n                            row -=1\\n                    else:\\n                        source[row] = source[row][:col-1] + source[row][end+2:]\\n                        if not len(source[row]):\\n                            source.pop(row)\\n                    continue\\n                col += 1\\n            row += 1\\n        return source\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106874,
                "title": "kotlin-using-when",
                "content": "```\\nclass Solution {\\n    fun removeComments(source: Array<String>): List<String> {\\n        val blocks_removed = MutableList<MutableList<Char>>(1) {MutableList(0) {\\'0\\'}}\\n        var j: Int\\n        var do_a_break: Boolean = false\\n        var in_comment: Boolean = false\\n        var window: String\\n        \\n        for (row in source) {\\n            j = 0; do_a_break = false\\n            \\n            while (j < row.length) {\\n                if (j + 1 < row.length) window = row.substring(j, j+2) else window = \"\"\\n                \\n                if (!in_comment) {\\n                    when(window) {\\n                        \"/*\" -> { in_comment = true; j++ }\\n                        \"//\" -> do_a_break = true\\n                        else -> blocks_removed.last().add(row[j])\\n                    }\\n                }\\n                \\n                else if (window == \"*/\") {\\n                    in_comment = false\\n                    j++\\n                }\\n                \\n                if (do_a_break) break\\n                j++\\n            }\\n            if (!in_comment) blocks_removed.add(MutableList(0) {\\'0\\'})\\n        }\\n        \\n        val modified_source = MutableList(0) {\"0\"}\\n        for (i in 0 until blocks_removed.size) {\\n            val sentence = blocks_removed[i].joinToString(separator = \"\")\\n            if (sentence.length > 0) modified_source.add(sentence)\\n        }\\n        \\n        return modified_source\\n    }\\n}```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun removeComments(source: Array<String>): List<String> {\\n        val blocks_removed = MutableList<MutableList<Char>>(1) {MutableList(0) {\\'0\\'}}\\n        var j: Int\\n        var do_a_break: Boolean = false\\n        var in_comment: Boolean = false\\n        var window: String\\n        \\n        for (row in source) {\\n            j = 0; do_a_break = false\\n            \\n            while (j < row.length) {\\n                if (j + 1 < row.length) window = row.substring(j, j+2) else window = \"\"\\n                \\n                if (!in_comment) {\\n                    when(window) {\\n                        \"/*\" -> { in_comment = true; j++ }\\n                        \"//\" -> do_a_break = true\\n                        else -> blocks_removed.last().add(row[j])\\n                    }\\n                }\\n                \\n                else if (window == \"*/\") {\\n                    in_comment = false\\n                    j++\\n                }\\n                \\n                if (do_a_break) break\\n                j++\\n            }\\n            if (!in_comment) blocks_removed.add(MutableList(0) {\\'0\\'})\\n        }\\n        \\n        val modified_source = MutableList(0) {\"0\"}\\n        for (i in 0 until blocks_removed.size) {\\n            val sentence = blocks_removed[i].joinToString(separator = \"\")\\n            if (sentence.length > 0) modified_source.add(sentence)\\n        }\\n        \\n        return modified_source\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1987846,
                "title": "python-iteration",
                "content": "```class Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res, buffer, isBlockOpen = [], \"\", False\\n        for line in source:\\n            index = 0\\n            while index < len(line):\\n                if line[index] == \\'/\\' and index + 1 < len(line) and line[index+1] == \"/\" and not isBlockOpen:\\n                    index = len(line)\\n                elif line[index] == \"/\" and index + 1 < len(line) and line[index+1] == \"*\" and not isBlockOpen:\\n                    isBlockOpen = True\\n                    index += 2\\n                elif line[index] == \"*\" and index + 1 < len(line) and line[index+1] == \"/\" and isBlockOpen:\\n                    isBlockOpen = False\\n                    index += 2\\n                elif isBlockOpen:\\n                    index += 1\\n                else:\\n                    buffer += line[index]\\n                    index  += 1\\n            if not isBlockOpen and buffer:\\n                res.append(buffer)\\n                buffer = \"\"\\n        return res",
                "solutionTags": [],
                "code": "```class Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res, buffer, isBlockOpen = [], \"\", False\\n        for line in source:\\n            index = 0\\n            while index < len(line):\\n                if line[index] == \\'/\\' and index + 1 < len(line) and line[index+1] == \"/\" and not isBlockOpen:\\n                    index = len(line)\\n                elif line[index] == \"/\" and index + 1 < len(line) and line[index+1] == \"*\" and not isBlockOpen:\\n                    isBlockOpen = True\\n                    index += 2\\n                elif line[index] == \"*\" and index + 1 < len(line) and line[index+1] == \"/\" and isBlockOpen:\\n                    isBlockOpen = False\\n                    index += 2\\n                elif isBlockOpen:\\n                    index += 1\\n                else:\\n                    buffer += line[index]\\n                    index  += 1\\n            if not isBlockOpen and buffer:\\n                res.append(buffer)\\n                buffer = \"\"\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1954768,
                "title": "java-clean-code",
                "content": "The real kickers are:\\n1. Determine which comment style appears first and pick that. \\n\\n2. Block comment style can end and start anywhere on the same line **multiple** times. We have to keep looking.\\n\\n3. Line comment style terminates the line.\\n\\n4. When block comment is active, don\\'t add the current string to the answer until it terminates. This is to achieve \"implicit newline characters can be deleted by block comments\" as required by the qeustion.\\n\\nI break down my codes such that there aren\\'t lots of nested logic like many posts on here.\\nI hope you find it easy to read and understand.\\nPlease **upvote** if you find it helpful!\\n```Java\\nclass Solution {\\n    final int SLASH= 1;\\n    final int BLOCK= 2;\\n    public List<String> removeComments(String[] source) {\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean comment = false;\\n\\n        for (String s : source){\\n            int cur = blockEnd(s, 0, comment);\\n            if (cur == -1)\\n                continue; // whole line is inside block comment, so we continue\\n            comment = false;\\n            int slash, block, chosen;\\n            do{\\n                slash = s.indexOf(\"//\", cur);\\n                block = s.indexOf(\"/*\", cur);\\n                chosen = selected(slash, block); // which one got picked?\\n                int end = switch(chosen){ // position the end accordingly\\n                    case SLASH: yield slash;\\n                    case BLOCK: yield block;\\n                    default: yield s.length();\\n                };\\n                sb.append(s.substring(cur, end));\\n                if (chosen == BLOCK){ // if block got picked, we advance to the end of it\\n                    cur = blockEnd(s, block + 2, true);\\n                    comment = cur == -1;\\n                }\\n            }while(!comment && chosen == BLOCK); // continue looping only when block comment was chosen but *not* active\\n\\n            if (!sb.isEmpty() && !comment){\\n                ans.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int blockEnd(String s, int st, boolean block){\\n        if (!block)\\n            return st;\\n        int end = s.indexOf(\"*/\", st);\\n        return end == -1? -1 : end + 2;\\n    }\\n\\n    private int selected(int slash, int block){\\n        if (block > -1 && (slash == -1 || block < slash))\\n            return BLOCK;\\n        if (slash > -1 && (block == -1 || slash < block))\\n            return SLASH;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    final int SLASH= 1;\\n    final int BLOCK= 2;\\n    public List<String> removeComments(String[] source) {\\n        List<String> ans = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean comment = false;\\n\\n        for (String s : source){\\n            int cur = blockEnd(s, 0, comment);\\n            if (cur == -1)\\n                continue; // whole line is inside block comment, so we continue\\n            comment = false;\\n            int slash, block, chosen;\\n            do{\\n                slash = s.indexOf(\"//\", cur);\\n                block = s.indexOf(\"/*\", cur);\\n                chosen = selected(slash, block); // which one got picked?\\n                int end = switch(chosen){ // position the end accordingly\\n                    case SLASH: yield slash;\\n                    case BLOCK: yield block;\\n                    default: yield s.length();\\n                };\\n                sb.append(s.substring(cur, end));\\n                if (chosen == BLOCK){ // if block got picked, we advance to the end of it\\n                    cur = blockEnd(s, block + 2, true);\\n                    comment = cur == -1;\\n                }\\n            }while(!comment && chosen == BLOCK); // continue looping only when block comment was chosen but *not* active\\n\\n            if (!sb.isEmpty() && !comment){\\n                ans.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int blockEnd(String s, int st, boolean block){\\n        if (!block)\\n            return st;\\n        int end = s.indexOf(\"*/\", st);\\n        return end == -1? -1 : end + 2;\\n    }\\n\\n    private int selected(int slash, int block){\\n        if (block > -1 && (slash == -1 || block < slash))\\n            return BLOCK;\\n        if (slash > -1 && (block == -1 || slash < block))\\n            return SLASH;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948296,
                "title": "java-if-else",
                "content": "```\\nclass Solution {\\n    \\n    boolean isCommentBegan=false;\\n    String lineBeforeComm=\"\";\\n    public List<String> removeComments(String[] source) {\\n        List<String> res=new ArrayList();\\n        for(String line:source){\\n            line=helper(line);\\n            if(line!=null){\\n                res.add(line);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private String helper(String line){\\n        if(line.length()==0){\\n            return null;\\n        }\\n        if(isCommentBegan){\\n            int index=line.indexOf(\"*/\");\\n            if(index<0){\\n                return null;\\n            }\\n            isCommentBegan=false;\\n            StringBuilder sb=new StringBuilder();\\n            sb.append(lineBeforeComm);\\n            sb.append(line.substring(index+2,line.length()));\\n            line=sb.toString();\\n        }else if(!isCommentBegan){\\n            int index1=line.indexOf(\"//\");\\n            int index2=line.indexOf(\"/*\");\\n            if(index1>=0 && (index2<0 || index1<index2) ){\\n                line=line.substring(0,index1);\\n            }else{\\n                if(index2<0){\\n                    return line;\\n                }\\n                isCommentBegan=true;\\n                lineBeforeComm=line.substring(0,index2);\\n                line=line.substring(index2+2,line.length());\\n            }\\n        }\\n        return helper(line);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    boolean isCommentBegan=false;\\n    String lineBeforeComm=\"\";\\n    public List<String> removeComments(String[] source) {\\n        List<String> res=new ArrayList();\\n        for(String line:source){\\n            line=helper(line);\\n            if(line!=null){\\n                res.add(line);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private String helper(String line){\\n        if(line.length()==0){\\n            return null;\\n        }\\n        if(isCommentBegan){\\n            int index=line.indexOf(\"*/\");\\n            if(index<0){\\n                return null;\\n            }\\n            isCommentBegan=false;\\n            StringBuilder sb=new StringBuilder();\\n            sb.append(lineBeforeComm);\\n            sb.append(line.substring(index+2,line.length()));\\n            line=sb.toString();\\n        }else if(!isCommentBegan){\\n            int index1=line.indexOf(\"//\");\\n            int index2=line.indexOf(\"/*\");\\n            if(index1>=0 && (index2<0 || index1<index2) ){\\n                line=line.substring(0,index1);\\n            }else{\\n                if(index2<0){\\n                    return line;\\n                }\\n                isCommentBegan=true;\\n                lineBeforeComm=line.substring(0,index2);\\n                line=line.substring(index2+2,line.length());\\n            }\\n        }\\n        return helper(line);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825426,
                "title": "c-o-n-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool b=0;\\n        string rem;\\n        for(auto &s:source){\\n          string ss=rem;\\n            for(int i=0;i<s.length();i++){\\n                if(b){\\n                    if(s[i]==\\'*\\' and i+1<s.length() and s[i+1]==\\'/\\')\\n                    {\\n                        i++;\\n                        b=0;\\n                    }\\n                }\\n                else{\\n                    if(s[i]==\\'/\\' and i+1<s.length() and s[i+1]==\\'*\\'){\\n                        i++;\\n                        b=1;\\n                    }\\n                    else if(s[i]==\\'/\\' and i+1<s.length() and s[i+1]==\\'/\\')\\n                        break;\\n                    else\\n                        ss.push_back(s[i]);\\n                }\\n            }\\n            if(b)\\n                rem=ss;\\n            else if(ss.length()>0) {\\n                ans.push_back(ss);\\n                rem=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool b=0;\\n        string rem;\\n        for(auto &s:source){\\n          string ss=rem;\\n            for(int i=0;i<s.length();i++){\\n                if(b){\\n                    if(s[i]==\\'*\\' and i+1<s.length() and s[i+1]==\\'/\\')\\n                    {\\n                        i++;\\n                        b=0;\\n                    }\\n                }\\n                else{\\n                    if(s[i]==\\'/\\' and i+1<s.length() and s[i+1]==\\'*\\'){\\n                        i++;\\n                        b=1;\\n                    }\\n                    else if(s[i]==\\'/\\' and i+1<s.length() and s[i+1]==\\'/\\')\\n                        break;\\n                    else\\n                        ss.push_back(s[i]);\\n                }\\n            }\\n            if(b)\\n                rem=ss;\\n            else if(ss.length()>0) {\\n                ans.push_back(ss);\\n                rem=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803203,
                "title": "java-code-beats-100",
                "content": "\\n\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>(); \\n        boolean commented = false; \\n        StringBuilder sb = new StringBuilder(); \\n        for (String line : source) {\\n            for (int i = 0; i < line.length(); i++) {\\n                if (commented) {\\n                    if (line.charAt(i) == \\'*\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        commented = false; \\n                        i++; \\n                    }\\n                }\\n                else {\\n                    if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'*\\') {\\n                        commented = true; \\n                        i++; \\n                    }\\n                    else if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        break;\\n                    }\\n                    else {\\n                        sb.append(line.charAt(i));\\n                    }\\n                }\\n            }\\n            if (!commented && sb.length() != 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder(); \\n            }\\n        }\\n        return res; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>(); \\n        boolean commented = false; \\n        StringBuilder sb = new StringBuilder(); \\n        for (String line : source) {\\n            for (int i = 0; i < line.length(); i++) {\\n                if (commented) {\\n                    if (line.charAt(i) == \\'*\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        commented = false; \\n                        i++; \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1683732,
                "title": "java-one-pass-solution-explained-with-comments",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        \\n        List<String> result = new ArrayList<>();\\n\\n        StringBuilder currLine = new StringBuilder();\\n        boolean blockCommentMode = false;\\n        \\n        // go through all lines in the source\\n        for(String line : source) {\\n            \\n            int i = 0;          \\n            while(i < line.length()) {     \\n                \\n                // if we are NOT in the block comment\\n                if(!blockCommentMode) {\\n                    // ignore single comment lines\\n                    if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i + 1) == \\'/\\') {\\n                        break;\\n                    } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i+1) == \\'*\\') {\\n                        // we have encountered a block comment, continue the loop after two chars\\n                        blockCommentMode = true;\\n                        i = i + 2; \\n                    } else {\\n                        // we should add character to the current line\\n                        currLine.append(line.charAt(i));  \\n                        i++;\\n                    }\\n                } else {\\n                    // we are in block comments mode, if we encounter the end of block comments, come out of\\n                    // the block comments mode, else just increment index and move to next character\\n                    if(i + 1 < line.length()  && line.charAt(i) == \\'*\\' && line.charAt(i + 1) == \\'/\\') {\\n                        blockCommentMode = false;\\n                        i = i + 2;\\n                   } else {\\n                        i++;\\n                    }\\n                }\\n            }\\n            \\n            if(!blockCommentMode) {\\n                addCurrLineToResult(currLine, result);\\n                currLine.setLength(0);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addCurrLineToResult(StringBuilder currLine, List<String> result) {\\n        if(currLine.length()!=0) {\\n            result.add(currLine.toString());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        \\n        List<String> result = new ArrayList<>();\\n\\n        StringBuilder currLine = new StringBuilder();\\n        boolean blockCommentMode = false;\\n        \\n        // go through all lines in the source\\n        for(String line : source) {\\n            \\n            int i = 0;          \\n            while(i < line.length()) {     \\n                \\n                // if we are NOT in the block comment\\n                if(!blockCommentMode) {\\n                    // ignore single comment lines\\n                    if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i + 1) == \\'/\\') {\\n                        break;\\n                    } else if(i + 1 < line.length() && line.charAt(i) == \\'/\\' && line.charAt(i+1) == \\'*\\') {\\n                        // we have encountered a block comment, continue the loop after two chars\\n                        blockCommentMode = true;\\n                        i = i + 2; \\n                    } else {\\n                        // we should add character to the current line\\n                        currLine.append(line.charAt(i));  \\n                        i++;\\n                    }\\n                } else {\\n                    // we are in block comments mode, if we encounter the end of block comments, come out of\\n                    // the block comments mode, else just increment index and move to next character\\n                    if(i + 1 < line.length()  && line.charAt(i) == \\'*\\' && line.charAt(i + 1) == \\'/\\') {\\n                        blockCommentMode = false;\\n                        i = i + 2;\\n                   } else {\\n                        i++;\\n                    }\\n                }\\n            }\\n            \\n            if(!blockCommentMode) {\\n                addCurrLineToResult(currLine, result);\\n                currLine.setLength(0);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addCurrLineToResult(StringBuilder currLine, List<String> result) {\\n        if(currLine.length()!=0) {\\n            result.add(currLine.toString());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648315,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        boolean block=false;\\n        String temp=\"\";\\n        ArrayList<String> result=new ArrayList<>();\\n        for(String line:source){\\n            if(!block)\\n                temp=\"\";\\n            for(int i=0;i<line.length();i++){\\n                if(block){\\n                    if(line.charAt(i)==\\'*\\'&&i+1<line.length()&&line.charAt(i+1)==\\'/\\')\\n                    {\\n                        block=false;\\n                        i++;\\n                    }\\n                }\\n                else{\\n                    \\n                    if(line.charAt(i)==\\'/\\'&&i+1<line.length()&&line.charAt(i+1)==\\'/\\'){\\n                        break;\\n                    }\\n                    if(line.charAt(i)==\\'/\\'&&i+1<line.length()&&line.charAt(i+1)==\\'*\\')\\n                    {\\n                        block=true;\\n                        i++;\\n                        continue;\\n                    }\\n                    \\n                    temp+=line.charAt(i);\\n                    \\n                }\\n            }\\n           if(!block){\\n                if(temp.length()>0)\\n                result.add(temp);\\n           } \\n           \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        boolean block=false;\\n        String temp=\"\";\\n        ArrayList<String> result=new ArrayList<>();\\n        for(String line:source){\\n            if(!block)\\n                temp=\"\";\\n            for(int i=0;i<line.length();i++){\\n                if(block){\\n                    if(line.charAt(i)==\\'*\\'&&i+1<line.length()&&line.charAt(i+1)==\\'/\\')\\n                    {\\n                        block=false;\\n                        i++;\\n                    }\\n                }\\n                else{\\n                    \\n                    if(line.charAt(i)==\\'/\\'&&i+1<line.length()&&line.charAt(i+1)==\\'/\\'){\\n                        break;\\n                    }\\n                    if(line.charAt(i)==\\'/\\'&&i+1<line.length()&&line.charAt(i+1)==\\'*\\')\\n                    {\\n                        block=true;\\n                        i++;\\n                        continue;\\n                    }\\n                    \\n                    temp+=line.charAt(i);\\n                    \\n                }\\n            }\\n           if(!block){\\n                if(temp.length()>0)\\n                result.add(temp);\\n           } \\n           \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617292,
                "title": "one-pass-c",
                "content": "1. Iterate over the vector\\n2. Iterate over the current line and check conditions and append to the temporary string. \\n3. Push the temporary string to the vector.\\n\\nCode :\\n```\\nvector<string> removeComments(vector<string>& source) {\\n\\tvector<string> res;\\n\\tbool multilinecomment = false;\\n\\tstring curr = \"\";\\n\\tfor(int line=0;line<source.size();line++)\\n\\t{\\n\\t\\tint len = source[line].length();\\n\\t\\tfor(int i=0;i<source[line].length();i++)\\n\\t\\t{\\n\\t\\t\\tif(multilinecomment)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i<len-1 && source[line][i]==\\'*\\' && source[line][i+1]==\\'/\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmultilinecomment = false;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i<len-1 && source[line][i]==\\'/\\' && source[line][i+1]==\\'/\\')\\n\\t\\t\\t\\t\\tgoto next;\\n\\t\\t\\t\\telse if(i<len-1 && source[line][i]==\\'/\\' && source[line][i+1]==\\'*\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmultilinecomment = true;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurr += source[line][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tnext:\\n\\t\\tif(!multilinecomment && curr!=\"\")\\n\\t\\t{\\n\\t\\t\\tres.push_back(curr);\\n\\t\\t\\tcurr = \"\";\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}",
                "solutionTags": [],
                "code": "1. Iterate over the vector\\n2. Iterate over the current line and check conditions and append to the temporary string. \\n3. Push the temporary string to the vector.\\n\\nCode :\\n```\\nvector<string> removeComments(vector<string>& source) {\\n\\tvector<string> res;\\n\\tbool multilinecomment = false;\\n\\tstring curr = \"\";\\n\\tfor(int line=0;line<source.size();line++)\\n\\t{\\n\\t\\tint len = source[line].length();\\n\\t\\tfor(int i=0;i<source[line].length();i++)\\n\\t\\t{\\n\\t\\t\\tif(multilinecomment)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i<len-1 && source[line][i]==\\'*\\' && source[line][i+1]==\\'/\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmultilinecomment = false;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i<len-1 && source[line][i]==\\'/\\' && source[line][i+1]==\\'/\\')\\n\\t\\t\\t\\t\\tgoto next;\\n\\t\\t\\t\\telse if(i<len-1 && source[line][i]==\\'/\\' && source[line][i+1]==\\'*\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmultilinecomment = true;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurr += source[line][i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tnext:\\n\\t\\tif(!multilinecomment && curr!=\"\")\\n\\t\\t{\\n\\t\\t\\tres.push_back(curr);\\n\\t\\t\\tcurr = \"\";\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1559853,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>(); \\n        boolean commented = false; \\n        StringBuilder sb = new StringBuilder(); \\n        for (String line : source) {\\n            for (int i = 0; i < line.length(); i++) {\\n                if (commented) {\\n                    if (line.charAt(i) == \\'*\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        commented = false; \\n                        i++; \\n                    }\\n                }\\n                else {\\n                    if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'*\\') {\\n                        commented = true; \\n                        i++; \\n                    }\\n                    else if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        break;\\n                    }\\n                    else {\\n                        sb.append(line.charAt(i));\\n                    }\\n                }\\n            }\\n            if (!commented && sb.length() != 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder(); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>(); \\n        boolean commented = false; \\n        StringBuilder sb = new StringBuilder(); \\n        for (String line : source) {\\n            for (int i = 0; i < line.length(); i++) {\\n                if (commented) {\\n                    if (line.charAt(i) == \\'*\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        commented = false; \\n                        i++; \\n                    }\\n                }\\n                else {\\n                    if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'*\\') {\\n                        commented = true; \\n                        i++; \\n                    }\\n                    else if (line.charAt(i) == \\'/\\' && i < line.length()-1&& line.charAt(i+1) == \\'/\\') {\\n                        break;\\n                    }\\n                    else {\\n                        sb.append(line.charAt(i));\\n                    }\\n                }\\n            }\\n            if (!commented && sb.length() != 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder(); \\n            }\\n        }\\n        return res; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473316,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n\\n    def _remove(self, source, i, j, curr_line, res):\\n        \"\"\"Parse the source starting from the i-th line and the j-th character,\\n        when the parsed result of the current line is in curr_line and the parsed result so far is in res.\\n        \"\"\"\\n        if i == len(source):\\n            return\\n        # find two special symbols\\n        loc1 = source[i].find(\\'//\\', j)\\n        loc2 = source[i].find(\\'/*\\', j)\\n        \\n        if loc1 == loc2 == -1:\\n            # no comment in this line\\n            curr_line += source[i][j:]\\n            if len(curr_line) > 0:\\n                res.append(curr_line)\\n            self._remove(source, i+1, 0, \\'\\', res)\\n        elif (loc1 != -1 and loc2 == -1) or (loc1 != -1 and loc2 != -1 and loc1 < loc2):\\n            # single-line comment\\n            curr_line += source[i][j:loc1]\\n            if len(curr_line) > 0:\\n                res.append(curr_line)\\n            self._remove(source, i+1, 0, \\'\\', res)\\n        else:\\n            # multi-line comment\\n            curr_line += source[i][j:loc2]\\n            # find the closing */\\n            next_i = i\\n            while next_i < len(source):\\n                if next_i == i:\\n                    next_loc = source[next_i].find(\\'*/\\', loc2+2)\\n                else:\\n                    next_loc = source[next_i].find(\\'*/\\')\\n                if next_loc == -1:\\n                    next_i += 1\\n                else:\\n                    self._remove(source, next_i, next_loc+2, curr_line, res)\\n                    break\\n \\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        self._remove(source, 0, 0, \\'\\', res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def _remove(self, source, i, j, curr_line, res):\\n        \"\"\"Parse the source starting from the i-th line and the j-th character,\\n        when the parsed result of the current line is in curr_line and the parsed result so far is in res.\\n        \"\"\"\\n        if i == len(source):\\n            return\\n        # find two special symbols\\n        loc1 = source[i].find(\\'//\\', j)\\n        loc2 = source[i].find(\\'/*\\', j)\\n        \\n        if loc1 == loc2 == -1:\\n            # no comment in this line\\n            curr_line += source[i][j:]\\n            if len(curr_line) > 0:\\n                res.append(curr_line)\\n            self._remove(source, i+1, 0, \\'\\', res)\\n        elif (loc1 != -1 and loc2 == -1) or (loc1 != -1 and loc2 != -1 and loc1 < loc2):\\n            # single-line comment\\n            curr_line += source[i][j:loc1]\\n            if len(curr_line) > 0:\\n                res.append(curr_line)\\n            self._remove(source, i+1, 0, \\'\\', res)\\n        else:\\n            # multi-line comment\\n            curr_line += source[i][j:loc2]\\n            # find the closing */\\n            next_i = i\\n            while next_i < len(source):\\n                if next_i == i:\\n                    next_loc = source[next_i].find(\\'*/\\', loc2+2)\\n                else:\\n                    next_loc = source[next_i].find(\\'*/\\')\\n                if next_loc == -1:\\n                    next_i += 1\\n                else:\\n                    self._remove(source, next_i, next_loc+2, curr_line, res)\\n                    break\\n \\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        self._remove(source, 0, 0, \\'\\', res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462331,
                "title": "c-one-pass-simulation-o-n",
                "content": "The code explains it self, very easy to understand.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string tmp;\\n        bool seenblock = false;\\n        \\n        for (auto& s : source){\\n            for (int i = 0; i < s.size(); i++){\\n                if (seenblock){\\n                    if (s[i] == \\'*\\' && i+1 < s.size() && s[i+1] == \\'/\\'){\\n                        seenblock = false;\\n                        i++;\\n                    }\\n                }else {\\n                    if (s[i] == \\'/\\' && i+1 < s.size()){\\n                        if (s[i+1] == \\'/\\') {\\n                            break;\\n                        }else if (s[i+1] == \\'*\\') {\\n                            seenblock = true, i++;\\n                        }else{\\n                            tmp.push_back(s[i]);    \\n                        }\\n                    }else{\\n                        tmp.push_back(s[i]);\\n                    }\\n                }\\n            }\\n            \\n            if (!seenblock && tmp.size()) ans.push_back(tmp), tmp.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string tmp;\\n        bool seenblock = false;\\n        \\n        for (auto& s : source){\\n            for (int i = 0; i < s.size(); i++){\\n                if (seenblock){\\n                    if (s[i] == \\'*\\' && i+1 < s.size() && s[i+1] == \\'/\\'){\\n                        seenblock = false;\\n                        i++;\\n                    }\\n                }else {\\n                    if (s[i] == \\'/\\' && i+1 < s.size()){\\n                        if (s[i+1] == \\'/\\') {\\n                            break;\\n                        }else if (s[i+1] == \\'*\\') {\\n                            seenblock = true, i++;\\n                        }else{\\n                            tmp.push_back(s[i]);    \\n                        }\\n                    }else{\\n                        tmp.push_back(s[i]);\\n                    }\\n                }\\n            }\\n            \\n            if (!seenblock && tmp.size()) ans.push_back(tmp), tmp.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457370,
                "title": "python3-1-pass",
                "content": "\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans = []\\n        comment = False # True for block comment \\n        \\n        for line in source: \\n            if not comment: ans.append([]) # if not started as comment\\n            i = 0\\n            while i < len(line): \\n                if comment: \\n                    if line[i:i+2] == \"*/\": \\n                        comment = False \\n                        i += 1\\n                else:  \\n                    if line[i:i+2] == \"//\": break \\n                    elif line[i:i+2] == \"/*\": \\n                        comment = True \\n                        i += 1\\n                    else: ans[-1].append(line[i])\\n                i += 1\\n        return filter(None, map(\"\".join, ans))\\n```\\n\\nImplemented in C++\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans; \\n        string val; \\n        bool comment = false; \\n        \\n        for (auto& line : source) {\\n            if (!comment) val = \"\"; \\n            for (int i = 0; i < line.size(); ++i) \\n                if (comment) {\\n                    if (line.substr(i, 2) == \"*/\") {\\n                        comment = false; \\n                        ++i; \\n                    } \\n                } else \\n                    if (line.substr(i, 2) == \"//\") break; \\n                    else if (line.substr(i, 2) == \"/*\") {\\n                        comment = true; \\n                        ++i; \\n                    } else val.push_back(line[i]); \\n            if (!comment && val.size()) ans.push_back(val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans = []\\n        comment = False # True for block comment \\n        \\n        for line in source: \\n            if not comment: ans.append([]) # if not started as comment\\n            i = 0\\n            while i < len(line): \\n                if comment: \\n                    if line[i:i+2] == \"*/\": \\n                        comment = False \\n                        i += 1\\n                else:  \\n                    if line[i:i+2] == \"//\": break \\n                    elif line[i:i+2] == \"/*\": \\n                        comment = True \\n                        i += 1\\n                    else: ans[-1].append(line[i])\\n                i += 1\\n        return filter(None, map(\"\".join, ans))\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans; \\n        string val; \\n        bool comment = false; \\n        \\n        for (auto& line : source) {\\n            if (!comment) val = \"\"; \\n            for (int i = 0; i < line.size(); ++i) \\n                if (comment) {\\n                    if (line.substr(i, 2) == \"*/\") {\\n                        comment = false; \\n                        ++i; \\n                    } \\n                } else \\n                    if (line.substr(i, 2) == \"//\") break; \\n                    else if (line.substr(i, 2) == \"/*\") {\\n                        comment = true; \\n                        ++i; \\n                    } else val.push_back(line[i]); \\n            if (!comment && val.size()) ans.push_back(val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395358,
                "title": "99-77-faster-python-solution-easy-understand",
                "content": "There are many tricky cases I guess nobody like them.\\n```\\nclass Solution:\\n    def removeComments(self, source):\\n\\t    #decide the order for processing, return True if need to first process \\'//\\'\\n        def who_first(line, commenting): \\n            atype, btype, ctype = line.find(\\'//\\'), line.find(\\'/*\\'), line.find(\\'*/\\')\\n            if atype != -1 and ctype != -1 and commenting:\\n                if commenting and ctype > atype: \\n                    return False\\n                else: return ctype > atype\\n            elif atype != -1 and btype != -1:\\n                return btype > atype\\n            return atype != -1\\n\\n        commenting, outputs, remained = False, [], \\'\\'\\n        for line in source:\\n            output = []\\n            while True: #only execute one time in most cases\\n\\t\\t\\t\\n\\t\\t\\t    #processing \\'//\\'\\n                if line.find(\\'//\\') != -1 and who_first(line, commenting):\\n                    line = line[:line.find(\\'//\\')]\\n                    if len(line) > 0: output.append(line)\\n                \\n\\t\\t\\t\\t#processing \\'/*\\'\\n                if not commenting and line.find(\\'/*\\') != -1:\\n                    remained, line, commenting = line[:line.find(\\'/*\\')], line[line.find(\\'/*\\')+2:], True\\n\\n\\t\\t\\t\\t#processing \\'*/\\', call the main body again if there are some remainings comments in this line\\n                if commenting and line.find(\\'*/\\') != -1:\\n                    line = line[line.find(\\'*/\\')+2:]\\n                    line, remained, commenting =remained + line, \\'\\', False\\n                    #processing unfinished comments\\n                    if line.find(\\'//\\')!=-1 or line.find(\\'/*\\')!=-1 or line.find(\\'*/\\')!=-1: continue\\n                    if len(line) > 0: output.append(line)\\n                break\\n\\n            if len(output) > 0: outputs.append(\\'\\'.join(output)) #lines with comments removed\\n            elif not commenting and len(line) > 0: outputs.append(line) #normal lines\\n        return outputs\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source):\\n\\t    #decide the order for processing, return True if need to first process \\'//\\'\\n        def who_first(line, commenting): \\n            atype, btype, ctype = line.find(\\'//\\'), line.find(\\'/*\\'), line.find(\\'*/\\')\\n            if atype != -1 and ctype != -1 and commenting:\\n                if commenting and ctype > atype: \\n                    return False\\n                else: return ctype > atype\\n            elif atype != -1 and btype != -1:\\n                return btype > atype\\n            return atype != -1\\n\\n        commenting, outputs, remained = False, [], \\'\\'\\n        for line in source:\\n            output = []\\n            while True: #only execute one time in most cases\\n\\t\\t\\t\\n\\t\\t\\t    #processing \\'//\\'\\n                if line.find(\\'//\\') != -1 and who_first(line, commenting):\\n                    line = line[:line.find(\\'//\\')]\\n                    if len(line) > 0: output.append(line)\\n                \\n\\t\\t\\t\\t#processing \\'/*\\'\\n                if not commenting and line.find(\\'/*\\') != -1:\\n                    remained, line, commenting = line[:line.find(\\'/*\\')], line[line.find(\\'/*\\')+2:], True\\n\\n\\t\\t\\t\\t#processing \\'*/\\', call the main body again if there are some remainings comments in this line\\n                if commenting and line.find(\\'*/\\') != -1:\\n                    line = line[line.find(\\'*/\\')+2:]\\n                    line, remained, commenting =remained + line, \\'\\', False\\n                    #processing unfinished comments\\n                    if line.find(\\'//\\')!=-1 or line.find(\\'/*\\')!=-1 or line.find(\\'*/\\')!=-1: continue\\n                    if len(line) > 0: output.append(line)\\n                break\\n\\n            if len(output) > 0: outputs.append(\\'\\'.join(output)) #lines with comments removed\\n            elif not commenting and len(line) > 0: outputs.append(line) #normal lines\\n        return outputs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394758,
                "title": "python-solve-it-without-skills",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        source = \\'\\\\n\\'.join(source)\\n        \\n        head, tail, ans = 0, 0, []\\n        \\n        while tail < len(source):\\n            token = source[tail:tail+2]\\n            \\n            if token == \\'//\\':\\n                ans.append(source[head:tail])\\n                \\n                while tail < len(source) and source[tail] != \\'\\\\n\\':\\n                    tail += 1\\n                head = tail\\n            elif token == \\'/*\\':\\n                ans.append(source[head:tail])\\n                tail += 2\\n                \\n                while tail < len(source) and source[tail:tail+2] != \\'*/\\':\\n                    tail += 1\\n                tail += 2\\n                head = tail\\n            else:\\n                tail += 1\\n\\n        ans.append(source[head:tail])\\n                \\n        return [line for line in \\'\\'.join(ans).split(\\'\\\\n\\') if line]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        source = \\'\\\\n\\'.join(source)\\n        \\n        head, tail, ans = 0, 0, []\\n        \\n        while tail < len(source):\\n            token = source[tail:tail+2]\\n            \\n            if token == \\'//\\':\\n                ans.append(source[head:tail])\\n                \\n                while tail < len(source) and source[tail] != \\'\\\\n\\':\\n                    tail += 1\\n                head = tail\\n            elif token == \\'/*\\':\\n                ans.append(source[head:tail])\\n                tail += 2\\n                \\n                while tail < len(source) and source[tail:tail+2] != \\'*/\\':\\n                    tail += 1\\n                tail += 2\\n                head = tail\\n            else:\\n                tail += 1\\n\\n        ans.append(source[head:tail])\\n                \\n        return [line for line in \\'\\'.join(ans).split(\\'\\\\n\\') if line]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344729,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();     \\n        boolean mode = false;\\n        for (String s : source) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (mode) { // mode 1: /**/\\n                    if (s.charAt(i) == \\'*\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'/\\') {\\n                        mode = false;\\n                        i++;        //skip \\'/\\' on next iteration of i\\n                    }\\n                } else {  // mode 2: //\\n                    if (s.charAt(i) == \\'/\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'/\\') {\\n                        break;      //ignore remaining characters on line s\\n                    } else if (s.charAt(i) == \\'/\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'*\\') {\\n                        mode = true;\\n                        i++;           //skip \\'*\\' on next iteration of i\\n                    } else {\\n                        sb.append(s.charAt(i));     //not a comment\\n                    }\\n                }\\n            }\\n            if (!mode && sb.length() > 0) { // no comments or // comment\\n                res.add(sb.toString());\\n                sb = new StringBuilder();   //reset for next line of source code\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();     \\n        boolean mode = false;\\n        for (String s : source) {\\n            for (int i = 0; i < s.length(); i++) {\\n                if (mode) { // mode 1: /**/\\n                    if (s.charAt(i) == \\'*\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'/\\') {\\n                        mode = false;\\n                        i++;        //skip \\'/\\' on next iteration of i\\n                    }\\n                } else {  // mode 2: //\\n                    if (s.charAt(i) == \\'/\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'/\\') {\\n                        break;      //ignore remaining characters on line s\\n                    } else if (s.charAt(i) == \\'/\\' && i < s.length() - 1 && s.charAt(i + 1) == \\'*\\') {\\n                        mode = true;\\n                        i++;           //skip \\'*\\' on next iteration of i\\n                    } else {\\n                        sb.append(s.charAt(i));     //not a comment\\n                    }\\n                }\\n            }\\n            if (!mode && sb.length() > 0) { // no comments or // comment\\n                res.add(sb.toString());\\n                sb = new StringBuilder();   //reset for next line of source code\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200273,
                "title": "c-1-pass-4-cases-with-explaination-and-comments",
                "content": "We maintain 3 states - `NO_COMMENT`, `SINGLE_COMMENT` and `BLOCK_COMMENT`.\\n\\nAnd transition based on the token we encounter while parsing the input file.\\n\\nBy default, we are in `NO_COMMENT` state.\\n*Case 1* : We parse through source file to find single line comment. if we find it and we are in `NO_COMMENT` state, we change state to `SINGLE_COMMENT`.\\n*Case 2*: We parse through source file to find start block comment. if we find it and we are in `NO_COMMENT` state, we change state to `BLOCK_COMMENT`\\n*Case 3*: We parse through source file to find end block comment. if we find it and we are in `BLOCK_COMMENT` state, we change state to `NO_COMMENT`\\n*Case 4*: We are in `NO_COMMENT` state, so we append the output to the current line.\\n\\nAt the end of line parsing, if we are in `SINGLE_COMMENT` state, we reset to `NO_COMMENT`.\\n\\n**If this helped you, please upvote!**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    enum st { // states are either no comment, single comment or block comment\\n        NO_COMMENT=1,\\n        SINGLE,\\n        BLOCK,\\n    };\\n    \\n    vector<string> removeComments(vector<string>& source) {\\n        int n = source.size();\\n        enum st state = NO_COMMENT; \\n        \\n        int i, j;\\n        \\n        vector <string> out(1); // start with empty current output line\\n        int outi=0; // index for output line\\n        \\n        for (i = 0; i < n;i++) {\\n            int m = source[i].size();\\n            for (j = 0 ; j < m; j++) {\\n                if (j < m-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'/\\' && state == NO_COMMENT) { \\n\\t\\t\\t\\t// Case 1: currently, we are in no comment, and we encounter //\\n                        state = SINGLE;\\n                        j++;\\n                }\\n                else if (j < m-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'*\\' \\n                         && state == NO_COMMENT) {\\n\\t\\t\\t\\t\\t\\t // Case 2: currently, we are in no comment, and we encounter / and *\\n                        state = BLOCK;\\n                        j++;\\n                }\\n                else if (j < m-1 && source[i][j] == \\'*\\' && source[i][j+1] == \\'/\\' \\n                         && state == BLOCK) {\\n\\t\\t\\t\\t\\t\\t // Case 3: currently we are in block comment, and we encounter close * and /\\n                        state = NO_COMMENT;\\n                        j++;\\n                } else {\\n\\t\\t\\t\\t// Case 4 if currently in no comment state, append output\\n                    if (state == NO_COMMENT) {\\n                        out[outi] += source[i][j];\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if we recently removed single comment, reset to no comment\\n            if (state == SINGLE)\\n                state = NO_COMMENT;\\n\\t\\t\\t\\t// if we have some output in the current line, add new line for output\\n            if (state == NO_COMMENT && out[outi].size() != 0) {\\n                outi++;\\n                out.push_back(\"\");\\n            }\\n        }\\n        // there might be 1 additional null line in output, remove that line\\n        if (out[out.size()-1].size() == 0)\\n            out.pop_back();\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    enum st { // states are either no comment, single comment or block comment\\n        NO_COMMENT=1,\\n        SINGLE,\\n        BLOCK,\\n    };\\n    \\n    vector<string> removeComments(vector<string>& source) {\\n        int n = source.size();\\n        enum st state = NO_COMMENT; \\n        \\n        int i, j;\\n        \\n        vector <string> out(1); // start with empty current output line\\n        int outi=0; // index for output line\\n        \\n        for (i = 0; i < n;i++) {\\n            int m = source[i].size();\\n            for (j = 0 ; j < m; j++) {\\n                if (j < m-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'/\\' && state == NO_COMMENT) { \\n\\t\\t\\t\\t// Case 1: currently, we are in no comment, and we encounter //\\n                        state = SINGLE;\\n                        j++;\\n                }\\n                else if (j < m-1 && source[i][j] == \\'/\\' && source[i][j+1] == \\'*\\' \\n                         && state == NO_COMMENT) {\\n\\t\\t\\t\\t\\t\\t // Case 2: currently, we are in no comment, and we encounter / and *\\n                        state = BLOCK;\\n                        j++;\\n                }\\n                else if (j < m-1 && source[i][j] == \\'*\\' && source[i][j+1] == \\'/\\' \\n                         && state == BLOCK) {\\n\\t\\t\\t\\t\\t\\t // Case 3: currently we are in block comment, and we encounter close * and /\\n                        state = NO_COMMENT;\\n                        j++;\\n                } else {\\n\\t\\t\\t\\t// Case 4 if currently in no comment state, append output\\n                    if (state == NO_COMMENT) {\\n                        out[outi] += source[i][j];\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if we recently removed single comment, reset to no comment\\n            if (state == SINGLE)\\n                state = NO_COMMENT;\\n\\t\\t\\t\\t// if we have some output in the current line, add new line for output\\n            if (state == NO_COMMENT && out[outi].size() != 0) {\\n                outi++;\\n                out.push_back(\"\");\\n            }\\n        }\\n        // there might be 1 additional null line in output, remove that line\\n        if (out[out.size()-1].size() == 0)\\n            out.pop_back();\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197432,
                "title": "c-solution-easy-to-read-and-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& sources) {\\n        bool blockComment = false;\\n        vector<string> ans;\\n        string s = \"\";\\n        for(auto source : sources) {\\n            int i = 0;\\n            int n = source.size() - 1;\\n            for(; i < n; i++) {\\n                if(!blockComment && source[i] == \\'/\\' && source[i + 1] == \\'/\\') {\\n                    break;\\n                } else if(!blockComment && source[i] == \\'/\\' && source[i + 1] == \\'*\\') {\\n                    i++;\\n                    blockComment = true;\\n                } else if(blockComment && source[i] == \\'*\\' && source[i + 1] == \\'/\\') {\\n                    i++;\\n                    blockComment = false;\\n                } else if(!blockComment) {\\n                    s += source[i];\\n                }\\n            }\\n\\n            if(i == source.size() - 1 && !blockComment) {\\n                s += source[i];\\n            }\\n            \\n            if(s.size() && !blockComment) {\\n                ans.push_back(s);\\n                s = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& sources) {\\n        bool blockComment = false;\\n        vector<string> ans;\\n        string s = \"\";\\n        for(auto source : sources) {\\n            int i = 0;\\n            int n = source.size() - 1;\\n            for(; i < n; i++) {\\n                if(!blockComment && source[i] == \\'/\\' && source[i + 1] == \\'/\\') {\\n                    break;\\n                } else if(!blockComment && source[i] == \\'/\\' && source[i + 1] == \\'*\\') {\\n                    i++;\\n                    blockComment = true;\\n                } else if(blockComment && source[i] == \\'*\\' && source[i + 1] == \\'/\\') {\\n                    i++;\\n                    blockComment = false;\\n                } else if(!blockComment) {\\n                    s += source[i];\\n                }\\n            }\\n\\n            if(i == source.size() - 1 && !blockComment) {\\n                s += source[i];\\n            }\\n            \\n            if(s.size() && !blockComment) {\\n                ans.push_back(s);\\n                s = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182248,
                "title": "c-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        bool com=false;\\n        int type=0;\\n        string temp=\"\";\\n        for(auto s:source){\\n            int n=s.size();\\n            for(int i=0;i<n;i++){\\n                if(com==false){\\n                    if(s[i]==\\'/\\' && i!=n-1){\\n                        if(s[i+1]==\\'/\\'){\\n                            com=true,type=0,i++;\\n                        }else if(s[i+1]==\\'*\\'){\\n                            com=true,type=1,i++;\\n                        }\\n                        else temp+=s[i];\\n                    }\\n                    else temp+=s[i];\\n                }\\n                else if(type==0)break;\\n                else if(type==1){\\n                    if(s[i]==\\'*\\' && i!=n-1){\\n                        if(s[i+1]==\\'/\\') {\\n                            com=false,i++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(type==0 && com){\\n                if(temp.size())ans.push_back(temp);\\n                temp=\"\",com=false;\\n            }\\n            else if(type==1 && com){\\n                continue;\\n            }\\n            else if(com==false && temp.size()){\\n                ans.push_back(temp),temp=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        bool com=false;\\n        int type=0;\\n        string temp=\"\";\\n        for(auto s:source){\\n            int n=s.size();\\n            for(int i=0;i<n;i++){\\n                if(com==false){\\n                    if(s[i]==\\'/\\' && i!=n-1){\\n                        if(s[i+1]==\\'/\\'){\\n                            com=true,type=0,i++;\\n                        }else if(s[i+1]==\\'*\\'){\\n                            com=true,type=1,i++;\\n                        }\\n                        else temp+=s[i];\\n                    }\\n                    else temp+=s[i];\\n                }\\n                else if(type==0)break;\\n                else if(type==1){\\n                    if(s[i]==\\'*\\' && i!=n-1){\\n                        if(s[i+1]==\\'/\\') {\\n                            com=false,i++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(type==0 && com){\\n                if(temp.size())ans.push_back(temp);\\n                temp=\"\",com=false;\\n            }\\n            else if(type==1 && com){\\n                continue;\\n            }\\n            else if(com==false && temp.size()){\\n                ans.push_back(temp),temp=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136112,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> removeComments(vector<string>& source) {\\n\\t\\t\\tvector<string>res;\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring res1=\"\";\\n\\t\\t\\tfor(int i=0;i<source.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=source[i];\\n\\n\\n\\t\\t\\t\\tfor(int j=0;j<s.size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[j]!=\\'/\\' && c==0)\\n\\t\\t\\t\\t\\t\\tres1+=s[j];\\n\\t\\t\\t\\t\\telse if(s[j]==\\'/\\' && c==0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(s[j+1]==\\'/\\' && c==0)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse if(s[j+1]==\\'*\\')\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tc=1;\\n\\t\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(c==0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tres1+=s[j];\\n\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(s[j]==\\'*\\' && c==1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(s[j+1]==\\'/\\')\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tc=0;\\n\\t\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(res1.size()>0 && c==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t   res.push_back(res1);\\n\\t\\t\\t\\t\\tres1=\"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> removeComments(vector<string>& source) {\\n\\t\\t\\tvector<string>res;\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring res1=\"\";\\n\\t\\t\\tfor(int i=0;i<source.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring s=source[i];\\n\\n\\n\\t\\t\\t\\tfor(int j=0;j<s.size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[j]!=\\'/\\' && c==0)\\n\\t\\t\\t\\t\\t\\tres1+=s[j];\\n\\t\\t\\t\\t\\telse if(s[j]==\\'/\\' && c==0 )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(s[j+1]==\\'/\\' && c==0)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse if(s[j+1]==\\'*\\')\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tc=1;\\n\\t\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1109152,
                "title": "c-easy-to-understand-fully-commented",
                "content": "\\n\\n\\tclass Solution {\\n\\tpublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        \\n        int i = 0, j = 0;\\n        string text = \"\";\\n        \\n        // flag1 -- true if found \"//\"\\n        // flag2 -- tru if found \"/*\", false if found \"*/\"\\n        \\n\\t\\t/*\\n\\t\\t// -- comment stmt\\n\\t\\t/*--*/ -- blocking stmt\\n\\t\\t*/\\n\\t\\t\\n        bool flag1, flag2;\\n        flag1 = flag2 = false;\\n        \\n        while(i < source.size()) {\\n            string stext = source[i];\\n            \\n            j = 0;\\n            \\n            while(j < stext.size()) {        \\n                string sub = stext.substr(j, 2);\\n                \\n                // if \"//\" is found and we\\'re not in blocking statement\\n                // here j++ becoz, second \\'/\\'\\'s contribution has been taken in\\n                // comment stmt\\n                if(sub == \"//\" && !flag2)\\n                    flag1 = true, j++;\\n                \\n                // blocking stmt found and we\\'re not in commented stmt\\n                // here j++ becoz \\'*\\'\\'s contribution has been taken in blocking\\n                // stmt so to avoid it\\'s further usage\\n                else if(sub == \"/*\" && !flag2 && !flag1)\\n                    flag2 = true, j++;\\n                \\n                // if neither flag is set\\n                else if(!flag1 && !flag2)\\n                    text.push_back(stext[j]);\\n                \\n                // if blocking stmt is getting closed\\n                // here j++ becoz, \\'/\\'\\'s contribution has been taken in closing the\\n                // blocking stmt\\n                else if(sub == \"*/\" && flag2)\\n                    flag2 = false, j++;\\n                \\n                j++;\\n            }\\n            \\n            flag1 = false;\\n            \\n            if(text.size() && !flag2)\\n                ans.push_back(text), text.clear();\\n            \\n            i++;\\n        }\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        \\n        int i = 0, j = 0;\\n        string text = \"\";\\n        \\n        // flag1 -- true if found \"//\"\\n        // flag2 -- tru if found \"/*\", false if found \"*/\"\\n        \\n\\t\\t/*\\n\\t\\t// -- comment stmt\\n\\t\\t/*--*/ -- blocking stmt\\n\\t\\t*/\\n\\t\\t\\n        bool flag1, flag2;\\n        flag1 = flag2 = false;\\n        \\n        while(i < source.size()) {\\n            string stext = source[i];\\n            \\n            j = 0;\\n            \\n            while(j < stext.size()) {        \\n                string sub = stext.substr(j, 2);\\n                \\n                // if \"//\" is found and we\\'re not in blocking statement\\n                // here j++ becoz, second \\'/\\'\\'s contribution has been taken in\\n                // comment stmt\\n                if(sub == \"//\" && !flag2)\\n                    flag1 = true, j++;\\n                \\n                // blocking stmt found and we\\'re not in commented stmt\\n                // here j++ becoz \\'*\\'\\'s contribution has been taken in blocking\\n                // stmt so to avoid it\\'s further usage\\n                else if(sub == \"/*\" && !flag2 && !flag1)\\n                    flag2 = true, j++;\\n                \\n                // if neither flag is set\\n                else if(!flag1 && !flag2)\\n                    text.push_back(stext[j]);\\n                \\n                // if blocking stmt is getting closed\\n                // here j++ becoz, \\'/\\'\\'s contribution has been taken in closing the\\n                // blocking stmt\\n                else if(sub == \"*/\" && flag2)\\n                    flag2 = false, j++;\\n                \\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1064469,
                "title": "simple-21-line-c-regex-solution-easy-to-understand-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        bool block = false;\\n        for(int i = 0; i < (int)source.size(); i++) {\\n            string s = source[i];\\n            // get rid of \\'...*/\\' and if found set block to false\\n            bool close = false;\\n            if(regex_search(s, regex(\"\\\\\\\\*/\")) && block) {\\n                s = regex_replace(s, regex(\".*?\\\\\\\\*/\"), \"\", regex_constants::format_first_only);\\n                block = false;\\n                close = true;\\n            }\\n            if(block) continue;\\n            // get rid of all \\'/*....*/\\' and \\'//..\\'\\n            s = regex_replace(s, regex(\"/\\\\\\\\*.*?\\\\\\\\*/|//.*\"), \"\");\\n            // then get rid of \\'/*...\\' and if found set block to true\\n            if(regex_search(s, regex(\"/\\\\\\\\*\"))) {\\n                s = regex_replace(s, regex(\"/\\\\\\\\*.*\"), \"\");\\n                block = true;\\n            }\\n            // if current line is not empty add to res\\n            if(s.empty()) continue;\\n            if(close) res.back() += s;\\n            else res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> res;\\n        bool block = false;\\n        for(int i = 0; i < (int)source.size(); i++) {\\n            string s = source[i];\\n            // get rid of \\'...*/\\' and if found set block to false\\n            bool close = false;\\n            if(regex_search(s, regex(\"\\\\\\\\*/\")) && block) {\\n                s = regex_replace(s, regex(\".*?\\\\\\\\*/\"), \"\", regex_constants::format_first_only);\\n                block = false;\\n                close = true;\\n            }\\n            if(block) continue;\\n            // get rid of all \\'/*....*/\\' and \\'//..\\'\\n            s = regex_replace(s, regex(\"/\\\\\\\\*.*?\\\\\\\\*/|//.*\"), \"\");\\n            // then get rid of \\'/*...\\' and if found set block to true\\n            if(regex_search(s, regex(\"/\\\\\\\\*\"))) {\\n                s = regex_replace(s, regex(\"/\\\\\\\\*.*\"), \"\");\\n                block = true;\\n            }\\n            // if current line is not empty add to res\\n            if(s.empty()) continue;\\n            if(close) res.back() += s;\\n            else res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039541,
                "title": "c-readable-40-lines-solution",
                "content": "```\\npublic class Solution\\n{\\n    public IList<string> RemoveComments(string[] source)\\n    {\\n        var result = new List<string>();\\n        \\n        var sb = new StringBuilder();\\n        var insideBlock = false;\\n        foreach(var str in source)\\n        {\\n            sb = insideBlock ? sb : sb.Clear();\\n            for(var i = 0; i < str.Length; i++)\\n            {\\n                var curr = str[i];\\n                var next = i != str.Length - 1 ? str[i+1] : \\'!\\';\\n\\n                if(insideBlock)\\n                {\\n                    if(curr == \\'*\\' && next == \\'/\\')\\n                    {\\n                        i++;\\n                        insideBlock = false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(curr == \\'/\\' && next == \\'/\\') break;\\n                    else if(curr == \\'/\\' && next == \\'*\\')\\n                    {\\n                        i++;\\n                        insideBlock = true;\\n                    }\\n                    else sb.Append(curr);\\n                }                \\n            }\\n            \\n            if(!insideBlock && sb.Length > 0)\\n            {\\n                result.Add(sb.ToString());\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> RemoveComments(string[] source)\\n    {\\n        var result = new List<string>();\\n        \\n        var sb = new StringBuilder();\\n        var insideBlock = false;\\n        foreach(var str in source)\\n        {\\n            sb = insideBlock ? sb : sb.Clear();\\n            for(var i = 0; i < str.Length; i++)\\n            {\\n                var curr = str[i];\\n                var next = i != str.Length - 1 ? str[i+1] : \\'!\\';\\n\\n                if(insideBlock)\\n                {\\n                    if(curr == \\'*\\' && next == \\'/\\')\\n                    {\\n                        i++;\\n                        insideBlock = false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(curr == \\'/\\' && next == \\'/\\') break;\\n                    else if(curr == \\'/\\' && next == \\'*\\')\\n                    {\\n                        i++;\\n                        insideBlock = true;\\n                    }\\n                    else sb.Append(curr);\\n                }                \\n            }\\n            \\n            if(!insideBlock && sb.Length > 0)\\n            {\\n                result.Add(sb.ToString());\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981251,
                "title": "python-one-pass-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        \\'\\'\\'\\n        is_block shows if we\\'re in a block comment or not\\n        Iterate over current line and detect line comments or start/end of block comments.\\n        End line early for a line comment, update is_block for block start/end and continue\\n        Only create new res_line if we reach the end of a line and is_block is false. \\n            This accounts for test cases like [\"a/*comment\", \"line\", \"more_comment*/b\"] -> [\"ab\"].\\n        \\'\\'\\'\\n        \\n        # define vars\\n        is_block = False\\n        res_line = []\\n        result = []\\n        \\n        # iterate over lines \\n        for source_line in source:\\n        \\n            # iterate over characters in line, look ahead for comment denoters\\n            i = 0\\n            while i < len(source_line):\\n            \\n                char = source_line[i]\\n\\n                # is this the start of a line comment?\\n                if not is_block and source_line[i:i+2] == \\'//\\':\\n                    i = len(source_line) # skip to end\\n\\n                # is this the start of a block comment?\\n                elif not is_block and source_line[i:i+2] == \\'/*\\':\\n                    is_block = True\\n                    i += 2\\n\\n                # is this the end of a block comment?\\n                elif is_block and source_line[i:i+2] == \\'*/\\':\\n                    is_block = False\\n                    i += 2\\n                    \\n                # we\\'re in a block comment, skip the char\\n                elif is_block:\\n                    i += 1\\n                    \\n                # we can add the char\\n                else:\\n                    res_line.append(char)\\n                    i += 1\\n                    \\n            # if not is_block, add to result and reset, filter empty lines\\n            if res_line and not is_block:\\n                result.append(\\'\\'.join(res_line))\\n                res_line = []\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        \\'\\'\\'\\n        is_block shows if we\\'re in a block comment or not\\n        Iterate over current line and detect line comments or start/end of block comments.\\n        End line early for a line comment, update is_block for block start/end and continue\\n        Only create new res_line if we reach the end of a line and is_block is false. \\n            This accounts for test cases like [\"a/*comment\", \"line\", \"more_comment*/b\"] -> [\"ab\"].\\n        \\'\\'\\'\\n        \\n        # define vars\\n        is_block = False\\n        res_line = []\\n        result = []\\n        \\n        # iterate over lines \\n        for source_line in source:\\n        \\n            # iterate over characters in line, look ahead for comment denoters\\n            i = 0\\n            while i < len(source_line):\\n            \\n                char = source_line[i]\\n\\n                # is this the start of a line comment?\\n                if not is_block and source_line[i:i+2] == \\'//\\':\\n                    i = len(source_line) # skip to end\\n\\n                # is this the start of a block comment?\\n                elif not is_block and source_line[i:i+2] == \\'/*\\':\\n                    is_block = True\\n                    i += 2\\n\\n                # is this the end of a block comment?\\n                elif is_block and source_line[i:i+2] == \\'*/\\':\\n                    is_block = False\\n                    i += 2\\n                    \\n                # we\\'re in a block comment, skip the char\\n                elif is_block:\\n                    i += 1\\n                    \\n                # we can add the char\\n                else:\\n                    res_line.append(char)\\n                    i += 1\\n                    \\n            # if not is_block, add to result and reset, filter empty lines\\n            if res_line and not is_block:\\n                result.append(\\'\\'.join(res_line))\\n                res_line = []\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961622,
                "title": "java-simple-one-pass-with-explanation-beats-100",
                "content": "Made code a bit more verbose than needed in order to accomodate more explanation inline.\\n\\n```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList();\\n        StringBuilder buffer = new StringBuilder();\\n        boolean blockComment = false;\\n        for(String line : source) {\\n            if(blockComment) {\\n                // don\\'t touch buffer, it has some chars from previous line where block comment started\\n            } else {\\n                // it\\'s fresh new line, fresh start\\n                buffer.setLength(0);\\n            }   \\n\\n            for(int i = 0; i < line.length(); i++) {\\n                if(blockComment) {\\n                    if(line.startsWith(\"*/\", i)) {\\n                        blockComment = false;\\n                        i++;// skip that forward slash character\\n                    } else {\\n                        // we\\'re still in comment, skipping chars\\n                    }\\n                } else if(line.startsWith(\"/*\", i)) {\\n                    blockComment = true;\\n                    i++;// skip that star character\\n                } else if(line.startsWith(\"//\", i)) {\\n                    break;// no need to move further in this line\\n                } else {\\n                    // legit character\\n                    buffer.append(line.charAt(i));\\n                }\\n            }\\n\\n            if(buffer.length() > 0){\\n                if(blockComment) {\\n                    // do nothing, keep buffer for later\\n                } else {\\n                    // this line is done\\n                    result.add(buffer.toString());\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\np.s. I hate text parsing",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> result = new ArrayList();\\n        StringBuilder buffer = new StringBuilder();\\n        boolean blockComment = false;\\n        for(String line : source) {\\n            if(blockComment) {\\n                // don\\'t touch buffer, it has some chars from previous line where block comment started\\n            } else {\\n                // it\\'s fresh new line, fresh start\\n                buffer.setLength(0);\\n            }   \\n\\n            for(int i = 0; i < line.length(); i++) {\\n                if(blockComment) {\\n                    if(line.startsWith(\"*/\", i)) {\\n                        blockComment = false;\\n                        i++;// skip that forward slash character\\n                    } else {\\n                        // we\\'re still in comment, skipping chars\\n                    }\\n                } else if(line.startsWith(\"/*\", i)) {\\n                    blockComment = true;\\n                    i++;// skip that star character\\n                } else if(line.startsWith(\"//\", i)) {\\n                    break;// no need to move further in this line\\n                } else {\\n                    // legit character\\n                    buffer.append(line.charAt(i));\\n                }\\n            }\\n\\n            if(buffer.length() > 0){\\n                if(blockComment) {\\n                    // do nothing, keep buffer for later\\n                } else {\\n                    // this line is done\\n                    result.add(buffer.toString());\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944912,
                "title": "java-100-python-how-to-draw-a-program",
                "content": "From my perspective, this is actually a Hard problem, because there are some tricky details which can easily be messed up during the actual interview. \\n\\nHowever, I can suggest the general approach to this kind of problems: identity states that program can be in, what are transition between states and what actions are to be performed during such transitions. This thing is called as Finite State Automaton among friends. So the first thing to do is to draw a program!\\n\\nFor this problem, states are as follows:\\n0 - \\'normal code\\' state, we are not inside the comment.\\n1 - \\'/\\' symbol encountered (expecting \\'*\\' or \\'/\\')-state\\n2 - we are inside block comment state  /* ... */ \\n3 - we are inside block comment, expecting closing \\'/\\n\\n![image](https://assets.leetcode.com/users/images/0b2a648f-e71b-4e8f-85cb-779c07ca55f2_1606032187.6626997.png)\\n\\nAfter that, \\'simply\\' code it:\\n\\nJava beats 100%:\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<String> removeComments(String[] src) {\\n        List<String> lines = new ArrayList<>();\\n        StringBuilder currentLine = new StringBuilder();\\n\\n        int state = 0;\\n\\n        for (String l : src) {\\n            for (int i = 0; i < l.length(); i++) {\\n                char ch = l.charAt(i); // only look at current character, no lookaheads\\n                if (state == 0) {\\n                    if (ch == \\'/\\') {\\n                        state = 1; // \\'expecting comment start\\' state\\n                    }\\n                    currentLine.append(ch);\\n                } else if (state == 1) {\\n                    if (ch == \\'/\\') { // started line comment - skip rest of the line\\n                        currentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\n                        state = 0;\\n                        break;\\n                    } else if (ch == \\'*\\') { // started block comment - skip everything until */\\n                        currentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\n                        state = 2;\\n                    } else { // failed to start line or block comment -> back to \\'normal\\' state\\n                        currentLine.append(ch);\\n                        state = 0;\\n                    }\\n                } else if (state == 2) {\\n                    if (ch == \\'*\\') { // \\'expecting block comment end\\' state\\n                        state = 3;\\n                    }\\n                } else if (state == 3) {\\n                    if (ch == \\'/\\') { // block comment end -> back to \\'normal\\' state\\n                        state = 0;\\n                    } else {\\n                        state = ch != \\'*\\' ? 2 : 3; // failed to end block comment - stay in the block comment state\\n                    }\\n                }\\n            }\\n\\n            if (state == 1) { // line processed, failed to start comment ->  back to \\'normal\\' state\\n                state = 0;\\n            }\\n\\n            if (state != 2 && state != 3 && currentLine.length() != 0) { // if we are not in block comment and currentLine not empty\\n                lines.add(currentLine.toString());\\n                currentLine.setLength(0); // clear current line\\n            }\\n        }\\n\\n        return lines;\\n    }\\n}\\n```\\n\\nPython implementation:\\n```\\nclass Solution(object):\\n    def removeComments(self, src):\\n        state = 0  # 0 - norm code, 1 - meet /, 2 - in block comment, 3 meet \\'*\\'\\n\\n        lines = []  # processed lines\\n        current_line_buffer = []\\n\\n        for line in src:\\n            for c in line:  # only look at current character, no lookaheads\\n                if state == 0:\\n                    if c == \\'/\\':\\n                        state = 1  # \\'expecting comment start\\' state\\n                    current_line_buffer.append(c)\\n                elif state == 1:\\n                    if c == \\'/\\':  # started line comment - skip rest of the line\\n                        current_line_buffer.pop()  # pop prev char\\n                        state = 0\\n                        break\\n                    elif c == \\'*\\':  # started block comment - skip everything until */\\n                        current_line_buffer.pop()  # pop prev char\\n                        state = 2\\n                    else:  # failed to start line or block comment -> back to \\'normal\\' state\\n                        current_line_buffer.append(c)\\n                        state = 0\\n                elif state == 2:\\n                    if c == \\'*\\':\\n                        state = 3\\n                elif state == 3:\\n                    if c == \\'/\\':  # block comment end -> back to \\'normal\\' state\\n                        state = 0\\n                    else:\\n                        state = 2 if c != \\'*\\' else 3  # failed to end block comment - stay in the block comment state\\n\\n            if state == 1:  # line processed, failed to start comment ->  back to \\'normal\\' state\\n                state = 0\\n\\n            if state not in (2, 3) and current_line_buffer:  # if we are not in block comment and currentLine not empty\\n                lines.append(\\'\\'.join(current_line_buffer))\\n                current_line_buffer.clear()\\n\\n        return lines\\n\\n```\\n\\nNote about Java implementation. First of all, it works by processing one character at a time, no lookaheads. Second, it is  crucial for performance to use the approrpiate data structure for the character-buffer-with-pop structure. \\n\\n```\\nStringBuilder currentLine = new StringBuilder(); // character buffer\\n//...\\ncurrentLine.append(c); // append\\n// ...\\ncurrentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\nlines.add(currentLine.toString()); // convert the buffer to String\\n\\ncurrentLine.setLength(0); // clear the buffer\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<String> removeComments(String[] src) {\\n        List<String> lines = new ArrayList<>();\\n        StringBuilder currentLine = new StringBuilder();\\n\\n        int state = 0;\\n\\n        for (String l : src) {\\n            for (int i = 0; i < l.length(); i++) {\\n                char ch = l.charAt(i); // only look at current character, no lookaheads\\n                if (state == 0) {\\n                    if (ch == \\'/\\') {\\n                        state = 1; // \\'expecting comment start\\' state\\n                    }\\n                    currentLine.append(ch);\\n                } else if (state == 1) {\\n                    if (ch == \\'/\\') { // started line comment - skip rest of the line\\n                        currentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\n                        state = 0;\\n                        break;\\n                    } else if (ch == \\'*\\') { // started block comment - skip everything until */\\n                        currentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\n                        state = 2;\\n                    } else { // failed to start line or block comment -> back to \\'normal\\' state\\n                        currentLine.append(ch);\\n                        state = 0;\\n                    }\\n                } else if (state == 2) {\\n                    if (ch == \\'*\\') { // \\'expecting block comment end\\' state\\n                        state = 3;\\n                    }\\n                } else if (state == 3) {\\n                    if (ch == \\'/\\') { // block comment end -> back to \\'normal\\' state\\n                        state = 0;\\n                    } else {\\n                        state = ch != \\'*\\' ? 2 : 3; // failed to end block comment - stay in the block comment state\\n                    }\\n                }\\n            }\\n\\n            if (state == 1) { // line processed, failed to start comment ->  back to \\'normal\\' state\\n                state = 0;\\n            }\\n\\n            if (state != 2 && state != 3 && currentLine.length() != 0) { // if we are not in block comment and currentLine not empty\\n                lines.add(currentLine.toString());\\n                currentLine.setLength(0); // clear current line\\n            }\\n        }\\n\\n        return lines;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def removeComments(self, src):\\n        state = 0  # 0 - norm code, 1 - meet /, 2 - in block comment, 3 meet \\'*\\'\\n\\n        lines = []  # processed lines\\n        current_line_buffer = []\\n\\n        for line in src:\\n            for c in line:  # only look at current character, no lookaheads\\n                if state == 0:\\n                    if c == \\'/\\':\\n                        state = 1  # \\'expecting comment start\\' state\\n                    current_line_buffer.append(c)\\n                elif state == 1:\\n                    if c == \\'/\\':  # started line comment - skip rest of the line\\n                        current_line_buffer.pop()  # pop prev char\\n                        state = 0\\n                        break\\n                    elif c == \\'*\\':  # started block comment - skip everything until */\\n                        current_line_buffer.pop()  # pop prev char\\n                        state = 2\\n                    else:  # failed to start line or block comment -> back to \\'normal\\' state\\n                        current_line_buffer.append(c)\\n                        state = 0\\n                elif state == 2:\\n                    if c == \\'*\\':\\n                        state = 3\\n                elif state == 3:\\n                    if c == \\'/\\':  # block comment end -> back to \\'normal\\' state\\n                        state = 0\\n                    else:\\n                        state = 2 if c != \\'*\\' else 3  # failed to end block comment - stay in the block comment state\\n\\n            if state == 1:  # line processed, failed to start comment ->  back to \\'normal\\' state\\n                state = 0\\n\\n            if state not in (2, 3) and current_line_buffer:  # if we are not in block comment and currentLine not empty\\n                lines.append(\\'\\'.join(current_line_buffer))\\n                current_line_buffer.clear()\\n\\n        return lines\\n\\n```\n```\\nStringBuilder currentLine = new StringBuilder(); // character buffer\\n//...\\ncurrentLine.append(c); // append\\n// ...\\ncurrentLine.setLength(currentLine.length() - 1); // efficiently pop last character\\nlines.add(currentLine.toString()); // convert the buffer to String\\n\\ncurrentLine.setLength(0); // clear the buffer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882518,
                "title": "explanation-with-easy-solution",
                "content": "```\\n/*\\n* easy but confusing question because of all the edge cases but if we think about them before we tackle the problem\\n* it becomes easier to solve\\n */\\nfun removeComments(source: Array<String>): List<String> {\\n    //here we just hold all the lines\\n    val answer = arrayListOf<String>()\\n    // we set our boolean below to true when we see \"/*\" \\n    // we want to let our algorithm know that we are in a comment block so ignore other rules \\n    // if we see // dont break \\n    // if we see another /* ignore it \\n    // if we are at a new string in our array dont add a new item to our answer array \\n    // and finally dont clear our string builder\\n    // just keep on going until we see \"*/\"\\n    var isInCommentBlock = false\\n    val sb = StringBuilder()\\n    source.forEach {line ->\\n        var index = 0\\n        if(!isInCommentBlock) sb.clear()\\n        loop@ while(index < line.length){\\n            when {\\n                index + 1 < line.length&& !isInCommentBlock &&  line[index] == \\'/\\' && line[index + 1] == \\'*\\' -> {\\n                    isInCommentBlock = true\\n                    index++\\n                }\\n                index + 1 < line.length && isInCommentBlock && line[index] == \\'*\\' && line[index + 1] == \\'/\\' -> {\\n                    isInCommentBlock = false\\n                    index++\\n                }\\n                index + 1 < line.length && !isInCommentBlock && line[index] == \\'/\\' && line[index + 1] == \\'/\\' -> break@loop\\n                !isInCommentBlock -> sb.append(line[index])\\n            }\\n            index++\\n        }\\n        if(!isInCommentBlock && sb.isNotEmpty()) answer.add(sb.toString())\\n    }\\n\\n    return answer\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n* easy but confusing question because of all the edge cases but if we think about them before we tackle the problem\\n* it becomes easier to solve\\n */\\nfun removeComments(source: Array<String>): List<String> {\\n    //here we just hold all the lines\\n    val answer = arrayListOf<String>()\\n    // we set our boolean below to true when we see \"/*\" \\n    // we want to let our algorithm know that we are in a comment block so ignore other rules \\n    // if we see // dont break \\n    // if we see another /* ignore it \\n    // if we are at a new string in our array dont add a new item to our answer array \\n    // and finally dont clear our string builder\\n    // just keep on going until we see \"*/\"\\n    var isInCommentBlock = false\\n    val sb = StringBuilder()\\n    source.forEach {line ->\\n        var index = 0\\n        if(!isInCommentBlock) sb.clear()\\n        loop@ while(index < line.length){\\n            when {\\n                index + 1 < line.length&& !isInCommentBlock &&  line[index] == \\'/\\' && line[index + 1] == \\'*\\' -> {\\n                    isInCommentBlock = true\\n                    index++\\n                }\\n                index + 1 < line.length && isInCommentBlock && line[index] == \\'*\\' && line[index + 1] == \\'/\\' -> {\\n                    isInCommentBlock = false\\n                    index++\\n                }\\n                index + 1 < line.length && !isInCommentBlock && line[index] == \\'/\\' && line[index + 1] == \\'/\\' -> break@loop\\n                !isInCommentBlock -> sb.append(line[index])\\n            }\\n            index++\\n        }\\n        if(!isInCommentBlock && sb.isNotEmpty()) answer.add(sb.toString())\\n    }\\n\\n    return answer\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 839312,
                "title": "python-clean-and-readable-solution",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        output = []\\n        ignore = False\\n        for line in source:\\n            if not ignore:\\n                buffer = []\\n            i = 0\\n            while i < len(line):\\n                end = min(i+2, len(line))\\n                token = line[i:end]\\n                if not ignore and token == \\'//\\':\\n                    break\\n                elif not ignore and token == \\'/*\\':\\n                    ignore = True\\n                    i += 1\\n                elif ignore and token == \\'*/\\':\\n                    ignore = False\\n                    i += 1\\n                elif not ignore:\\n                    buffer.append(line[i])\\n                i += 1\\n            if not ignore and buffer:\\n                output.append(\\'\\'.join(buffer))\\n\\n        return output\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        output = []\\n        ignore = False\\n        for line in source:\\n            if not ignore:\\n                buffer = []\\n            i = 0\\n            while i < len(line):\\n                end = min(i+2, len(line))\\n                token = line[i:end]\\n                if not ignore and token == \\'//\\':\\n                    break\\n                elif not ignore and token == \\'/*\\':\\n                    ignore = True\\n                    i += 1\\n                elif ignore and token == \\'*/\\':\\n                    ignore = False\\n                    i += 1\\n                elif not ignore:\\n                    buffer.append(line[i])\\n                i += 1\\n            if not ignore and buffer:\\n                output.append(\\'\\'.join(buffer))\\n\\n        return output\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 839120,
                "title": "o-n-in-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string tmp;\\n    void deal(string & s, int & status){\\n        // status = 0: OK\\n        // 1: after //\\n        // 2: after /*\\n        for(int i = 0; i < s.size(); i++){\\n            if(status == 0){\\n                if(s[i] == \\'/\\' && i + 1 < s.size() && s[i+1] == \\'/\\') status = 1;\\n                else if(s[i] == \\'/\\' && i + 1 < s.size() && s[i+1] == \\'*\\') {status = 2; i++;}\\n                else tmp.push_back(s[i]);\\n            }else if(status == 2){\\n                if(s[i] == \\'*\\' && i + 1 < s.size() && s[i+1] == \\'/\\'){ status = 0; i++;}\\n            }\\n        }\\n        if(status == 0 || status == 1){ status = 0; \\n                                       if(tmp.size()) ans.push_back(tmp); \\n                                       tmp.clear();}\\n    }\\n    vector<string> removeComments(vector<string>& source) {\\n        int status = 0;\\n        for(string s : source){\\n            deal(s, status);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string tmp;\\n    void deal(string & s, int & status){\\n        // status = 0: OK\\n        // 1: after //\\n        // 2: after /*\\n        for(int i = 0; i < s.size(); i++){\\n            if(status == 0){\\n                if(s[i] == \\'/\\' && i + 1 < s.size() && s[i+1] == \\'/\\') status = 1;\\n                else if(s[i] == \\'/\\' && i + 1 < s.size() && s[i+1] == \\'*\\') {status = 2; i++;}\\n                else tmp.push_back(s[i]);\\n            }else if(status == 2){\\n                if(s[i] == \\'*\\' && i + 1 < s.size() && s[i+1] == \\'/\\'){ status = 0; i++;}\\n            }\\n        }\\n        if(status == 0 || status == 1){ status = 0; \\n                                       if(tmp.size()) ans.push_back(tmp); \\n                                       tmp.clear();}\\n    }\\n    vector<string> removeComments(vector<string>& source) {\\n        int status = 0;\\n        for(string s : source){\\n            deal(s, status);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804513,
                "title": "python-state-machine-solution",
                "content": "```python\\nfrom typing import List\\nfrom enum import Enum\\n\\n\\nclass States(Enum):\\n    TEXT = 1\\n    BLOCK = 2\\n    LINE = 3\\n\\n\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        s = \\'\\\\n\\'.join(source)\\n        out = []\\n        if not len(s):\\n            return source\\n        state = States.TEXT\\n        pos = 0\\n        while pos < len(s):\\n            if state == States.TEXT:\\n                if pos + 1 < len(s) and s[pos: pos + 2] == \\'/*\\':\\n                    state = States.BLOCK\\n                    pos += 2\\n                elif pos + 1 < len(s) and s[pos: pos + 2] == \\'//\\':\\n                    state = States.LINE\\n                    pos += 2\\n                else:\\n                    out.append(s[pos])\\n                    pos += 1\\n            elif state == States.BLOCK:\\n                if pos + 1 < len(s) and s[pos: pos + 2] == \\'*/\\':\\n                    state = States.TEXT\\n                    pos += 2\\n                else:\\n                    pos += 1\\n            elif state == States.LINE:\\n                if s[pos] == \\'\\\\n\\':\\n                    state = States.TEXT\\n                    out.append(\\'\\\\n\\')\\n                    pos += 1\\n                else:\\n                    pos += 1\\n        # filter out empty blocks\\n        return list(filter(None, \\'\\'.join(out).split(\\'\\\\n\\')))\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom typing import List\\nfrom enum import Enum\\n\\n\\nclass States(Enum):\\n    TEXT = 1\\n    BLOCK = 2\\n    LINE = 3\\n\\n\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        s = \\'\\\\n\\'.join(source)\\n        out = []\\n        if not len(s):\\n            return source\\n        state = States.TEXT\\n        pos = 0\\n        while pos < len(s):\\n            if state == States.TEXT:\\n                if pos + 1 < len(s) and s[pos: pos + 2] == \\'/*\\':\\n                    state = States.BLOCK\\n                    pos += 2\\n                elif pos + 1 < len(s) and s[pos: pos + 2] == \\'//\\':\\n                    state = States.LINE\\n                    pos += 2\\n                else:\\n                    out.append(s[pos])\\n                    pos += 1\\n            elif state == States.BLOCK:\\n                if pos + 1 < len(s) and s[pos: pos + 2] == \\'*/\\':\\n                    state = States.TEXT\\n                    pos += 2\\n                else:\\n                    pos += 1\\n            elif state == States.LINE:\\n                if s[pos] == \\'\\\\n\\':\\n                    state = States.TEXT\\n                    out.append(\\'\\\\n\\')\\n                    pos += 1\\n                else:\\n                    pos += 1\\n        # filter out empty blocks\\n        return list(filter(None, \\'\\'.join(out).split(\\'\\\\n\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739545,
                "title": "python-rust-solutions",
                "content": "- **Python**\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res, mode, buffer = [], False, \\'\\'\\n        \\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if mode:\\n                    if line[i:i+2] == \\'*/\\':\\n                        mode = False\\n                        i += 1\\n                else:\\n                    if line[i:i+2] == \\'//\\':\\n                        break\\n                    elif line[i:i+2] == \\'/*\\':\\n                        mode = True\\n                        i += 1\\n                    else:\\n                        buffer += line[i]\\n                i += 1\\n                \\n            if not mode and len(buffer):\\n                res.append(buffer)\\n                buffer = \\'\\'\\n\\n        return res  \\n```\\n\\n- **Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        let mut res: Vec<String> = Vec::new();\\n        let mut buffer: String = String::new();\\n        let mut mode: bool = false;\\n        \\n        for line in source.iter() {\\n            let mut i = 0;\\n            let len = line.len();\\n            while i < len {\\n                if mode {\\n                    if i < len - 1 && &line[i..i+2] == \"*/\" {\\n                        mode = false;\\n                        i += 1;\\n                    }\\n                } else {\\n                    if i < len - 1 && &line[i..i+2] == \"//\" {\\n                        break;\\n                    } else if i < len - 1 && &line[i..i+2] == \"/*\" {\\n                        mode = true;\\n                        i += 1;\\n                    } else {\\n                        buffer.push_str(&line[i..i+1]);\\n                    }\\n                }\\n                i += 1;\\n            }\\n            if !mode && buffer.len() > 0 {\\n                res.push(buffer);\\n                buffer = String::new();\\n            }    \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res, mode, buffer = [], False, \\'\\'\\n        \\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if mode:\\n                    if line[i:i+2] == \\'*/\\':\\n                        mode = False\\n                        i += 1\\n                else:\\n                    if line[i:i+2] == \\'//\\':\\n                        break\\n                    elif line[i:i+2] == \\'/*\\':\\n                        mode = True\\n                        i += 1\\n                    else:\\n                        buffer += line[i]\\n                i += 1\\n                \\n            if not mode and len(buffer):\\n                res.append(buffer)\\n                buffer = \\'\\'\\n\\n        return res  \\n```\n```rust\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        let mut res: Vec<String> = Vec::new();\\n        let mut buffer: String = String::new();\\n        let mut mode: bool = false;\\n        \\n        for line in source.iter() {\\n            let mut i = 0;\\n            let len = line.len();\\n            while i < len {\\n                if mode {\\n                    if i < len - 1 && &line[i..i+2] == \"*/\" {\\n                        mode = false;\\n                        i += 1;\\n                    }\\n                } else {\\n                    if i < len - 1 && &line[i..i+2] == \"//\" {\\n                        break;\\n                    } else if i < len - 1 && &line[i..i+2] == \"/*\" {\\n                        mode = true;\\n                        i += 1;\\n                    } else {\\n                        buffer.push_str(&line[i..i+1]);\\n                    }\\n                }\\n                i += 1;\\n            }\\n            if !mode && buffer.len() > 0 {\\n                res.push(buffer);\\n                buffer = String::new();\\n            }    \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727832,
                "title": "very-concise-python-solution-without-using-regex",
                "content": "The idea is to transform the input to a single string, which is much easier to handle. Using a special character as the spliter, e.g. \"\\\\n\".\\nThen iteratively remove the comment symbols.\\n\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        line = \"\\\\n\".join(source) + \"\\\\n\"\\n        while True:\\n            single, multiple = line.find(\\'//\\'), line.find(\\'/*\\')\\n            if single == multiple == -1:\\n                break\\n            if single == -1 or -1 < multiple < single:\\n                line = line[: multiple] + line[line.find(\\'*/\\', multiple + 2) + 2:]\\n            else:\\n                line = line[: single] + line[line.find(\\'\\\\n\\', single + 2) :]\\n        return list(filter(lambda x: x != \\'\\', line.split(\\'\\\\n\\')))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        line = \"\\\\n\".join(source) + \"\\\\n\"\\n        while True:\\n            single, multiple = line.find(\\'//\\'), line.find(\\'/*\\')\\n            if single == multiple == -1:\\n                break\\n            if single == -1 or -1 < multiple < single:\\n                line = line[: multiple] + line[line.find(\\'*/\\', multiple + 2) + 2:]\\n            else:\\n                line = line[: single] + line[line.find(\\'\\\\n\\', single + 2) :]\\n        return list(filter(lambda x: x != \\'\\', line.split(\\'\\\\n\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726336,
                "title": "easy-one-pass-c-code",
                "content": "bc: inside block comment\\nlc: inside line comment\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> code;\\n        string code_line=\"\";\\n        int bc=0;\\n        for(auto line: source){\\n            int l= line.length();\\n            int i=0, lc=0;\\n            while(i<l){\\n                if(!lc && !bc && i<l-1 && line[i] == \\'/\\' && line[i+1] == \\'/\\')\\n                    lc = 1, i+=2;\\n                else if(!lc && !bc && i<l-1 && line[i] == \\'/\\' && line[i+1] == \\'*\\')\\n                    bc = 1,i+=2;\\n                else if(!lc && bc && i<l-1 && line[i] == \\'*\\' && line[i+1] == \\'/\\')\\n                    bc = 0, i+=2;\\n                \\n                else if(!lc && !bc && i<l) code_line += line[i++];\\n                else i++;\\n            }\\n            if(!bc && code_line.length()>0){\\n                code.push_back(code_line);\\n                code_line = \"\";\\n            }\\n        }\\n        return code;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> code;\\n        string code_line=\"\";\\n        int bc=0;\\n        for(auto line: source){\\n            int l= line.length();\\n            int i=0, lc=0;\\n            while(i<l){\\n                if(!lc && !bc && i<l-1 && line[i] == \\'/\\' && line[i+1] == \\'/\\')\\n                    lc = 1, i+=2;\\n                else if(!lc && !bc && i<l-1 && line[i] == \\'/\\' && line[i+1] == \\'*\\')\\n                    bc = 1,i+=2;\\n                else if(!lc && bc && i<l-1 && line[i] == \\'*\\' && line[i+1] == \\'/\\')\\n                    bc = 0, i+=2;\\n                \\n                else if(!lc && !bc && i<l) code_line += line[i++];\\n                else i++;\\n            }\\n            if(!bc && code_line.length()>0){\\n                code.push_back(code_line);\\n                code_line = \"\";\\n            }\\n        }\\n        return code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576214,
                "title": "simple-java-solution",
                "content": "```\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean inBlock = false;\\n        for(String s : source) {\\n            for(int i = 0; i < s.length(); i++) {\\n                if(inBlock) {\\n                    int idx = s.indexOf(\"*/\", i);\\n                    if(idx == -1) break;\\n                    i = idx + 1;\\n                    inBlock = false;\\n                } else if(s.charAt(i) == \\'/\\' && i + 1 < s.length() && s.charAt(i + 1) == \\'*\\') {\\n                    inBlock = true;\\n                    i++;\\n                } else if(s.charAt(i) == \\'/\\' && i + 1 < s.length() && s.charAt(i + 1) == \\'/\\') {\\n                    i = s.length();\\n                } else {\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n            \\n            if(!inBlock && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean inBlock = false;\\n        for(String s : source) {\\n            for(int i = 0; i < s.length(); i++) {\\n                if(inBlock) {\\n                    int idx = s.indexOf(\"*/\", i);\\n                    if(idx == -1) break;\\n                    i = idx + 1;\\n                    inBlock = false;\\n                } else if(s.charAt(i) == \\'/\\' && i + 1 < s.length() && s.charAt(i + 1) == \\'*\\') {\\n                    inBlock = true;\\n                    i++;\\n                } else if(s.charAt(i) == \\'/\\' && i + 1 < s.length() && s.charAt(i + 1) == \\'/\\') {\\n                    i = s.length();\\n                } else {\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n            \\n            if(!inBlock && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540459,
                "title": "1ms-java",
                "content": "Very simple. Took 10minutes or less due to the cheeky edge cases. I think my solution is garbage though, as I am reconstructing the entire source as a string. Means 1GB source in memory.\\n\\nTypically, you want this in a stream, as line by line.\\n```\\n    public List<String> removeComments(String[] source) {\\n        String joined = String.join(\"\\\\n\", source);        \\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < joined.length();j++) {\\n            if(j+1 < joined.length() && joined.charAt(j) == \\'/\\' && joined.charAt(j+1) == \\'*\\') {\\n                j = joined.indexOf(\"*/\", Math.min(j+2, joined.length() - 1));\\n                j++;\\n            }\\n            else if(j+1 < joined.length() && joined.charAt(j) == \\'/\\' && joined.charAt(j+1) == \\'/\\') {\\n                j = joined.indexOf(\"\\\\n\", Math.min(j+2, joined.length() - 1));\\n                if(j == -1)\\n                    break;\\n                j--;\\n            }\\n            else {\\n                sb.append(joined.charAt(j));\\n            }\\n        }\\n        String[] split = sb.toString().split(\"\\\\n\");\\n        List<String> answer = new ArrayList<>();\\n        for(String s : split) {\\n            if(s.length() > 0)\\n                answer.add(s);\\n        }\\n        return answer;\\n    }\\n```\\n\\nEdit: I have changed from parsing entire string, to lines. 0ms now.\\n```\\n    public List<String> removeComments(String[] source) {\\n\\n        boolean multim = false;\\n        StringBuilder sb = new StringBuilder();\\n        List<String> lines = new ArrayList<>();\\n        for(int i = 0; i < source.length; i++) {\\n            String line = source[i];\\n            for(int j = 0; j < line.length(); j++) {\\n                if(!multim && line.charAt(j) == \\'/\\' && j + 1 < line.length() &&\\n                    line.charAt(j + 1) == \\'/\\') {\\n                    break;\\n                }\\n                // int a = 2; /* garbage comment */ int c= 2;\\n                else if(!multim && line.charAt(j) == \\'/\\' && j + 1 < line.length() &&\\n                        line.charAt(j+1) == \\'*\\') {\\n                    multim = true;\\n                    j++;\\n                }\\n                else if(multim && line.charAt(j) == \\'*\\' && j + 1 < line.length() &&\\n                        line.charAt(j+1) == \\'/\\') {\\n                    j++;\\n                    multim = false;\\n                }\\n                else {\\n                    if(!multim)\\n                        sb.append(line.charAt(j));\\n                }\\n            }\\n            if(!multim) {\\n                if(sb.length() > 0) {\\n                    lines.add(sb.toString());\\n                    sb.setLength(0);\\n                }\\n            }\\n        }\\n        return lines;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> removeComments(String[] source) {\\n        String joined = String.join(\"\\\\n\", source);        \\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < joined.length();j++) {\\n            if(j+1 < joined.length() && joined.charAt(j) == \\'/\\' && joined.charAt(j+1) == \\'*\\') {\\n                j = joined.indexOf(\"*/\", Math.min(j+2, joined.length() - 1));\\n                j++;\\n            }\\n            else if(j+1 < joined.length() && joined.charAt(j) == \\'/\\' && joined.charAt(j+1) == \\'/\\') {\\n                j = joined.indexOf(\"\\\\n\", Math.min(j+2, joined.length() - 1));\\n                if(j == -1)\\n                    break;\\n                j--;\\n            }\\n            else {\\n                sb.append(joined.charAt(j));\\n            }\\n        }\\n        String[] split = sb.toString().split(\"\\\\n\");\\n        List<String> answer = new ArrayList<>();\\n        for(String s : split) {\\n            if(s.length() > 0)\\n                answer.add(s);\\n        }\\n        return answer;\\n    }\\n```\n```\\n    public List<String> removeComments(String[] source) {\\n\\n        boolean multim = false;\\n        StringBuilder sb = new StringBuilder();\\n        List<String> lines = new ArrayList<>();\\n        for(int i = 0; i < source.length; i++) {\\n            String line = source[i];\\n            for(int j = 0; j < line.length(); j++) {\\n                if(!multim && line.charAt(j) == \\'/\\' && j + 1 < line.length() &&\\n                    line.charAt(j + 1) == \\'/\\') {\\n                    break;\\n                }\\n                // int a = 2; /* garbage comment */ int c= 2;\\n                else if(!multim && line.charAt(j) == \\'/\\' && j + 1 < line.length() &&\\n                        line.charAt(j+1) == \\'*\\') {\\n                    multim = true;\\n                    j++;\\n                }\\n                else if(multim && line.charAt(j) == \\'*\\' && j + 1 < line.length() &&\\n                        line.charAt(j+1) == \\'/\\') {\\n                    j++;\\n                    multim = false;\\n                }\\n                else {\\n                    if(!multim)\\n                        sb.append(line.charAt(j));\\n                }\\n            }\\n            if(!multim) {\\n                if(sb.length() > 0) {\\n                    lines.add(sb.toString());\\n                    sb.setLength(0);\\n                }\\n            }\\n        }\\n        return lines;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470336,
                "title": "simple-java-solution-with-comments",
                "content": "Based on nrl\\'s solution, I have added comments that makes the code easy to understand. Beats 100% time and space complexity.\\n\\n```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<String>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean mode = false; // multiline comment mode\\n        \\n        // edge cases\\n        if(source == null || source.length == 0)\\n            return res;\\n        \\n        for(String s: source) { // each line in source\\n            for(int i = 0; i<s.length(); i++) { // loop through all strings in the same line\\n                if(mode) {\\n                    if(s.charAt(i) == \\'*\\' && i<s.length()-1 && s.charAt(i+1) == \\'/\\') {\\n                        mode = false;\\n                        i++;\\n                    }\\n                } else {\\n                    if(s.charAt(i) == \\'/\\' && i<s.length()-1 && s.charAt(i+1) == \\'/\\') {\\n                        // single line comment\\n                        break; // move to next line\\n                    } else if(s.charAt(i) == \\'/\\' && i<s.length()-1 && s.charAt(i+1) == \\'*\\') {\\n                        // multiline comment\\n                        mode = true;\\n                        i++;\\n                    } else {\\n                        sb.append(s.charAt(i)); // regular code/string\\n                    }\\n                }\\n            }\\n            // after finishing one line, check if mode is comment or not and add sb value to result list\\n            if(!mode && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder(); // reset the stringbuilder for next line\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<String>();\\n        StringBuilder sb = new StringBuilder();\\n        boolean mode = false; // multiline comment mode\\n        \\n        // edge cases\\n        if(source == null || source.length == 0)\\n            return res;\\n        \\n        for(String s: source) { // each line in source\\n            for(int i = 0; i<s.length(); i++) { // loop through all strings in the same line\\n                if(mode) {\\n                    if(s.charAt(i) == \\'*\\' && i<s.length()-1 && s.charAt(i+1) == \\'/\\') {\\n                        mode = false;\\n                        i++;\\n                    }\\n                } else {\\n                    if(s.charAt(i) == \\'/\\' && i<s.length()-1 && s.charAt(i+1) == \\'/\\') {\\n                        // single line comment\\n                        break; // move to next line\\n                    } else if(s.charAt(i) == \\'/\\' && i<s.length()-1 && s.charAt(i+1) == \\'*\\') {\\n                        // multiline comment\\n                        mode = true;\\n                        i++;\\n                    } else {\\n                        sb.append(s.charAt(i)); // regular code/string\\n                    }\\n                }\\n            }\\n            // after finishing one line, check if mode is comment or not and add sb value to result list\\n            if(!mode && sb.length() > 0) {\\n                res.add(sb.toString());\\n                sb = new StringBuilder(); // reset the stringbuilder for next line\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420129,
                "title": "recursion-o-n-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str], flag = 0) -> List[str]:\\n        def foo(source: List[str], flag = 0):\\n            if not source:\\n                return \"\"\\n            line = source[0]\\n            if flag:\\n                if \"*/\" not in line:\\n                    return foo(source[1:],1)\\n                else:\\n                    return foo([line[line.find(\\'*/\\')+2:]] + source[1:],0)\\n            else:\\n                if \"/*\" in line or \"//\" in line:\\n                    a = line.find(\\'/*\\')\\n                    b = line.find(\\'//\\')\\n                    if (a<b and a!=-1) or b==-1:\\n                        return line[:a]+foo([line[a+2:]]+source[1:],1)\\n                    else:\\n                        return line[:b]+\"\\\\n\"+foo(source[1:],0)\\n                else:\\n                    return line + \"\\\\n\" + foo(source[1:],0)\\n        return [i for i in foo(source, 0).split(\\'\\\\n\\') if i] \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str], flag = 0) -> List[str]:\\n        def foo(source: List[str], flag = 0):\\n            if not source:\\n                return \"\"\\n            line = source[0]\\n            if flag:\\n                if \"*/\" not in line:\\n                    return foo(source[1:],1)\\n                else:\\n                    return foo([line[line.find(\\'*/\\')+2:]] + source[1:],0)\\n            else:\\n                if \"/*\" in line or \"//\" in line:\\n                    a = line.find(\\'/*\\')\\n                    b = line.find(\\'//\\')\\n                    if (a<b and a!=-1) or b==-1:\\n                        return line[:a]+foo([line[a+2:]]+source[1:],1)\\n                    else:\\n                        return line[:b]+\"\\\\n\"+foo(source[1:],0)\\n                else:\\n                    return line + \"\\\\n\" + foo(source[1:],0)\\n        return [i for i in foo(source, 0).split(\\'\\\\n\\') if i] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 418122,
                "title": "c-state-machine",
                "content": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int block_mode = 0, count = 0, pos = 0;\\n    char tmp[160];\\n    char **target = (char **)malloc(sizeof(char *) * 100);\\n    for (int i = 0; i < sourceSize; ++i) {\\n        char *str = source[i];\\n        char prev = str[0];\\n        if (prev == \\'\\\\0\\')\\n            continue;\\n        char curr = str[1];\\n        if (!block_mode) {\\n            pos = 0;\\n            tmp[pos++] = prev;\\n        }\\n        for (int j = 1; curr != \\'\\\\0\\'; ++j) {\\n            if (block_mode) {\\n                if (prev == \\'*\\' && curr == \\'/\\') {\\n                    block_mode = 0;\\n                    if ((curr = str[++j]) == \\'\\\\0\\')\\n                        break;\\n                }\\n            } else if (prev == \\'/\\') {\\n                if (curr == \\'/\\') {\\n                    pos--;\\n                    break;\\n                } else if (curr == \\'*\\') {\\n                    block_mode = 1;\\n                    pos--;\\n                    j++;\\n                    if ((prev = str[j]) != \\'\\\\0\\' && (curr = str[j+1]) != \\'\\\\0\\')\\n                        continue;\\n                    else\\n                        break;\\n                }\\n            }\\n            if (!block_mode)\\n                tmp[pos++] = curr;\\n            prev = curr;\\n            curr = str[j+1];\\n        }\\n        if (!block_mode) {\\n            if (pos == 0)\\n                continue;\\n            target[count] = (char *)malloc(sizeof(char) * (pos+1));\\n            char *dest = target[count++];\\n            for (int k = 0; k < pos; ++k)\\n                dest[k] = tmp[k];\\n            dest[pos] = \\'\\\\0\\';\\n        }\\n    }\\n    *returnSize = count;\\n    return target;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int block_mode = 0, count = 0, pos = 0;\\n    char tmp[160];\\n    char **target = (char **)malloc(sizeof(char *) * 100);\\n    for (int i = 0; i < sourceSize; ++i) {\\n        char *str = source[i];\\n        char prev = str[0];\\n        if (prev == \\'\\\\0\\')\\n            continue;\\n        char curr = str[1];\\n        if (!block_mode) {\\n            pos = 0;\\n            tmp[pos++] = prev;\\n        }\\n        for (int j = 1; curr != \\'\\\\0\\'; ++j) {\\n            if (block_mode) {\\n                if (prev == \\'*\\' && curr == \\'/\\') {\\n                    block_mode = 0;\\n                    if ((curr = str[++j]) == \\'\\\\0\\')\\n                        break;\\n                }\\n            } else if (prev == \\'/\\') {\\n                if (curr == \\'/\\') {\\n                    pos--;\\n                    break;\\n                } else if (curr == \\'*\\') {\\n                    block_mode = 1;\\n                    pos--;\\n                    j++;\\n                    if ((prev = str[j]) != \\'\\\\0\\' && (curr = str[j+1]) != \\'\\\\0\\')\\n                        continue;\\n                    else\\n                        break;\\n                }\\n            }\\n            if (!block_mode)\\n                tmp[pos++] = curr;\\n            prev = curr;\\n            curr = str[j+1];\\n        }\\n        if (!block_mode) {\\n            if (pos == 0)\\n                continue;\\n            target[count] = (char *)malloc(sizeof(char) * (pos+1));\\n            char *dest = target[count++];\\n            for (int k = 0; k < pos; ++k)\\n                dest[k] = tmp[k];\\n            dest[pos] = \\'\\\\0\\';\\n        }\\n    }\\n    *returnSize = count;\\n    return target;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 411710,
                "title": "java-o-n-with-stringbuilder",
                "content": "```\\npublic List<String> removeComments(String[] source) {\\n        ArrayList<String> res = new ArrayList<>();\\n        \\n        boolean open = false;\\n        StringBuilder strb = new StringBuilder();\\n        for(int i = 0; i < source.length;){\\n            String st = source[i];\\n            ll:for(int ci = 0; ci < st.length();){\\n                char c = st.charAt(ci);\\n                if(!open && c==\\'/\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'*\\' ){\\n                    open = true;\\n                    ci+=2;    \\n                }\\n                else if(!open && c==\\'/\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'/\\' ){\\n                    if(strb.length() != 0){\\n                        res.add(strb.toString());\\n                        strb = new StringBuilder();\\n                    }\\n                    break ll;\\n                }\\n                else if(!open){\\n                    strb.append(c);\\n                    ci++;\\n                }\\n                else if(c==\\'*\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'/\\' ){\\n                    open = false;\\n                    ci+=2;\\n                }\\n                else ci++;\\n                \\n                if(ci == st.length() && !open && strb.length() != 0){\\n                    res.add(strb.toString());\\n                    strb = new StringBuilder();\\n                }\\n                \\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(strb.length() != 0) res.add(strb.toString());\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<String> removeComments(String[] source) {\\n        ArrayList<String> res = new ArrayList<>();\\n        \\n        boolean open = false;\\n        StringBuilder strb = new StringBuilder();\\n        for(int i = 0; i < source.length;){\\n            String st = source[i];\\n            ll:for(int ci = 0; ci < st.length();){\\n                char c = st.charAt(ci);\\n                if(!open && c==\\'/\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'*\\' ){\\n                    open = true;\\n                    ci+=2;    \\n                }\\n                else if(!open && c==\\'/\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'/\\' ){\\n                    if(strb.length() != 0){\\n                        res.add(strb.toString());\\n                        strb = new StringBuilder();\\n                    }\\n                    break ll;\\n                }\\n                else if(!open){\\n                    strb.append(c);\\n                    ci++;\\n                }\\n                else if(c==\\'*\\' && ci+1<st.length() \\n                   && st.charAt(ci+1) == \\'/\\' ){\\n                    open = false;\\n                    ci+=2;\\n                }\\n                else ci++;\\n                \\n                if(ci == st.length() && !open && strb.length() != 0){\\n                    res.add(strb.toString());\\n                    strb = new StringBuilder();\\n                }\\n                \\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(strb.length() != 0) res.add(strb.toString());\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 404482,
                "title": "east-to-understand-java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        int i = 0;\\n        List<String> res = new ArrayList();\\n        while(i < source.length) {\\n            int lineStart = source[i].indexOf(\"//\"), blockStart = source[i].indexOf(\"/*\");\\n            if(blockStart < 0 && lineStart < 0) {// no comments\\n                if(source[i].length() > 0)// non-empty string\\n                    res.add(source[i]);\\n                i++;\\n            } else if(blockStart < 0 || (lineStart >= 0 && lineStart < blockStart) ){// line comments\\n                if(lineStart != 0)// non-empty string\\n                    res.add(source[i].substring(0, lineStart));\\n                i++;\\n            } else {// block comments;\\n                for(int j = i; j < source.length; j++) {\\n                    int blockEnd = source[j].indexOf(\"*/\");\\n                    if(j == i) {// corner case: \"/*/\", \"/*/ */\"\\n                        blockEnd = source[i].indexOf(\"*/\", blockStart+2);\\n                    }\\n                    if(blockEnd != -1) {\\n                        // remove block comments\\n                        source[j] = source[i].substring(0, blockStart)+source[j].substring(blockEnd+2);\\n                        i = j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        int i = 0;\\n        List<String> res = new ArrayList();\\n        while(i < source.length) {\\n            int lineStart = source[i].indexOf(\"//\"), blockStart = source[i].indexOf(\"/*\");\\n            if(blockStart < 0 && lineStart < 0) {// no comments\\n                if(source[i].length() > 0)// non-empty string\\n                    res.add(source[i]);\\n                i++;\\n            } else if(blockStart < 0 || (lineStart >= 0 && lineStart < blockStart) ){// line comments\\n                if(lineStart != 0)// non-empty string\\n                    res.add(source[i].substring(0, lineStart));\\n                i++;\\n            } else {// block comments;\\n                for(int j = i; j < source.length; j++) {\\n                    int blockEnd = source[j].indexOf(\"*/\");\\n                    if(j == i) {// corner case: \"/*/\", \"/*/ */\"\\n                        blockEnd = source[i].indexOf(\"*/\", blockStart+2);\\n                    }\\n                    if(blockEnd != -1) {\\n                        // remove block comments\\n                        source[j] = source[i].substring(0, blockStart)+source[j].substring(blockEnd+2);\\n                        i = j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284922,
                "title": "short-c-solution-beat-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool flag = false;\\n        vector<string> res;\\n        for(auto s:source){\\n            string code = flag? code:\"\"; // append code or new code based on the flag status \\n            for(int i = 0; i<s.size();++i){\\n                if(!flag && i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'*\\'){ flag = true; ++i;} // if /* set the flag\\n                else if(!flag && i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'/\\') break; // if // all gone \\n                else if(flag && i < s.size()-1 && s[i] == \\'*\\' && s[i+1] == \\'/\\') {flag = false; ++i;} // if flag is up and */\\n                else {if(!flag) code += s[i];} // if no flag then add the char \\n            }\\n            if(!flag && code != \"\") res.push_back(code); // if not inside /* */ and got some char then push it \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool flag = false;\\n        vector<string> res;\\n        for(auto s:source){\\n            string code = flag? code:\"\"; // append code or new code based on the flag status \\n            for(int i = 0; i<s.size();++i){\\n                if(!flag && i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'*\\'){ flag = true; ++i;} // if /* set the flag\\n                else if(!flag && i < s.size()-1 && s[i] == \\'/\\' && s[i+1] == \\'/\\') break; // if // all gone \\n                else if(flag && i < s.size()-1 && s[i] == \\'*\\' && s[i+1] == \\'/\\') {flag = false; ++i;} // if flag is up and */\\n                else {if(!flag) code += s[i];} // if no flag then add the char \\n            }\\n            if(!flag && code != \"\") res.push_back(code); // if not inside /* */ and got some char then push it \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262631,
                "title": "java-1ms-solution",
                "content": "The key idea here is to update current line when a comment is found. \\nUse a while loop to iterate over ```source```\\n1. when no ```//``` or ```/*``` is found, add current line to ```result```, check next line\\n2. when ```//``` or ```/*``` is found, handle the first appear one\\n\\t2.1 if ```//``` comes first, update current line to remove those after ```//```\\n\\t2.2 if ```/*``` comes first, keep those before ```/*``` as ```firstPart```, and go in another while loop looking for the ```*/```, keep those after ```*/``` as ```secondPart```, update current line with ```firstPart + secondPart```\\n\\n```\\n    public List<String> removeComments(String[] source) {\\n        if (source == null || source.length == 0) {\\n            return new LinkedList<>();\\n        }\\n        \\n        int i = 0;\\n        List<String> result = new LinkedList<>();\\n        while (i < source.length) {\\n            String line = source[i];\\n            if (line.isEmpty()) {\\n                i++;\\n                continue;\\n            }\\n            int singleIndex = line.indexOf(\"//\");\\n            int multipleIndex = line.indexOf(\"/*\");\\n            if (singleIndex == -1 && multipleIndex == -1) {\\n                result.add(line);\\n                i++;\\n            }\\n            else {\\n                if (singleIndex != -1 && (multipleIndex == -1 || singleIndex < multipleIndex)) {\\n                    source[i] = line.substring(0, singleIndex);\\n                }\\n                else if (multipleIndex != -1 && (singleIndex == -1 || multipleIndex < singleIndex)) {\\n                    String firstPart = line.substring(0, line.indexOf(\"/*\"));\\n                    source[i] = source[i].substring(source[i].indexOf(\"/*\") + 2, source[i].length());\\n                    String secondPart = \"\";\\n                    while (i < source.length) {\\n                        if (source[i].indexOf(\"*/\") != -1) {\\n                            secondPart = source[i].substring(source[i].indexOf(\"*/\") + 2, source[i].length());\\n                            source[i] = firstPart + secondPart;\\n                            break;\\n                        }\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```source```\n```//```\n```/*```\n```result```\n```//```\n```/*```\n```//```\n```//```\n```/*```\n```/*```\n```firstPart```\n```*/```\n```*/```\n```secondPart```\n```firstPart + secondPart```\n```\\n    public List<String> removeComments(String[] source) {\\n        if (source == null || source.length == 0) {\\n            return new LinkedList<>();\\n        }\\n        \\n        int i = 0;\\n        List<String> result = new LinkedList<>();\\n        while (i < source.length) {\\n            String line = source[i];\\n            if (line.isEmpty()) {\\n                i++;\\n                continue;\\n            }\\n            int singleIndex = line.indexOf(\"//\");\\n            int multipleIndex = line.indexOf(\"/*\");\\n            if (singleIndex == -1 && multipleIndex == -1) {\\n                result.add(line);\\n                i++;\\n            }\\n            else {\\n                if (singleIndex != -1 && (multipleIndex == -1 || singleIndex < multipleIndex)) {\\n                    source[i] = line.substring(0, singleIndex);\\n                }\\n                else if (multipleIndex != -1 && (singleIndex == -1 || multipleIndex < singleIndex)) {\\n                    String firstPart = line.substring(0, line.indexOf(\"/*\"));\\n                    source[i] = source[i].substring(source[i].indexOf(\"/*\") + 2, source[i].length());\\n                    String secondPart = \"\";\\n                    while (i < source.length) {\\n                        if (source[i].indexOf(\"*/\") != -1) {\\n                            secondPart = source[i].substring(source[i].indexOf(\"*/\") + 2, source[i].length());\\n                            source[i] = firstPart + secondPart;\\n                            break;\\n                        }\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201990,
                "title": "java-o-n-solution-time-3ms",
                "content": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String>res = new ArrayList<>();\\n        boolean multiline=false;\\n        boolean singleline=false;\\n        StringBuilder bld = new StringBuilder();\\n        for (String s: source){\\n            if (!multiline){\\n            bld = new StringBuilder();\\n            }\\n            for (int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if (multiline){\\n                    if (c==\\'*\\' && i<s.length()-1 && s.charAt(i+1)==\\'/\\'){\\n                        i++;\\n                        multiline=false;\\n                    }\\n                }\\n                else if (singleline){\\n                    continue;\\n                }\\n                else if (c==\\'/\\' && i<s.length()-1 ){\\n                    if (s.charAt(i+1)==\\'/\\'){\\n                        singleline=true;\\n                        i++;\\n                    }\\n                    else if (s.charAt(i+1)==\\'*\\'){\\n                        multiline=true;\\n                        i++;\\n                    }\\n                    else bld.append(c);\\n                }\\n                else bld.append(c);\\n            }\\n            singleline=false;\\n            if (!multiline && bld.toString().length()>0)res.add(bld.toString());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String>res = new ArrayList<>();\\n        boolean multiline=false;\\n        boolean singleline=false;\\n        StringBuilder bld = new StringBuilder();\\n        for (String s: source){\\n            if (!multiline){\\n            bld = new StringBuilder();\\n            }\\n            for (int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if (multiline){\\n                    if (c==\\'*\\' && i<s.length()-1 && s.charAt(i+1)==\\'/\\'){\\n                        i++;\\n                        multiline=false;\\n                    }\\n                }\\n                else if (singleline){\\n                    continue;\\n                }\\n                else if (c==\\'/\\' && i<s.length()-1 ){\\n                    if (s.charAt(i+1)==\\'/\\'){\\n                        singleline=true;\\n                        i++;\\n                    }\\n                    else if (s.charAt(i+1)==\\'*\\'){\\n                        multiline=true;\\n                        i++;\\n                    }\\n                    else bld.append(c);\\n                }\\n                else bld.append(c);\\n            }\\n            singleline=false;\\n            if (!multiline && bld.toString().length()>0)res.add(bld.toString());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172048,
                "title": "python-beats-100",
                "content": "```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        # if the comment starts with // we just substringfy everything and attach that to a list\\n        # if the comment starts with /* we need to add the string until the end\\n        \\n        return_list = []\\n        block_on = False\\n        cur_string = \"\"\\n        for source_string in source:\\n            index = 0\\n            while index < len(source_string):\\n                if block_on:\\n                    if source_string[index] == \"*\":\\n                        if index < len(source_string) - 1 and source_string[index+1] == \"/\":\\n                            block_on=False\\n                            index += 1\\n                    else:\\n                        pass\\n                    \\n                elif source_string[index] == \"/\":\\n                    if index < (len(source_string) - 1) and source_string[index+1] == \"*\":\\n                        block_on = True\\n                        index += 1\\n                    elif index < (len(source_string) - 1) and source_string[index+1] == \"/\":\\n                        break\\n                    else:\\n                        cur_string += source_string[index]\\n                else:\\n                    cur_string += source_string[index]\\n                index += 1\\n            if cur_string != \"\" and block_on == False:\\n                return_list.append(cur_string)\\n                cur_string = \"\"\\n        return return_list\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        # if the comment starts with // we just substringfy everything and attach that to a list\\n        # if the comment starts with /* we need to add the string until the end\\n        \\n        return_list = []\\n        block_on = False\\n        cur_string = \"\"\\n        for source_string in source:\\n            index = 0\\n            while index < len(source_string):\\n                if block_on:\\n                    if source_string[index] == \"*\":\\n                        if index < len(source_string) - 1 and source_string[index+1] == \"/\":\\n                            block_on=False\\n                            index += 1\\n                    else:\\n                        pass\\n                    \\n                elif source_string[index] == \"/\":\\n                    if index < (len(source_string) - 1) and source_string[index+1] == \"*\":\\n                        block_on = True\\n                        index += 1\\n                    elif index < (len(source_string) - 1) and source_string[index+1] == \"/\":\\n                        break\\n                    else:\\n                        cur_string += source_string[index]\\n                else:\\n                    cur_string += source_string[index]\\n                index += 1\\n            if cur_string != \"\" and block_on == False:\\n                return_list.append(cur_string)\\n                cur_string = \"\"\\n        return return_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163035,
                "title": "simple-3ms-java-soln",
                "content": "```\\n    public List<String> removeComments(String[] source) {\\n        StringBuilder line=new StringBuilder();\\n        boolean add=true;\\n        List<String> resp=new ArrayList<>();\\n        for(String row:source){\\n            if(row.length()==0) continue;\\n            if(add && row.trim().length()==0){\\n                resp.add(row); continue;\\n            }\\n            for(int i=0; i<row.length(); i++){\\n                if(row.charAt(i)==\\'/\\' && i!=row.length()-1 && row.charAt(i+1)==\\'/\\' && add) break;\\n                else if(row.charAt(i)==\\'/\\' && i!=row.length()-1 && row.charAt(i+1)==\\'*\\' && add){\\n                    add=false; ++i;\\n                }else if(row.charAt(i)==\\'*\\' && i!=row.length()-1 && row.charAt(i+1)==\\'/\\' && !add){\\n                    add=true; ++i;\\n                }else if(add) line.append(row.charAt(i));\\n            }\\n            if(line.length()!=0 && add){\\n                resp.add(line.toString());\\n                line=new StringBuilder();\\n            }           \\n        }\\n        return resp;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    public List<String> removeComments(String[] source) {\\n        StringBuilder line=new StringBuilder();\\n        boolean add=true;\\n        List<String> resp=new ArrayList<>();\\n        for(String row:source){\\n            if(row.length()==0) continue;\\n            if(add && row.trim().length()==0){\\n                resp.add(row); continue;\\n            }\\n            for(int i=0; i<row.length(); i++){\\n                if(row.charAt(i)==\\'/\\' && i!=row.length()-1 && row.charAt(i+1)==\\'/\\' && add) break;\\n                else if(row.charAt(i)==\\'/\\' && i!=row.length()-1 && row.charAt(i+1)==\\'*\\' && add){\\n                    add=false; ++i;\\n                }else if(row.charAt(i)==\\'*\\' && i!=row.length()-1 && row.charAt(i+1)==\\'/\\' && !add){\\n                    add=true; ++i;\\n                }else if(add) line.append(row.charAt(i));\\n            }\\n            if(line.length()!=0 && add){\\n                resp.add(line.toString());\\n                line=new StringBuilder();\\n            }           \\n        }\\n        return resp;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 157705,
                "title": "concise-python-3-o-n-time-o-1-space-beats-100-36ms",
                "content": "```python\\nclass Solution:\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        source, cur = \\'\\\\n\\'.join(source), 0\\n        while \\'//\\' in source or \\'/*\\' in source:\\n            lc, bc = source.find(\\'//\\', cur), source.find(\\'/*\\', cur)\\n            if bc == -1 or lc != -1 and lc < bc: # line comment\\n                bl = source.find(\\'\\\\n\\', lc)\\n                source = source[:lc] + (source[bl:] if bl != -1 else \\'\\')\\n                cur = lc\\n            else: # block comment\\n                source = source[:bc] + source[source.index(\\'*/\\', bc+2) + 2:]\\n                cur = bc\\n        return [x for x in source.split(\\'\\\\n\\') if x]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        source, cur = \\'\\\\n\\'.join(source), 0\\n        while \\'//\\' in source or \\'/*\\' in source:\\n            lc, bc = source.find(\\'//\\', cur), source.find(\\'/*\\', cur)\\n            if bc == -1 or lc != -1 and lc < bc: # line comment\\n                bl = source.find(\\'\\\\n\\', lc)\\n                source = source[:lc] + (source[bl:] if bl != -1 else \\'\\')\\n                cur = lc\\n            else: # block comment\\n                source = source[:bc] + source[source.index(\\'*/\\', bc+2) + 2:]\\n                cur = bc\\n        return [x for x in source.split(\\'\\\\n\\') if x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155949,
                "title": "my-one-pass-python-solution-beats-98-53-36-ms",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source):\\n        res, block, hold, blockStart = [], False, False, -1\\n        for line in source:\\n            if not hold: cache = \"\"\\n            for i, c in enumerate(line):\\n                if not block: cache += c\\n                if cache[-2:] == \"//\":\\n                    cache = cache[:-2]\\n                    break\\n                elif cache[-2:] == \"/*\": blockStart, cache, block = i, cache[:-2], True\\n                elif line[i - 1:i + 1] == \"*/\" and blockStart < i - 1: block = False\\n            if not block:\\n                if cache: res += cache,\\n                hold = False\\n            else: hold, blockStart = True, -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source):\\n        res, block, hold, blockStart = [], False, False, -1\\n        for line in source:\\n            if not hold: cache = \"\"\\n            for i, c in enumerate(line):\\n                if not block: cache += c\\n                if cache[-2:] == \"//\":\\n                    cache = cache[:-2]\\n                    break\\n                elif cache[-2:] == \"/*\": blockStart, cache, block = i, cache[:-2], True\\n                elif line[i - 1:i + 1] == \"*/\" and blockStart < i - 1: block = False\\n            if not block:\\n                if cache: res += cache,\\n                hold = False\\n            else: hold, blockStart = True, -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140490,
                "title": "goto-is-hazardous-but-i-still-love-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        bool open=false;\\n        for (auto i:source){\\n            string now=i;\\n            loop:;\\n            if (open){\\n                if (now.find(\"*/\")==string::npos) continue;\\n                now.erase(0,now.find(\"*/\")+2);\\n                open=false;\\n            }\\n            int pos1=-1,pos2=-1;\\n            if (now.find(\"//\")!=string::npos) pos1=now.find(\"//\");\\n            if (now.find(\"/*\")!=string::npos) pos2=now.find(\"/*\");\\n            if (pos1==-1&&pos2==-1){\\n                temp+=now;\\n                if (temp!=\"\") ans.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            if ((pos1!=-1&&pos2!=-1&&pos1<pos2)||pos2==-1){\\n                temp+=now.substr(0,now.find(\"//\"));\\n                if (temp!=\"\") ans.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            else{\\n                temp+=now.substr(0,now.find(\"/*\"));\\n                now.erase(0,now.find(\"/*\")+2);\\n                open=true;\\n                goto loop;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        bool open=false;\\n        for (auto i:source){\\n            string now=i;\\n            loop:;\\n            if (open){\\n                if (now.find(\"*/\")==string::npos) continue;\\n                now.erase(0,now.find(\"*/\")+2);\\n                open=false;\\n            }\\n            int pos1=-1,pos2=-1;\\n            if (now.find(\"//\")!=string::npos) pos1=now.find(\"//\");\\n            if (now.find(\"/*\")!=string::npos) pos2=now.find(\"/*\");\\n            if (pos1==-1&&pos2==-1){\\n                temp+=now;\\n                if (temp!=\"\") ans.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            if ((pos1!=-1&&pos2!=-1&&pos1<pos2)||pos2==-1){\\n                temp+=now.substr(0,now.find(\"//\"));\\n                if (temp!=\"\") ans.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            else{\\n                temp+=now.substr(0,now.find(\"/*\"));\\n                now.erase(0,now.find(\"/*\")+2);\\n                open=true;\\n                goto loop;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121534,
                "title": "google-interview-questions-general-solution-beats-98-percent",
                "content": "considering sing/double quotes and escape characters:\\n\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::string> removeComments(std::vector<std::string>& source) {\\n        std::string x;\\n        for (auto& t : source) {\\n            x.append(t);\\n            x.push_back(\\'\\\\n\\');\\n        }\\n        std::string res;\\n        for (int i = 0; i < x.size(); i++) {\\n            if (x[i] == \\'/\\' && i + 1 < x.size() && x[i + 1] == \\'*\\') {\\n                i += 2;\\n                while (i + 1 < x.size() && (x[i] != \\'*\\' || x[i + 1] != \\'/\\'))i++;\\n                i += 1;\\n            }\\n            else if (x[i] == \\'/\\' && i + 1 < x.size() && x[i + 1] == \\'/\\') {\\n                i += 2;\\n                while (i < x.size() && x[i] != \\'\\\\n\\')i++;\\n                i--;\\n            }\\n            else if (x[i] == \\'\"\\') {\\n                res.push_back(x[i++]);\\n                while (true) {\\n                    while (i < x.size() && x[i] != \\'\"\\') {\\n                        res.push_back(x[i++]);\\n                    }\\n                    res.push_back(\\'\"\\');\\n                    int j = i - 1;\\n                    while (x[j] == \\'\\\\\\\\\\') j--;\\n                    if ((i - 1 - j) % 2 == 0) break;\\n                    i++;\\n                }\\n            }\\n            else if (x[i] == \\'\\\\\\'\\' && i + 1 < x.size() && x[i + 1] == \\'\"\\') {\\n                res.push_back(x[i]);\\n                res.push_back(x[i + 1]);\\n                res.push_back(x[i + 2]);\\n                i += 2;\\n            }\\n            else {\\n                res.push_back(x[i]);\\n            }\\n        }\\n        int i = 0, j = 0;\\n        std::vector<std::string> vs;\\n        while ((j = res.find(\\'\\\\n\\', j)) != res.npos) {\\n            if (j != i) vs.push_back(res.substr(i, j - i));\\n            j = i = j + 1;\\n        }\\n        return vs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<std::string> removeComments(std::vector<std::string>& source) {\\n        std::string x;\\n        for (auto& t : source) {\\n            x.append(t);\\n            x.push_back(\\'\\\\n\\');\\n        }\\n        std::string res;\\n        for (int i = 0; i < x.size(); i++) {\\n            if (x[i] == \\'/\\' && i + 1 < x.size() && x[i + 1] == \\'*\\') {\\n                i += 2;\\n                while (i + 1 < x.size() && (x[i] != \\'*\\' || x[i + 1] != \\'/\\'))i++;\\n                i += 1;\\n            }\\n            else if (x[i] == \\'/\\' && i + 1 < x.size() && x[i + 1] == \\'/\\') {\\n                i += 2;\\n                while (i < x.size() && x[i] != \\'\\\\n\\')i++;\\n                i--;\\n            }\\n            else if (x[i] == \\'\"\\') {\\n                res.push_back(x[i++]);\\n                while (true) {\\n                    while (i < x.size() && x[i] != \\'\"\\') {\\n                        res.push_back(x[i++]);\\n                    }\\n                    res.push_back(\\'\"\\');\\n                    int j = i - 1;\\n                    while (x[j] == \\'\\\\\\\\\\') j--;\\n                    if ((i - 1 - j) % 2 == 0) break;\\n                    i++;\\n                }\\n            }\\n            else if (x[i] == \\'\\\\\\'\\' && i + 1 < x.size() && x[i + 1] == \\'\"\\') {\\n                res.push_back(x[i]);\\n                res.push_back(x[i + 1]);\\n                res.push_back(x[i + 2]);\\n                i += 2;\\n            }\\n            else {\\n                res.push_back(x[i]);\\n            }\\n        }\\n        int i = 0, j = 0;\\n        std::vector<std::string> vs;\\n        while ((j = res.find(\\'\\\\n\\', j)) != res.npos) {\\n            if (j != i) vs.push_back(res.substr(i, j - i));\\n            j = i = j + 1;\\n        }\\n        return vs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112725,
                "title": "6-liner-c-regex-replacement",
                "content": "Thanks to solution by @StefanPochmann \\n```cpp\\n    vector<string> removeComments(vector<string>& source) \\n    {        \\n        string s; // join source into a single line with token '\\\\n'\\n        for (auto& line : source) s += line+'\\\\n';\\n\\n        vector<string> res; // split comment removed string into lines\\n        for (stringstream ss(regex_replace(s,regex(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\"),\"\")); getline(ss,s);)\\n            if(!s.empty()) res.push_back(s);\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\n    vector<string> removeComments(vector<string>& source) \\n    {        \\n        string s; // join source into a single line with token '\\\\n'\\n        for (auto& line : source) s += line+'\\\\n';\\n\\n        vector<string> res; // split comment removed string into lines\\n        for (stringstream ss(regex_replace(s,regex(\"//.*|/\\\\\\\\*(.|\\\\n)*?\\\\\\\\*/\"),\"\")); getline(ss,s);)\\n            if(!s.empty()) res.push_back(s);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109212,
                "title": "easy-java-solution",
                "content": "```\\npublic List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        if(source == null || source.length == 0) return res;\\n        boolean left = false;\\n        boolean add = true;\\n        StringBuilder prev = new StringBuilder(\"\");\\n        for(String str: source){\\n            char[] s = str.toCharArray();\\n            for(int i = 0; i < s.length; i++){\\n                if(add) prev.append(s[i]);\\n                if(i < s.length - 1 && s[i] == '/' && s[i + 1] == '/' && !left){\\n                    prev.deleteCharAt(prev.length() - 1);\\n                    break;\\n                }\\n                else if(i < s.length - 1 && s[i] == '/' && s[i + 1] == '*' && !left){\\n                    prev.deleteCharAt(prev.length() - 1);\\n                    left = true;\\n                    add = false;\\n                    i = i + 1;\\n                }\\n                else if(i < s.length - 1 && s[i] == '*' && s[i + 1] == '/' && left){\\n                    left = false;\\n                    add = true;\\n                    i = i + 1;\\n                }\\n            }\\n            if(add && prev.length() > 0){\\n                res.add(prev.toString());\\n                prev = new StringBuilder(\"\");\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> removeComments(String[] source) {\\n        List<String> res = new ArrayList<>();\\n        if(source == null || source.length == 0) return res;\\n        boolean left = false;\\n        boolean add = true;\\n        StringBuilder prev = new StringBuilder(\"\");\\n        for(String str: source){\\n            char[] s = str.toCharArray();\\n            for(int i = 0; i < s.length; i++){\\n                if(add) prev.append(s[i]);\\n                if(i < s.length - 1 && s[i] == '/' && s[i + 1] == '/' && !left){\\n                    prev.deleteCharAt(prev.length() - 1);\\n                    break;\\n                }\\n                else if(i < s.length - 1 && s[i] == '/' && s[i + 1] == '*' && !left){\\n                    prev.deleteCharAt(prev.length() - 1);\\n                    left = true;\\n                    add = false;\\n                    i = i + 1;\\n                }\\n                else if(i < s.length - 1 && s[i] == '*' && s[i + 1] == '/' && left){\\n                    left = false;\\n                    add = true;\\n                    i = i + 1;\\n                }\\n            }\\n            if(add && prev.length() > 0){\\n                res.add(prev.toString());\\n                prev = new StringBuilder(\"\");\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098072,
                "title": "memory-beats-96-30-of-users-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n13.25 mb\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        result =[]\\n        multilines = False\\n        start_row=0\\n        end_row=0\\n        \\n        for i in range(len(source)):\\n            line =source[i]\\n            j=0\\n            curr= \"\"\\n            while j < len(line):\\n                \\n                if multilines == False:\\n                    if line[j:j + 2] == \"/*\":\\n                        multilines = True\\n                        start_row = i\\n                        start_col = j\\n                        j = j + 1\\n                    elif line[j:j + 2] == \"//\":\\n                        break\\n                    else:\\n                        curr += line[j]\\n                        \\n                    # end if\\n                else:\\n                    if line[j:j + 2] == \"*/\":\\n                        multilines = False\\n                        end_row = i\\n                        end_col = j\\n                        j = j+1\\n                    # end if\\n                # end if\\n                j += 1\\n            # end while\\n           \\n            \\n            result.append(curr)\\n        # end for\\n        \\n        if start_row != end_row:\\n            \\n            result[start_row] = result[start_row] + result[end_row]\\n            result[end_row] =\"\"\\n\\n        result = list(filter(None, result))    \\n        # end if\\n        return result\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeComments(self, source):\\n        \"\"\"\\n        :type source: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        result =[]\\n        multilines = False\\n        start_row=0\\n        end_row=0\\n        \\n        for i in range(len(source)):\\n            line =source[i]\\n            j=0\\n            curr= \"\"\\n            while j < len(line):\\n                \\n                if multilines == False:\\n                    if line[j:j + 2] == \"/*\":\\n                        multilines = True\\n                        start_row = i\\n                        start_col = j\\n                        j = j + 1\\n                    elif line[j:j + 2] == \"//\":\\n                        break\\n                    else:\\n                        curr += line[j]\\n                        \\n                    # end if\\n                else:\\n                    if line[j:j + 2] == \"*/\":\\n                        multilines = False\\n                        end_row = i\\n                        end_col = j\\n                        j = j+1\\n                    # end if\\n                # end if\\n                j += 1\\n            # end while\\n           \\n            \\n            result.append(curr)\\n        # end for\\n        \\n        if start_row != end_row:\\n            \\n            result[start_row] = result[start_row] + result[end_row]\\n            result[end_row] =\"\"\\n\\n        result = list(filter(None, result))    \\n        # end if\\n        return result\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091308,
                "title": "php-runtime-beats-100-memory-beats-100",
                "content": "# Intuition\\n-Loop for lines and characters\\n\\n# Approach\\n-Copy linewise character in result\\n-If // found, break the loop and skip entire line\\n-If /* found, stop coping characters, set multilines true\\n-if */ found and multilines is true , start copying characters from the next j position\\n-For multilines comment , combine two rows in one ,start_row and end_row\\n-return the result without comments\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $source\\n     * @return String[]\\n     */\\n    function removeComments($source) {\\n        $result =array();\\n        $multilines = false;\\n        \\n    foreach($source as $i=>$line)\\n     {\\n         for($j=0; $j < strlen($line); $j++)\\n        { if($multilines == false)  \\n            {  if($line[$j].$line[$j+1] == \"/*\" )\\n                {       \\n                        $multilines = true;\\n                        $start_row=$i;\\n                        $start_col =$j;\\n                        $j=$j+1;\\n\\n                }\\n                elseif($line[$j].$line[$j+1] == \"//\")\\n                {\\n                       break;\\n                }\\n                else {          \\n                    $result[$i]=$result[$i].$line[$j];\\n                }                              \\n            }\\n          else\\n           {  if($line[$j].$line[$j+1] == \"*/\")\\n                {   \\n                    $multilines = false;\\n                    $end_row=$i;\\n                    $end_col =$j;\\n                    $j=$j+1;\\n                    \\n                }          \\n             }                \\n        }                                    \\n     }\\n    if($start_row != $end_row)\\n    { \\n        $result[$start_row]  =$result[$start_row] . $result[$end_row]; \\n        $result[$end_row] =\"\";\\n     }\\n   \\n    return array_filter($result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $source\\n     * @return String[]\\n     */\\n    function removeComments($source) {\\n        $result =array();\\n        $multilines = false;\\n        \\n    foreach($source as $i=>$line)\\n     {\\n         for($j=0; $j < strlen($line); $j++)\\n        { if($multilines == false)  \\n            {  if($line[$j].$line[$j+1] == \"/*\" )\\n                {       \\n                        $multilines = true;\\n                        $start_row=$i;\\n                        $start_col =$j;\\n                        $j=$j+1;\\n\\n                }\\n                elseif($line[$j].$line[$j+1] == \"//\")\\n                {\\n                       break;\\n                }\\n                else {          \\n                    $result[$i]=$result[$i].$line[$j];\\n                }                              \\n            }\\n          else\\n           {  if($line[$j].$line[$j+1] == \"*/\")\\n                {   \\n                    $multilines = false;\\n                    $end_row=$i;\\n                    $end_col =$j;\\n                    $j=$j+1;\\n                    \\n                }          \\n             }                \\n        }                                    \\n     }\\n    if($start_row != $end_row)\\n    { \\n        $result[$start_row]  =$result[$start_row] . $result[$end_row]; \\n        $result[$end_row] =\"\";\\n     }\\n   \\n    return array_filter($result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992163,
                "title": "easy-solution-with-comments-beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        // ans which contains all lines which are free from comments\\n        vector<string> ans;\\n        // storing boolean if multi line comment comes or not \\n        bool multiLineComment = false;\\n        // string storing the value before multi line comment \\n        string tem = \"\";\\n        for(auto i:source){\\n            // string storing the value for every line after removing \\n            // the comments \\n            string temp = \"\";\\n            // if any of the multi line comment block exists first \\n            // then we have to add the previous ans to the current \\n            // one \\n            if(multiLineComment){\\n                temp = tem;\\n            }\\n            // storing if single line comment comes in any line \\n            bool singleLineComment = false;\\n            for(int j=0;j<i.length();j++){\\n                // checking if multi line or single line comment \\n                // exists or not if yes then pass this case\\n                if(j+1<i.length() && !multiLineComment && !singleLineComment){\\n                    // checking of single line comments\\n                    if(i[j] == \\'/\\' && i[j+1]==\\'/\\'){\\n                        singleLineComment = true;\\n                        j++;\\n                        continue;\\n                    }\\n                    // checking of the multi line comments\\n                    else if(i[j] == \\'/\\' && i[j+1]==\\'*\\'){\\n                        multiLineComment = true;\\n                        j++;\\n                        continue;\\n                    }\\n                }\\n                // checking if multi line comment exists to remove it \\n                if(j+1<i.length() && multiLineComment){\\n                    // checking for the ending of the multi line \\n                    // comment if it is here \\n                    if(i[j] == \\'*\\' && i[j+1]==\\'/\\'){\\n                        multiLineComment = false;\\n                        j++;\\n                        continue;\\n                    }\\n                }\\n                // if none of types of comments are there then add \\n                // the character to the string \\n                if(!singleLineComment && !multiLineComment){\\n                    temp+=i[j];\\n                }\\n            }\\n            // checking for the empty string becoz we dont need to\\n            // add it to our answer and cheching if multi line exists \\n            // or not if it is then we have to add the current string \\n            // to the previous one\\n            if(temp.length()!=0 && !multiLineComment){\\n                ans.push_back(temp);\\n            }\\n            // adding the current string to the previous string when \\n            // we have encountered with the multi line comment before \\n            if(multiLineComment && temp.length()>0){\\n                tem = temp;\\n            }\\n        }\\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        // ans which contains all lines which are free from comments\\n        vector<string> ans;\\n        // storing boolean if multi line comment comes or not \\n        bool multiLineComment = false;\\n        // string storing the value before multi line comment \\n        string tem = \"\";\\n        for(auto i:source){\\n            // string storing the value for every line after removing \\n            // the comments \\n            string temp = \"\";\\n            // if any of the multi line comment block exists first \\n            // then we have to add the previous ans to the current \\n            // one \\n            if(multiLineComment){\\n                temp = tem;\\n            }\\n            // storing if single line comment comes in any line \\n            bool singleLineComment = false;\\n            for(int j=0;j<i.length();j++){\\n                // checking if multi line or single line comment \\n                // exists or not if yes then pass this case\\n                if(j+1<i.length() && !multiLineComment && !singleLineComment){\\n                    // checking of single line comments\\n                    if(i[j] == \\'/\\' && i[j+1]==\\'/\\'){\\n                        singleLineComment = true;\\n                        j++;\\n                        continue;\\n                    }\\n                    // checking of the multi line comments\\n                    else if(i[j] == \\'/\\' && i[j+1]==\\'*\\'){\\n                        multiLineComment = true;\\n                        j++;\\n                        continue;\\n                    }\\n                }\\n                // checking if multi line comment exists to remove it \\n                if(j+1<i.length() && multiLineComment){\\n                    // checking for the ending of the multi line \\n                    // comment if it is here \\n                    if(i[j] == \\'*\\' && i[j+1]==\\'/\\'){\\n                        multiLineComment = false;\\n                        j++;\\n                        continue;\\n                    }\\n                }\\n                // if none of types of comments are there then add \\n                // the character to the string \\n                if(!singleLineComment && !multiLineComment){\\n                    temp+=i[j];\\n                }\\n            }\\n            // checking for the empty string becoz we dont need to\\n            // add it to our answer and cheching if multi line exists \\n            // or not if it is then we have to add the current string \\n            // to the previous one\\n            if(temp.length()!=0 && !multiLineComment){\\n                ans.push_back(temp);\\n            }\\n            // adding the current string to the previous string when \\n            // we have encountered with the multi line comment before \\n            if(multiLineComment && temp.length()>0){\\n                tem = temp;\\n            }\\n        }\\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956380,
                "title": "go-solution",
                "content": "#### Go\\n\\n```go\\nfunc removeComments(source []string) []string {\\n    line := \"\"\\n    filteredSource := make([]string, 0, len(source))\\n    for len(source) != 0 {\\n        line, source = getLine(source)\\n        if line != \"\" {\\n            filteredSource = append(filteredSource, line)\\n        }\\n    }\\n    return filteredSource\\n}\\n\\nfunc getLine(source []string) (string, []string) {\\n    \\n    prefix, suffix := \"\", \"\"\\n    inComment := false\\n    for {\\n        line := source[0]\\n        source = source[1:]\\n        for i := 0; i < len(line); i++ {\\n            if inComment {\\n                if strings.HasPrefix(line[i:], \"*/\") {\\n                    suffix = line[i+2:]\\n                    return \"\", append([]string{prefix + suffix}, source...)\\n                }\\n            } else {\\n                if strings.HasPrefix(line[i:], \"//\") {\\n                    line = line[:i]\\n                    return line, source\\n                } else if strings.HasPrefix(line[i:], \"/*\") {\\n                    prefix = line[:i]\\n                    i++\\n                    inComment = true\\n                }\\n            }\\n        }\\n        if !inComment {\\n            return line, source\\n        }\\n    }\\n    return \"\", source\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc removeComments(source []string) []string {\\n    line := \"\"\\n    filteredSource := make([]string, 0, len(source))\\n    for len(source) != 0 {\\n        line, source = getLine(source)\\n        if line != \"\" {\\n            filteredSource = append(filteredSource, line)\\n        }\\n    }\\n    return filteredSource\\n}\\n\\nfunc getLine(source []string) (string, []string) {\\n    \\n    prefix, suffix := \"\", \"\"\\n    inComment := false\\n    for {\\n        line := source[0]\\n        source = source[1:]\\n        for i := 0; i < len(line); i++ {\\n            if inComment {\\n                if strings.HasPrefix(line[i:], \"*/\") {\\n                    suffix = line[i+2:]\\n                    return \"\", append([]string{prefix + suffix}, source...)\\n                }\\n            } else {\\n                if strings.HasPrefix(line[i:], \"//\") {\\n                    line = line[:i]\\n                    return line, source\\n                } else if strings.HasPrefix(line[i:], \"/*\") {\\n                    prefix = line[:i]\\n                    i++\\n                    inComment = true\\n                }\\n            }\\n        }\\n        if !inComment {\\n            return line, source\\n        }\\n    }\\n    return \"\", source\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951181,
                "title": "python-o-n-with-comments",
                "content": "With comments:\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        \\n        #set a number to see if the code is inBlockComment\\n        #0 means False, meaning not in a block a comment\\n        #whenever a block comment starts,\\n        #this variable is set to (i + 1)*(j + 1)\\n        #this is so that the starting position of the block comment is recorded \\n        #both i and j are used to have a unique position\\n        inBlockComment = 0 \\n        \\n        for j in range(len(source)):\\n            line = source[j]\\n            \\n            #only refresh the resultLine if not in a block comment\\n            #because if we are in a block comment, newlines could be deleted\\n            if not inBlockComment:\\n                resultLine = \"\"\\n            for i in range(len(line)):\\n                \\n                #check for // \\n                if not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"/\":\\n                    break\\n                    \\n                #check for /*, start of block comment\\n                elif not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"*\":\\n                    inBlockComment = (i + 1)*(j + 1)\\n                \\n                if not inBlockComment:\\n                    resultLine += line[i]\\n                   \\n                #check for */, end of block comment\\n                if inBlockComment and i > 0 and line[i - 1] == \"*\" and line[i] == \"/\":\\n                    \\n                    #check for /*/, start and end of block comment cannot be oerlapping\\n                    if i > 1 and line[i - 2] == \"/\" and inBlockComment == (i - 1)*(j + 1):\\n                        continue\\n                    inBlockComment = 0\\n            \\n            #add to the result\\n            if not inBlockComment and resultLine != \"\":\\n                result.append(resultLine)\\n        return result\\n```\\n\\nWithout comments:\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        inBlockComment = 0 \\n        \\n        for j in range(len(source)):\\n            line = source[j]\\n\\n            if not inBlockComment:\\n                resultLine = \"\"\\n            for i in range(len(line)):\\n                if not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"/\":\\n                    break\\n                elif not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"*\":\\n                    inBlockComment = (i + 1)*(j + 1)                \\n                if not inBlockComment:\\n                    resultLine += line[i]\\n                if inBlockComment and i > 0 and line[i - 1] == \"*\" and line[i] == \"/\":\\n                    if i > 1 and line[i - 2] == \"/\" and inBlockComment == (i - 1)*(j + 1):\\n                        continue\\n                    inBlockComment = 0\\n\\n            if not inBlockComment and resultLine != \"\":\\n                result.append(resultLine)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        \\n        #set a number to see if the code is inBlockComment\\n        #0 means False, meaning not in a block a comment\\n        #whenever a block comment starts,\\n        #this variable is set to (i + 1)*(j + 1)\\n        #this is so that the starting position of the block comment is recorded \\n        #both i and j are used to have a unique position\\n        inBlockComment = 0 \\n        \\n        for j in range(len(source)):\\n            line = source[j]\\n            \\n            #only refresh the resultLine if not in a block comment\\n            #because if we are in a block comment, newlines could be deleted\\n            if not inBlockComment:\\n                resultLine = \"\"\\n            for i in range(len(line)):\\n                \\n                #check for // \\n                if not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"/\":\\n                    break\\n                    \\n                #check for /*, start of block comment\\n                elif not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"*\":\\n                    inBlockComment = (i + 1)*(j + 1)\\n                \\n                if not inBlockComment:\\n                    resultLine += line[i]\\n                   \\n                #check for */, end of block comment\\n                if inBlockComment and i > 0 and line[i - 1] == \"*\" and line[i] == \"/\":\\n                    \\n                    #check for /*/, start and end of block comment cannot be oerlapping\\n                    if i > 1 and line[i - 2] == \"/\" and inBlockComment == (i - 1)*(j + 1):\\n                        continue\\n                    inBlockComment = 0\\n            \\n            #add to the result\\n            if not inBlockComment and resultLine != \"\":\\n                result.append(resultLine)\\n        return result\\n```\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        inBlockComment = 0 \\n        \\n        for j in range(len(source)):\\n            line = source[j]\\n\\n            if not inBlockComment:\\n                resultLine = \"\"\\n            for i in range(len(line)):\\n                if not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"/\":\\n                    break\\n                elif not inBlockComment and i != len(line) - 1 and line[i] == \"/\" and line[i + 1] == \"*\":\\n                    inBlockComment = (i + 1)*(j + 1)                \\n                if not inBlockComment:\\n                    resultLine += line[i]\\n                if inBlockComment and i > 0 and line[i - 1] == \"*\" and line[i] == \"/\":\\n                    if i > 1 and line[i - 2] == \"/\" and inBlockComment == (i - 1)*(j + 1):\\n                        continue\\n                    inBlockComment = 0\\n\\n            if not inBlockComment and resultLine != \"\":\\n                result.append(resultLine)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946813,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    \\n    boolean isCommentBegan=false;\\n    String lineBeforeComm=\"\";\\n    public List<String> removeComments(String[] source) {\\n        List<String> res=new ArrayList();\\n        for(String line:source){\\n            line=helper(line);\\n            if(line!=null){\\n                res.add(line);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private String helper(String line){\\n        if(line.length()==0){\\n            return null;\\n        }\\n        if(isCommentBegan){\\n            int index=line.indexOf(\"*/\");\\n            if(index<0){\\n                return null;\\n            }\\n            isCommentBegan=false;\\n            StringBuilder sb=new StringBuilder();\\n            sb.append(lineBeforeComm);\\n            sb.append(line.substring(index+2,line.length()));\\n            line=sb.toString();\\n        }else if(!isCommentBegan){\\n            int index1=line.indexOf(\"//\");\\n            int index2=line.indexOf(\"/*\");\\n            if(index1>=0 && (index2<0 || index1<index2) ){\\n                line=line.substring(0,index1);\\n            }else{\\n                if(index2<0){\\n                    return line;\\n                }\\n                isCommentBegan=true;\\n                lineBeforeComm=line.substring(0,index2);\\n                line=line.substring(index2+2,line.length());\\n            }\\n        }\\n        return helper(line);\\n    }\\n}\\n```\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {      \\n        string cur=\"\";\\n        vector<string> out;\\n        bool comm=false; // it will help us see whether comment is active or not\\n\\n        for(string s: source){\\n            for(int j=0; j<s.size(); j++){\\n                // that means a comment is started\\n                if(!comm && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                    comm = true;\\n                    j++;\\n                }\\n                // what if a // <- is present, then full line is not read & break\\n                // also make sure it is outside comments\\n                else if(!comm && s[j]==\\'/\\' && s[j+1]==\\'/\\') break;\\n                // check if a comment is completed\\n                else if(comm && s[j]==\\'*\\' && s[j+1]==\\'/\\') {\\n                    comm=false;\\n                    j++;\\n                }\\n                // or else it is a valid code\\n                else if (!comm)\\n                    cur+=s[j];\\n            }\\n            // now check if it\\'s a comment or not and its not blank (because comments\\n            // are blank lines) and add it to output\\n\\n            if(!comm && cur.size()){\\n                out.push_back(cur);\\n                cur=\"\";\\n            }\\n        }\\n        return out; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    \\n    boolean isCommentBegan=false;\\n    String lineBeforeComm=\"\";\\n    public List<String> removeComments(String[] source) {\\n        List<String> res=new ArrayList();\\n        for(String line:source){\\n            line=helper(line);\\n            if(line!=null){\\n                res.add(line);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private String helper(String line){\\n        if(line.length()==0){\\n            return null;\\n        }\\n        if(isCommentBegan){\\n            int index=line.indexOf(\"*/\");\\n            if(index<0){\\n                return null;\\n            }\\n            isCommentBegan=false;\\n            StringBuilder sb=new StringBuilder();\\n            sb.append(lineBeforeComm);\\n            sb.append(line.substring(index+2,line.length()));\\n            line=sb.toString();\\n        }else if(!isCommentBegan){\\n            int index1=line.indexOf(\"//\");\\n            int index2=line.indexOf(\"/*\");\\n            if(index1>=0 && (index2<0 || index1<index2) ){\\n                line=line.substring(0,index1);\\n            }else{\\n                if(index2<0){\\n                    return line;\\n                }\\n                isCommentBegan=true;\\n                lineBeforeComm=line.substring(0,index2);\\n                line=line.substring(index2+2,line.length());\\n            }\\n        }\\n        return helper(line);\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {      \\n        string cur=\"\";\\n        vector<string> out;\\n        bool comm=false; // it will help us see whether comment is active or not\\n\\n        for(string s: source){\\n            for(int j=0; j<s.size(); j++){\\n                // that means a comment is started\\n                if(!comm && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                    comm = true;\\n                    j++;\\n                }\\n                // what if a // <- is present, then full line is not read & break\\n                // also make sure it is outside comments\\n                else if(!comm && s[j]==\\'/\\' && s[j+1]==\\'/\\') break;\\n                // check if a comment is completed\\n                else if(comm && s[j]==\\'*\\' && s[j+1]==\\'/\\') {\\n                    comm=false;\\n                    j++;\\n                }\\n                // or else it is a valid code\\n                else if (!comm)\\n                    cur+=s[j];\\n            }\\n            // now check if it\\'s a comment or not and its not blank (because comments\\n            // are blank lines) and add it to output\\n\\n            if(!comm && cur.size()){\\n                out.push_back(cur);\\n                cur=\"\";\\n            }\\n        }\\n        return out; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935743,
                "title": "python3-one-pass",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = list()\\n        box_comment = False \\n        tmp = \"\"\\n\\n        for val in source:\\n            idx = 0 \\n            while idx < len(val):\\n                char = val[idx]\\n                if box_comment and char == \"*\" and idx + 1 <len(val) and val[idx+1] == \"/\":\\n                    idx += 1\\n                    box_comment = False\\n                elif not box_comment and char == \"/\" and idx + 1 <len(val) and val[idx+1] == \"/\":\\n                    idx += 1\\n                    break\\n                elif not box_comment and char == \"/\" and idx + 1 <len(val) and val[idx+1] == \"*\":\\n                    idx += 1\\n                    box_comment = True\\n                elif not box_comment:\\n                    tmp += char\\n                idx += 1\\n                \\n            if tmp != \"\" and not box_comment:\\n                result.append(tmp)\\n                tmp = \"\"\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = list()\\n        box_comment = False \\n        tmp = \"\"\\n\\n        for val in source:\\n            idx = 0 \\n            while idx < len(val):\\n                char = val[idx]\\n                if box_comment and char == \"*\" and idx + 1 <len(val) and val[idx+1] == \"/\":\\n                    idx += 1\\n                    box_comment = False\\n                elif not box_comment and char == \"/\" and idx + 1 <len(val) and val[idx+1] == \"/\":\\n                    idx += 1\\n                    break\\n                elif not box_comment and char == \"/\" and idx + 1 <len(val) and val[idx+1] == \"*\":\\n                    idx += 1\\n                    box_comment = True\\n                elif not box_comment:\\n                    tmp += char\\n                idx += 1\\n                \\n            if tmp != \"\" and not box_comment:\\n                result.append(tmp)\\n                tmp = \"\"\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927267,
                "title": "beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwhile traversing through source and each string just take a flag var to know if u encounter a comment statement /* in other case // u just need to break there u wont require any thing as // is fr only single line  comments so u add string to ans if there is no /* comment and string not empty and to encounter */ we see at first if f==1 and check if we have */ in this case we added extra string before /* and after */ thats y we intialized string t before for loop to avoid prob while merging instead of taking everytime a string t=\"\" for each string in source .\\nhope you got something please upvote if you like.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n       \\n        vector<string> ans;\\n        int f=0;\\n       \\n        string t=\"\";\\n        for(auto x:source){\\n               \\n                for(int i=0;i<x.size();){\\n                    if(f==1){\\n                        if(x[i]==\\'*\\' && x[i+1]==\\'/\\')\\n                          {f=0;\\n                          i=i+2;\\n                          }\\n                          else i++;\\n                    }\\n                    else {\\n                    if(x[i]==\\'/\\' && x[i+1]==\\'/\\'){\\n                        break;\\n                    }\\n                    else if(x[i]==\\'/\\' && x[i+1]==\\'*\\')\\n                    {\\n                        f=1;\\n                        i=i+2;\\n                    }\\n                    else{\\n                        t+=x[i];\\n                        i++;\\n                    }\\n                    }\\n                }\\n              \\n                if(f==0 && t.size()!=0)  {\\n                   ans.push_back(t);\\n                   t=\"\";\\n                   }\\n               \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n       \\n        vector<string> ans;\\n        int f=0;\\n       \\n        string t=\"\";\\n        for(auto x:source){\\n               \\n                for(int i=0;i<x.size();){\\n                    if(f==1){\\n                        if(x[i]==\\'*\\' && x[i+1]==\\'/\\')\\n                          {f=0;\\n                          i=i+2;\\n                          }\\n                          else i++;\\n                    }\\n                    else {\\n                    if(x[i]==\\'/\\' && x[i+1]==\\'/\\'){\\n                        break;\\n                    }\\n                    else if(x[i]==\\'/\\' && x[i+1]==\\'*\\')\\n                    {\\n                        f=1;\\n                        i=i+2;\\n                    }\\n                    else{\\n                        t+=x[i];\\n                        i++;\\n                    }\\n                    }\\n                }\\n              \\n                if(f==0 && t.size()!=0)  {\\n                   ans.push_back(t);\\n                   t=\"\";\\n                   }\\n               \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919811,
                "title": "easy-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        int n=source.size();\\n        int i=0;\\n        string str=\"\";\\n         bool flag1=false;\\n            bool flag2=false;\\n            bool flag3=false;\\n        for(int i=0;i<n;i++){\\n            string curr=source[i];\\n            int j=0;\\n            int size=curr.length();\\n            while(j<size){\\n                 if(!flag2 && j+1<size && curr[j]==\\'/\\' && curr[j+1]==\\'/\\'){\\n               // flag1=true;\\n                break;\\n                }\\n               else if(!flag2 && j+1<size && curr[j]==\\'/\\' && curr[j+1]==\\'*\\'){\\n                    flag2=true;\\n                    j+=2;\\n                }\\n               else if(flag2 && j+1<size && curr[j]==\\'*\\' && curr[j+1]==\\'/\\'){\\n                    flag2=false;\\n                    j+=2;\\n                }\\n               \\n               else if(!flag2){\\n                    str+=curr[j];\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            if(!flag2 ){\\n                if(str.length()>0){\\n                ans.push_back(str);\\n                str=\"\";\\n                }\\n                str=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string>ans;\\n        int n=source.size();\\n        int i=0;\\n        string str=\"\";\\n         bool flag1=false;\\n            bool flag2=false;\\n            bool flag3=false;\\n        for(int i=0;i<n;i++){\\n            string curr=source[i];\\n            int j=0;\\n            int size=curr.length();\\n            while(j<size){\\n                 if(!flag2 && j+1<size && curr[j]==\\'/\\' && curr[j+1]==\\'/\\'){\\n               // flag1=true;\\n                break;\\n                }\\n               else if(!flag2 && j+1<size && curr[j]==\\'/\\' && curr[j+1]==\\'*\\'){\\n                    flag2=true;\\n                    j+=2;\\n                }\\n               else if(flag2 && j+1<size && curr[j]==\\'*\\' && curr[j+1]==\\'/\\'){\\n                    flag2=false;\\n                    j+=2;\\n                }\\n               \\n               else if(!flag2){\\n                    str+=curr[j];\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            if(!flag2 ){\\n                if(str.length()>0){\\n                ans.push_back(str);\\n                str=\"\";\\n                }\\n                str=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901132,
                "title": "python-1-pass",
                "content": "Imagine that you need to process `ROWS x COLS` grid row by row, column to column.\\n\\n1. You have 2 cases:\\n1.1. You\\'re adding chars\\nTill you get `//` and now you skip the line and go to the next line\\nTill you get `/*` and now you set skip mode and skip all text till you get `*/`\\n1.2. You\\'re skipping chars\\nTill you get `*/`. Turn off skip mode.\\n2. If you processed the line:\\n2.1. You add processing result to output if you\\'re not in skip mode. Move to next line\\n2.2. Move to next line\\n\\n![image](https://assets.leetcode.com/users/images/be8a54ce-cd50-4e06-a6da-34be765f4def_1691880001.56001.png)\\n\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \"\"\"\\n        \"/*Test program */\" <-- found \\'/*\\', skip all till \\'*/\\'. if left empty -> skip line\\n        \"int main()\" <-- return as is\\n        \"{ \" <-- return as is\\n        \"  // variable declaration \" <-- remove all after \\'//\\'. if left empty -> skip line\\n        \"int a, b, c;\" <-- return as is\\n        \"/* This is a test\"<-- found \\'/*\\'\\n        \"   multiline  \"skip all till \\'*/\\'\\n        \"   comment for \"skip all till \\'*/\\'\\n        \"   testing */\"skip all till \\'*/\\'. if left empty -> skip line\\n        \"a = b + c;\" <-- return as is\\n        \"}\" <-- return as is\\n        \\n        \"a/*comment\" <-- found \\'/*\\'. if left empty -> skip line\\n        \"line\" <--  skip all till \\'*/\\'\\n        \"more_comment*/b\" <--  skip all till \\'*/\\'. if left empty -> skip line\\n        \\n        \"a/*/*/b\" is a valid comment <-- ab\\n        \"\"\"\\n        res = []\\n        skip = False\\n        line = []\\n        for s in source:\\n            c = 0\\n            while c < len(s):\\n                if skip:\\n                    if s[c:c+2] == \\'*/\\':\\n                        skip = False\\n                        c += 1\\n                elif not skip:\\n                    if s[c:c+2] == \\'//\\':\\n                        break\\n                    elif s[c:c+2] == \\'/*\\':\\n                        skip = True\\n                        c += 1\\n                    else:\\n                        line.append(s[c])\\n                c += 1\\n            if not skip and len(line):\\n                res.append(\\'\\'.join(line))\\n                line = []\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \"\"\"\\n        \"/*Test program */\" <-- found \\'/*\\', skip all till \\'*/\\'. if left empty -> skip line\\n        \"int main()\" <-- return as is\\n        \"{ \" <-- return as is\\n        \"  // variable declaration \" <-- remove all after \\'//\\'. if left empty -> skip line\\n        \"int a, b, c;\" <-- return as is\\n        \"/* This is a test\"<-- found \\'/*\\'\\n        \"   multiline  \"skip all till \\'*/\\'\\n        \"   comment for \"skip all till \\'*/\\'\\n        \"   testing */\"skip all till \\'*/\\'. if left empty -> skip line\\n        \"a = b + c;\" <-- return as is\\n        \"}\" <-- return as is\\n        \\n        \"a/*comment\" <-- found \\'/*\\'. if left empty -> skip line\\n        \"line\" <--  skip all till \\'*/\\'\\n        \"more_comment*/b\" <--  skip all till \\'*/\\'. if left empty -> skip line\\n        \\n        \"a/*/*/b\" is a valid comment <-- ab\\n        \"\"\"\\n        res = []\\n        skip = False\\n        line = []\\n        for s in source:\\n            c = 0\\n            while c < len(s):\\n                if skip:\\n                    if s[c:c+2] == \\'*/\\':\\n                        skip = False\\n                        c += 1\\n                elif not skip:\\n                    if s[c:c+2] == \\'//\\':\\n                        break\\n                    elif s[c:c+2] == \\'/*\\':\\n                        skip = True\\n                        c += 1\\n                    else:\\n                        line.append(s[c])\\n                c += 1\\n            if not skip and len(line):\\n                res.append(\\'\\'.join(line))\\n                line = []\\n        return res\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3886920,
                "title": "go-easy-to-understand",
                "content": "```\\nfunc removeComments(source []string) []string {\\n    res, cur, block := []string{}, \"\", false\\n    \\n    for _, line := range source {\\n        n := len(line)\\n\\n        for i := 0; i < n; i++ {\\n            char, isLast := line[i], false\\n            var next byte\\n\\n            if i == n - 1 {\\n                isLast = true\\n            } else {\\n                next = line[i + 1]\\n            }\\n\\n            if block {\\n                if char == \\'*\\' && !isLast && next == \\'/\\' {\\n                    block = false\\n                    i++\\n                }\\n            } else {\\n                if char == \\'/\\' && !isLast && (next == \\'/\\' || next == \\'*\\') {\\n                    if next == \\'*\\' {\\n                        block = true\\n                        i++\\n                    } else {\\n                        break\\n                    }\\n                } else {\\n                    cur += string(char)\\n                }\\n            }\\n        }\\n\\n        if !block && cur != \"\" {\\n            res = append(res, cur)\\n            cur = \"\"\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeComments(source []string) []string {\\n    res, cur, block := []string{}, \"\", false\\n    \\n    for _, line := range source {\\n        n := len(line)\\n\\n        for i := 0; i < n; i++ {\\n            char, isLast := line[i], false\\n            var next byte\\n\\n            if i == n - 1 {\\n                isLast = true\\n            } else {\\n                next = line[i + 1]\\n            }\\n\\n            if block {\\n                if char == \\'*\\' && !isLast && next == \\'/\\' {\\n                    block = false\\n                    i++\\n                }\\n            } else {\\n                if char == \\'/\\' && !isLast && (next == \\'/\\' || next == \\'*\\') {\\n                    if next == \\'*\\' {\\n                        block = true\\n                        i++\\n                    } else {\\n                        break\\n                    }\\n                } else {\\n                    cur += string(char)\\n                }\\n            }\\n        }\\n\\n        if !block && cur != \"\" {\\n            res = append(res, cur)\\n            cur = \"\"\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855811,
                "title": "stright-foward-python3-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        # for i in source:\\n        #     print(i, \"\\\\n\")\\n        \\n        res = [] \\n        blockComment = False \\n        blockEndingThisLine = False \\n        blockStartingThisLine = False \\n        for line in source:\\n            newLineTemp = \"\"\\n            i = 0 \\n            \\n            blockStartingThisLine=False\\n            while i <= (len(line)-1):\\n                if line[i:i+2] == \"//\" and blockComment == False:\\n                    break \\n                if line[i:i+2] == \"/*\" and blockComment == False: \\n                    blockComment = True \\n                    blockStartingThisLine = True \\n                    i +=2\\n                    # print(\"blockComment = True\" , line[i:i+2])\\n                    if i >len(line)-1:\\n                        break \\n                if line[i:i+2] == \"*/\" and blockComment == True: \\n                    blockComment = False \\n                    if blockStartingThisLine: \\n                        blockEndingThisLine = False \\n                    else:\\n                        blockEndingThisLine = True \\n                    # print(\"blockComment = False, ending block comment i+=2\" , line[i:i+2], blockEndingThisLine)\\n                    i +=2\\n                    if i >len(line)-1:\\n                        blockEndingThisLine = False \\n                        break \\n                else: \\n                    if blockComment == False: \\n                        newLineTemp = newLineTemp + line[i]\\n                        i +=1\\n                    else: \\n                        i +=1\\n            \\n            if \"/**/\" in line:\\n                blockEndingThisLine = False \\n\\n            # print(\"newLineTemp: \", newLineTemp)\\n            if newLineTemp:\\n                if blockEndingThisLine == True:\\n                    # print(\"temp: \", newLineTemp, \"line: \",line , blockEndingThisLine)\\n                    res[-1] = res[-1] + newLineTemp\\n                    blockEndingThisLine = False \\n                else: \\n                    res.append(newLineTemp)\\n        \\n        return(res)\\n                     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        # for i in source:\\n        #     print(i, \"\\\\n\")\\n        \\n        res = [] \\n        blockComment = False \\n        blockEndingThisLine = False \\n        blockStartingThisLine = False \\n        for line in source:\\n            newLineTemp = \"\"\\n            i = 0 \\n            \\n            blockStartingThisLine=False\\n            while i <= (len(line)-1):\\n                if line[i:i+2] == \"//\" and blockComment == False:\\n                    break \\n                if line[i:i+2] == \"/*\" and blockComment == False: \\n                    blockComment = True \\n                    blockStartingThisLine = True \\n                    i +=2\\n                    # print(\"blockComment = True\" , line[i:i+2])\\n                    if i >len(line)-1:\\n                        break \\n                if line[i:i+2] == \"*/\" and blockComment == True: \\n                    blockComment = False \\n                    if blockStartingThisLine: \\n                        blockEndingThisLine = False \\n                    else:\\n                        blockEndingThisLine = True \\n                    # print(\"blockComment = False, ending block comment i+=2\" , line[i:i+2], blockEndingThisLine)\\n                    i +=2\\n                    if i >len(line)-1:\\n                        blockEndingThisLine = False \\n                        break \\n                else: \\n                    if blockComment == False: \\n                        newLineTemp = newLineTemp + line[i]\\n                        i +=1\\n                    else: \\n                        i +=1\\n            \\n            if \"/**/\" in line:\\n                blockEndingThisLine = False \\n\\n            # print(\"newLineTemp: \", newLineTemp)\\n            if newLineTemp:\\n                if blockEndingThisLine == True:\\n                    # print(\"temp: \", newLineTemp, \"line: \",line , blockEndingThisLine)\\n                    res[-1] = res[-1] + newLineTemp\\n                    blockEndingThisLine = False \\n                else: \\n                    res.append(newLineTemp)\\n        \\n        return(res)\\n                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828324,
                "title": "remove-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- see code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- see code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- m\\n\\n# Code\\n```\\n// // class Solution {\\n// // public:\\n// // vector<string> removeComments(vector<string>& source) {\\n// //     int n = source.size();\\n// //     vector<string> ans;\\n// //     int k = 0;\\n// //     int c = 0;\\n    \\n// //     for (int i = 0; i < n; i++) {\\n// //         for (int j = 0; j < source[i].size(); j++) {\\n// //             if (source[i][j] == \\'/\\' && source[i][j + 1] == \\'/\\') {\\n// //                 break; // Single-line comment, move to the next line\\n// //             }\\n// //             if (source[i][j] == \\'/\\' && source[i][j + 1] == \\'*\\') {\\n// //                 c = 1; // Start of multi-line comment\\n// //                 j++; // Skip the second \\'/\\'\\n// //             }\\n// //             if (source[i][j] == \\'*\\' && source[i][j + 1] == \\'/\\') {\\n// //                 c = 0; // End of multi-line comment\\n// //                 j++;\\n// //                 // Skip the second \\'/\\'\\n                \\n// //             }\\n// //             if (c == 1) {\\n// //                 continue; // Inside a multi-line comment, skip the character\\n// //             }\\n// //            if (c != 1) {\\n// //                 if (ans.size() <= k) {\\n// //                     ans.push_back(\"\"); // Ensure there\\'s a string at index k\\n// //                 }\\n// //                 if(source[i][j]==\\'/\\')\\n// //                 {\\n// //                     continue;\\n// //                 }\\n// //                 ans[k] += source[i][j]; // Append the character to the current ans[k]\\n// //             }\\n// //         }\\n// //         if (c == 0 && !ans[k].empty()) {\\n// //             k++; // Move to the next line in ans\\n// //         }\\n// //     }\\n// //     ans.resize(k); // Resize ans to remove unused entries (if any)\\n    \\n        \\n    \\n// //     return ans;\\n// // }\\n\\n// // };\\n\\n// // O(Linear Traversal) Time and O(1) Space --> Linear Search Approach\\n// class Solution {\\n//     bool isLineComment(const string& s, int col){\\n//         if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n//         else return false;\\n//     }\\n//     bool isMultilineCommentStart(const string& s, int col){\\n//         if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'*\\') return true;\\n//         else return false;\\n//     }\\n//     bool isMultilineCommentEnd(const string& s, int col){\\n//         if(s[col] == \\'*\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n//         else return false;\\n//     }\\n// public:\\n//     vector<string> removeComments(vector<string>& source) {\\n//         vector<string> result;\\n//         for(int line = 0; line < source.size();){\\n//             string currLine;\\n//             for(int col = 0; col < source[line].size();){\\n//                 if(isLineComment(source[line], col)){break;}\\n//                 else if(isMultilineCommentStart(source[line], col)){\\n//                     col += 2;\\n//                     while(true){\\n//                         if(col >= source[line].size()){line++; col = 0;}\\n//                         if(isMultilineCommentEnd(source[line], col)){col += 2;break;}\\n//                         else{col++;}\\n//                     }\\n//                 }\\n//                 else{currLine.push_back(source[line][col++]);}\\n//             }\\n//             if(currLine.size()) result.push_back(currLine);\\n//             line++;\\n//         }\\n//         return result;\\n//     }\\n// };\\n\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool bl=false;\\n        vector<string> res;\\n        string s;\\n        for(auto x : source){\\n            \\n            for(auto i=0; i < x.size(); i++){\\n                if(bl==false){\\n                    if(x[i]==\\'/\\'&& i < x.size()-1 && x[i+1]==\\'/\\')\\n                        break;\\n                    if(x[i]==\\'/\\'&& i < x.size()-1 && x[i+1]==\\'*\\')\\n                    {\\n                        bl=true;\\n                        i++;\\n                    }else\\n                        s+=x[i];\\n                }else{      \\n                    if(x[i]==\\'*\\' && i<x.size()-1 &&x[i+1]==\\'/\\')\\n                    {\\n                        bl=false;\\n                        i++;\\n                    }\\n                }\\n            }\\n            if(!bl)\\n                if(!s.empty()){\\n                    res.push_back(s);\\n                    s=\"\";\\n                }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// // class Solution {\\n// // public:\\n// // vector<string> removeComments(vector<string>& source) {\\n// //     int n = source.size();\\n// //     vector<string> ans;\\n// //     int k = 0;\\n// //     int c = 0;\\n    \\n// //     for (int i = 0; i < n; i++) {\\n// //         for (int j = 0; j < source[i].size(); j++) {\\n// //             if (source[i][j] == \\'/\\' && source[i][j + 1] == \\'/\\') {\\n// //                 break; // Single-line comment, move to the next line\\n// //             }\\n// //             if (source[i][j] == \\'/\\' && source[i][j + 1] == \\'*\\') {\\n// //                 c = 1; // Start of multi-line comment\\n// //                 j++; // Skip the second \\'/\\'\\n// //             }\\n// //             if (source[i][j] == \\'*\\' && source[i][j + 1] == \\'/\\') {\\n// //                 c = 0; // End of multi-line comment\\n// //                 j++;\\n// //                 // Skip the second \\'/\\'\\n                \\n// //             }\\n// //             if (c == 1) {\\n// //                 continue; // Inside a multi-line comment, skip the character\\n// //             }\\n// //            if (c != 1) {\\n// //                 if (ans.size() <= k) {\\n// //                     ans.push_back(\"\"); // Ensure there\\'s a string at index k\\n// //                 }\\n// //                 if(source[i][j]==\\'/\\')\\n// //                 {\\n// //                     continue;\\n// //                 }\\n// //                 ans[k] += source[i][j]; // Append the character to the current ans[k]\\n// //             }\\n// //         }\\n// //         if (c == 0 && !ans[k].empty()) {\\n// //             k++; // Move to the next line in ans\\n// //         }\\n// //     }\\n// //     ans.resize(k); // Resize ans to remove unused entries (if any)\\n    \\n        \\n    \\n// //     return ans;\\n// // }\\n\\n// // };\\n\\n// // O(Linear Traversal) Time and O(1) Space --> Linear Search Approach\\n// class Solution {\\n//     bool isLineComment(const string& s, int col){\\n//         if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n//         else return false;\\n//     }\\n//     bool isMultilineCommentStart(const string& s, int col){\\n//         if(s[col] == \\'/\\' and col+1 != s.length() and s[col+1] == \\'*\\') return true;\\n//         else return false;\\n//     }\\n//     bool isMultilineCommentEnd(const string& s, int col){\\n//         if(s[col] == \\'*\\' and col+1 != s.length() and s[col+1] == \\'/\\') return true;\\n//         else return false;\\n//     }\\n// public:\\n//     vector<string> removeComments(vector<string>& source) {\\n//         vector<string> result;\\n//         for(int line = 0; line < source.size();){\\n//             string currLine;\\n//             for(int col = 0; col < source[line].size();){\\n//                 if(isLineComment(source[line], col)){break;}\\n//                 else if(isMultilineCommentStart(source[line], col)){\\n//                     col += 2;\\n//                     while(true){\\n//                         if(col >= source[line].size()){line++; col = 0;}\\n//                         if(isMultilineCommentEnd(source[line], col)){col += 2;break;}\\n//                         else{col++;}\\n//                     }\\n//                 }\\n//                 else{currLine.push_back(source[line][col++]);}\\n//             }\\n//             if(currLine.size()) result.push_back(currLine);\\n//             line++;\\n//         }\\n//         return result;\\n//     }\\n// };\\n\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        bool bl=false;\\n        vector<string> res;\\n        string s;\\n        for(auto x : source){\\n            \\n            for(auto i=0; i < x.size(); i++){\\n                if(bl==false){\\n                    if(x[i]==\\'/\\'&& i < x.size()-1 && x[i+1]==\\'/\\')\\n                        break;\\n                    if(x[i]==\\'/\\'&& i < x.size()-1 && x[i+1]==\\'*\\')\\n                    {\\n                        bl=true;\\n                        i++;\\n                    }else\\n                        s+=x[i];\\n                }else{      \\n                    if(x[i]==\\'*\\' && i<x.size()-1 &&x[i+1]==\\'/\\')\\n                    {\\n                        bl=false;\\n                        i++;\\n                    }\\n                }\\n            }\\n            if(!bl)\\n                if(!s.empty()){\\n                    res.push_back(s);\\n                    s=\"\";\\n                }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773715,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string str;\\n        bool b = 0;\\n        for(auto &s : source)\\n        {\\n            string ss = str;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(b)\\n                {\\n                    if(s[i] == \\'*\\' && i+1<s.length() && s[i+1] == \\'/\\')\\n                    {\\n                        i++;\\n                        b=0;\\n                    }\\n                }\\n                else\\n                {\\n                    if(s[i] == \\'/\\' && i+1<s.length() && s[i+1] == \\'*\\')\\n                    {\\n                        i++;\\n                        b=1;\\n                    }\\n                    else if(s[i] == \\'/\\' && i+1<s.length() && s[i+1] == \\'/\\')\\n                    {\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        ss.push_back(s[i]);\\n                    }\\n                }\\n            }\\n            if(b)\\n            {\\n                str = ss;\\n            }  \\n            else if(ss.length()>0)\\n            {\\n                ans.push_back(ss);\\n                str=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string str;\\n        bool b = 0;\\n        for(auto &s : source)\\n        {\\n            string ss = str;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(b)\\n                {\\n                    if(s[i] == \\'*\\' && i+1<s.length() && s[i+1] == \\'/\\')\\n                    {\\n                        i++;\\n                        b=0;\\n                    }\\n                }\\n                else\\n                {\\n                    if(s[i] == \\'/\\' && i+1<s.length() && s[i+1] == \\'*\\')\\n                    {\\n                        i++;\\n                        b=1;\\n                    }\\n                    else if(s[i] == \\'/\\' && i+1<s.length() && s[i+1] == \\'/\\')\\n                    {\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        ss.push_back(s[i]);\\n                    }\\n                }\\n            }\\n            if(b)\\n            {\\n                str = ss;\\n            }  \\n            else if(ss.length()>0)\\n            {\\n                ans.push_back(ss);\\n                str=\"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753266,
                "title": "clean-code-using-status",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee approach below.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing status variable, just traverse through each char. By default status is 0 which you can insert the char into buffer. Status 0 can change into either 1 (line comment) or 2 (block comment), where status 1 can only change back to 0, the same as status 2 as well (see problem description). You don\\'t insert any char to buffer during status 1 or 2.\\n\\nWhen to insert buffer to the line list? Obviously not when the status is 2. You can insert the buffer when buffer is not empty, and status is either 0 or 1 (as you can write some code and add the single-line comment in the same line).\\n\\nI wrote the code below using C#, but you should be able to convert this to your other favorite language (or using ChatGPT if you\\'re too lazy). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWhere n is num of total chars in source: $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> RemoveComments(string[] source) {\\n        IList<string> result = new List<string>();\\n        int status = 0; // 0 --> no comment, 1 --> line, 2 --> block\\n        IList<char> buffer = new List<char>();\\n\\n        foreach (string line in source)\\n        {\\n            // line comment ends at newline.\\n            if (status == 1)\\n            {\\n                status = 0;\\n            }\\n\\n            for (int idx = 0; idx < line.Length; idx++)\\n            {\\n                char curr = line[idx];\\n                \\n                if (status == 0 && idx + 1 < line.Length && curr == \\'/\\' && line[idx + 1] == \\'/\\')\\n                {\\n                    // line comment\\n                    status = 1;\\n                    idx++;\\n                }\\n                else if (status == 0 && idx + 1 < line.Length && curr == \\'/\\' && line[idx + 1] == \\'*\\')\\n                {\\n                    // begin block comment\\n                    status = 2;\\n                    idx++;\\n                }\\n                else if (status == 2 && idx + 1 < line.Length && curr == \\'*\\' && line[idx + 1] == \\'/\\')\\n                {\\n                    // end block comment\\n                    status = 0;\\n                    idx++;\\n                }\\n                else if (status == 0)\\n                {\\n                    buffer.Add(curr);\\n                }\\n            }\\n\\n            if (status != 2 && buffer.Count > 0)\\n            {\\n                char[] chars = buffer.ToArray();\\n                result.Add(new string(chars));\\n                buffer = new List<char>();\\n            }\\n        }\\n         \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> RemoveComments(string[] source) {\\n        IList<string> result = new List<string>();\\n        int status = 0; // 0 --> no comment, 1 --> line, 2 --> block\\n        IList<char> buffer = new List<char>();\\n\\n        foreach (string line in source)\\n        {\\n            // line comment ends at newline.\\n            if (status == 1)\\n            {\\n                status = 0;\\n            }\\n\\n            for (int idx = 0; idx < line.Length; idx++)\\n            {\\n                char curr = line[idx];\\n                \\n                if (status == 0 && idx + 1 < line.Length && curr == \\'/\\' && line[idx + 1] == \\'/\\')\\n                {\\n                    // line comment\\n                    status = 1;\\n                    idx++;\\n                }\\n                else if (status == 0 && idx + 1 < line.Length && curr == \\'/\\' && line[idx + 1] == \\'*\\')\\n                {\\n                    // begin block comment\\n                    status = 2;\\n                    idx++;\\n                }\\n                else if (status == 2 && idx + 1 < line.Length && curr == \\'*\\' && line[idx + 1] == \\'/\\')\\n                {\\n                    // end block comment\\n                    status = 0;\\n                    idx++;\\n                }\\n                else if (status == 0)\\n                {\\n                    buffer.Add(curr);\\n                }\\n            }\\n\\n            if (status != 2 && buffer.Count > 0)\\n            {\\n                char[] chars = buffer.ToArray();\\n                result.Add(new string(chars));\\n                buffer = new List<char>();\\n            }\\n        }\\n         \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667962,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String>l=new ArrayList<>();\\n       StringBuilder sb=new StringBuilder();\\n       boolean multiline=false;\\n      for(String s:source){\\n           \\n          for(int i=0;i<s.length();i++){\\n              \\n            if(multiline){\\n             if(s.charAt(i)==\\'*\\'&&i<s.length()-1&&s.charAt(i+1)==\\'/\\'){\\n               multiline =false;\\n                i++;\\n              // break;\\n             }\\n            }\\n            else {\\n                if(s.charAt(i)==\\'/\\'&&i<s.length()-1&&s.charAt(i+1)==\\'*\\'){\\n                  multiline=true;\\n                  i++;\\n                  \\n\\n                }\\n                else if(s.charAt(i)==\\'/\\'&&i<s.length()-1&&s.charAt(i+1)==\\'/\\'){\\n                  break;\\n                }\\n                else{\\n                  sb.append(s.charAt(i));\\n                }\\n            }\\n          }\\n          if(sb.length()>0&&multiline==false){\\n            String ans=sb.toString();\\n          l.add(ans);\\n          sb=new StringBuilder();\\n          }\\n          \\n          \\n      } \\n      return l; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeComments(String[] source) {\\n        List<String>l=new ArrayList<>();\\n       StringBuilder sb=new StringBuilder();\\n       boolean multiline=false;\\n      for(String s:source){\\n           \\n          for(int i=0;i<s.length();i++){\\n              \\n            if(multiline){\\n             if(s.charAt(i)==\\'*\\'&&i<s.length()-1&&s.charAt(i+1)==\\'/\\'){\\n               multiline =false;\\n                i++;\\n              // break;\\n             }\\n            }\\n            else {\\n                if(s.charAt(i)==\\'/\\'&&i<s.length()-1&&s.charAt(i+1)==\\'*\\'){\\n                  multiline=true;\\n                  i++;\\n                  \\n\\n                }\\n                else if(s.charAt(i)==\\'/\\'&&i<s.length()-1&&s.charAt(i+1)==\\'/\\'){\\n                  break;\\n                }\\n                else{\\n                  sb.append(s.charAt(i));\\n                }\\n            }\\n          }\\n          if(sb.length()>0&&multiline==false){\\n            String ans=sb.toString();\\n          l.add(ans);\\n          sb=new StringBuilder();\\n          }\\n          \\n          \\n      } \\n      return l; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650210,
                "title": "a-small-and-simple-solution-in-c-with-explain-100-score-in-beats-and-uses-only-7-7-mb-of-memory",
                "content": "- This is my solution to the problem with an explanation in comments.\\n- I chose C++ to solve this problem, but you can use the same algorithm in Python, Ruby, or another language.\\n- It has achieved a 100% score in Beats and uses only 7.7 MB of memory.\\n- If you have any questions, confusion, or advice, feel free to leave a comment below.\\n- Thank you in advance!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> dst; // A vector of strings that will contain the text without any comments.\\n        string stock; // We will store the line that we will add to the dst.\\n        bool insideComment = false; // We will use it to know if we are inside a comment or outside.\\n\\n        for (auto& str : source) {\\n            int stringSize = str.size();\\n            for (int i = 0; i < stringSize; i++) { // We will loop through the string.\\n                if (insideComment == false && \"//\" == str.substr(i, 2)) { // If we find \\'//\\' we will break because everything after it is just a comment.\\n                    break;\\n                }\\n                if (insideComment == false && \"/*\" == str.substr(i, 2)) { // If we find \\'/*\\' and we are not inside a comment, it means the start of a comment.\\n                    insideComment = true;\\n                    i++;\\n                } else if (insideComment == true && \"*/\" == str.substr(i, 2)) { // The first \\'*/\\' after \\'/*\\' means the end of the comment.\\n                    insideComment = false;\\n                    i++;\\n                } else if (insideComment == false) { // We won\\'t add any characters to stock if we are inside a comment.\\n                    stock += str[i];\\n                }\\n            }\\n            if (insideComment == false && !stock.empty()) { // We check if we are inside a comment and if the stock is not empty.\\n                dst.push_back(stock); // We push the stock to the back of the vector (dst).\\n                stock = \"\"; // We empty our stock.\\n            }\\n        }\\n        return dst; // Return the new vector without any comments.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> dst; // A vector of strings that will contain the text without any comments.\\n        string stock; // We will store the line that we will add to the dst.\\n        bool insideComment = false; // We will use it to know if we are inside a comment or outside.\\n\\n        for (auto& str : source) {\\n            int stringSize = str.size();\\n            for (int i = 0; i < stringSize; i++) { // We will loop through the string.\\n                if (insideComment == false && \"//\" == str.substr(i, 2)) { // If we find \\'//\\' we will break because everything after it is just a comment.\\n                    break;\\n                }\\n                if (insideComment == false && \"/*\" == str.substr(i, 2)) { // If we find \\'/*\\' and we are not inside a comment, it means the start of a comment.\\n                    insideComment = true;\\n                    i++;\\n                } else if (insideComment == true && \"*/\" == str.substr(i, 2)) { // The first \\'*/\\' after \\'/*\\' means the end of the comment.\\n                    insideComment = false;\\n                    i++;\\n                } else if (insideComment == false) { // We won\\'t add any characters to stock if we are inside a comment.\\n                    stock += str[i];\\n                }\\n            }\\n            if (insideComment == false && !stock.empty()) { // We check if we are inside a comment and if the stock is not empty.\\n                dst.push_back(stock); // We push the stock to the back of the vector (dst).\\n                stock = \"\"; // We empty our stock.\\n            }\\n        }\\n        return dst; // Return the new vector without any comments.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565163,
                "title": "simple-matching-approach-with-detailed-explanation",
                "content": "# Intuition\\nThe `cache` variable stores the checked char, and the `pre` variable controls the `cache` when it will be allowed to store char.\\n\\nFollowing is the process.\\n1.`cache` stores char untill the first `\"//\"` is catched. Then, drop residue chars.\\nAs the process over, `cache` has stored all chars each of that is not behind `\"//\"`.\\n2.`cache` stores char untill the first `\"/*\"` is catched. Then, `cache` stop storing char and continue the process untill `\"*/\"` is found.\\n\\nIn the process of storing char in the string where there has `\"/*\"`, there will be two branchs.\\nOne branch is `\"*/\"` is found in this string, the char that between `\"/*\"` and `\"*/\"` will be droped.\\nThe other is `\"*/\"` is not found in this string, we will continue to search `\"*/\"` in the next string untill `\"*/\"` is found.\\nAs the process over,the char that not between `\"/*\"` and `\"*/\"` is stored in the `cache`.\\n![7.png](https://assets.leetcode.com/users/images/8b5aecc1-c27c-4ef8-b35b-9230db0030f1_1685169969.862554.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n\\n        string cache,pre;\\n        for(auto& n: source)\\n        {\\n            for(int i = 0;i < n.size();++i)\\n            {\\n                if(\"/*\" == pre)\\n                {\\n                    if(\\'*\\' == n[i] && \\'/\\' == n[i + 1])\\n                        pre.clear(),++i;\\n                    continue;\\n                }\\n\\n                if(\\'/\\' == n[i])\\n                {\\n                    if(\\'/\\' == n[i + 1]) break;\\n                    if(\\'*\\' == n[i + 1])\\n                    {\\n                        pre = \"/*\",++i;\\n                        continue;  \\n                    }\\n                }\\n                cache += n[i];\\n            }\\n            \\n            if(\"/*\" != pre)\\n            {\\n                if(!cache.empty()) ans.emplace_back(cache);\\n                cache.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n\\n        char pre[2] = {\\'\\\\0\\'};\\n        string cache;\\n        for(string& str: source)\\n        {\\n            for(int i = 0;i < str.size();++i)\\n            {\\n                if(\\'/\\' == pre[0] && \\'*\\' == pre[1])\\n                {\\n                    if(\\'*\\' == str[i] && \\'/\\' == str[i + 1])\\n                    {\\n                        pre[0] = pre[1] = \\'\\\\0\\';\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n\\n                if(\\'/\\' == str[i])\\n                {\\n                    if(\\'/\\' == str[i + 1]) break;\\n                    if(\\'*\\' == str[i + 1])\\n                    {\\n                        pre[0] = \\'/\\';\\n                        pre[1] = \\'*\\';\\n                        ++i;\\n                        continue;\\n                    }\\n                }\\n                cache += str[i];\\n            }\\n            if(!(\\'/\\' == pre[0] && \\'*\\' == pre[1]))\\n            {\\n                if(!cache.empty()) ans.emplace_back(cache);\\n                cache.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n\\n        string cache,pre;\\n        for(auto& n: source)\\n        {\\n            for(int i = 0;i < n.size();++i)\\n            {\\n                if(\"/*\" == pre)\\n                {\\n                    if(\\'*\\' == n[i] && \\'/\\' == n[i + 1])\\n                        pre.clear(),++i;\\n                    continue;\\n                }\\n\\n                if(\\'/\\' == n[i])\\n                {\\n                    if(\\'/\\' == n[i + 1]) break;\\n                    if(\\'*\\' == n[i + 1])\\n                    {\\n                        pre = \"/*\",++i;\\n                        continue;  \\n                    }\\n                }\\n                cache += n[i];\\n            }\\n            \\n            if(\"/*\" != pre)\\n            {\\n                if(!cache.empty()) ans.emplace_back(cache);\\n                cache.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n\\n        char pre[2] = {\\'\\\\0\\'};\\n        string cache;\\n        for(string& str: source)\\n        {\\n            for(int i = 0;i < str.size();++i)\\n            {\\n                if(\\'/\\' == pre[0] && \\'*\\' == pre[1])\\n                {\\n                    if(\\'*\\' == str[i] && \\'/\\' == str[i + 1])\\n                    {\\n                        pre[0] = pre[1] = \\'\\\\0\\';\\n                        ++i;\\n                    }\\n                    continue;\\n                }\\n\\n                if(\\'/\\' == str[i])\\n                {\\n                    if(\\'/\\' == str[i + 1]) break;\\n                    if(\\'*\\' == str[i + 1])\\n                    {\\n                        pre[0] = \\'/\\';\\n                        pre[1] = \\'*\\';\\n                        ++i;\\n                        continue;\\n                    }\\n                }\\n                cache += str[i];\\n            }\\n            if(!(\\'/\\' == pre[0] && \\'*\\' == pre[1]))\\n            {\\n                if(!cache.empty()) ans.emplace_back(cache);\\n                cache.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511416,
                "title": "simple-solution-in-c",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n^2)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<string> removeComments(vector<string> &source)\\n{\\n    vector<string> &v = source;\\n    bool comm = false;\\n    vector<string> program;\\n    string line = \"\";\\n    for (int i = 0; i < v.size(); i++)\\n    {\\n        for (int j = 0; j < v[i].size(); j++)\\n        {\\n            if (j < v[i].size()-1 and v[i][j] == \\'/\\' and v[i][j+1] == \\'*\\' and !comm) { comm = true; j++; continue; }\\n            if (j < v[i].size()-1 and v[i][j] == \\'/\\' and v[i][j+1] == \\'/\\' and !comm) break;\\n            if (j < v[i].size()-1  and v[i][j] == \\'*\\' and v[i][j+1] == \\'/\\' and comm)  { comm = false; j++; continue; }\\n\\n            if (!comm) line.push_back(v[i][j]);\\n        }\\n        if (line != \"\" and !comm) { program.push_back(line); line = \"\"; } \\n    }\\n    return program;\\n}   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string> removeComments(vector<string> &source)\\n{\\n    vector<string> &v = source;\\n    bool comm = false;\\n    vector<string> program;\\n    string line = \"\";\\n    for (int i = 0; i < v.size(); i++)\\n    {\\n        for (int j = 0; j < v[i].size(); j++)\\n        {\\n            if (j < v[i].size()-1 and v[i][j] == \\'/\\' and v[i][j+1] == \\'*\\' and !comm) { comm = true; j++; continue; }\\n            if (j < v[i].size()-1 and v[i][j] == \\'/\\' and v[i][j+1] == \\'/\\' and !comm) break;\\n            if (j < v[i].size()-1  and v[i][j] == \\'*\\' and v[i][j+1] == \\'/\\' and comm)  { comm = false; j++; continue; }\\n\\n            if (!comm) line.push_back(v[i][j]);\\n        }\\n        if (line != \"\" and !comm) { program.push_back(line); line = \"\"; } \\n    }\\n    return program;\\n}   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472611,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_characters)\\n * Space Complexity: O(1)\\n * where `n_characters` is the number of the characters of all strings in the vector `source`\\n */\\nclass Solution {\\n public:\\n  vector<string> removeComments(const vector<string> &source) {\\n    constexpr char slash = \\'/\\';\\n    constexpr char star = \\'*\\';\\n    vector<string> ret;\\n    string target_line;\\n    bool in_block_comment = false;\\n    for (const string &source_line : source) {\\n      const int n_source_line = static_cast<int>(source_line.size());\\n      for (int i = 0; i < n_source_line; ++i) {\\n        if (in_block_comment) {\\n          if (source_line[i] == star && i + 1 < n_source_line && source_line[i + 1] == slash) {\\n            in_block_comment = false;\\n            ++i;\\n          }\\n          continue;\\n        }\\n        \\n        // !in_block_comment\\n        if (source_line[i] == slash && i + 1 < n_source_line) {\\n          if (source_line[i + 1] == slash) {\\n            // a line comment starts\\n            break;\\n          }\\n          if (source_line[i + 1] == star) {\\n            // a block comment starts\\n            in_block_comment = true;\\n            ++i;\\n            continue;\\n          }\\n        }\\n        \\n        target_line.push_back(source_line[i]);\\n      }\\n      if (!in_block_comment && !target_line.empty()) {\\n        ret.emplace_back(move(target_line));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_characters)\\n * Space Complexity: O(1)\\n * where `n_characters` is the number of the characters of all strings in the vector `source`\\n */\\nclass Solution {\\n public:\\n  vector<string> removeComments(const vector<string> &source) {\\n    constexpr char slash = \\'/\\';\\n    constexpr char star = \\'*\\';\\n    vector<string> ret;\\n    string target_line;\\n    bool in_block_comment = false;\\n    for (const string &source_line : source) {\\n      const int n_source_line = static_cast<int>(source_line.size());\\n      for (int i = 0; i < n_source_line; ++i) {\\n        if (in_block_comment) {\\n          if (source_line[i] == star && i + 1 < n_source_line && source_line[i + 1] == slash) {\\n            in_block_comment = false;\\n            ++i;\\n          }\\n          continue;\\n        }\\n        \\n        // !in_block_comment\\n        if (source_line[i] == slash && i + 1 < n_source_line) {\\n          if (source_line[i + 1] == slash) {\\n            // a line comment starts\\n            break;\\n          }\\n          if (source_line[i + 1] == star) {\\n            // a block comment starts\\n            in_block_comment = true;\\n            ++i;\\n            continue;\\n          }\\n        }\\n        \\n        target_line.push_back(source_line[i]);\\n      }\\n      if (!in_block_comment && !target_line.empty()) {\\n        ret.emplace_back(move(target_line));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451719,
                "title": "c-short-and-clean",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> answer;\\n        bool multiline = false;\\n\\n        for (int i = 0; i < source.size(); ++i) {\\n            string current = multiline ? current : \"\";\\n            int size = source[i].size();\\n\\n            for (int j = 0; j < size; ++j) {\\n                if (j <= size-1 and multiline and source[i][j] == \\'*\\' and source[i][j+1] == \\'/\\') {\\n                    multiline = false;\\n                    ++j;\\n                } else if (j <= size-1 and not multiline and source[i][j] == \\'/\\' and source[i][j+1] == \\'*\\') {\\n                    multiline = true;\\n                    ++j;\\n                } else if (j <= size-1 and not multiline and source[i][j] == \\'/\\' and source[i][j+1] == \\'/\\') {\\n                    break;\\n                } else if (not multiline){\\n                    current += source[i][j];\\n                }\\n            }\\n\\n            if (not multiline and current.size())\\n                answer.push_back(current);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> answer;\\n        bool multiline = false;\\n\\n        for (int i = 0; i < source.size(); ++i) {\\n            string current = multiline ? current : \"\";\\n            int size = source[i].size();\\n\\n            for (int j = 0; j < size; ++j) {\\n                if (j <= size-1 and multiline and source[i][j] == \\'*\\' and source[i][j+1] == \\'/\\') {\\n                    multiline = false;\\n                    ++j;\\n                } else if (j <= size-1 and not multiline and source[i][j] == \\'/\\' and source[i][j+1] == \\'*\\') {\\n                    multiline = true;\\n                    ++j;\\n                } else if (j <= size-1 and not multiline and source[i][j] == \\'/\\' and source[i][j+1] == \\'/\\') {\\n                    break;\\n                } else if (not multiline){\\n                    current += source[i][j];\\n                }\\n            }\\n\\n            if (not multiline and current.size())\\n                answer.push_back(current);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407175,
                "title": "single-pass-python-full-explaination-easy-to-understand-beats-99-runtime",
                "content": "# Intuition\\nBuild result as you go. \\n\\n# Approach\\n- Traverse through the array once line by line and character by character (left to right).\\n- Maintain a buffer of characters that are not in any comment \\n- For block comments, comments we track start and ends. We ignore every character between start and end irrespective of lines. If a block comment starts midway on a line, we merge buffers with the start and end lines.  \\n- For line comments, we just omit everything on the line after the comment starts\\n- Write buffer to result on every new line, unless being merged separately\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k)$$\\n\\n*n: number of lines of code\\nk: max number of characters in any line*\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k)$$\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        is_block = False\\n        curr_line = []\\n        \\n        for line in source:\\n            prev_char = None\\n            for char in line:\\n                if is_block:\\n                    if prev_char == \"*\" and char == \"/\":\\n                        is_block = False\\n                        prev_char = None  # Needed for overlapping \"*/\" and \"//\" eg: \"ab*//c\" \\n                    else:    \\n                        prev_char = char\\n                    continue\\n                \\n                # Execution reaches here only when character is not in a block comment\\n                # Case where we have a line comment\\n                if prev_char == \"/\" and char == \"/\":\\n                    curr_line.pop()\\n                    break\\n                \\n                # Check for a start of a block comment\\n                if prev_char == \"/\" and char == \"*\":\\n                    is_block = True\\n                    curr_line.pop()\\n                    continue\\n\\n                curr_line.append(char)\\n                prev_char = char\\n            \\n            # Clear out current line buffer, if not in block comment\\n            if not is_block and curr_line:\\n                result.append(\"\".join(curr_line))\\n                curr_line = []\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []\\n        is_block = False\\n        curr_line = []\\n        \\n        for line in source:\\n            prev_char = None\\n            for char in line:\\n                if is_block:\\n                    if prev_char == \"*\" and char == \"/\":\\n                        is_block = False\\n                        prev_char = None  # Needed for overlapping \"*/\" and \"//\" eg: \"ab*//c\" \\n                    else:    \\n                        prev_char = char\\n                    continue\\n                \\n                # Execution reaches here only when character is not in a block comment\\n                # Case where we have a line comment\\n                if prev_char == \"/\" and char == \"/\":\\n                    curr_line.pop()\\n                    break\\n                \\n                # Check for a start of a block comment\\n                if prev_char == \"/\" and char == \"*\":\\n                    is_block = True\\n                    curr_line.pop()\\n                    continue\\n\\n                curr_line.append(char)\\n                prev_char = char\\n            \\n            # Clear out current line buffer, if not in block comment\\n            if not is_block and curr_line:\\n                result.append(\"\".join(curr_line))\\n                curr_line = []\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385364,
                "title": "cursor-data-structure-with-helper-functions",
                "content": "Fun little data structures problem. Not trying to be terse here: with some simple helper functions in the `Cursor` data structure, the overall parser logic becomes very simple.\\n\\n```\\nclass Solution {\\n  // The cursor marks the position that is about to be read.\\n  class Cursor {\\n    const std::vector<std::string> &source_;\\n    const int lines_;\\n\\n  public:\\n    // Public for convenience, although these can be hidden\\n    // behind some accessors.\\n    int row{}, col{};\\n\\n    // Getter functions.\\n    Cursor(std::vector<std::string> &source)\\n        : source_{source}, lines_(source_.size()) {}\\n    bool eol() const { return col == row_len(); }\\n    bool eof() const { return row == lines_ - 1 && eol(); }\\n    char at() const { return source_[row][col]; }\\n    int row_len() const { return source_[row].length(); }\\n\\n    // Check for the digram at the current position, with error checking.\\n    bool digram(char a, char b) const {\\n      return col + 1 < row_len() && at() == a && source_[row][col + 1] == b;\\n    }\\n\\n    // Operators.\\n    Cursor &operator++() {\\n      if (eol()) {\\n        ++row;\\n        col = 0;\\n      } else {\\n        ++col;\\n      }\\n      return *this;\\n    }\\n  };\\n\\npublic:\\n  vector<string> removeComments(vector<string> &source) {\\n    std::vector<std::string> res{{}};\\n    for (Cursor c{source}; !c.eof(); ++c) {\\n      if (c.eol()) {\\n        // Don\\'t push empty lines.\\n        if (!res.back().empty()) {\\n          res.push_back({});\\n        }\\n      } else if (c.digram(\\'/\\', \\'/\\')) {\\n        // Line comment. Discard until the end of this line.\\n        c.col = c.row_len() - 1;\\n      } else if (c.digram(\\'/\\', \\'*\\')) {\\n        // Read block comment.\\n        ++++c;\\n        while (!c.digram(\\'*\\', \\'/\\')) {\\n          ++c;\\n        }\\n        ++c;\\n      } else {\\n        // Copy character over.\\n        res.back().push_back(c.at());\\n      }\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  // The cursor marks the position that is about to be read.\\n  class Cursor {\\n    const std::vector<std::string> &source_;\\n    const int lines_;\\n\\n  public:\\n    // Public for convenience, although these can be hidden\\n    // behind some accessors.\\n    int row{}, col{};\\n\\n    // Getter functions.\\n    Cursor(std::vector<std::string> &source)\\n        : source_{source}, lines_(source_.size()) {}\\n    bool eol() const { return col == row_len(); }\\n    bool eof() const { return row == lines_ - 1 && eol(); }\\n    char at() const { return source_[row][col]; }\\n    int row_len() const { return source_[row].length(); }\\n\\n    // Check for the digram at the current position, with error checking.\\n    bool digram(char a, char b) const {\\n      return col + 1 < row_len() && at() == a && source_[row][col + 1] == b;\\n    }\\n\\n    // Operators.\\n    Cursor &operator++() {\\n      if (eol()) {\\n        ++row;\\n        col = 0;\\n      } else {\\n        ++col;\\n      }\\n      return *this;\\n    }\\n  };\\n\\npublic:\\n  vector<string> removeComments(vector<string> &source) {\\n    std::vector<std::string> res{{}};\\n    for (Cursor c{source}; !c.eof(); ++c) {\\n      if (c.eol()) {\\n        // Don\\'t push empty lines.\\n        if (!res.back().empty()) {\\n          res.push_back({});\\n        }\\n      } else if (c.digram(\\'/\\', \\'/\\')) {\\n        // Line comment. Discard until the end of this line.\\n        c.col = c.row_len() - 1;\\n      } else if (c.digram(\\'/\\', \\'*\\')) {\\n        // Read block comment.\\n        ++++c;\\n        while (!c.digram(\\'*\\', \\'/\\')) {\\n          ++c;\\n        }\\n        ++c;\\n      } else {\\n        // Copy character over.\\n        res.back().push_back(c.at());\\n      }\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363120,
                "title": "c-string-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool in_block = false;\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string res = \"\";\\n        for (auto& s : source) {\\n            bool pre_state = in_block;  // save state before production\\n            string tmp = produceLine(s);\\n            if (!tmp.empty() && !in_block && pre_state == in_block) {\\n                ans.push_back(tmp);\\n            } else if (in_block) {\\n                res += tmp;\\n            } else if (!in_block && pre_state) {\\n                res += tmp;\\n                if (res.empty()) continue;\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    string produceLine(string& s) {\\n        // if this line included in a block comment\\n        if (in_block) {  \\n            int pos = s.find(\"*/\");\\n            if (pos == -1) {\\n                return \"\";\\n            }\\n            s = s.substr(pos + 2);\\n            in_block = false;\\n            return produceLine(s);\\n        }\\n        int line_cmt = s.find(\"//\");\\n        int block_cmt = s.find(\"/*\");\\n        // find no /* */ or //\\n        if (line_cmt == -1 && block_cmt == -1) {\\n            return s;\\n        }\\n        // if // occurs before /*\\n        if (block_cmt == -1 || (line_cmt >= 0 && line_cmt < block_cmt)) {\\n            s = s.substr(0, line_cmt);\\n            return s;\\n        }\\n        string s1 = s.substr(0, block_cmt);\\n        string s2 = s.substr(block_cmt + 2);\\n        in_block = true;\\n        return s1 + produceLine(s2); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool in_block = false;\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        string res = \"\";\\n        for (auto& s : source) {\\n            bool pre_state = in_block;  // save state before production\\n            string tmp = produceLine(s);\\n            if (!tmp.empty() && !in_block && pre_state == in_block) {\\n                ans.push_back(tmp);\\n            } else if (in_block) {\\n                res += tmp;\\n            } else if (!in_block && pre_state) {\\n                res += tmp;\\n                if (res.empty()) continue;\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    string produceLine(string& s) {\\n        // if this line included in a block comment\\n        if (in_block) {  \\n            int pos = s.find(\"*/\");\\n            if (pos == -1) {\\n                return \"\";\\n            }\\n            s = s.substr(pos + 2);\\n            in_block = false;\\n            return produceLine(s);\\n        }\\n        int line_cmt = s.find(\"//\");\\n        int block_cmt = s.find(\"/*\");\\n        // find no /* */ or //\\n        if (line_cmt == -1 && block_cmt == -1) {\\n            return s;\\n        }\\n        // if // occurs before /*\\n        if (block_cmt == -1 || (line_cmt >= 0 && line_cmt < block_cmt)) {\\n            s = s.substr(0, line_cmt);\\n            return s;\\n        }\\n        string s1 = s.substr(0, block_cmt);\\n        string s2 = s.substr(block_cmt + 2);\\n        in_block = true;\\n        return s1 + produceLine(s2); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277527,
                "title": "stack-solution-first-intuition",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        stack<char> st;\\n        vector<string> res;\\n        char l = \\'/\\';\\n        string v;\\n        for(int i =0 ; i < source.size(); i++) {\\n            string s = source[i];\\n            int cnt = count(s.begin(), s.end(), l);\\n            if(st.empty() && cnt != 0) {\\n                int j=0;\\n                while(j<s.size()){\\n                    if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                        st.push(\\'*\\');\\n                        j=j+2;\\n                    }else if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'/\\')\\n                        break;\\n                    else if(!st.empty() && s[j]==\\'*\\' && s[j+1]==\\'/\\'){\\n                        st.pop();\\n                        j=j+2;\\n                    }\\n                    else if(st.empty()){\\n                        v.push_back(s[j]);\\n                        j++;\\n                    }    \\n                    else j++;\\n                }\\n                if(st.empty() && v.size() != 0) { res.push_back(v); v.clear(); }\\n            } else if(!st.empty() && cnt == 0) continue;\\n            else if(!st.empty() && cnt ) { // bottom portion is exactly same as above. copy pasted.\\n                int j=0;\\n                while(j<s.size()){\\n                    if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                        st.push(\\'*\\');\\n                        j=j+2;\\n                    }else if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'/\\')\\n                        break;\\n                    else if(!st.empty() && s[j]==\\'*\\' && s[j+1]==\\'/\\'){\\n                        st.pop();\\n                        j=j+2;\\n                    }\\n                    else if(st.empty()){\\n                        v.push_back(s[j]);\\n                        j++;\\n                    }    \\n                    else j++;\\n                }\\n                if(st.empty() && v.size() != 0) { res.push_back(v); v.clear(); }\\n            } else if(st.empty() && cnt==0) {\\n                res.push_back(s);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        stack<char> st;\\n        vector<string> res;\\n        char l = \\'/\\';\\n        string v;\\n        for(int i =0 ; i < source.size(); i++) {\\n            string s = source[i];\\n            int cnt = count(s.begin(), s.end(), l);\\n            if(st.empty() && cnt != 0) {\\n                int j=0;\\n                while(j<s.size()){\\n                    if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                        st.push(\\'*\\');\\n                        j=j+2;\\n                    }else if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'/\\')\\n                        break;\\n                    else if(!st.empty() && s[j]==\\'*\\' && s[j+1]==\\'/\\'){\\n                        st.pop();\\n                        j=j+2;\\n                    }\\n                    else if(st.empty()){\\n                        v.push_back(s[j]);\\n                        j++;\\n                    }    \\n                    else j++;\\n                }\\n                if(st.empty() && v.size() != 0) { res.push_back(v); v.clear(); }\\n            } else if(!st.empty() && cnt == 0) continue;\\n            else if(!st.empty() && cnt ) { // bottom portion is exactly same as above. copy pasted.\\n                int j=0;\\n                while(j<s.size()){\\n                    if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                        st.push(\\'*\\');\\n                        j=j+2;\\n                    }else if(st.empty() && s[j]==\\'/\\' && s[j+1]==\\'/\\')\\n                        break;\\n                    else if(!st.empty() && s[j]==\\'*\\' && s[j+1]==\\'/\\'){\\n                        st.pop();\\n                        j=j+2;\\n                    }\\n                    else if(st.empty()){\\n                        v.push_back(s[j]);\\n                        j++;\\n                    }    \\n                    else j++;\\n                }\\n                if(st.empty() && v.size() != 0) { res.push_back(v); v.clear(); }\\n            } else if(st.empty() && cnt==0) {\\n                res.push_back(s);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246278,
                "title": "python3-poke-it-with-a-stick-algorithm",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        in_block = False\\n        ret = \"\"\\n\\n        while source:\\n            s = (source.pop(0) + \\'\\\\n\\').replace(\\'\\\\n\\\\n\\', \\'\\\\n\\')\\n            \\n            ind1 = s.find(\\'//\\')\\n            ind2 = s.find(\\'/*\\')\\n            ind3 = s.find(\\'*/\\')\\n\\n            if in_block and ind3 >= 0:\\n                s=s[ind3 + 2:]\\n                source.insert(0, s)\\n                in_block = False\\n                continue\\n            if in_block:\\n                continue\\n            if ind1>=0 and ind2>=0:\\n                if ind1 < ind2:\\n                    ind2 = -1\\n                else:\\n                    ind1 = -1\\n            if ind1>=0:\\n                ret += s[:ind1] + \\'\\\\n\\'\\n                continue\\n            if ind2>=0:\\n\\n                ret += s[:ind2]\\n                in_block = True\\n                source.insert(0, s[ind2+2:])\\n                continue\\n            ret+=s\\n\\n        return [x for x in ret.split(\\'\\\\n\\') if x]\\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        in_block = False\\n        ret = \"\"\\n\\n        while source:\\n            s = (source.pop(0) + \\'\\\\n\\').replace(\\'\\\\n\\\\n\\', \\'\\\\n\\')\\n            \\n            ind1 = s.find(\\'//\\')\\n            ind2 = s.find(\\'/*\\')\\n            ind3 = s.find(\\'*/\\')\\n\\n            if in_block and ind3 >= 0:\\n                s=s[ind3 + 2:]\\n                source.insert(0, s)\\n                in_block = False\\n                continue\\n            if in_block:\\n                continue\\n            if ind1>=0 and ind2>=0:\\n                if ind1 < ind2:\\n                    ind2 = -1\\n                else:\\n                    ind1 = -1\\n            if ind1>=0:\\n                ret += s[:ind1] + \\'\\\\n\\'\\n                continue\\n            if ind2>=0:\\n\\n                ret += s[:ind2]\\n                in_block = True\\n                source.insert(0, s[ind2+2:])\\n                continue\\n            ret+=s\\n\\n        return [x for x in ret.split(\\'\\\\n\\') if x]\\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159779,
                "title": "very-simple-solution-using-vector-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply need all string in single line so that we can iterate to see block comment , so i have inserted all chars in vector and to see end of line i have added -1 to it .\\nAnd now according to conditions it is iterating .\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& src) {\\n        vector<string> ans;\\n        vector<int> code;\\n        for(int i=0;i<src.size();i++){\\n            for(auto c: src[i]) code.push_back(c);\\n            code.push_back(-1);\\n        }\\n        string tem = \"\";\\n        int i=0;\\n        while(i<code.size()){\\n            if(code[i] == -1){\\n                if(tem.length() > 0) ans.push_back(tem);\\n                tem = \"\";\\n                i++;\\n            }else if(code[i] == \\'/\\' && i+1 < code.size() && code[i+1] == \\'/\\'){\\n                // we iterate till -1\\n                while(code[i] != -1) i++;\\n                if(tem.length() > 0) ans.push_back(tem);\\n                tem = \"\";\\n                i++;\\n            }else if(code[i] == \\'/\\' && i+1 < code.size() && code[i+1] == \\'*\\'){\\n                // iterate till */\\n                i += 2;\\n                while(code[i] != \\'*\\' || code[i+1] != \\'/\\') i++;\\n                i += 2;\\n            }else tem += (char)code[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& src) {\\n        vector<string> ans;\\n        vector<int> code;\\n        for(int i=0;i<src.size();i++){\\n            for(auto c: src[i]) code.push_back(c);\\n            code.push_back(-1);\\n        }\\n        string tem = \"\";\\n        int i=0;\\n        while(i<code.size()){\\n            if(code[i] == -1){\\n                if(tem.length() > 0) ans.push_back(tem);\\n                tem = \"\";\\n                i++;\\n            }else if(code[i] == \\'/\\' && i+1 < code.size() && code[i+1] == \\'/\\'){\\n                // we iterate till -1\\n                while(code[i] != -1) i++;\\n                if(tem.length() > 0) ans.push_back(tem);\\n                tem = \"\";\\n                i++;\\n            }else if(code[i] == \\'/\\' && i+1 < code.size() && code[i+1] == \\'*\\'){\\n                // iterate till */\\n                i += 2;\\n                while(code[i] != \\'*\\' || code[i+1] != \\'/\\') i++;\\n                i += 2;\\n            }else tem += (char)code[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044320,
                "title": "c-clean-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> RemoveComments(string[] source) \\n    {\\n        var res = new List<string>();\\n        \\n        bool blocked = false; \\n        \\n        var builder = new StringBuilder(); \\n        \\n        \\n         for(int pos = 0; pos < source.Length; ++pos)\\n         {\\n             if(!blocked)\\n                 builder = new StringBuilder();\\n             \\n             var input = source[pos];\\n             \\n             int index = 0;\\n             \\n             while(index < input.Length)\\n             {\\n                 if(!blocked)\\n                 {\\n                    if(index < input.Length - 1 && input[index] == \\'/\\' && input[index + 1] == \\'/\\')\\n                    {\\n                        break;\\n                    }\\n                    else if(index < input.Length - 1 && input[index] == \\'/\\' && input[index + 1] == \\'*\\')\\n                    {\\n                        blocked = true;\\n                        index += 2;\\n                    }\\n                    else\\n                    {\\n                        builder.Append($\"{input[index]}\");\\n                        ++index;\\n                    }\\n                 }\\n                 else\\n                 {\\n                    if(index < input.Length - 1 && input[index] == \\'*\\' && input[index + 1] == \\'/\\')\\n                    {\\n                        blocked = false;\\n                        index +=2;\\n                    }\\n                     else\\n                     {\\n                         ++index;\\n                     }\\n                 }\\n             }\\n             \\n             if(builder.Length != 0 && !blocked)\\n                 res.Add(builder.ToString());\\n         }\\n        \\n        return res;\\n    }\\n}\\n\\n \\n    \\n    \\n    \\n    \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> RemoveComments(string[] source) \\n    {\\n        var res = new List<string>();\\n        \\n        bool blocked = false; \\n        \\n        var builder = new StringBuilder(); \\n        \\n        \\n         for(int pos = 0; pos < source.Length; ++pos)\\n         {\\n             if(!blocked)\\n                 builder = new StringBuilder();\\n             \\n             var input = source[pos];\\n             \\n             int index = 0;\\n             \\n             while(index < input.Length)\\n             {\\n                 if(!blocked)\\n                 {\\n                    if(index < input.Length - 1 && input[index] == \\'/\\' && input[index + 1] == \\'/\\')\\n                    {\\n                        break;\\n                    }\\n                    else if(index < input.Length - 1 && input[index] == \\'/\\' && input[index + 1] == \\'*\\')\\n                    {\\n                        blocked = true;\\n                        index += 2;\\n                    }\\n                    else\\n                    {\\n                        builder.Append($\"{input[index]}\");\\n                        ++index;\\n                    }\\n                 }\\n                 else\\n                 {\\n                    if(index < input.Length - 1 && input[index] == \\'*\\' && input[index + 1] == \\'/\\')\\n                    {\\n                        blocked = false;\\n                        index +=2;\\n                    }\\n                     else\\n                     {\\n                         ++index;\\n                     }\\n                 }\\n             }\\n             \\n             if(builder.Length != 0 && !blocked)\\n                 res.Add(builder.ToString());\\n         }\\n        \\n        return res;\\n    }\\n}\\n\\n \\n    \\n    \\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987668,
                "title": "722-remove-comments-python-time-complexity-using-big-o-n-2",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans=[]\\n        stack=[]\\n        temp=\"\"\\n        for i in range(len(source)):\\n            line=list(source[i])\\n            for j in range(len(line)):\\n                if j<len(line)-1 and (line[j]+line[j+1])==\"/*\" and len(stack)==0:\\n                    stack.append([i,j+1])\\n                elif (line[j-1]+line[j])==\"*/\" and stack and stack[-1]!=[i,j-1]:\\n                    stack.pop()\\n                elif j<len(line)-1 and (line[j]+line[j+1])==\"//\" and len(stack)==0:\\n                    if temp:\\n                        ans.append(temp)\\n                    temp=\"\"\\n                    break\\n                elif len(stack)==0:\\n                    temp+=line[j]\\n            if len(stack)==0 and temp:\\n                ans.append(temp)\\n                temp=\"\"\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        ans=[]\\n        stack=[]\\n        temp=\"\"\\n        for i in range(len(source)):\\n            line=list(source[i])\\n            for j in range(len(line)):\\n                if j<len(line)-1 and (line[j]+line[j+1])==\"/*\" and len(stack)==0:\\n                    stack.append([i,j+1])\\n                elif (line[j-1]+line[j])==\"*/\" and stack and stack[-1]!=[i,j-1]:\\n                    stack.pop()\\n                elif j<len(line)-1 and (line[j]+line[j+1])==\"//\" and len(stack)==0:\\n                    if temp:\\n                        ans.append(temp)\\n                    temp=\"\"\\n                    break\\n                elif len(stack)==0:\\n                    temp+=line[j]\\n            if len(stack)==0 and temp:\\n                ans.append(temp)\\n                temp=\"\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971938,
                "title": "o-1-space-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        opened = False\\n        temp = \"\"\\n        \\n        for command in source:\\n            if not opened:\\n                temp = \"\"\\n            n = len(command)\\n            i = 0\\n            while i < n:\\n                if not opened:\\n                    if i+1 < n and command[i] == \"/\" and command[i+1] == \"/\":\\n                        break\\n                    elif i+1 < n and command[i] == \"/\" and command[i+1] == \"*\":\\n                        i += 2\\n                        opened = True\\n                    else:\\n                        temp += command[i]\\n                        i += 1\\n                else:\\n                    if i+1 < n and command[i] == \"*\" and command[i+1] == \"/\":\\n                        opened = False\\n                        i += 2\\n                    else: \\n                        i += 1\\n            \\n            if not opened and len(temp) > 0:\\n                res.append(temp)      \\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        opened = False\\n        temp = \"\"\\n        \\n        for command in source:\\n            if not opened:\\n                temp = \"\"\\n            n = len(command)\\n            i = 0\\n            while i < n:\\n                if not opened:\\n                    if i+1 < n and command[i] == \"/\" and command[i+1] == \"/\":\\n                        break\\n                    elif i+1 < n and command[i] == \"/\" and command[i+1] == \"*\":\\n                        i += 2\\n                        opened = True\\n                    else:\\n                        temp += command[i]\\n                        i += 1\\n                else:\\n                    if i+1 < n and command[i] == \"*\" and command[i+1] == \"/\":\\n                        opened = False\\n                        i += 2\\n                    else: \\n                        i += 1\\n            \\n            if not opened and len(temp) > 0:\\n                res.append(temp)      \\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971905,
                "title": "o-1-space-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        look = False\\n        temp = \"\"\\n        for command in source:\\n            if not look:\\n                temp = \"\"\\n            n = len(command)\\n            i = 0\\n            while i < n:\\n                if not look:\\n                    if i+1 < n and command[i] == \"/\" and command[i+1] == \"/\":\\n                        break\\n                    elif i+1 < n and command[i] == \"/\" and command[i+1] == \"*\":\\n                        i += 2\\n                        look = True\\n                    else:\\n                        temp += command[i]\\n                        i += 1\\n                else:\\n                    if i+1 < n and command[i] == \"*\" and command[i+1] == \"/\":\\n                        look = False\\n                        i += 2\\n                    else: \\n                        i += 1\\n            \\n            if not look and len(temp) > 0:\\n                res.append(temp)      \\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        res = []\\n        look = False\\n        temp = \"\"\\n        for command in source:\\n            if not look:\\n                temp = \"\"\\n            n = len(command)\\n            i = 0\\n            while i < n:\\n                if not look:\\n                    if i+1 < n and command[i] == \"/\" and command[i+1] == \"/\":\\n                        break\\n                    elif i+1 < n and command[i] == \"/\" and command[i+1] == \"*\":\\n                        i += 2\\n                        look = True\\n                    else:\\n                        temp += command[i]\\n                        i += 1\\n                else:\\n                    if i+1 < n and command[i] == \"*\" and command[i+1] == \"/\":\\n                        look = False\\n                        i += 2\\n                    else: \\n                        i += 1\\n            \\n            if not look and len(temp) > 0:\\n                res.append(temp)      \\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969459,
                "title": "short-python-one-pass-only-while-if-else-no-find",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        inBlock=False\\n        ans=[]\\n        for line in source:\\n            curr=[]\\n            if inBlock and ans:\\n                curr.append(ans.pop())\\n            i=0\\n            while i<len(line):\\n                if inBlock:\\n                    if line[i:i+2]==\"*/\":\\n                        inBlock=False\\n                        i+=2\\n                    else:\\n                        i+=1\\n                else:\\n                    if line[i:i+2]==\"//\":\\n                        break\\n                    elif line[i:i+2]==\"/*\":\\n                        inBlock=True\\n                        i+=2\\n                    else:\\n                        curr.append(line[i])\\n                        i+=1\\n                        \\n            if curr:\\n                ans.append(\"\".join(curr))\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        \\n        inBlock=False\\n        ans=[]\\n        for line in source:\\n            curr=[]\\n            if inBlock and ans:\\n                curr.append(ans.pop())\\n            i=0\\n            while i<len(line):\\n                if inBlock:\\n                    if line[i:i+2]==\"*/\":\\n                        inBlock=False\\n                        i+=2\\n                    else:\\n                        i+=1\\n                else:\\n                    if line[i:i+2]==\"//\":\\n                        break\\n                    elif line[i:i+2]==\"/*\":\\n                        inBlock=True\\n                        i+=2\\n                    else:\\n                        curr.append(line[i])\\n                        i+=1\\n                        \\n            if curr:\\n                ans.append(\"\".join(curr))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967713,
                "title": "self-explanatory-code-with-comments",
                "content": "# Intuition\\nThis is a very beautiful questions which doesn\\'t test your DSA/CP skills but pure logical thinking.\\n\\n# Approach\\nMy solution is time optimized but you can do inplace changes to optimize it over space (but that will increase time). The comments are self explanatory.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$ where n is number of lines in input test case and m is number of characters in each line.\\n- Note: the $m$ factor is a crucial factor and only some solutions have accounted for it. Without reading each character we will not be able to come to the correct solution. So, it is the least complexity you could achieve in the worst case.\\n\\n- Space complexity: $$O(n)$$ for storing the output (if you do an inplace editing you can reduce this to constant but that will increase the time taken as arrays are really bad at removing elements from middle which you would require almost in every test case).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {      \\n        string cur=\"\";\\n        vector<string> out;\\n        bool comm=false; // it will help us see whether comment is active or not\\n\\n        for(string s: source){\\n            for(int j=0; j<s.size(); j++){\\n                // that means a comment is started\\n                if(!comm && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                    comm = true;\\n                    j++;\\n                }\\n                // what if a // <- is present, then full line is not read & break\\n                // also make sure it is outside comments\\n                else if(!comm && s[j]==\\'/\\' && s[j+1]==\\'/\\') break;\\n                // check if a comment is completed\\n                else if(comm && s[j]==\\'*\\' && s[j+1]==\\'/\\') {\\n                    comm=false;\\n                    j++;\\n                }\\n                // or else it is a valid code\\n                else if (!comm)\\n                    cur+=s[j];\\n            }\\n            // now check if it\\'s a comment or not and its not blank (because comments\\n            // are blank lines) and add it to output\\n\\n            if(!comm && cur.size()){\\n                out.push_back(cur);\\n                cur=\"\";\\n            }\\n        }\\n        return out; \\n    }\\n};\\n```\\nThanks!\\nWith \\u2764\\uFE0F from Ayush",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {      \\n        string cur=\"\";\\n        vector<string> out;\\n        bool comm=false; // it will help us see whether comment is active or not\\n\\n        for(string s: source){\\n            for(int j=0; j<s.size(); j++){\\n                // that means a comment is started\\n                if(!comm && s[j]==\\'/\\' && s[j+1]==\\'*\\'){\\n                    comm = true;\\n                    j++;\\n                }\\n                // what if a // <- is present, then full line is not read & break\\n                // also make sure it is outside comments\\n                else if(!comm && s[j]==\\'/\\' && s[j+1]==\\'/\\') break;\\n                // check if a comment is completed\\n                else if(comm && s[j]==\\'*\\' && s[j+1]==\\'/\\') {\\n                    comm=false;\\n                    j++;\\n                }\\n                // or else it is a valid code\\n                else if (!comm)\\n                    cur+=s[j];\\n            }\\n            // now check if it\\'s a comment or not and its not blank (because comments\\n            // are blank lines) and add it to output\\n\\n            if(!comm && cur.size()){\\n                out.push_back(cur);\\n                cur=\"\";\\n            }\\n        }\\n        return out; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919539,
                "title": "c-regex",
                "content": "https://github.com/lambdacode-dev/leetcode/blob/main/722b.Remove-Comments.cpp\\n```\\n//[C++ regex]\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        string src = accumulate(source.begin(), source.end(), string{}, [](auto const& a, auto const& b) { return a+b+\"\\\\n\"; });\\n        string shortestblockcomment = \"/\\\\\\\\*\"  \"(.|\\\\\\\\n)*?\"  \"\\\\\\\\*/\";\\n        string linecomment = \"//.*\";\\n        regex comment(\"(\" + shortestblockcomment + \")|(\" + linecomment + \")\");\\n        src = std::regex_replace(src, comment, \"\");\\n        istringstream f(src);\\n        source.clear();\\n        for(string line; getline(f, line); ) {\\n            if(!line.empty())\\n                source.push_back(line);\\n        }\\n        return source;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//[C++ regex]\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        string src = accumulate(source.begin(), source.end(), string{}, [](auto const& a, auto const& b) { return a+b+\"\\\\n\"; });\\n        string shortestblockcomment = \"/\\\\\\\\*\"  \"(.|\\\\\\\\n)*?\"  \"\\\\\\\\*/\";\\n        string linecomment = \"//.*\";\\n        regex comment(\"(\" + shortestblockcomment + \")|(\" + linecomment + \")\");\\n        src = std::regex_replace(src, comment, \"\");\\n        istringstream f(src);\\n        source.clear();\\n        for(string line; getline(f, line); ) {\\n            if(!line.empty())\\n                source.push_back(line);\\n        }\\n        return source;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919406,
                "title": "c-scan-and-block-comment-states-update",
                "content": "https://github.com/lambdacode-dev/leetcode/blob/main/722.Remove-Comments.cpp\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> code;   \\n        for(int i = 0, inblock = 0, wasinblock = 0; i < source.size(); ++i) {\\n            string line = source[i];\\n            if(inblock) {\\n                if(auto pos = line.find(\"*/\"); pos != string::npos) {\\n                    line = line.substr(pos+2);\\n                    inblock = !(wasinblock = true);\\n                    source[i--] = line;\\n                }\\n            }\\n            else {\\n                auto pos1 = line.find(\"/*\"), pos2 = line.find(\"//\");\\n                if(pos1 == string::npos) pos1 = line.size();\\n                if(pos2 == string::npos) pos2 = line.size();\\n                if(pos1 != pos2) {\\n                    inblock = (pos1 < pos2);\\n                    line = line.substr(0, std::min(pos1, pos2));\\n                }\\n                if(wasinblock) {\\n                    line = code.back() + line;\\n                    code.pop_back();\\n                    wasinblock = false;\\n                } \\n                if(inblock || !line.empty()) {\\n                    code.push_back(line);\\n                }\\n                if(inblock) {\\n                    line = source[i].substr(pos1+2);\\n                    source[i--] = line;\\n                }\\n            }\\n        }\\n        return code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> code;   \\n        for(int i = 0, inblock = 0, wasinblock = 0; i < source.size(); ++i) {\\n            string line = source[i];\\n            if(inblock) {\\n                if(auto pos = line.find(\"*/\"); pos != string::npos) {\\n                    line = line.substr(pos+2);\\n                    inblock = !(wasinblock = true);\\n                    source[i--] = line;\\n                }\\n            }\\n            else {\\n                auto pos1 = line.find(\"/*\"), pos2 = line.find(\"//\");\\n                if(pos1 == string::npos) pos1 = line.size();\\n                if(pos2 == string::npos) pos2 = line.size();\\n                if(pos1 != pos2) {\\n                    inblock = (pos1 < pos2);\\n                    line = line.substr(0, std::min(pos1, pos2));\\n                }\\n                if(wasinblock) {\\n                    line = code.back() + line;\\n                    code.pop_back();\\n                    wasinblock = false;\\n                } \\n                if(inblock || !line.empty()) {\\n                    code.push_back(line);\\n                }\\n                if(inblock) {\\n                    line = source[i].substr(pos1+2);\\n                    source[i--] = line;\\n                }\\n            }\\n        }\\n        return code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894638,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Iterative Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source)\\n    {\\n        vector <string> res;\\n        string out = \"\";\\n        bool block = false;\\n\\n        for(string line : source)\\n        {\\n            for(int i=0; i<line.length();i++)\\n            {\\n                if(!block)\\n                {\\n                    if(i==line.length()-1)\\n                    {\\n                        out+=line[i];\\n                    }\\n                    else\\n                    {\\n                        string t = line.substr(i,2);\\n                        if(t==\"/*\")\\n                        {\\n                            block = true;\\n                            i++;\\n                        }\\n                        else if(t==\"//\")\\n                        {\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            out += line[i];\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    string t = line.substr(i,2);\\n                    if(t==\"*/\")\\n                    {\\n                        block = false;\\n                        i++;\\n                    }\\n                }\\n            }\\n            if(!out.empty() && !block)\\n            {\\n                res.push_back(out);\\n                out = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source)\\n    {\\n        vector <string> res;\\n        string out = \"\";\\n        bool block = false;\\n\\n        for(string line : source)\\n        {\\n            for(int i=0; i<line.length();i++)\\n            {\\n                if(!block)\\n                {\\n                    if(i==line.length()-1)\\n                    {\\n                        out+=line[i];\\n                    }\\n                    else\\n                    {\\n                        string t = line.substr(i,2);\\n                        if(t==\"/*\")\\n                        {\\n                            block = true;\\n                            i++;\\n                        }\\n                        else if(t==\"//\")\\n                        {\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            out += line[i];\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    string t = line.substr(i,2);\\n                    if(t==\"*/\")\\n                    {\\n                        block = false;\\n                        i++;\\n                    }\\n                }\\n            }\\n            if(!out.empty() && !block)\\n            {\\n                res.push_back(out);\\n                out = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894380,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        fn _remove_comments(source: &[String]) -> Option<Vec<String>> {\\n            let mut result = Vec::new();\\n            let mut in_block_comment = false;\\n            let mut line = String::new();\\n\\n            for s in source {\\n                let mut i = 0;\\n                while i < s.len() {\\n                    if in_block_comment {\\n                        if i + 1 < s.len() && &s[i..i + 2] == \"*/\" {\\n                            in_block_comment = false;\\n                            i += 2;\\n                        } else {\\n                            i += 1;\\n                        }\\n                    } else if i + 1 < s.len() && &s[i..i + 2] == \"/*\" {\\n                        in_block_comment = true;\\n                        i += 2;\\n                    } else if i + 1 < s.len() && &s[i..i + 2] == \"//\" {\\n                        break;\\n                    } else {\\n                        line.push(s.chars().nth(i)?);\\n                        i += 1;\\n                    }\\n                }\\n\\n                if !in_block_comment && !line.is_empty() {\\n                    result.push(line);\\n                    line = String::new();\\n                }\\n            }\\n\\n            Some(result)\\n        }\\n        _remove_comments(&source).unwrap_or_default()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        fn _remove_comments(source: &[String]) -> Option<Vec<String>> {\\n            let mut result = Vec::new();\\n            let mut in_block_comment = false;\\n            let mut line = String::new();\\n\\n            for s in source {\\n                let mut i = 0;\\n                while i < s.len() {\\n                    if in_block_comment {\\n                        if i + 1 < s.len() && &s[i..i + 2] == \"*/\" {\\n                            in_block_comment = false;\\n                            i += 2;\\n                        } else {\\n                            i += 1;\\n                        }\\n                    } else if i + 1 < s.len() && &s[i..i + 2] == \"/*\" {\\n                        in_block_comment = true;\\n                        i += 2;\\n                    } else if i + 1 < s.len() && &s[i..i + 2] == \"//\" {\\n                        break;\\n                    } else {\\n                        line.push(s.chars().nth(i)?);\\n                        i += 1;\\n                    }\\n                }\\n\\n                if !in_block_comment && !line.is_empty() {\\n                    result.push(line);\\n                    line = String::new();\\n                }\\n            }\\n\\n            Some(result)\\n        }\\n        _remove_comments(&source).unwrap_or_default()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877686,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []        \\n        is_comment = \"\"\\n        substring = \"\"        \\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if not is_comment and line[i:i+2] == \\'//\\':\\n                    break\\n\\n                elif line[i:i+2] == \\'/*\\':\\n                    if not is_comment:\\n                        is_comment = True\\n                        i += 1\\n\\n                elif is_comment and line[i:i+2] == \\'*/\\':\\n                    is_comment = False\\n                    i += 1\\n                \\n                elif not is_comment:\\n                    substring += line[i]                \\n                    \\n                i += 1\\n                \\n            if substring and not is_comment:\\n                result.append(substring)\\n                substring = \"\"\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeComments(self, source: List[str]) -> List[str]:\\n        result = []        \\n        is_comment = \"\"\\n        substring = \"\"        \\n        for line in source:\\n            i = 0\\n            while i < len(line):\\n                if not is_comment and line[i:i+2] == \\'//\\':\\n                    break\\n\\n                elif line[i:i+2] == \\'/*\\':\\n                    if not is_comment:\\n                        is_comment = True\\n                        i += 1\\n\\n                elif is_comment and line[i:i+2] == \\'*/\\':\\n                    is_comment = False\\n                    i += 1\\n                \\n                elif not is_comment:\\n                    substring += line[i]                \\n                    \\n                i += 1\\n                \\n            if substring and not is_comment:\\n                result.append(substring)\\n                substring = \"\"\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864525,
                "title": "interesting-problem",
                "content": "```\\nclass Solution:\\n    def source2string(self, source : List[str]) ->str:\\n        res = \"\"\\n        for line in source:\\n            res += line\\n            res += \"\\\\n\"\\n        return res\\n    \\n    def string2source(self, string : str) -> List[str]:\\n        # res = []\\n        # temp = \"\"\\n        # n = len(string)\\n        # i = 0\\n        # while(i < n):\\n        #     if(string[i] != \"\\\\n\"):\\n        #         temp += string[i]\\n        #     else:\\n        #         #string[i] == \"\\\\n\"\\n        #         if(temp != \"\"):\\n        #             res.append(temp)\\n        #         temp = \"\"\\n        #     i += 1\\n        # res.append(temp)\\n        # return res\\n        return string.split(\\'\\\\n\\')\\n            \\n    def removeComments(self, source: List[str]) -> List[str]:\\n        string = self.source2string(source)\\n        queue = \"\"\\n        n = len(string)\\n        i = 0\\n        #dont delete any \\\\n\\n        while(i < n-1):\\n            if(string[i:i+2] != \"/*\" and string[i:i+2] != \"//\"):\\n                queue += string[i]\\n        \\n            elif(string[i:i+2] == \"//\"):\\n                while( string[i]!=\"\\\\n\" ):\\n                    i += 1\\n                #now string[i] == \"\\\\n\" \\n                queue += string[i]\\n                \\n            else:\\n                #string[i:i+2] == \"/*\"\\n                startIndex = i\\n                i += 2\\n                while(i < n-1 and string[i:i+2]!=\"*/\"):\\n                    i += 1\\n                #now i == n-1 or string[i:i+2] == \"*/\"\\n                if(i == n-1):\\n                    #nothing happen\\n                    i = startIndex\\n                    queue += string[i]\\n                else:\\n                    #now string[i:i+2]==\"*/\"\\n                    i += 1    \\n            i += 1\\n        \\n        res = self.string2source(queue)\\n        temp = []\\n        for line in res:\\n            if(line != \"\"):\\n                temp.append(line)\\n        res = temp\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def source2string(self, source : List[str]) ->str:\\n        res = \"\"\\n        for line in source:\\n            res += line\\n            res += \"\\\\n\"\\n        return res\\n    \\n    def string2source(self, string : str) -> List[str]:\\n        # res = []\\n        # temp = \"\"\\n        # n = len(string)\\n        # i = 0\\n        # while(i < n):\\n        #     if(string[i] != \"\\\\n\"):\\n        #         temp += string[i]\\n        #     else:\\n        #         #string[i] == \"\\\\n\"\\n        #         if(temp != \"\"):\\n        #             res.append(temp)\\n        #         temp = \"\"\\n        #     i += 1\\n        # res.append(temp)\\n        # return res\\n        return string.split(\\'\\\\n\\')\\n            \\n    def removeComments(self, source: List[str]) -> List[str]:\\n        string = self.source2string(source)\\n        queue = \"\"\\n        n = len(string)\\n        i = 0\\n        #dont delete any \\\\n\\n        while(i < n-1):\\n            if(string[i:i+2] != \"/*\" and string[i:i+2] != \"//\"):\\n                queue += string[i]\\n        \\n            elif(string[i:i+2] == \"//\"):\\n                while( string[i]!=\"\\\\n\" ):\\n                    i += 1\\n                #now string[i] == \"\\\\n\" \\n                queue += string[i]\\n                \\n            else:\\n                #string[i:i+2] == \"/*\"\\n                startIndex = i\\n                i += 2\\n                while(i < n-1 and string[i:i+2]!=\"*/\"):\\n                    i += 1\\n                #now i == n-1 or string[i:i+2] == \"*/\"\\n                if(i == n-1):\\n                    #nothing happen\\n                    i = startIndex\\n                    queue += string[i]\\n                else:\\n                    #now string[i:i+2]==\"*/\"\\n                    i += 1    \\n            i += 1\\n        \\n        res = self.string2source(queue)\\n        temp = []\\n        for line in res:\\n            if(line != \"\"):\\n                temp.append(line)\\n        res = temp\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851598,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool commentMode = false;\\n        string cur = \"\";\\n        for (auto& v : source) {\\n            for (int i = 0; i < v.size(); ++i){\\n                if (!commentMode){\\n                    if (v[i] == \\'/\\'){\\n                        if (v[i + 1] == \\'/\\'){\\n                            break;\\n                        }\\n                        else if (v[i + 1] == \\'*\\'){\\n                            commentMode = true;\\n                            ++i;\\n                            continue;\\n                        }\\n                    }\\n                    cur += v[i];\\n                }\\n                else{\\n                     if (v[i] == \\'*\\' && v[i + 1] == \\'/\\'){\\n                        ++i;\\n                        commentMode = false;\\n                    }\\n                }\\n            }\\n          \\n            if (!cur.empty() && !commentMode){\\n                ans.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeComments(vector<string>& source) {\\n        vector<string> ans;\\n        bool commentMode = false;\\n        string cur = \"\";\\n        for (auto& v : source) {\\n            for (int i = 0; i < v.size(); ++i){\\n                if (!commentMode){\\n                    if (v[i] == \\'/\\'){\\n                        if (v[i + 1] == \\'/\\'){\\n                            break;\\n                        }\\n                        else if (v[i + 1] == \\'*\\'){\\n                            commentMode = true;\\n                            ++i;\\n                            continue;\\n                        }\\n                    }\\n                    cur += v[i];\\n                }\\n                else{\\n                     if (v[i] == \\'*\\' && v[i + 1] == \\'/\\'){\\n                        ++i;\\n                        commentMode = false;\\n                    }\\n                }\\n            }\\n          \\n            if (!cur.empty() && !commentMode){\\n                ans.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842547,
                "title": "java-boring-straightforward-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n        public List<String> removeComments(String[] source) {\\n\\n            List<String> resultLines = new ArrayList<>();\\n            boolean isBlockOpen = false;\\n            StringBuilder resultLine = new StringBuilder();\\n\\n            for (String inputLine : source) {\\n                char lastChar = \\' \\';\\n                if(!isBlockOpen) {\\n                    resultLine.delete(0,resultLine.length());\\n                }\\n\\n                boolean lineCommented = false;\\n\\n\\n                for (char c : inputLine.toCharArray()) {\\n                    if (lineCommented) {\\n                        break;\\n                    } else \\n                        if (isBlockOpen) {\\n                            if (lastChar == \\'*\\' && c == \\'/\\') {\\n                                isBlockOpen = false;\\n                                lastChar = \\' \\';\\n                            } else {\\n                                lastChar = c;\\n                            }\\n\\n                            continue;\\n                        }\\n            \\n                    if (lastChar == \\'/\\' && c == \\'*\\') {\\n                        isBlockOpen = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        lastChar = \\' \\';\\n                        continue;\\n                    }\\n    \\n\\n                    if (lastChar == \\'/\\' && c == \\'/\\') {\\n                        lineCommented = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        continue;\\n                    }\\n\\n\\n                    resultLine.append(c);\\n\\n                    lastChar = c;\\n\\n                }\\n\\n                if (!resultLine.toString().isEmpty() && !isBlockOpen) {\\n                    resultLines.add(resultLine.toString());\\n                }\\n\\n            }\\n\\n\\n            return resultLines;\\n        }\\n}\\n\\n  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n        public List<String> removeComments(String[] source) {\\n\\n            List<String> resultLines = new ArrayList<>();\\n            boolean isBlockOpen = false;\\n            StringBuilder resultLine = new StringBuilder();\\n\\n            for (String inputLine : source) {\\n                char lastChar = \\' \\';\\n                if(!isBlockOpen) {\\n                    resultLine.delete(0,resultLine.length());\\n                }\\n\\n                boolean lineCommented = false;\\n\\n\\n                for (char c : inputLine.toCharArray()) {\\n                    if (lineCommented) {\\n                        break;\\n                    } else \\n                        if (isBlockOpen) {\\n                            if (lastChar == \\'*\\' && c == \\'/\\') {\\n                                isBlockOpen = false;\\n                                lastChar = \\' \\';\\n                            } else {\\n                                lastChar = c;\\n                            }\\n\\n                            continue;\\n                        }\\n            \\n                    if (lastChar == \\'/\\' && c == \\'*\\') {\\n                        isBlockOpen = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        lastChar = \\' \\';\\n                        continue;\\n                    }\\n    \\n\\n                    if (lastChar == \\'/\\' && c == \\'/\\') {\\n                        lineCommented = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        continue;\\n                    }\\n\\n\\n                    resultLine.append(c);\\n\\n                    lastChar = c;\\n\\n                }\\n\\n                if (!resultLine.toString().isEmpty() && !isBlockOpen) {\\n                    resultLines.add(resultLine.toString());\\n                }\\n\\n            }\\n\\n\\n            return resultLines;\\n        }\\n}\\n\\n  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842546,
                "title": "java-one-pass-straightforward-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n        public List<String> removeComments(String[] source) {\\n\\n            List<String> resultLines = new ArrayList<>();\\n            boolean isBlockOpen = false;\\n            StringBuilder resultLine = new StringBuilder();\\n\\n            for (String inputLine : source) {\\n                char lastChar = \\' \\';\\n                if(!isBlockOpen) {\\n                    resultLine.delete(0,resultLine.length());\\n                }\\n\\n                boolean lineCommented = false;\\n\\n\\n                for (char c : inputLine.toCharArray()) {\\n                    if (lineCommented) {\\n                        break;\\n                    } else \\n                        if (isBlockOpen) {\\n                            if (lastChar == \\'*\\' && c == \\'/\\') {\\n                                isBlockOpen = false;\\n                                lastChar = \\' \\';\\n                            } else {\\n                                lastChar = c;\\n                            }\\n\\n                            continue;\\n                        }\\n            \\n                    if (lastChar == \\'/\\' && c == \\'*\\') {\\n                        isBlockOpen = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        lastChar = \\' \\';\\n                        continue;\\n                    }\\n    \\n\\n                    if (lastChar == \\'/\\' && c == \\'/\\') {\\n                        lineCommented = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        continue;\\n                    }\\n\\n\\n                    resultLine.append(c);\\n\\n                    lastChar = c;\\n\\n                }\\n\\n                if (!resultLine.toString().isEmpty() && !isBlockOpen) {\\n                    resultLines.add(resultLine.toString());\\n                }\\n\\n            }\\n\\n\\n            return resultLines;\\n        }\\n}\\n\\n  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n        public List<String> removeComments(String[] source) {\\n\\n            List<String> resultLines = new ArrayList<>();\\n            boolean isBlockOpen = false;\\n            StringBuilder resultLine = new StringBuilder();\\n\\n            for (String inputLine : source) {\\n                char lastChar = \\' \\';\\n                if(!isBlockOpen) {\\n                    resultLine.delete(0,resultLine.length());\\n                }\\n\\n                boolean lineCommented = false;\\n\\n\\n                for (char c : inputLine.toCharArray()) {\\n                    if (lineCommented) {\\n                        break;\\n                    } else \\n                        if (isBlockOpen) {\\n                            if (lastChar == \\'*\\' && c == \\'/\\') {\\n                                isBlockOpen = false;\\n                                lastChar = \\' \\';\\n                            } else {\\n                                lastChar = c;\\n                            }\\n\\n                            continue;\\n                        }\\n            \\n                    if (lastChar == \\'/\\' && c == \\'*\\') {\\n                        isBlockOpen = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        lastChar = \\' \\';\\n                        continue;\\n                    }\\n    \\n\\n                    if (lastChar == \\'/\\' && c == \\'/\\') {\\n                        lineCommented = true;\\n                        resultLine.deleteCharAt(resultLine.length() - 1);\\n                        continue;\\n                    }\\n\\n\\n                    resultLine.append(c);\\n\\n                    lastChar = c;\\n\\n                }\\n\\n                if (!resultLine.toString().isEmpty() && !isBlockOpen) {\\n                    resultLines.add(resultLine.toString());\\n                }\\n\\n            }\\n\\n\\n            return resultLines;\\n        }\\n}\\n\\n  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841984,
                "title": "rust-using-recursion-to-process-the-lines",
                "content": "~~~\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        let mut open = false;\\n        let mut ret = vec![];\\n        let mut cache = String::new();\\n        \\n        for s in source {\\n            let s = s.chars().collect::<Vec<char>>();\\n            let str = Self::read(&s, 0, &mut open);\\n            cache += &str;\\n            if open == false && cache.is_empty() == false {\\n                ret.push(cache.clone());\\n                cache.clear();\\n            }\\n        }\\n        \\n        return ret\\n    }\\n\\n    fn read(s: &Vec<char>, k: usize, open: &mut bool) -> String {\\n        let (mut i, n) = (k, s.len());\\n        let mut ret = String::new();\\n        \\n        if i == n { return ret }\\n        \\n        if *open {\\n            while i + 1 < n {\\n                if s[i] == \\'*\\' && s[i + 1] == \\'/\\' {\\n                    *open = false;\\n                    return Self::read(s, i + 2, open);\\n                }\\n                i += 1;\\n            }\\n            \\n            return ret\\n        }\\n        \\n        while i < n {\\n            if i + 1 < n && s[i] == \\'/\\' && s[i + 1] == \\'/\\' { return ret }\\n            if i + 1 < n && s[i] == \\'/\\' && s[i + 1] == \\'*\\' {\\n                *open = true;\\n                let temp = Self::read(s, i + 2, open);\\n                ret += &temp;\\n                return ret\\n            }\\n            ret.push(s[i]);\\n            i += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn remove_comments(source: Vec<String>) -> Vec<String> {\\n        let mut open = false;\\n        let mut ret = vec![];\\n        let mut cache = String::new();\\n        \\n        for s in source {\\n            let s = s.chars().collect::<Vec<char>>();\\n            let str = Self::read(&s, 0, &mut open);\\n            cache += &str;\\n            if open == false && cache.is_empty() == false {\\n                ret.push(cache.clone());\\n                cache.clear();\\n            }\\n        }\\n        \\n        return ret\\n    }\\n\\n    fn read(s: &Vec<char>, k: usize, open: &mut bool) -> String {\\n        let (mut i, n) = (k, s.len());\\n        let mut ret = String::new();\\n        \\n        if i == n { return ret }\\n        \\n        if *open {\\n            while i + 1 < n {\\n                if s[i] == \\'*\\' && s[i + 1] == \\'/\\' {\\n                    *open = false;\\n                    return Self::read(s, i + 2, open);\\n                }\\n                i += 1;\\n            }\\n            \\n            return ret\\n        }\\n        \\n        while i < n {\\n            if i + 1 < n && s[i] == \\'/\\' && s[i + 1] == \\'/\\' { return ret }\\n            if i + 1 < n && s[i] == \\'/\\' && s[i + 1] == \\'*\\' {\\n                *open = true;\\n                let temp = Self::read(s, i + 2, open);\\n                ret += &temp;\\n                return ret\\n            }\\n            ret.push(s[i]);\\n            i += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574046,
                "content": [
                    {
                        "username": "DeepOceanWhale",
                        "content": "I think it should return \"a\", \"b\" instead of \"ab\".\\n\\nConsider the code below:\\n\\nint ab = 1;\\na/* comment */b = 2;\\n\\nif after remove comment is ab = 2; that means the code should work but actually it doesn\\'t.\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "according to the question we should remove all block of text in comments. Now as per the sample input, the comments are made inline with \"a\" so we start highlighting it as a comment, the thing to note is that the newline character (or the next line) starts within the comment block so it is removed and no newline character is made outside of the comment block and therefore it is \"ab\" and not \"a\", \"b\". hope it helps!"
                    },
                    {
                        "username": "RedHornet",
                        "content": "Do not try this at home."
                    },
                    {
                        "username": "lalalaaron",
                        "content": "I was very happy debugging the corner cases until I hit the 51/53. lol. If I get this question in an interview, I will reject that company. This question was designed to disgust people.\\n\\n"
                    },
                    {
                        "username": "somethingblue",
                        "content": "My friend... what the heck is going on with 51?"
                    },
                    {
                        "username": "ariboi27",
                        "content": "First time in my 450 questions (humble brag) I have solved, am i going to be pissed .. i absolutely despise this question"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "this was asked by an HFT so you can just think of it. One thing I find really beautiful about this question is that it doesn\\'t test your CP or existing DSA knowledge but tests (extensively) your logical thinking. Thats the beauty of it."
                    }
                ]
            },
            {
                "id": 1730422,
                "content": [
                    {
                        "username": "DeepOceanWhale",
                        "content": "I think it should return \"a\", \"b\" instead of \"ab\".\\n\\nConsider the code below:\\n\\nint ab = 1;\\na/* comment */b = 2;\\n\\nif after remove comment is ab = 2; that means the code should work but actually it doesn\\'t.\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "according to the question we should remove all block of text in comments. Now as per the sample input, the comments are made inline with \"a\" so we start highlighting it as a comment, the thing to note is that the newline character (or the next line) starts within the comment block so it is removed and no newline character is made outside of the comment block and therefore it is \"ab\" and not \"a\", \"b\". hope it helps!"
                    },
                    {
                        "username": "RedHornet",
                        "content": "Do not try this at home."
                    },
                    {
                        "username": "lalalaaron",
                        "content": "I was very happy debugging the corner cases until I hit the 51/53. lol. If I get this question in an interview, I will reject that company. This question was designed to disgust people.\\n\\n"
                    },
                    {
                        "username": "somethingblue",
                        "content": "My friend... what the heck is going on with 51?"
                    },
                    {
                        "username": "ariboi27",
                        "content": "First time in my 450 questions (humble brag) I have solved, am i going to be pissed .. i absolutely despise this question"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "this was asked by an HFT so you can just think of it. One thing I find really beautiful about this question is that it doesn\\'t test your CP or existing DSA knowledge but tests (extensively) your logical thinking. Thats the beauty of it."
                    }
                ]
            },
            {
                "id": 1765716,
                "content": [
                    {
                        "username": "DeepOceanWhale",
                        "content": "I think it should return \"a\", \"b\" instead of \"ab\".\\n\\nConsider the code below:\\n\\nint ab = 1;\\na/* comment */b = 2;\\n\\nif after remove comment is ab = 2; that means the code should work but actually it doesn\\'t.\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "according to the question we should remove all block of text in comments. Now as per the sample input, the comments are made inline with \"a\" so we start highlighting it as a comment, the thing to note is that the newline character (or the next line) starts within the comment block so it is removed and no newline character is made outside of the comment block and therefore it is \"ab\" and not \"a\", \"b\". hope it helps!"
                    },
                    {
                        "username": "RedHornet",
                        "content": "Do not try this at home."
                    },
                    {
                        "username": "lalalaaron",
                        "content": "I was very happy debugging the corner cases until I hit the 51/53. lol. If I get this question in an interview, I will reject that company. This question was designed to disgust people.\\n\\n"
                    },
                    {
                        "username": "somethingblue",
                        "content": "My friend... what the heck is going on with 51?"
                    },
                    {
                        "username": "ariboi27",
                        "content": "First time in my 450 questions (humble brag) I have solved, am i going to be pissed .. i absolutely despise this question"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "this was asked by an HFT so you can just think of it. One thing I find really beautiful about this question is that it doesn\\'t test your CP or existing DSA knowledge but tests (extensively) your logical thinking. Thats the beauty of it."
                    }
                ]
            },
            {
                "id": 1717665,
                "content": [
                    {
                        "username": "DeepOceanWhale",
                        "content": "I think it should return \"a\", \"b\" instead of \"ab\".\\n\\nConsider the code below:\\n\\nint ab = 1;\\na/* comment */b = 2;\\n\\nif after remove comment is ab = 2; that means the code should work but actually it doesn\\'t.\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "according to the question we should remove all block of text in comments. Now as per the sample input, the comments are made inline with \"a\" so we start highlighting it as a comment, the thing to note is that the newline character (or the next line) starts within the comment block so it is removed and no newline character is made outside of the comment block and therefore it is \"ab\" and not \"a\", \"b\". hope it helps!"
                    },
                    {
                        "username": "RedHornet",
                        "content": "Do not try this at home."
                    },
                    {
                        "username": "lalalaaron",
                        "content": "I was very happy debugging the corner cases until I hit the 51/53. lol. If I get this question in an interview, I will reject that company. This question was designed to disgust people.\\n\\n"
                    },
                    {
                        "username": "somethingblue",
                        "content": "My friend... what the heck is going on with 51?"
                    },
                    {
                        "username": "ariboi27",
                        "content": "First time in my 450 questions (humble brag) I have solved, am i going to be pissed .. i absolutely despise this question"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "this was asked by an HFT so you can just think of it. One thing I find really beautiful about this question is that it doesn\\'t test your CP or existing DSA knowledge but tests (extensively) your logical thinking. Thats the beauty of it."
                    }
                ]
            }
        ]
    }
]