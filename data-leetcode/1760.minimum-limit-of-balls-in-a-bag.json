[
    {
        "title": "Knight Dialer",
        "question_content": "The chess knight has a unique movement,&nbsp;it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\nA chess knight can move as indicated in the chess diagram below:\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell&nbsp;(i.e. blue cell).\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\nExample 2:\n\nInput: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\nExample 3:\n\nInput: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 5000",
        "solutions": [
            {
                "id": 190787,
                "title": "how-to-solve-this-problem-explained-for-noobs",
                "content": "We can think of this problem as the total number of unique paths the knight can travel making n hops because to dial distinct numbers, the path taken by the knight must be unique.\\n\\nIn this post I want to explain how I came up with a solution to this problem. This approach can be used to solve other similar problems such as Unique Paths, Minimum Path Sum etc.\\n\\nImagine an 8 x 8 chess board with Knight (k) sitting at some index `(i, j)`. The board would look as follows,\\n\\n```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\\n\\n\\n**[0]** If k is at index `(i, j)`, then in a single hop, k can move to 8 possible positions which are below. \\n\\n\\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\\n\\n**[1]** Conversely, you can also say that in a single hop, there are 8 possible places (a,b,c,d,e,f,g,h) from which you can move to k.\\n\\n**Math behind the solution:**\\n\\nConsider a function paths(i, j, n) which calculates the total number of unique paths to reach index (i, j) for a given n, where n is the number of hops. From [0] or [1], we can recusively define paths(i, j, n) for all non-trivial (n > 1, that is, more than one hop) cases as follows,\\n\\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf we translate this to plain english, all we are saying is \"the total number of unique paths to (i, j) for certain hops n is equal to the sum of total number of unique paths to each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nIf you are confused why it is n - 1 hops, note that when we are at (i, j), we already made one hop and we have n - 1 hops more to take.\\n\\nFor the trivial case (n = 1, that is no hops), the problem states that this must be considered as one path. Therefore, paths(i, j, n) = 1, for n = 1.\\n\\n**A Sample Trace**\\n\\nIf the above recursive equation or it\\'s translation is not very enlightening, you can follow this sample trace to get a better understanding of the logic.\\n\\nOur keypad is a 4 x 3 matrix which looks like below.\\n\\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\\n\\nNote that in the code there is no need to use a matrix like this. This is just for explanation purpose.\\n\\nWe shall trace the recursion tree of paths(0, 0, 3) in this section, that is, all the possible unique paths from 1 (0, 0) in 3 hops. From 1 (0, 0), in a single hop, we have two possible places to jump to - 6 and 8.\\n\\nWait! Didn\\'t I say that a knight can jump to 8 possible places in a single hop some where in this post?\\n\\n*...\"in a single hop, k can move to 8 possible positions\"...*\\n\\nYes, a knight can jump to 8 possible places in a single hop and this is still true. However, 6 of the other hops will take you outside of the matrix. You will see later in the code how this is being handled as a part of base case.\\n\\n*A brief on notation*: \\n\\nI am representing each node in the recursion tree something like X (i, j, n). This means that we are at the call paths(0, 0, 3) and the knight is currently sitting on the number X with n - 1 hops remaining.\\n\\nBelow is the recursion tree for paths(0, 0, 3).\\n\\nNote: The following tree diagram is not visually appealing with the old UI. I recommend to view this in the new UI for a proper visual representation.\\n\\n                                  1 (0,0,3)\\n\\t\\t\\t\\t               /\\t\\t     \\\\\\n\\t\\t\\t\\t\\t          /               \\\\\\n\\t\\t\\t\\t  \\t  6 (1,2,2)             8 (2,1,2)\\t\\n\\t\\t\\t\\t   \\t/   |    \\\\                |   \\t\\\\\\n\\t\\t\\t\\t   /\\t|\\t  \\\\\\t\\t          |  \\t \\\\\\n\\t\\t1 (0,0,1)  0 (3,1,1)  7 (2,0,1)   1 (0,0,1)  3 (0,2,1)\\n\\n\\nSince, 6 jumps are invalid, that leaves us with only two valid jumps `e (i + 1, j + 2)` and  `f  (i + 2, j + 1)` from 1 (0, 0). In other words, from 1 the knight can jump only to 8 and 6. \\n\\nIn fact, in this matrix, the maximum number of valid jumps you can make is 3 which is from 4, 6.\\n\\nExplanation of this recursion tree is below,\\n\\nFrom 1 (0, 0, 3), the knight can go to 6 (1, 2, 2) and 8 (2, 1, 2) in a single hop. As we go down the recursion tree, we pass the number of hops to make as 1 less than the current.\\n\\nFrom 6 (1, 2, 2), it can go to 1 (0, 0, 1) , 0 (3, 1, 1) and 7 (2, 0, 1). We pass n as 1 as we are going down in the recursion. At this point, each of these calls return 1 (since n = 1 which is the trivial case). \\n\\nTherefore, **[2]** 6 (1, 2, 2) = 1 + 1 + 1 = 3, which means that there are 3 unique paths from 6 when n = 2 and they are 61, 60, 67.\\n\\nFrom 8 (2,1,2), it can go to 1 (0, 0, 1) and 3 (0, 2, 1). At this point, each of these calls return 1 (since n = 1).\\n\\nTherefore, **[3]** 8 (2, 1, 2) = 1 + 1 = 2, which means that there are 2 unique paths from 8 when n = 2 and they are 81, 83.\\n\\nFinally, 1 (0, 0, 3) = 6 (1, 2, 2) + 8 (2, 1, 2)\\n\\nFrom [2], [3], we can write this as,\\n\\n1 (0, 0, 3) = 3 + 2 = 5, which means that there are 5 unique paths from 1 when n = 3 and they are 161, 160, 167, 181, 183.\\n\\n**Naive Recursive Code**\\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\\n\\nIf you run this code for n = 50 in your favorite programming language, you will realize that it takes at least an hour to get the answer. \\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems. What does this mean? Let me explain with an example.\\n\\nAs seen in the above trace, a subproblem of 1 (0, 0, 3) is 8 (2, 1, 2). \\n\\nA subproblem of 3 (0, 2, 3) is also 8 (2, 1, 2) because you can get from 3 to 8 in a single hop.\\n\\nWe have already computed the solution to 8 (2, 1, 2) while computing the solution to 1 (0, 0, 3) and there is no need to re-compute this solution if were to store the solution somewhere in memory. The above recursive solution re-computes the solutions to overlapping subproblems and therefore is highly inefficient (runs in the order of O(3 ^ n) I believe).\\n\\n**Top down Dynamic programming solution**\\n\\nWe use dynamic programming and store the solution of each subproblem in M. M is a 3D array and each index of M corresponds to a solution of n. Each n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\nBelow is the code.\\n\\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```\\n\\nAny questions or feedback is welcome!\\n\\n**P.S: The wysiwyg editor of leetcode sucks! :P**\\n",
                "solutionTags": [],
                "code": "```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189252,
                "title": "o-logn",
                "content": "<img src=\"https://assets.leetcode.com/users/lee215/image_1541301837.png\" style=\"width:200px;\"/>\\n\\n**Naive recursion:**\\n`O(N)` time and `O(1)` space, good enough.\\n\\n```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```\\n\\n\\nIn fact, we recursively did pow operation.\\nThis can be optimised to `O(log)` time.\\n\\nConstruct a 10 * 10 transformation matrix M.\\n`M[i][j] = 1` if i and j is connnected.\\n\\nif N = 1, return 10.\\nif N > 1, return sum of `[1,1,1,1,1,1,1,1,1,1] * M ^ (N - 1)`\\n\\nThe power of matrix reveals the number of walks in an undirected graph.\\nFind more details on this link provide by @shankark:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\n\\n```\\n    def knightDialer(self, N):\\n        mod = 10**9 + 7\\n        if N == 1: return 10\\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\\n        res, N = 1, N - 1\\n        while N:\\n            if N % 2: res = res * M % mod\\n            M = M * M % mod\\n            N /= 2\\n        return int(np.sum(res)) % mod",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189287,
                "title": "o-n-time-o-1-space-dp-solution-google-interview-question-writeup",
                "content": "This is former Google interview question. It was leaked over a year ago and was soon after blacklisted. Because of this, a former Google interviewer decided to write an excellent blog post breaking down how he asked this question and what he expected from candidates who attempt it. This blog post explains the background of this question, common pitfalls candidates encounter, four different ways to solve it, and how a Google interviewer will evaluate your solution. This article is a gold mine for anyone considering interviewing at Google.\\nhttps://medium.com/@alexgolec/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029\\n\\nAccording to the article, four possible solutions are (1) naive recursive number generation, (2) naive recursive counting, (3) recursion + memoization, and (4) dynamic programming. A candidate who coded either the memoization or DP solution is likely to receive a \"strong hire\" recommendation.\\n\\nI encourage everyone to check out the article. If you\\'re just here for the solution, below is an accepted leetcode solution based on the ideas from the article.\\n```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189271,
                "title": "java-top-down-memo-dp-o-n",
                "content": "The problem can be transformed into:\\nTraverse a directed graph (each node with a number as label and edges are defined by Knight\\'s moving rule)\\nStart from `0 to 9`\\nMove `N - 1` step\\nReturn `how many ways to reach the end`\\n\\nEasy to come up with a DFS solution to start traversal from 0 to 9\\nIn each recursion, move to one of the current node\\'s neighbors and the remain step becomes `N-1`\\nStop recursion when `N == 0`\\n\\n**Optimization:**\\nObserve the recursive problem. The variances are:\\n1. Current Node\\n2. Remain Steps\\n\\nTherefore, we can store these two variables as the memo to speed up DFS (then it\\'s a Top Down DP)\\n```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```\\n**Time Complexity:** `O(10*N) = O(N)` fill the memo\\n**Space Complexity:** `O(N)` depth of the recursion ",
                "solutionTags": [],
                "code": "```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655853,
                "title": "if-you-want-to-laugh-check-out-this-stupid-solution-guarantee-you-could-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (hop1+hop2+hop3+hop4+hop6+hop7+hop8+hop9+hop0)%kMod;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 189251,
                "title": "c-5-lines-dp",
                "content": "The ```moves``` show the possible hoops from a given number. Each digit in ```dial[i]``` contains numbers that end with this digit. For each hoop, we add numbers from other digits that we can hop out from. For example, for digit 4 we add numbers from digits 3, 9 and 0:\\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "solutionTags": [],
                "code": "```moves```\n```dial[i]```\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189322,
                "title": "java-dfs-with-memo",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189265,
                "title": "concise-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824317,
                "title": "simple-c-solution-dp-92-time-efficient",
                "content": "**Think of it as for the current postion how many times we can fix it with 0,1...**\\nconsider -->if previous place is 0 then current place can be fixed with 4 and 6 so if v[0] is the count of 0 in previous place and tmp is for current postion then at current postion we will get 4 due to 0 as previous ,is v[0] times and similarly for current 6 due to previous 0 is v[0] times.\\n**so considering tmp as current and v as previous counts\\ntmp[x]=sum of all the previous values from which we can reach x;**\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189273,
                "title": "9-line-python-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189229,
                "title": "concise-c-using-dp-with-explanation",
                "content": "**Explanation:**  The row of the DP vector represent the N number of hops.  The column of the DP vector represent\nthe numeric phone pad keys [0:9] ( zero to nine, inclusive ).  Then the DP formula is as follows:\n \n**Base case:** when N is 1, the knight will take zero hops from its current digit\n \n```dp[1][0:9] = 1```\n \n**Recursive case:** observe the overlapping subproblems and optimal substructure.  The current i-th hop for each keypad digit can be found from the previous i-th-minus-1 hop for each keypad digit which can reach the current keypad digit from a single hop.  Therefore calculate the current i-th hop for each keypad destination digit (dst) as the sum of all keypad source digits (src) i-th-minus-1 hop solutions.\n \n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n\n**verbose DP solution #1:**  \n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n\n**verbose DP solution #2:** same concept as above, but optimized for memory use as we only need to keep track of the previous i-th-minus-1 hop values ( i.e. use a \"sliding window\" of size 2 ).\n\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Concise DP solution #3:** same concepts as above, using \"hops\" to track the next hops from each current digit.  (The current digit's value is the index of the vector of vectors \"hops\".)\n\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**More concise DP solution #4:** same concepts as above, just remove a handful of lines\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Recursive top-down DFS solution:** same concept as above, recursively top-down with memoization\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "solutionTags": [],
                "code": "```dp[1][0:9] = 1```\n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 189230,
                "title": "java-straightforward-simulation-dp-whatever",
                "content": "I don\\'t want to call it dp, because I just simply simulate the process.\\n```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540675,
                "title": "c-simple-clean-and-concise-solution-with-detailed-explanation-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nFirst, we set a map from each number to its neighbors to easily know where we can go, using a vector and its indices.\\nThe `count` vector keeps the number of phone numbers we can dial starting from each index.\\nWe initialize `count` with `1`s, because we can place the knight in any cell initially, and need no steps to make numbers with 1 digit.\\nNow, we loop `n` times.\\nEach time, we go through all the numbers - `0` to `9` - and try to continue another step from that number.\\nWe count the new ways in a temporary vector `curr_count` to keep track of the old and new counts.\\nAt the end, we sum up `count` to get the total numbers we can dial.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) (All vectors have constant sizes)\\n\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469930,
                "title": "1-for-loop-4-ints-that-s-it",
                "content": "Python, 5 lines, 97% time efficient, 96% memory efficient, no DP. \\n\\nI came up with a pretty elegant solution by thinking about this problem in terms of board-states. Each square the knight can stand on has certain properties. I classified all the squares on the keypad into 5 types of board-states.\\n\\n- A\\n\\t- Squares: 0\\n\\t- Moves: B, B\\n- B\\n\\t- Squares: 4, 6\\n\\t- Moves: A, C, C\\n- C\\n\\t- Squares: 1, 3, 7, 9\\n\\t- Moves: B, D\\n- D\\n\\t- Squares: 2, 8\\n\\t- Moves: C, C\\n- E\\n\\t- Squares: 5\\n\\t- Moves: none\\n\\nTo translate these classifications: every time you arrive at a C-square, one B-square and one D-square are available for your next move. I counted how many of each of the board-states we started with, and wrote down the formulas for how many of each board-state would be created for the next round by our existing board-states. Here\\'s my code:\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278584,
                "title": "easy-c-solution-3-approaches",
                "content": "# Approach 1 : Recursion - TLE\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach2 : DP Top Down - Accepted\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\\n\\n# Approach 3 : DP Bottom Up - Accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476546,
                "title": "python-simple-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191495,
                "title": "java-dp-talk-about-patience",
                "content": "Patience for manually doing the mapping :)\\n\\n```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317319,
                "title": "fully-commented-easy-dp-java-solution",
                "content": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```\\ndp[i][j] represents\\uFF1A<b>when there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have</b>\\nThus, we can use our graph to trace back to each of j\\'s (j is the current number) neighbors as we keep deducting steps number i.\\nThus the state transfer equation is defined as: \\n\\t<b>dp[i][j] += dp[i - 1][neighbor];</b>\\nFor example, if our current number is 0 and have 2 hops left, it would be <b>dp[2][0]</b>, \\nthen our dp array will try to get the value stored in <b>dp[1][4]</b> and <b>dp[1][6]</b>, which will both return 1. Then our  <b>dp[2][0]</b> will be store the value 2, which is equavalent to try out the number combination \"04\" and \"06\"",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189249,
                "title": "don-t-know-why-tle-by-python",
                "content": "       **It doesn't cost much time in my Jupyter**\n\t\t\t\t\n\t\t\t\tif N==0:\n            return None\n        if N==1:\n            return 10\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n\n        res=collections.Counter(num)\n\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n            for number in res:\n                for j in phone[number]:\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n\n        return(ans%(10**9+7))",
                "solutionTags": [],
                "code": "\t\t\t\tif N==0:\n        if N==1:\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n        res=collections.Counter(num)\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n        return(ans%(10**9+7))",
                "codeTag": "Unknown"
            },
            {
                "id": 1806575,
                "title": "easy-memoization-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893523,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The problem can be solved by matrix power. Similar problems are\\n[70. Climbing Stairs ](https://leetcode.com/problems/climbing-stairs/discuss/929659/Evolve-from-brute-force-to-optimal)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/discuss/989672/Evolve-from-intuition)\\n[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/discuss/650804/Evolve-from-brute-force-to-optimal).\\n1. Brute force O(3^n), may be larger than O(2^n) since 4 and 6 have three next states. The last array is the start locations\\n```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\\n2. Memoization O(n), mem[i][j] caches dfs(i,j). It means the number of ways starting at number j with i jumps to go.\\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\\n3. dp O(n) Time, O(n) Space. From #1 and #2, it is clear that dp[i][j] = sum(dp[i-1][k]), k=next[j].\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\\n4. dp O(n) Time, constant space. In #3, dp[i] is computed from dp[i-1] only, so we only need to cache two rows.\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\\n5. State transition O(logn). There are only 10 numbers/states. Similar as above, the next state look up matrix can be represented as a 10x10 binary matrix. The matrix is extended to 10x10 because I want to use matrix multiplication to solve the problem. The ith row is the next states of i. The ith column is the states that jumps to i. Current state s={s0,s1,..s9} 1x10 times the 10x10 matrix gives the next state 1x10 s\\'={s0\\',s1\\'..s9\\'}. An entry s[i] in state vector means the number of ways that end at i. When it multiplies the matrix, it extracts the ith row and update the 1s to s\\'. Ex, the knight starts from 0 and takes 1 jump. We multiply {1,0...0} with the transition matrix and get {0,0,0,0,1,0,1,0,0,0} which is the first row of the matrix. Sum the vector is the total number of ways to take 1 jump from 0. In general, \\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526276,
                "title": "java-use-dfs",
                "content": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456762,
                "title": "c-dp-easy-solution-with-explanation",
                "content": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289217,
                "title": "c-with-explanation-2-approaches-dp-and-memoization-o-n",
                "content": "*Idea for both Approaches (Memoization and DP)*\\nSay we have to find the number of possible combinations of length n starting from 0. Then this is the same as the sum of number of combinations of length n-1 from 4 +6 as from 0 , the knight can hop to 4 and 6. Create a vector of possible hops where the index represents soucre and the vector represents possible hops and apply this logic.\\nTime Complexity: O(10n)=O(n) for both Approaches\\nSpace Compelxity->O(10n)=O(n) for both Approaches\\n\\n**Approach-1** (Memoization)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach-2** (DP)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985146,
                "title": "using-recursion-top-down-dp-cpp",
                "content": "# Intuition\\nrecursive and dp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n```\\n// recursive code\\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\\n// top down dp\\n\\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1544986,
                "title": "python-simple-dp-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292870,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241911,
                "title": "js-dp-based-solution-o-n-with-explanation-78",
                "content": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705341,
                "title": "c-easy-solution-with-diagram",
                "content": "**Key Idea** : \\n\\nGiven you are at a position on the keypad, find all keys from where you can reach the current position. \\n\\nFor eg: 1 can be reached by a knight\\'s move from 8 and 6. Also, if you can get to 1 from 6, you can also get to 6 from 1. \\n\\n5 is a special case. It can not be reached from any key. There is no way to reach 5 other than starting out at 5.\\n\\nYou can then construct a undirected graph as below. \\n\\n![image](https://assets.leetcode.com/users/images/e5392c69-0e3d-4608-bd06-85fed7f56f34_1593109968.5285418.png)\\n\\n\\nOnce you have the adjaceny-graph, the following dp recurssion formula can be applied for all r from [1...N]: \\n```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\\n\\n**Optimization**:\\n\\nOnce you have the solution using the Nx10 matrix, you can collapse the Nx10 matrix to 2x10 matrix, since for evaluting a row \\'r\\' in the Nx10 matrix we use only values from row \\'r-1\\'. You can therefore then cyclically use the 2x10 matrix to evaluate all the rows in the Nx10 matrix.\\n\\n**Solution**: \\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313285,
                "title": "c-recursion-memoization",
                "content": "we just have to traverse dial pad one by one and at each num we use dfs to count the number.\\n**\"we don\\'t need to make matrix\"**\\n```\\nclass Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }\\n    int knightDialer(int n)\\n    {\\n       int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n       for(int i=0;i<4;i++)                                                       // dial Pad\\n           for(int j=0;j<3;j++)\\n               ans=(ans+solve(n,i,j))%mod;\\n        return ans;\\n    }\\n};\\n\\n// Feel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2171762,
                "title": "python-math-t-m-98-96",
                "content": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "codeTag": "Java"
            },
            {
                "id": 1594768,
                "title": "easy-recursion-solutinon-cpp-memoziation",
                "content": "**UPVOTE ME IF THIS IS HELPFULL AND COMMENT FOR DOUBTS \\nTHIS SIDE MOHIT.KOTA || HAPPY CODING TO ALL CODERS **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270845,
                "title": "python-o-logn-100-with-explanation",
                "content": "I used to ask this question for virtually every phone screen, so I\\'ve seen this done well over a hundred times at this point. I also know the absolute *best* solution for it and this is it.\\n- create a numpy matrix representing 1 move\\n- we subtract 1 from `n` because the the number of moves is the length of the string minus 1\\n- multiplying that move matrix by itself represents 2 moves\\n- doing that `n` times, represents `2**n` moves\\n- we initialize our answer as a `1x10` vector of ones (ie one move on each square)\\n- for each power of 2, if that power of 2 is in `n`, we add it to our answer\\n- then we create the next power of 2 by multiplying it by itself\\n- we also mod by `10**9 + 7` because the question says so\\n```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399690,
                "title": "10-lines-super-concise-java-solution-beat-98-in-speed-with-explanation",
                "content": "There is no need to do DP for each specific digit. Classifying them into different sets.\\n\\n```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338833,
                "title": "c-top-down-with-memo-o-n-easy",
                "content": "**Intuition:** Think of every number as a state (0 to 9). You can move from one state to another just like a knight moves on a chessboard. This information is enough to find the states you can go to from a given state. You can start from any state.\\n\\nI stored the state information in a 2D vector. Now, when I start on a state, I know exactly where all I can go with the help of the 2D vector. When I move from one state to another I reduce N by 1.\\n\\nSolve the question using recursion first. You\\'ll find your solution TLE before N = 16 or so.\\nDraw the recursion tree, you\\'ll find that it has overlapping subproblems, so memoize them.\\n\\nCODE:\\n\\n```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189232,
                "title": "python-o-n",
                "content": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856954,
                "title": "easy-implementation-using-recursion-and-memoization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358333,
                "title": "dp-solution-easy-to-undersatnd-recursion-memoization",
                "content": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285446,
                "title": "python-top-down-and-bottom-up-approach-following-intuition",
                "content": "# Approach\\nConsider all 8 positions knight can jump from current position in a grid of 4x3 in which all positions are valid except cell (3, 0) and (3, 2).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n**NOTE:** Above complexity has some contants also `3 * 4 * 8 = 96` so it\\'s actually `O(96*n)`\\n\\n# Code\\n## 1. Top down with memoization\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\\n\\n## 2. Bottom up\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761128,
                "title": "python-dp-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437317,
                "title": "c-easy-top-down-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}\\n\\t\\t\\tlong long int ans=0;\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tans+=(dp[i]%mod);\\n\\t\\t\\tans%=mod;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2287071,
                "title": "java-dynamic-programming-explanation-in-comments",
                "content": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[n+1][10];\\n        \\n        for(int i=0;i<10;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        \\n        int sum = 0;\\n        for(int i=2;i<n+1;i++){\\n            for(int j=0; j<10; j++){\\n                for(int k =0;k<paths[j].length;k++){\\n                    int y = paths[j][k];\\n                    dp[i][j] += dp[i-1][y];\\n\\t\\t\\t\\t\\t// if this gets too big we mod it per problem description\\n                    dp[i][j] = dp[i][j] % mod;\\n                }        \\n            }\\n        }\\n        \\n        for(int j=0;j<10;j++){\\n            sum+=dp[n][j];\\n\\t\\t\\t// if this gets too big we mod it per problem description\\n            sum = sum % mod;\\n        }\\n        return sum;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2241874,
                "title": "c-recursive-dp-solution-easy-to-understand",
                "content": "We simply recurse through all the possible scenarios, and store the reuslt in a dp array, so that we do not have to recalculate moves that we have already gone through. \\nFor example, \\nfor n = 3. We will consider all the numbers on the numberpad.\\nlets consider 2 paths - from number 0, and from number 3.\\nas we can see, in both the cases we will have to calculate the number of moves for n = 2 and number = 4. (since 3 and 0 both can lead to 4 by the horse). \\nthus to avoid recalculation, we will use the dp array. \\n```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2169422,
                "title": "java-dp-graph-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668711,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549261,
                "title": "python-simple-top-down-approach-recursion-with-memoization",
                "content": "1. Construct a matrix to represent a dialer.\\n2. Defined in valid cells for entry.\\n3. Create helper function to return valid jumps.\\n4. Iterate over the each cell and find the possible numbers and add them.\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031451,
                "title": "c-dfs-with-memoization-easiest-to-understand",
                "content": "Standard DFS + memo \\n```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809858,
                "title": "javascript-o-n-time-o-1-space",
                "content": "First solution:\\n```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\\n\\nOptimized for space:\\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766418,
                "title": "very-easy-to-understand-o-n-c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}, {6,8}, {7,9}, {4,8},\\n\\t\\t\\t\\t{3,9,0}, {}, {1,7,0},\\n\\t\\t\\t\\t{6,2}, {1,3}, {2,4},\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<int>> dp(N+1, vector<int>(10, 0));\\n\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t\\tdp[1][i] = 1;\\n\\n\\t\\t\\tfor(int i=2; i<=N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<10; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int x : paths[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j] + dp[i-1][x]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong res = 0;\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres = (res + dp[N][i]) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 764265,
                "title": "python3-6-line-116ms-solution-using-maths",
                "content": "OK, this is a very over-engineered solution, but I find it really interesting nonetheless.\\n\\nIf we look closely at the transition graph of our positions, we can notice that there are actually 4 distinct kinds of positions:\\n* Group 1: positions 8 and 2, which can only transition to group 2,\\n* Group 2: positions 1, 3, 7 and 9, which can either transition to group 1 or 3,\\n* Group 3: positions 4 and 6, which can either transition to group 2 or 4,\\n* Group 4: position 0, which can only transition to group 3.\\n\\nLet me draw a graph of the transitions to make that more clear:\\n\\n```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\\n\\nNow, if we call `a_k`, `b_k`, `c_k`, `d_k` the number of numbers ending in each of our four groups after k jumps, we can write the recursive relation between our values:\\n\\n* `a_(k+1) = b_k`: each knight in group 2 has one way to move at jump k + 1 to a position in group 1,\\n* `b_(k+1) = 2 * (a_k + c_k)`: each knight in group 1 has two ways to move to group 2; similarly, each knight in group 3 has two ways to move to group 2; therefore, we must count twice the numbers from both groups,\\n* `c_(k+1) = b_k + 2 * d_k`: each knight in group 2 has one way to move to a position in group 3, and each knight in group 4 has two ways to move to a position in group 3,\\n* `d_(k+1) = c_k`: each knight in group 3 has one way to move to a position in group 4.\\n\\nThis lets us write a concise recursion formula. We simply have to apply the recursion `N - 1` times from the initial state.\\n\\nThe complexity is the same as the optimized dynamic programming solution, `O(n)` time `O(1)` space.\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "solutionTags": [],
                "code": "```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343847,
                "title": "easy-peasy-python-o-n-solution",
                "content": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "solutionTags": [],
                "code": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "codeTag": "Unknown"
            },
            {
                "id": 189244,
                "title": "straightforward-dp-java",
                "content": "The count of values that can be generated from a given starting position with **N hops** == Sum of the counts of hops that can be generated starting from each of its neighbors with **N-1 hops.** \n\n```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744139,
                "title": "java-dp-w-explanation-solution-easier-to-read",
                "content": "# Intuition\\nLet\\'s think about this problem w/o DP first:\\nLet\\'s say we start off on the \\'1\\' button first and N=5. I can either reach 6 or 8. If i go to \\'6\\' after wards i have n=5 more jumps i can do. If i go to \\'8\\' i also have n=5 more different moves i can do. We want to check both of them\\n\\nDP:\\nThe unique combinations in our DP array we can have is based on how many moves we have left (n) and which number we\\'re currently at. \\nFor example, if on one iteration i have 4 moves left and i\\'m at number \\'0\\', the next time on a differet iteration I happen to have 4 moves left and i\\'m also at \\'0\\' we don\\'t need to recompute from here. We just pull up dp[n][0]\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711116,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658072,
                "title": "constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nJust for a second think about various positions on the dialpad and how they can be reached.\\n\\n# Approach\\nNow that you must have got an idea that every key on the dialpad can only be reached by certain keys. For example, the key 1 can only be reached by keys 8 and 6 and NONE other. Now that we know that, we can think that at every stage if we press the current button, the previous state must have had one of the possible path keys (in case of 1 - 8 and 6). Now this looks like a good problem for DP but, notice that we only need the last state of dialpad, hence can be done in constant space. \\nSo first initialise the curr vector, with 10 keys. If n=1, number of buttons pressed = 1. Initialise next vector same as current. Now at every next step ranging from 2 to n, we see that if the current button was x, what are the ways to reach x. For example x is 1, so the number of ways to reach 1 in next state is when current state is at 8 or 6. Following this logic, count the next state for every number on the dialpad. At last of iteration, assign curr to next, as this will become our current state for the next step. \\nAt last just add all the number of ways to each each key on the dialpad.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404843,
                "title": "python3-clean-top-down-dp-solution-with-lru-cache",
                "content": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338188,
                "title": "easy-understanding-c-solution-o-n-tc-and-o-1-sc-using-math",
                "content": "### **Thinking:**\\n* Let\\'s part the numbers as follow:\\n* a{2,8} b{1,3,7,9} c{4,6} d{0} e{5}\\n* for n>1 there would no phone_numbers ending with 5 (not possible).\\n* For any new digit of group a, previous digit should be ending with group b.\\n\\t* Also notice that for each number, there can be only two previous numbers, both from group b.\\n\\t* i.e. for let say 2, previous digit should be either 7 or 9.\\n* For any new digit of group b, previous digit should be ending with group a or c.\\n\\t* Also notice that for each number, there can be only two previous numbers, that too one from group a, another from group c.\\n\\t* i.e. for let say 1, previous digit should be either 8 or 6.\\n*  For any new digit of group c, previous digit should be ending with group b or d.\\n\\t* Also notice that for each number, there can be only three previous numbers, that too two from group b, another from group d.\\n\\t* i.e. for let say 4, previous digit should be 3 or 9 or 0.\\n* For any new digit of group d, previous digit should be ending with group c.\\n\\t* Also notice that for each number, there can be only two previous number, both from group c.\\n\\t* i.e. for 0, previous digit should be either 4 or 6.\\n\\nLet\\'s store number of phone_numbers ending with the digit of certain group as variable a, b, c, d.\\nLet\\'s update the value for each increment of n.\\nFinally after n operations, We have the number of unique phone_numbers ending with certain group. So just multiplying those with the number of element of each group, we can find the total number of unique phone_numbers.\\n\\t\\n### **Code:**\\n```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Comment For any Explanation, Upvote if you like it...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336836,
                "title": "dfs-brute-force-with-memoization",
                "content": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268842,
                "title": "o-n-time-complexity",
                "content": "possible moves for each number\\n0 -> 4,6\\n1 -> 8,6\\n2 -> 9,7\\n3 -> 4,8\\n4 -> 3,9,0\\n5 -> -\\n6 -> 1,7,0\\n7 -> 6,2\\n8 -> 1,3\\n9 -> 4,2\\n\\ninitially for n=1\\nwe can dial any no. but for n more than 2 we have to make combinations of moves associated to that number\\na=current row, b=prev row\\n```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194403,
                "title": "java-bottom-up-dp-explained-with-thinking-process",
                "content": "Given a Numeric Keypad where we can type a Number in a Knights Move, we need to calculate different number combinations of a given Length.\\nWe need some crucial Information before Proceeding ahead.\\n\\n```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\\nFor every length, the Knight has multiple options to move from the Current Numeric Button to other Numeric Button. For every length we have 10 buttons to press. Let\\'s take a look on the Combinations:\\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\\n\\n\\nTo Simulate the Above process, we will run 2 For loops:\\n1. First for every n Length Combination that we can get.\\n2. Then for every Numeric Keypad Button from 0 to 9.\\n\\nWe would depend on the values for the Previous length Combinations that can be made. The further is explained below in the Code.\\n\\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124467,
                "title": "javascript-simple-and-clean-o-n-o-1",
                "content": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969250,
                "title": "c-recursive-and-memoization-dp-simple-and-easy",
                "content": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```\\n### if you like it upvote it",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923343,
                "title": "python3-dp-top-down",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892977,
                "title": "python-dp-bottom-up",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858519,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767477,
                "title": "golang-o-n-time-o-1-mem-simple-dp",
                "content": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578340,
                "title": "python-dp",
                "content": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "solutionTags": [],
                "code": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "codeTag": "Python3"
            },
            {
                "id": 1542218,
                "title": "easy-to-understand-with-explanation-java",
                "content": "There are TEN total trees, with each 0, 1, 2 ... 9 being root nodes.\\nThe final answer, is just the sum of count of leaf nodes formed, with each 0, 1, 2, ... 9 as roots.\\n\\nNow, what does each tree look like?\\n\\nIts simple:\\nFor every root, there is a finite number of leaf nodes that one can reach. \\nFor instance: \\n* \\tWith 0 as the root node, it can reach nodes 4 and 6 ( children )\\n\\t* \\tFirst child, node 4, can form links with nodes 0, 9, 3 \\n\\t* \\tSecond child, node 6, can form links with nodes 0, 1, 7\\n\\t\\n\\tThis continues till level n.\\n\\tCount the number of leaf nodes, add it to a sum variable.\\n\\t\\nWith one particular exception, which is node with root as 5. No one can reach node 5, nor can node 5 form any children.\\n\\nBruteforce would obviously timeout, because it involves recursively traversing all branches, more than once.\\n\\nA simple straight forward solution, would be to count the number of parents, that a node can have, which eventually contributes to the number of pathways from the root node.\\n\\nFor n = 1, there are no parents. So the base case, is the number of root nodes themselves, i.e 10.\\nFor n = 2:\\n\\tNode 0 can be a parent of 4 and 6,\\n\\tNode 1 can be a parent of 6 and 8 \\n\\t...\\n\\t...\\n\\tSo the final parent counts of each node for n = 2 will be:\\n\\tFor node 0 => 2 possible parents;\\n\\t\\t  node 1 => 2 possible parents;\\n\\t\\t\\t\\t   2 => 2 possible parents; \\n\\t\\t\\t\\t   3 => 2 possible parents; \\n\\t\\t\\t\\t   4 => 3 possible parents;\\n\\t\\t\\t\\t   5 => 0 possible parents;\\n\\t\\t\\t\\t   6 => 3 possible parents;\\n\\t\\t\\t\\t   7 => 2 possible parents;\\n\\t\\t\\t\\t   8 => 2 possible parents; \\n\\t\\t\\t\\t   9 => 2 possible parents;\\n\\t\\t\\t\\t   \\nTotal parent count for all nodes from 0 to 9 is = 20 ( which is the expected answer );\\n\\nBelow is the code, where branches array indicate parent to child links, branch[0] is  parent, branch[1] is the child.\\n\\nFinal Solution:\\n```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503880,
                "title": "python-o-log-n-solution-beats-100-with-fast-power",
                "content": "* By symmetry, when n >= 2 there are only four states s0: [1, 3, 7, 9], s1: [2, 8], s2: [4, 6], s3: [0]\\n* The transform is linear, thus, we are able to use the fast power of matrix to solve it\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443294,
                "title": "java-solution-top-down-dp",
                "content": "\\tclass Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6});\\n        map.put(1, new int[]{8,6});\\n        map.put(2, new int[]{7,9});\\n        map.put(3, new int[]{4,8});\\n        map.put(4, new int[]{0,9,3});\\n        map.put(6, new int[]{7,0,1});\\n        map.put(7, new int[]{2,6});\\n        map.put(8, new int[]{1,3});\\n        map.put(9, new int[]{2,4});\\n        \\n        Map<String,Integer> memoization = new HashMap<String,Integer>();\\n        int ans = 0;\\n        for(int i = 0; i <= 9; i++)\\n        {\\n            ans = (ans + dfs(map, i, n, memoization))%mod;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int dfs(Map<Integer, int[]> map, int src, int n, Map<String,Integer> memoization)\\n    {\\n        if(n == 1)\\n        {\\n            return 1;\\n        }\\n        \\n        String key = src + \" \"+ n;\\n        if(memoization.containsKey(key))\\n        {\\n            return memoization.get(key);\\n        }\\n        \\n        int localAns = 0;\\n        if(map.containsKey(src))\\n        {\\n            for(int target : map.get(src))\\n            {\\n                localAns = (localAns + dfs(map, target, n-1, memoization))%mod;\\n            }\\n        }\\n        \\n        memoization.put(key, localAns);\\n        return memoization.get(key);\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 1419970,
                "title": "java-o-1-space-dp",
                "content": "\\n```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1318678,
                "title": "java-dp-and-recursive-solution",
                "content": "Java DP\\n```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\\n\\tJava recursive\\n\\t```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\n```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198572,
                "title": "faster-than-90-both-recursive-memo-dp-and-table-iterative-dp-solution",
                "content": "**Recursive+Memo Dp-Solution:**\\njava code is:\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\\n\\n**Table-Dp(Iterative) Solution:**\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166451,
                "title": "vanilla-growing-dp",
                "content": "The idea is to grow from N=1;\\nWe create a dp array, this dp array stores all the possible combinations starting from the corresponding digit.\\nWe have 2 arrays, of new values of and old values. After every iteration the old values have to be updated as the new values. Let\\'s call our old array t1 and new array t2, based on the L paded phone. We can make the following recurrence relations for numbers starting with each digit.\\nt1 is the old array and t2 is the new array.\\nt2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\nSo for N=1 the array looks like this\\n# [1 1 1 1 1 1 1 1 1 1]\\nfor N=2 the possible combinations are;\\n{04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94} and the array looks like this\\n # [2 2 2 2 3 0 3 2 2 2]\\n For N=3, this is what the array looks like\\n # [6 5 4 4 6 0 6 5 4 5]\\n \\n\\n\\n**Here\\'s the code**\\n\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141532,
                "title": "python-o-n-o-logn-beat-98",
                "content": "Python - O(n):\\n\\nDP[i, num]: the total ways of forming a string (length i) with last element (num)\\ncurrent ways [last element \\'num\\'] = previous ways which can jump on \\'num\\'\\nFor example, DP[i, 2] = DP[i-1, 7] + DP[i-1, 9]\\n\\nVectorize this idea: DP[i, :] = DP[i-1, :] * matrixA\\nmatrixA is a 10 x 10 matrix, which represents the rule of chess knight jump.\\n\\nSo final results, DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\n\\n\\nHowever, 10 x 10 matrix is still huge. We can further simplify this.\\nBased on the knight jump rule, we can divide [0,1,2,3,4,6,7,8,9] (no 5 since no number can jump on 5)\\ninto 4 types: C (corner, 1, 3, 7, 9), E0 (Edge0, 4, 6, i.e. edge can jump to 0), E1 (Edge1, 2, 8), O (0)\\n\\nThe jump rule is:\\n1C   -> 1E0 + 1E1\\n1E0 -> 2C + 1O\\n1E1 -> 2C\\n1O  -> 2E0\\n\\nSo, if DP[i,:] = [numC, numE0, numE1, numO],\\nthen matrixA = [[ 0 1 1 0]\\n                          [ 2 0 0 1]\\n                          [ 2 0 0 0]\\n                          [ 0 2 0 0]]\\n\\nThis can be simplified as 4 x 4 matrix multiplication.\\nDP[i, :] = DP[i-1, :] * matrixA\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\\n\\nIn short:\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\\n\\n\\n\\n\\nImprovement:\\n\\nDP[i, :] = DP[i-1, :] * matrixA <==> DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\nThe problem is to calculate matrixB = matrixA ** (n-1)\\nwhich is O(logn) if we use divide and conqur in \\'Power (x, n)\\' problem\\n\\nPython - O(logn) :\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```\\n\\nThe O(N) method takes around 140-170 ms, 95% in Python.\\nHowever, due to the time complex of matrix multiplication, the final time for O(logN) is around 100 ms, 98% in Python.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087365,
                "title": "python-top-down-hard-coding",
                "content": "Inspired by the solution on [https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!](http://) \\n[top rated top down solution](https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!) This solution is so generalized and not taking any advantage of only 10 numbers.\\nThe rule has known, so we could create a variable called \"paths\" to hard code all the possibilities.\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007506,
                "title": "easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929183,
                "title": "dp-memoization-approach-o-n-easy-to-understand-short-code",
                "content": "## Explanation\\n\\nFirst we need to realize what are **DP** depends on. It\\'s pretty clear that the length of the number **n** is one such parameter, the other one is our **Starting Point** say if we have n = 2\\nand we start from digit 1 then :\\n``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\\n**Hence we need to add answer for all possible starting points and get our answer**\\n\\n\\n# Code\\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796049,
                "title": "very-easy-c-solution-with-detailed-comments",
                "content": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 751674,
                "title": "swift-dfs-memo-dp",
                "content": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693989,
                "title": "easy-java-top-down-iterative-approach-with-diagram",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nExample: \\nIf N=3, then the answer is the sum of elements from dp[N][0]...+dp[N][9]\\n\\n![image](https://assets.leetcode.com/users/alphakiller/image_1592499072.png)\\n\\nTime Complexity: O(N). Derived from O(N * dial * keyNum) = Dial is a constant & has a value of 10. KeyNum is also a constant with value either 2 or 3.\\nSpace Complexity: O(N*dial)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522714,
                "title": "c-dp-16ms-8-6mb-beat-100",
                "content": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426205,
                "title": "simple-c-dp-solution",
                "content": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375123,
                "title": "python-level-traversal",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332177,
                "title": "recursive-solution-cpp-this-is-more-reasonable-to-come-up-with-instead-of-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306446,
                "title": "python-4-line-solution",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 303437,
                "title": "straightforward-python-memoization",
                "content": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\\n\\nOr if you\\'d rather use a generic memoization decorator:\\n\\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294494,
                "title": "c-dynamic-programming-o-n-time-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274043,
                "title": "python-rolling-dp",
                "content": "We can count number of ways to dial with K moves based on that with K-1 moves.\\nE.g. If our last dial number (Kth move) if 1, the K-1th move is either 4 or 6 based on Knight moving rule. So number of ways to reach 1 at Kth move is number of ways to reach 4 or 6at Kth move. Or ```dp[K][1] = dp[K-1][4] + dp[K-1][6]```. Based on that, we can have our recurrence equation.\\nAnd the only array we used to calculate dp[K] is dp[K-1], we can use two rolling arrays here to reduce space compleixty to O(1).\\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[K][1] = dp[K-1][4] + dp[K-1][6]```\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261616,
                "title": "java-backtrack",
                "content": "Runtime : O(10 * N)\\nSpace: O(10 * N)\\n\\n```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241756,
                "title": "python-dp-solution",
                "content": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205506,
                "title": "c-13line",
                "content": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 190620,
                "title": "c-o-logn-time-o-1-space-complexity",
                "content": "If you represent the digits as nodes in a graph and create their adjacency matrix, you can raise the matrix to the (N - 1)th power to get a new adjacency matrix, the values of which now mean the number of different paths from node `i` to node `j` after (N - 1) moves. Using this in combination with the fast power for matrices allows you to do this all in O(logN).\\n\\nI\\'ve left my output of the resulting matrix there so that you can easily see it if you want to.\\n\\nI\\'ve already seen this solution here, but it was written in Python so I decided to share mine too.\\n\\n```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 189237,
                "title": "java-solution",
                "content": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069244,
                "title": "dp-both-approaches",
                "content": "# Recursive and Memoized Version (kinda noob one) \\n# Code\\n```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```  \\n\\n# Tabulation\\nThink like a function f(n, d) where n is the input and d is a numner from 0 to 9 basically if i need \\nf(n, 1) = f(n-1, 6) + f(n-1, 4) \\nthese are 2 possible ways that could get me to one \\n\\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960054,
                "title": "best-solution-for-beginners-easily-explained",
                "content": "# Complexity\\n- Time complexity: $$O(10*8*n)$$ = O(n) \\n\\n- Space complexity: $$O(10*n)$$ = O(n)\\n\\n# Code\\n```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927716,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598919,
                "title": "python-solution-taking-each-possible-case-into-consideration-recursive-forumla-dp",
                "content": "Each number has only certain numbers Knight can move from\\nEg. From 1, Knight can move to 8 or 6 Similarly, we can map for all the numbers\\n\\nNow we can specify a recursive formula\\ndp[start, len]: Mentions the possibilities of len length phone numbers starting from start\\nfor all numbers in mapping[start]\\ndp[start, len] = sum(dp[num, len-1])\\n\\nNow, if we are at a number, the next move can be to any of the numbers it can go to\\n# Code\\n```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521767,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\\n\\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404090,
                "title": "hashmap-dp-c",
                "content": "# Code\\n```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387861,
                "title": "simple-and-easy-to-understand-approach-using-concept-of-dfs-and-memoization-clean-and-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimilar to problem [688. Knight Probability in Chessboard\\n](https://leetcode.com/problems/knight-probability-in-chessboard/\\n)\\nJust modified the constraints and base case\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(4x3xN)=O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362170,
                "title": "100-working-solution-in-java-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2};\\n    int[] dy= {1,2,2,1,-1,-2,-2,-1};\\n    int[][][] dp= new int[5][4][5002];\\n    \\n    public int knightDialer(int n) {\\n        int[][] nums= new int[4][3];\\n        nums[3][1]= 0;\\n        nums[3][0]= -1;\\n        nums[3][2]= -1;\\n        int x=1;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                nums[i][j]=x;\\n                x++;\\n            }\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            for(int j=0; j<4; j++){\\n                for(int k=0; k<5002; k++){\\n                    dp[i][j][k]= -1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(nums[i][j]!=-1){\\n                    ans= (ans+solve(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int[][] nums, int i, int j, int n){\\n        if(i<0 || j<0 || i>=4 || j>=3 || nums[i][j]==-1){\\n            return 0;\\n        }\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        \\n        if(dp[i][j][n]!=-1){\\n            return dp[i][j][n];\\n        }\\n        \\n        int t=0;\\n        for(int k=0; k<8; k++){\\n            int x= i+dx[k];\\n            int y= j+dy[k];\\n            \\n            t= (t+solve(nums,x,y,n-1))%mod;\\n        }\\n        \\n        return dp[i][j][n] = (t%mod);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2}",
                "codeTag": "Java"
            },
            {
                "id": 3040767,
                "title": "python-concise-dynamic-programming-bottom-up",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObserve that, moving as a knight, you can only reach certain keys from certain others (we exclude `*` and `#` as they are not part of valid numbers)\\n\\nThus, the number of ways to reach a certain square is simply the sum of ways to reach each previous square that can lead to it. This screams dynamic programming!\\n \\n\\n# Code\\n```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```\\n\\n# Optimization\\nWe make the code run a bit faster by taking advantage of mathematical property `( x + y ) % z == ( x % z + y % z ) % z` to make the intermediate numbers smaller. \\n\\nWe could make the code significantly faster by using a 2d array rather than updating it, but that would balloon the space complexity.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904752,
                "title": "java-solution-easy-and-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730909,
                "title": "c-dfs-recursion-memoization",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/7556f7f2-d573-40a0-b5a1-43b70eb0d6f2_1666409793.871762.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method -2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/a669d023-8e91-4f93-af77-84df93d8d6ea_1666409807.1825833.png)\\n\\n**T->O(12 * n) && S->O(12 * n) && O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n,vector<vector<vector<int>>>& dp){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tif(dp[i][j][n]!=-1) return dp[i][j][n];\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j][n]=ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tvector<vector<vector<int>>> dp(4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1,dp)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2608668,
                "title": "935",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}\\n\\t\\t\\tdp = [1]*10\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tfor _ in range(n-1):\\n\\t\\t\\t\\tnewdp = [0]*10\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tfor j in jumps[i]:\\n\\t\\t\\t\\t\\t\\tnewdp[i] += dp[j]\\n\\t\\t\\t\\t\\t\\tnewdp[i] %= mod\\n\\t\\t\\t\\tdp = newdp\\n\\n\\t\\t\\treturn sum(dp)%mod",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}",
                "codeTag": "Java"
            },
            {
                "id": 2569606,
                "title": "java-completely-explained-tabulation-efficient",
                "content": "```\\nclass Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}, {6,8}, {7,9},{4,8},{3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};\\n    public int knightDialer(int n) {\\n        \\n        /*\\n           we decide that in the beggining all the actions and movements by the knight has been completed and for each \\n           cell we check from which positions it has come like for eg. to come to zero we can arrive from 4 and 6 and so on and\\n           we traverse back to initial positions with each increasing n.\\n        */\\n        \\n        int [][] dp =new int[n+1][10];\\n        \\n        // first row is filled with zeroes and second row is filled with ones \\n        // cause we have to move n-1 times\\n        for(int j=0;j<dp[0].length;j++)\\n        {\\n            dp[1][j]=1;\\n        }\\n        \\n        for(int i=2;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                 for(int cell :cells[j])\\n                 {\\n                     dp[i][j] = (dp[i][j] +dp[i-1][cell]) % 1000000007;\\n                 }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int k=0;k<dp[0].length;k++)\\n        {\\n            res= (res + dp[n][k])  % 1000000007;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2547327,
                "title": "python3-dp-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "codeTag": "Java"
            },
            {
                "id": 2453739,
                "title": "c-dp-tabulation-method-tc-o-n-sc-o-1",
                "content": "* Using constant extra space of number of numeric digits in the keypad ,i.e, 10.\\n* Time Complexity is O(n*number_of_numeric_digits).\\n* Upvote if you like the solution.\\n```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422753,
                "title": "python-different-solution-with-thorough-explanation",
                "content": "# Method One: Smart\\nWe have `x0` through `x9` for each of the digits on the number pad that represent the amount of possible phone numbers that it can dial (we continuously update it as we move iterations).\\n\\nThe intuition is that we iterate through `n-1` times and each time we update `x0` through `x9` to be the sum of the total possible paths that they can do. \\n\\nFor example, from `x1` the knight can jump to `x6` or `x8`, so we update `x1` to be the sum of `x6` and `x8`. After that, the amount of total combinations will be the sum of the total combinations of each pad. Of course, we handle the mod.\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\\n\\t\\n# Method 2: Recursion with Memo\\nWe use recursion with memorization here to avoid the nasty TLE errors.\\nThe intuition is the same as method 1, but implemented a bit differently. \\n\\nWe map each cell to the possible paths it could take the the next ceoo. I used `-1` as the pad before the knight is on the number pad, since the knight can start at any cell. We use a helper function to recurse and get the count of total possible paths. \\n\\nWe pass our paths dictionary, `n` as the index (amount of digits dialed), `-1` as the starting cell, but `curr` will eventually be the current cell, and our cache (initialized to `{}`). \\n\\nInside the helper function:\\n1. check if current index + path are already saved: if yes, just return it (that\\'s literally the entire point of caching and memo)\\n2. if the index is 0 (we haven\\'t even started yet), we can only dial 1 number: the number we are on right now\\n\\nNow the real stuff is starting:\\n3. initialize count to be total amount of paths\\n4. for every possible path from this current cell,\\n5. we recurse the previous index and add that to our count\\n6. save it to the cache\\n7. the helper function returns an integer `count`: the total number of paths from `curr` at index `n`. \\n\\nNote: the initial call for the helper function has parameter `idx` of `n`, not `n-1` since we start from the dummy pad -1. \\n\\nAnd we return the function return mod 10^9 + 7.\\n\\nRecursion expansion:\\n[![image](https://assets.leetcode.com/users/images/3c66d256-869d-4146-85ae-6a10b5addbfa_1660512488.936091.png)\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396607,
                "title": "java-recursion-memoization-easy-solution",
                "content": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392430,
                "title": "c-wrong-what-s-wrong",
                "content": "```\\n\\nGetting wrong answer what i missing anyone ?????\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }\\n        return (one+two+three+four+five+six+seven+eight+nine+zero+star+hash)%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2369123,
                "title": "java-dp-o-1-space-o-n-time",
                "content": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363389,
                "title": "python-matrix-multiplication-solution",
                "content": "Start with identity matrix and multiply by M^2i at the relevant bits!\\nI mistook the bit breakdown (addition) and forgot it\\'s actually in the power when solving the problem\\nWe just keep multiplying till the end, and finally sum all the elements up\\n\\nSimilar problem: [Leetcode 552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/)\\n\\nThat one is little harder to arrive at the state transitions though\\n```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308692,
                "title": "o-logn-solution",
                "content": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267066,
                "title": "70-86-faster-pyhton-dynamic-programming-tabulation-d-p",
                "content": "If you think you are weak in Dynamic Programming please watch the Dynamic playlist by Striver on youtube the link is given below .It helped me a lot.\\n[https://www.youtube.com/watch?v=FfXoiwwnxFw&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY](http://)\\nThe dpTab is the ap array keeps the track of the previous iteration with all the numbers excluding 5 as 5 can never be obtained n>=2 .\\nThe code for the same is given below .\\nI will request you all to understand the recursive code first then move on to Tabulated one .\\n\\n\\n**RECURSIVE CODE:---(WILL GIVE TLE)**\\n```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\\n\\n\\n\\n**TABULATED CODE (ACCEPTED!)**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247460,
                "title": "easy-java-solution-dp",
                "content": "**Please upvote if you like the solution, Happy learning!**\\n**Explanation:**\\n1. First fill the map with possible positions knight can move from every number from `0 - 9`\\n2. Since now you know from every position, where is the next step, start running  a path finder from `0-9`\\n\\n```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238560,
                "title": "python-dp",
                "content": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "solutionTags": [],
                "code": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2206866,
                "title": "very-simple-dp-approach",
                "content": "\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n             if(key==2){\\n              return  dp[key][n]= (func(7,n-1)%M+ func(9,n-1)%M)%M;\\n          }\\n             if(key==3){\\n              return  dp[key][n]= (func(8,n-1)%M+ func(4,n-1)%M)%M;\\n          }\\n             if(key==4){\\n              return  dp[key][n]= (func(3,n-1)%M+ func(9,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==5){\\n              return  dp[key][n]= 0;\\n          }\\n             if(key==6){\\n              return  dp[key][n]= (func(1,n-1)%M+ func(7,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==7){\\n              return   dp[key][n]=( func(2,n-1)%M + func(6,n-1)%M )%M;\\n          }\\n             if(key==8){ \\n              return  dp[key][n]= (func(1,n-1)%M+ func(3,n-1)%M)%M;\\n          }\\n             if(key==9){\\n              return  dp[key][n]= (func(4,n-1)%M+ func(2,n-1)%M)%M;\\n          }\\n           if(key==0){\\n              return   dp[key][n]=(func(4,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n          return 0;\\n      }\\n    int knightDialer(int n) {\\n         int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=9;i++){\\n             ans= (ans%M+func(i,n)%M)%M;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2172077,
                "title": "python-dp-clean-code",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141399,
                "title": "java-solution-2d-dp-memoization",
                "content": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136453,
                "title": "python-somewhat-ok-solution",
                "content": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118758,
                "title": "c-easy-and-concise-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056965,
                "title": "memoized-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052655,
                "title": "dp-c",
                "content": "```\\n// dp[i][j][k]=count of i digits no\\'s that can be formed if start moving from from (j,k)\\n//from (i,j) we have 8 choices to move as per the move of knight\\n\\n#define lln long long int\\nlln mod=1e9+7;\\n\\nint dx[8]={2,2,-2,-2,1,1,-1,-1};\\nint dy[8]={1,-1,1,-1,2,-2,2,-2};\\n\\nlln dp[5001][4][4]; \\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }\\n        }\\n        \\n        return ans%mod;\\n    }\\n    \\n    lln find(int i,int j,int len,int n){\\n    \\n        if(len==n){\\n            return 1;\\n        }\\n        \\n        if(dp[len][i][j]!=-1)\\n            return dp[len][i][j];\\n        \\n        lln count=0;\\n        \\n        for(int x=0;x<8;x++){\\n            int i1=i+dx[x];\\n            int j1=j+dy[x];\\n            \\n         if((i1==3 && j1==0) || (i1==3 && j1==2))\\n             continue;\\n    \\n        if(i1>=4 || i1<0 || j1>=3 || j1<0)\\n            continue;\\n                \\n         count=(count%mod+find(i1,j1,len+1,n)%mod)%mod;\\n\\n        }\\n        \\n        return dp[len][i][j]=count%mod;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2030753,
                "title": "java-dp-memoization-solution",
                "content": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997235,
                "title": "java-dp-memoization-intuitive-approach",
                "content": "The idea is to find the repeatitive subproblems with optimal substructure property. \\nHere we can see that all the states when which have \\'1\\' (or any other digit) in previous position will not be same. (1_ and 1 _ _  are not same subproblems, as these two states have different answers).\\nSo what our subproblem will be?\\nCan we say that whenever our previous position =1 (for example) and if the number of remaining digits are same, then these 2 will be same subproblems.\\nex - 231_ _ and 51_ _ => are same states, as now onward both will produce same answer, since both have 2 digits remaining and for both states last filled digit is same.\\nThus in our dp solution, we will be be caching previous digit and number of remaining digits as one state. \\n\\nclass Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    // dp states - prev, n-pos+1          \\n\\t// prev - digit present at previous position. \\n\\t// n-pos+1 - number of left positions to be filled\\n\\t// (pos: current position to be filled; n: lenght of phone number)\\n    \\n    private int dfs(Map<Integer,List<Integer>> adjMap, int prev, int pos, int n, int dp[][]){\\n        \\n        if(pos == n+1)                      \\n            return 1;                \\n        \\n        if(dp[prev][n-pos+1]!=-1)   return dp[prev][n-pos+1];\\n        \\n        int t=0;\\n        for(int child: adjMap.get(prev)){\\n            t += dfs(adjMap, child, pos+1, n, dp);  \\n            t=t%mod;\\n        }\\n        \\n        return dp[prev][n-pos+1] = t;\\n    }\\n    \\n    private void getAdjMap(Map<Integer,List<Integer>> map){\\n        for(int i=0;i<=9;i++)\\n            map.put(i, new ArrayList<>());\\n        \\n        map.put(0, List.of(4,6));\\n        map.put(1, List.of(6,8));\\n        map.put(2, List.of(7,9));\\n        map.put(3, List.of(4,8));\\n        map.put(4, List.of(0,3,9));\\n        map.put(6, List.of(0,1,7));\\n        map.put(7, List.of(2,6));\\n        map.put(8, List.of(1,3));\\n        map.put(9, List.of(2,4));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978970,
                "title": "simple-recursive-dp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f605fb70-db83-41d3-bbb2-902297aa2039_1650817004.5904217.png)\\n```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967691,
                "title": "c-60-fast-solution-top-down-dp-very-easy-approach",
                "content": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894969,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};\\n    vector<vector<vector<int>>>memo;\\n    int findAns(int r,int c,int n){\\n        if(r<0 or r>3 or c<0 or c>2 or (r==3 and c==2) or (r==3 and c==0)){\\n            return 0;\\n        } else if(n==0){\\n            return 1;\\n        } else if(memo[r][c][n]!=-1){\\n            return memo[r][c][n];\\n        } else {\\n            int ans=0;\\n            for(int i=0;i<8;i++){\\n                int nr=r+moves[i][0];\\n                int nc=c+moves[i][1];\\n                if(nr<0 or nc<0 or nr>3 or nc>2 or (nr==3 and (nc==0 or nc==2))){\\n                    continue;\\n                } else {\\n                    ans=(ans%mod+findAns(nr,nc,n-1)%mod)%mod;\\n                }\\n            }\\n            return memo[r][c][n]=ans%mod;\\n        }\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                ans=(ans%mod+findAns(i,j,n-1)%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1857693,
                "title": "c-recursion-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }\\n        return dp[num][n] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n          map<int, vector<int>> v;\\n    v[1] = {6,8},v[2] = {7,9}, v[3] = {4,8}, v[4] = {0,3,9}, v[5] = {}, v[6] = {0,1,7}, v[7] = {2,6}, v[8] = {1,3}, v[9] = {2,4}, v[0] = {4,6};\\n         memset(dp, -1, sizeof(dp));\\n         int ans = 0;\\n         for(int i=0; i<=9; i++){\\n             ans = (ans + solve(i,n, v)) % mod;\\n         }\\n        \\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1847842,
                "title": "javascript-top-down-recursive-memoization-explanation",
                "content": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821648,
                "title": "c-3d-dp",
                "content": "Hopefully it helps average peeps like me get some intuition.\\n```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794663,
                "title": "java-easy-clean-and-detailed-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773547,
                "title": "c-ez-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```\\nif this help, pls upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772664,
                "title": "c-sol-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity -: O(n x 4 x 3) = O(n);",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723487,
                "title": "python3-bottom-up-approach-dp",
                "content": "**consider after ith jump we reach digit 1 , then on (i-1)th jump we will be at either 6 or 8\\nso dp relation becomes dp[i][1]=dp[i-1][6]+dp[i-1][8]. Similar for every number .**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701719,
                "title": "c-solution-dynamic-programming-recursive-bottom-up",
                "content": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "codeTag": "Unknown"
            },
            {
                "id": 1671885,
                "title": "python-top-down-dynamic-programming-time-out",
                "content": "Could someone explain why this is getting time-out errors?\\n\\nI\\'ve used top-down DP (recursion + memoization) and it\\'s still timing out:\\n\\n```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662475,
                "title": "python-2-ways-dfs-cache-dp",
                "content": "Solution1 : DFS + Memo\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\\n\\nThink about when standing at number x, length=n , path(n) += each path(mapping(n-1)) , so if we solve all length=n-1 case for all numbers (0-9), can get number x when length=n , formular :\\ndp[n][x] += dp[n-1][mapping[n]] \\nso we could start with solving n=1 case, then n=2 , ... until n=n \\nSolution2 : DP\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661330,
                "title": "java-2ms-dp",
                "content": "`static` memo is the key.\\n\\n```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641780,
                "title": "c-o-n-time-o-1-space-0-ms-5-8-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612327,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6});\\n        moves.put(1, new int[]{6, 8});\\n        moves.put(2, new int[]{7, 9});\\n        moves.put(3, new int[]{4, 8});\\n        moves.put(4, new int[]{0, 3, 9});\\n        moves.put(5, new int[]{});\\n        moves.put(6, new int[]{0, 1, 7});\\n        moves.put(7, new int[]{2, 6});\\n        moves.put(8, new int[]{1, 3});\\n        moves.put(9, new int[]{2, 4});\\n        \\n        long[][] dp = new long[10][n + 1];\\n        for (int i = 0; i < 10; i++) \\n            Arrays.fill(dp[i], -1);\\n        \\n        long res = 0;\\n        for (int i = 0; i < 10; i++) \\n            res += knightDialerHelper(i, 1, n, moves, dp);\\n        return (int) (res % mod);\\n    }\\n    \\n    public long knightDialerHelper(int step, int level, int targetLevel, Map<Integer, int[]> moves, long[][] dp) {\\n        if (level == targetLevel) return 1;\\n        if (dp[step][level] != -1) return dp[step][level];\\n        \\n        long res = 0;\\n        for (int neighbors : moves.get(step)) \\n            res += knightDialerHelper(neighbors, level + 1, targetLevel, moves, dp) % mod;\\n        \\n        dp[step][level] = res;\\n        return dp[step][level];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6}",
                "codeTag": "Java"
            },
            {
                "id": 1591091,
                "title": "clean-dp-c-11-solution",
                "content": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589287,
                "title": "easy-c-dfs-memo-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535517,
                "title": "python-recursion-memo",
                "content": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511068,
                "title": "python-super-simple-bottom-up-dp",
                "content": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "solutionTags": [],
                "code": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "codeTag": "Java"
            },
            {
                "id": 1455243,
                "title": "dp-on-the-possible-paths-of-knight-c",
                "content": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431522,
                "title": "python-o-n-dp-and-thinking-process",
                "content": "We could start from a naive brutal force recursive solution as follows. Just iterate each possible next positions on the dial board.\\n\\n```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\\n\\nSo we found the key is actually compute the **number of next position**, which is the **current end digit of the dial string**. And since the dial board is a small and fixed one, we could store all possible next positions given the current position. And keep updating number of strings with each ending digits.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\\n\\nAnd the final version is using a two-dim dp_array. The first dimension is the current step. And the second dimension is the **numbers of string with that ending digit**.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1422012,
                "title": "c-dp-98",
                "content": "public class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }\\n        \\n        for(int steps=2;steps<=n;steps++)\\n        {\\n            dp[0,steps] = (dp[4,steps-1] + dp[6,steps-1]) % mod;\\n            dp[1,steps] = (dp[6,steps-1] + dp[8,steps-1]) % mod;\\n            dp[2,steps] = (dp[7,steps-1] + dp[9,steps-1]) % mod;\\n            dp[3,steps] = (dp[4,steps-1] + dp[8,steps-1]) % mod;\\n            dp[4,steps] = (dp[0,steps-1] + dp[3,steps-1] + dp[9,steps-1]) % mod ;\\n            dp[6,steps] = (dp[1,steps-1] + dp[7,steps-1] + dp[0,steps-1]) % mod;\\n            dp[7,steps] = (dp[2,steps-1] + dp[6,steps-1]) % mod;\\n            dp[8,steps] = (dp[1,steps-1] + dp[3,steps-1]) % mod;\\n            dp[9,steps] = (dp[4,steps-1] + dp[2,steps-1]) % mod;\\n        }\\n        \\n        long total = 0;\\n        for(int i=0;i<10;i++)\\n        {\\n              total += dp[i,n] % mod;\\n        }\\n          \\n        return (int)(total % mod);\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "question_content": "<p>Given the string <code>s</code>, return the size of the longest substring containing each vowel an even number of times. That is, &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39; must appear an even number of times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;eleetminicoworoep&quot;\n<strong>Output:</strong> 13\n<strong>Explanation: </strong>The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: <strong>e</strong>, <strong>i</strong> and <strong>o</strong> and zero of the vowels: <strong>a</strong> and <strong>u</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcodeisgreat&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The longest substring is &quot;leetc&quot; which contains two e&#39;s.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bcbcbc&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> In this case, the given string &quot;bcbcbc&quot; is the longest because all vowels: <strong>a</strong>, <strong>e</strong>, <strong>i</strong>, <strong>o</strong> and <strong>u</strong> appear zero times.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>\n\t<li><code>s</code>&nbsp;contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 531840,
                "title": "java-c-python-one-pass",
                "content": "# Explanation\\n`cur` records the count of \"aeiou\"\\n`cur & 1` = the records of `a` % 2\\n`cur & 2` = the records of `e` % 2\\n`cur & 4` = the records of `i` % 2\\n`cur & 8` = the records of `o` % 2\\n`cur & 16` = the records of `u` % 2\\n`seen` note the index of first occurrence of `cur`\\n\\n\\nNote that we don\\'t really need the exact count number,\\nwe only need to know if it\\'s odd or even.\\n\\nIf it\\'s one of `aeiou`,\\n`\\'aeiou\\'.find(c)` can find the index of vowel,\\n`cur ^= 1 << \\'aeiou\\'.find(c)` will toggle the count of vowel.\\n\\nBut for no vowel characters,\\n`\\'aeiou\\'.find(c)` will return -1,\\nthat\\'s reason that we do `1 << (\\'aeiou\\'.find(c) + 1) >> 1`.\\n\\nHope this explain enough.\\n\\n# Complexity\\nTime `O(N)`, Space `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0 , cur = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1 ) >> 1;\\n            seen.putIfAbsent(cur, i);\\n            res = Math.max(res, i - seen.get(cur));\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nby @chenkkkabc\\n```cpp\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m{{0, -1}};\\n        int res = 0, n = s.length(), cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            cur ^= 1 << string(\"aeiou\").find(s[i]) + 1 >> 1;\\n            if (!m.count(cur)) m[cur] = i;\\n            res = max(res, i - m[cur]);\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def findTheLongestSubstring(self, s):\\n        seen = {0: -1}\\n        res = cur = 0\\n        for i, c in enumerate(s):\\n            cur ^= 1 << (\\'aeiou\\'.find(c) + 1) >> 1\\n            seen.setdefault(cur, i)\\n            res = max(res, i - seen[cur])\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0 , cur = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1 ) >> 1;\\n            seen.putIfAbsent(cur, i);\\n            res = Math.max(res, i - seen.get(cur));\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m{{0, -1}};\\n        int res = 0, n = s.length(), cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            cur ^= 1 << string(\"aeiou\").find(s[i]) + 1 >> 1;\\n            if (!m.count(cur)) m[cur] = i;\\n            res = max(res, i - m[cur]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findTheLongestSubstring(self, s):\\n        seen = {0: -1}\\n        res = cur = 0\\n        for i, c in enumerate(s):\\n            cur ^= 1 << (\\'aeiou\\'.find(c) + 1) >> 1\\n            seen.setdefault(cur, i)\\n            res = max(res, i - seen[cur])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534135,
                "title": "c-java-with-picture",
                "content": "#### Intuition\\nWe do not need to know the exact count, we just need a flag indicating whether a vowel is even or odd. So, we can track the status of each vowel using a bit mask. Since we only have 5 vowels in the English alphabet, we will have 32 possible combinations.\\n\\nNow, if our mask is zero, then our string contains only even vowels. Also, if a mask is the same for indexes `i` and `j`, the mask for substring `[i +1, j]` must be zero. Therefore, substring `[i +1, j]` also contains even vowels only.\\n\\n#### Algorithm\\nAs we go through our string, we update `mask`, and track the smallest index for each `mask` combination. If we encounter the same `mask` later in the string, that means the string between smallest (exclusive) and current (inclusive) index meets the problem criteria.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584056896.png)\\n\\nIn other words, we need to find the maximum distance between the first and last index for each `mask` combination.\\n\\n> Note that for zero `mask` (all vowels\\' count is even), the first index is \\'-1\\' - so that we include the string from very beginning. \\n\\n**C++**\\nI am using arrays here (e.g. instead of hash maps) for the performance. With fast IO settings, the runtime of this C++ code is 16 ms.\\n\\n```cpp\\nstatic constexpr char c_m[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};    \\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    vector<int> m(32, -1);\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= c_m[s[i] - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\nchar[] c_m = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\npublic int findTheLongestSubstring(String s) {\\n    int mask = 0, res = 0;\\n    int[] m = new int[32];\\n    Arrays.fill(m, -1);\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= c_m[s.charAt(i) - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = Math.max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Complexity Analysis\\n- Time: O(n)\\n- Memory: O(2 ^ m), where m is the number of characters we need to track counts for.\\n  - 5 vowels needs 32 positions to track in this problem.",
                "solutionTags": [],
                "code": "```cpp\\nstatic constexpr char c_m[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};    \\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    vector<int> m(32, -1);\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= c_m[s[i] - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\n```java\\nchar[] c_m = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\npublic int findTheLongestSubstring(String s) {\\n    int mask = 0, res = 0;\\n    int[] m = new int[32];\\n    Arrays.fill(m, -1);\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= c_m[s.charAt(i) - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = Math.max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 531850,
                "title": "python-solution-in-o-n-time-and-o-1-space-explained",
                "content": "We can use 5 bits to represent the parity of the number of occurrences of vowels. For example, we can use 0/1 for even/odd numbers, then if we have 4a, 3e, 2i, 1o, 0u, the representation would be 01010. As we scan through the array, we can update the representation in O(1) time by using the XOR operation, and then store the index where every different representation first appeared. When we encounter a representation, say 01010 again at index `j`, we can look back on the index `i` where 01010 first appeared, and we know that the substring from `i` to `j` must be a valid string, and it is the longest valid substring that ends at `j`.\\n```python\\ndef findTheLongestSubstring(self, s: str) -> int:\\n    vowels = {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n    d, n, r = {0: -1}, 0, 0\\n    for i, c in enumerate(s):\\n        if c in vowels:\\n            n ^= vowels[c]\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            r = max(r, i - d[n])\\n    return r\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\ndef findTheLongestSubstring(self, s: str) -> int:\\n    vowels = {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n    d, n, r = {0: -1}, 0, 0\\n    for i, c in enumerate(s):\\n        if c in vowels:\\n            n ^= vowels[c]\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            r = max(r, i - d[n])\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534210,
                "title": "dew-it-simple-illustration-for-the-trick",
                "content": "**THE BASIC IDEA**\\nExample: \"leetcodeisgreat\"\\n* For any index i in the given char array, we can imagine a 5 sized vector *u* representing the count of the 5 vowels from 0 to i (i.e. the prefix sum of vowels\\' count)\\n\\n*u*\\'s for all indices\\n|chars|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|a|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|\\n|e|0|1|2|2|2|2|2|3|3|3|3|3|4|4|4|\\n|i|0|0|0|0|0|0|0|0|1|1|1|1|1|1|1|\\n|o|0|0|0|0|0|1|1|1|1|1|1|1|1|1|1|\\n|u|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\\n\\n* Further, imagine a vector *v* where the counts from *u* go through an \\'isOdd\\' check and give boolean values\\n\\n*v*\\'s for all indices\\n|chars|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|a|false|false|false|false|false|false|false|false|false|false|false|false|false|true|true|\\n|e|false|true|false|false|false|false|false|true|true|true|true|true|false|false|false|\\n|i|false|false|false|false|false|false|false|false|true|true|true|true|true|true|true|\\n|o|false|false|false|false|false|true|true|true|true|true|true|true|true|true|true|\\n|u|false|false|false|false|false|false|false|false|false|false|false|false|false|false|false|\\n\\n* Now, think about \\'a\\' alone for a sec: our required substring (containing even counts for \\'a\\') ending at i should begin at a point j where the **prefix sum at j-1 matches the prefix sum at i**. Here, \"match\" means if prefix sum is odd at i, the start should also have the prefix sum odd (even = vice versa)\\n* Standing at index i, we may ask: what\\'s the longest substring ending with i where every vowel occurs even number of times?\\n**For the *v* computed at i, we need to find the VERY FIRST occurrence of the same *v* before i**\\n* We can \"encode\" the vector *v* by representing true/false as bits 1/0 and finding the decimal representation\\n\\n|vowel|a|e|i|o|u|\\n|:-:|:-:|:-:|:-:|:-:|:-:|\\n|contrib\\'n if true|1|2|4|8|16\\n\\n|chars|-|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|code|0|0|2|0|0|0|8|8|10|14|14|14|14|12|13|13|\\n**THE CODE**\\n\\n**Readable**\\n```\\nclass Solution {\\n    char[] vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    int[] pow = { 1, 2, 4, 8, 16 };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd = new boolean[5];\\n        \\n        HashMap<Integer, Integer> encoded = new HashMap<>();\\n        encoded.put(code, -1);\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded.containsKey(code)) ans = Math.max(i-encoded.get(code), ans);\\n            else encoded.put(code, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Faster**\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray(), vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd =  new boolean[5];\\n        \\n        int[] encoded = new int[32], pow = { 1, 2, 4, 8, 16 };\\n        for(int i=0; i<32; ++i) encoded[i] = -2;\\n        encoded[0] = -1;\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded[code]>-2) ans = Math.max(i-encoded[code], ans);\\n            else encoded[code] = i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    int[] pow = { 1, 2, 4, 8, 16 };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd = new boolean[5];\\n        \\n        HashMap<Integer, Integer> encoded = new HashMap<>();\\n        encoded.put(code, -1);\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded.containsKey(code)) ans = Math.max(i-encoded.get(code), ans);\\n            else encoded.put(code, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray(), vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd =  new boolean[5];\\n        \\n        int[] encoded = new int[32], pow = { 1, 2, 4, 8, 16 };\\n        for(int i=0; i<32; ++i) encoded[i] = -2;\\n        encoded[0] = -1;\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded[code]>-2) ans = Math.max(i-encoded[code], ans);\\n            else encoded[code] = i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532101,
                "title": "java-o-n-one-pass-solution-easy-to-understand",
                "content": "Inspired by lee215\\'s solution with some extension to make the solution more easy to understand.\\n\\nlee 215\\'s solution\\n https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaPython-One-Pass\\n \\n Same idea, we use a state to encode the vowels inforation for prefix string end at index i.\\n*  1 State has 5 bits, each bits to indicate if the corresponding vowel have even count or not.\\n*  2 When current index have a vowel character, we use bitwise xor to toggle the bit value.  state ^= (1 << digit);\\n*  3 For the substring between two index have identical state, then all vowels\\'s count are even number.\\n\\t* Eg if from 0 - i, we have even number of \\'a\\', and from 0- j, if we have even number of \\'a\\' again, then the substring between i and j will have even number of \\'a\\' as well. This would be the same if 0 - i and 0 - j both have odd number of \\'a\\'.  \\n\\n*  * Suggested by @multics, we are tracking the value that corresponds to the value of the desired bit to flip. In this way, we can avoid bit shifting.\\n\\n```\\nclass Solution {\\n    HashMap<Character, Integer> vowlToBitIndex = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 1);\\n            put(\\'e\\', 2);\\n            put(\\'i\\', 4);\\n            put(\\'o\\', 8);\\n            put(\\'u\\', 16);\\n        }\\n    };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> stateToIndex = new HashMap<>();\\n        stateToIndex.put(0, -1);\\n        int state = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            char cur = s.charAt(i);\\n            if(vowlToBitIndex.containsKey(cur)) {\\n                // flap the digits of the state. 1-> 0 or 0 -> 1\\n                int bitToFlip = vowlToBitIndex.get(cur); \\n                state ^= bitToFlip; \\n            }\\n            \\n            stateToIndex.putIfAbsent(state, i);\\n            maxLen = Math.max(maxLen, i - stateToIndex.get(state));\\n        }\\n        \\n        return maxLen;    \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Character, Integer> vowlToBitIndex = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 1);\\n            put(\\'e\\', 2);\\n            put(\\'i\\', 4);\\n            put(\\'o\\', 8);\\n            put(\\'u\\', 16);\\n        }\\n    };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> stateToIndex = new HashMap<>();\\n        stateToIndex.put(0, -1);\\n        int state = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            char cur = s.charAt(i);\\n            if(vowlToBitIndex.containsKey(cur)) {\\n                // flap the digits of the state. 1-> 0 or 0 -> 1\\n                int bitToFlip = vowlToBitIndex.get(cur); \\n                state ^= bitToFlip; \\n            }\\n            \\n            stateToIndex.putIfAbsent(state, i);\\n            maxLen = Math.max(maxLen, i - stateToIndex.get(state));\\n        }\\n        \\n        return maxLen;    \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1245925,
                "title": "easy-c-with-thought-process-of-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\t//the problem is hard one \\n\\t// so lets start\\n\\t//we will require a mask to implement this(thought process- we cannot apply sliding window because removing current even vowel can destroy our maximum length of even vowel substring in future p.s(i tried sliding window :p))\\n\\t// mask ~ aeiou\\n  //          00000\\n//when ever i will find a vowel i will toggle the bit and if in any case the state gets repeated this means we have even vowels within the indices\\n\\t\\t\\t // reason ~ every bit takes two toggle to return to its original state like 0-->1-->0\\n\\t\\n    map<int,int>m;\\n        m[0]=-1;\\n        string v=\"aeiou\";\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<5;j++){\\n                if(s[i]==v[j]){\\n                    mask=mask^(1<<j);\\n                    break;\\n                }\\n            }\\n                //cout<<1<<\" \";\\n                if(m.find(mask)==m.end()){\\n                    m[mask]=i;\\n                }\\n                res=max(res,i-m[mask]);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\t//the problem is hard one \\n\\t// so lets start\\n\\t//we will require a mask to implement this(thought process- we cannot apply sliding window because removing current even vowel can destroy our maximum length of even vowel substring in future p.s(i tried sliding window :p))\\n\\t// mask ~ aeiou\\n  //          00000\\n//when ever i will find a vowel i will toggle the bit and if in any case the state gets repeated this means we have even vowels within the indices\\n\\t\\t\\t // reason ~ every bit takes two toggle to return to its original state like 0-->1-->0\\n\\t\\n    map<int,int>m;\\n        m[0]=-1;\\n        string v=\"aeiou\";\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<5;j++){\\n                if(s[i]==v[j]){\\n                    mask=mask^(1<<j);\\n                    break;\\n                }\\n            }\\n                //cout<<1<<\" \";\\n                if(m.find(mask)==m.end()){\\n                    m[mask]=i;\\n                }\\n                res=max(res,i-m[mask]);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 531807,
                "title": "python-two-sum-like-hash-map-solution",
                "content": "Python two-sum-like hash map solution\\n\\nUse a 5-dimension True/False tuple to represent how many times each vowel has appeared so far. If a vowel has appeared even times, that dimension is False, otherwise that dimension is True. So whenever a vowel appears, just copy the previous tuple, and toggle that corresponding dimension.\\n\\nThe rest is just like two-sum: iterate each tuple, and check if we have seen this tuple before.\\n\\n```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        integrals = [(False, False, False, False, False)] # integrals[10][mapping[\"a\"]] == False means we have seen \"a\" appears even times before index 10\\n        mapping = {\\n            \"a\": 0,\\n            \"i\": 1,\\n            \"u\": 2,\\n            \"e\": 3,\\n            \"o\": 4\\n        }\\n\\n        for v in s:\\n            vector = list(integrals[-1])\\n            if v in mapping: # if v is a vowel\\n                vector[mapping[v]] = not vector[mapping[v]] # toggle that dimension, because if v had appeared even times before, it becomes odd times now\\n            integrals.append(tuple(vector))\\n\\n        seen = {}\\n        res = 0\\n\\n        for i, v in enumerate(integrals):\\n            if v in seen: # we have seen this vector before\\n                res = max(res, i - seen[v]) # compare its substring length\\n            else:\\n                seen[v] = i # just record the first time each vector appears\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        integrals = [(False, False, False, False, False)] # integrals[10][mapping[\"a\"]] == False means we have seen \"a\" appears even times before index 10\\n        mapping = {\\n            \"a\": 0,\\n            \"i\": 1,\\n            \"u\": 2,\\n            \"e\": 3,\\n            \"o\": 4\\n        }\\n\\n        for v in s:\\n            vector = list(integrals[-1])\\n            if v in mapping: # if v is a vowel\\n                vector[mapping[v]] = not vector[mapping[v]] # toggle that dimension, because if v had appeared even times before, it becomes odd times now\\n            integrals.append(tuple(vector))\\n\\n        seen = {}\\n        res = 0\\n\\n        for i, v in enumerate(integrals):\\n            if v in seen: # we have seen this vector before\\n                res = max(res, i - seen[v]) # compare its substring length\\n            else:\\n                seen[v] = i # just record the first time each vector appears\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531818,
                "title": "c-bit-mask",
                "content": "Since there are only 5 vowels, we can use bit-mask to record 32 states. (For each vowel, its count is either odd or even.) ```0``` means even number of counts while ```1``` means odd number of counts. We pass the string one time and record the state up to each character. If we find a state that has been found before, by the property of odd and even numbers, the substring between two indices meets the criteria. Since we want the longest one, we only record the index of the state when it first appears.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        const string vowels(\"aeiou\");\\n        int ans(0), mask(0);\\n        \\n        for (int k = 0; k < s.length(); ++k) {\\n            for (int i = 0; i < 5; ++i)\\n                if (s[k] == vowels[i]) {\\n                    mask ^= 1 << i;\\n                    break;\\n                }\\n            states[mask] == -2 ? states[mask] = k : ans = max(ans, k - states[mask]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```0```\n```1```\n```cpp\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        const string vowels(\"aeiou\");\\n        int ans(0), mask(0);\\n        \\n        for (int k = 0; k < s.length(); ++k) {\\n            for (int i = 0; i < 5; ++i)\\n                if (s[k] == vowels[i]) {\\n                    mask ^= 1 << i;\\n                    break;\\n                }\\n            states[mask] == -2 ? states[mask] = k : ans = max(ans, k - states[mask]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531870,
                "title": "python-easy-sliding-window",
                "content": "Explaination - Sliding window over each substring of s starting with substring of len(s). If count of any vowel in substring is not even, break and try next substring.\\n\\nHope this makes sense, feel free to critique my code - very new to programming. Thanks!\\n\\n```class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        for i in range(len(s),-1,-1):\\n            for x in range(len(s) - i +1):\\n                counter = 0\\n                temp = s[x:x+i]\\n                for k in \\'aeiou\\':\\n                    if temp.count(k) % 2 != 0:\\n                        counter += 1\\n                        break\\n                if counter == 0:\\n                    return i\\n",
                "solutionTags": [],
                "code": "Explaination - Sliding window over each substring of s starting with substring of len(s). If count of any vowel in substring is not even, break and try next substring.\\n\\nHope this makes sense, feel free to critique my code - very new to programming. Thanks!\\n\\n```class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        for i in range(len(s),-1,-1):\\n            for x in range(len(s) - i +1):\\n                counter = 0\\n                temp = s[x:x+i]\\n                for k in \\'aeiou\\':\\n                    if temp.count(k) % 2 != 0:\\n                        counter += 1\\n                        break\\n                if counter == 0:\\n                    return i\\n",
                "codeTag": "Java"
            },
            {
                "id": 1471541,
                "title": "c-1-using-sliding-window-tle-2-using-mask-linear-approach-accepted",
                "content": "```\\n//Approach-1 (Using Sliding Window) 52/53 test cases passed\\nclass Solution {\\npublic:\\n    bool isVowel(const char& ch) {\\n        return ch==\\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        int n     = s.length();\\n        int maxL  = 0;\\n        int start = 0;\\n        int end   = 0;\\n        \\n        while(end < n) {\\n            char curr = s[end];\\n            end++;\\n            if(isVowel(curr)) mp[curr]++;\\n            \\n            unordered_map<char, int> temp(mp); //create a temporary map\\n            \\n            //you need to decrease the window size until you get all vowels in even count\\n            while(temp[\\'a\\']%2 || temp[\\'e\\']%2 || temp[\\'i\\']%2 || temp[\\'o\\']%2 || temp[\\'u\\']%2) {\\n                if(isVowel(s[start]))\\n                    temp[s[start]]--;\\n                \\n                start++; //reduce the window size\\n                \\n                if(end-start <= maxL) break; //aage barhne se fayda nahi hai bhai\\n            }\\n            \\n            maxL = max(maxL, end-start);\\n            start = 0;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (using Mask and Xor property)\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int mask = 0;\\n        int maxL = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            int val = 0;\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                val = s[i]; //agar vowel hai to uski value lelo else consonant me 0 rahegi val\\n            \\n            mask = mask^val; //xor nikala\\n            \\n            if(!mp.count(mask)) //agar past me nahi dekha to map me daaldo\\n                mp[mask] = i;\\n            \\n            maxL = max(maxL, i - mp[mask]); //maxL nikaal lo\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Sliding Window) 52/53 test cases passed\\nclass Solution {\\npublic:\\n    bool isVowel(const char& ch) {\\n        return ch==\\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        int n     = s.length();\\n        int maxL  = 0;\\n        int start = 0;\\n        int end   = 0;\\n        \\n        while(end < n) {\\n            char curr = s[end];\\n            end++;\\n            if(isVowel(curr)) mp[curr]++;\\n            \\n            unordered_map<char, int> temp(mp); //create a temporary map\\n            \\n            //you need to decrease the window size until you get all vowels in even count\\n            while(temp[\\'a\\']%2 || temp[\\'e\\']%2 || temp[\\'i\\']%2 || temp[\\'o\\']%2 || temp[\\'u\\']%2) {\\n                if(isVowel(s[start]))\\n                    temp[s[start]]--;\\n                \\n                start++; //reduce the window size\\n                \\n                if(end-start <= maxL) break; //aage barhne se fayda nahi hai bhai\\n            }\\n            \\n            maxL = max(maxL, end-start);\\n            start = 0;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\n```\\n//Approach-2 (using Mask and Xor property)\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int mask = 0;\\n        int maxL = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            int val = 0;\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                val = s[i]; //agar vowel hai to uski value lelo else consonant me 0 rahegi val\\n            \\n            mask = mask^val; //xor nikala\\n            \\n            if(!mp.count(mask)) //agar past me nahi dekha to map me daaldo\\n                mp[mask] = i;\\n            \\n            maxL = max(maxL, i - mp[mask]); //maxL nikaal lo\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373747,
                "title": "java-one-pass-bit-mask",
                "content": "```\\npublic int findTheLongestSubstring(String s) {\\n        int mask = 0;\\n        int[] freq = new int[128];\\n        int ans = 0;\\n        Arrays.fill(freq,-2);\\n        freq[0] = -1;\\n        int i=0;\\n        for(Character ch:s.toCharArray()){\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'e\\' || ch == \\'o\\' || ch == \\'u\\'){\\n                if(ch == \\'a\\'){\\n                    mask^=(1<<0);\\n                }\\n                else if(ch == \\'e\\'){\\n                    mask^=(1<<1);\\n                }\\n                else if(ch == \\'i\\'){\\n                    mask^=(1<<2);\\n                }\\n                else if(ch == \\'o\\'){\\n                    mask^=(1<<3);\\n                }\\n                else{\\n                    mask^=(1<<4);\\n                }\\n            }\\n            if(freq[mask]!=-2){\\n                ans = Math.max(ans,i-freq[mask]);\\n            }\\n            else{\\n                freq[mask] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n        int mask = 0;\\n        int[] freq = new int[128];\\n        int ans = 0;\\n        Arrays.fill(freq,-2);\\n        freq[0] = -1;\\n        int i=0;\\n        for(Character ch:s.toCharArray()){\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'e\\' || ch == \\'o\\' || ch == \\'u\\'){\\n                if(ch == \\'a\\'){\\n                    mask^=(1<<0);\\n                }\\n                else if(ch == \\'e\\'){\\n                    mask^=(1<<1);\\n                }\\n                else if(ch == \\'i\\'){\\n                    mask^=(1<<2);\\n                }\\n                else if(ch == \\'o\\'){\\n                    mask^=(1<<3);\\n                }\\n                else{\\n                    mask^=(1<<4);\\n                }\\n            }\\n            if(freq[mask]!=-2){\\n                ans = Math.max(ans,i-freq[mask]);\\n            }\\n            else{\\n                freq[mask] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 664445,
                "title": "short-and-simple-c-solution-well-explained",
                "content": "**Approach - 1**\\n\\n```\\n/*\\n\\tI first tried this approach to keep the count of vowels at every step as a binary string an then comapre it.\\n\\tBut it shows that all the test cases passed but took too long.\\n\\tSO BASICALLY THIS APPROACH GETS TLE.\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char,int>cnt;\\n        unordered_map<string,int>mp; mp[\"00000\"]=-1;\\n        vector<char>vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans=0; string temp=\"\";\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            char x=s[i]; temp=\"\";\\n            cnt[x]++;\\n            for(int j=0 ; j<5 ; j++) temp+=to_string(cnt[vowels[j]]%2);\\n            if(mp.find(temp)!=mp.end()) ans=max(ans,i-mp[temp]);\\n            else mp[temp]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach - 2**\\n\\n\\n```\\n/*\\n\\t\\tSo I tried with some modifications and this one worked fine.\\n\\tEach time we process a vowel, update the running bitmask by flipping this vowel\\'s parity.\\n\\tFor each different parity state, we save its earliest occurence in a map. \\n\\tFor each state, if it has never appeared before, save it to the map.\\n\\tIf it has appeared before, update the global best result. \\n\\tA repeating state means the substring in between its earliest and current occurence has all even counts of vowels.\\n*/\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int ans=0; int curr=0; mp[0]=-1;\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int x=s[i]-\\'a\\';\\n                curr ^= 1<<x;      //update the parity when you see a vowel\\n            }\\n            if(mp.find(curr)==mp.end()) mp[curr]=i;   \\n            ans=max(ans,i-mp[curr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tI first tried this approach to keep the count of vowels at every step as a binary string an then comapre it.\\n\\tBut it shows that all the test cases passed but took too long.\\n\\tSO BASICALLY THIS APPROACH GETS TLE.\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char,int>cnt;\\n        unordered_map<string,int>mp; mp[\"00000\"]=-1;\\n        vector<char>vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans=0; string temp=\"\";\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            char x=s[i]; temp=\"\";\\n            cnt[x]++;\\n            for(int j=0 ; j<5 ; j++) temp+=to_string(cnt[vowels[j]]%2);\\n            if(mp.find(temp)!=mp.end()) ans=max(ans,i-mp[temp]);\\n            else mp[temp]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n\\t\\tSo I tried with some modifications and this one worked fine.\\n\\tEach time we process a vowel, update the running bitmask by flipping this vowel\\'s parity.\\n\\tFor each different parity state, we save its earliest occurence in a map. \\n\\tFor each state, if it has never appeared before, save it to the map.\\n\\tIf it has appeared before, update the global best result. \\n\\tA repeating state means the substring in between its earliest and current occurence has all even counts of vowels.\\n*/\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int ans=0; int curr=0; mp[0]=-1;\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int x=s[i]-\\'a\\';\\n                curr ^= 1<<x;      //update the parity when you see a vowel\\n            }\\n            if(mp.find(curr)==mp.end()) mp[curr]=i;   \\n            ans=max(ans,i-mp[curr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976840,
                "title": "python-3-8-lines-bit-mask-w-example-t-m-91-69",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n                                                    #       Example: \\'leetcodoe\\'\\n        d = defaultdict(int)\\n        v = {\\'a\\':0,\\'e\\':1,\\'i\\':2,\\'o\\':3,\\'u\\':4,}        #    i   ch      n    ans    d\\n        n, ans, d[0] = 0, 0, -1                     #  \\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    0    l    00000   1    {0:-1}\\n        for i, ch in enumerate(s):                  #    1    e    00010   1    {0:-1, 2:1}}\\n            if ch in \\'aeiou\\': n ^= (1<<v[ch])       #    2    e    00000   3    {0:-1, 2:1}}\\n                                                    #    3    t    00000   4    {0:-1, 2:1}}\\n            if n in d: ans = max(ans, i - d[n])     #    4    c    00000   5    {0:-1, 2:1, 8:5}\\n            else:      d[n] = i                     #    5    o    01000   5    {0:-1, 2:1, 8:5}\\n                                                    #    6    d    01000   5    {0:-1, 2:1, 8:5}\\n        return ans                                  #    7    o    00000   8    {0:-1, 2:1, 8:5}\\n                                                    #    8    e    00010   8    {0:-1, 2:1, 8:5}\\n                                                    #   /          |||||\\n                                                    #  return     \\'uoiea\\'\\n```\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/868729915/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n                                                    #       Example: \\'leetcodoe\\'\\n        d = defaultdict(int)\\n        v = {\\'a\\':0,\\'e\\':1,\\'i\\':2,\\'o\\':3,\\'u\\':4,}        #    i   ch      n    ans    d\\n        n, ans, d[0] = 0, 0, -1                     #  \\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    0    l    00000   1    {0:-1}\\n        for i, ch in enumerate(s):                  #    1    e    00010   1    {0:-1, 2:1}}\\n            if ch in \\'aeiou\\': n ^= (1<<v[ch])       #    2    e    00000   3    {0:-1, 2:1}}\\n                                                    #    3    t    00000   4    {0:-1, 2:1}}\\n            if n in d: ans = max(ans, i - d[n])     #    4    c    00000   5    {0:-1, 2:1, 8:5}\\n            else:      d[n] = i                     #    5    o    01000   5    {0:-1, 2:1, 8:5}\\n                                                    #    6    d    01000   5    {0:-1, 2:1, 8:5}\\n        return ans                                  #    7    o    00000   8    {0:-1, 2:1, 8:5}\\n                                                    #    8    e    00010   8    {0:-1, 2:1, 8:5}\\n                                                    #   /          |||||\\n                                                    #  return     \\'uoiea\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751178,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_set<char>vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int n = s.length();\\n        int max_len = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vowel.find(s[i]) != vowel.end())\\n            {\\n                mask ^= 1 << (s[i] - \\'a\\');\\n                if(M.find(mask) == M.end())\\n                    M[mask] = i;\\n            }\\n            max_len = max(max_len,i - M[mask]);\\n            \\n        }\\n        return max_len;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_set<char>vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int n = s.length();\\n        int max_len = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vowel.find(s[i]) != vowel.end())\\n            {\\n                mask ^= 1 << (s[i] - \\'a\\');\\n                if(M.find(mask) == M.end())\\n                    M[mask] = i;\\n            }\\n            max_len = max(max_len,i - M[mask]);\\n            \\n        }\\n        return max_len;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782312,
                "title": "bit-mask-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sz = (1<<6) - 1;\\n    int INF = 1e9 + 7;\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int>mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<int>dp(sz, INF);\\n        \\n        dp[0] = -1;\\n        int mask = 0;\\n        int ans = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.count(s[i]) != 0)\\n                mask ^= 1 << (mp[s[i]]);\\n            \\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz = (1<<6) - 1;\\n    int INF = 1e9 + 7;\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int>mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<int>dp(sz, INF);\\n        \\n        dp[0] = -1;\\n        int mask = 0;\\n        int ans = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.count(s[i]) != 0)\\n                mask ^= 1 << (mp[s[i]]);\\n            \\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643618,
                "title": "c-hash-map",
                "content": "**Intuition:**\\nKeep a mask vector for all vowels.\\nKeeping xoring the vowel masks, set each mask\\'s 1st encounter index in hashmap. If we encounter this mask again we calculate the current length  with (i-hm[mask]). If mask is zero, then calculate the length from start of the string.\\n(i-(-1) = i+1) \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int mask = 0, res = 0;\\n        vector<int>count = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        unordered_map<int, int>hm;\\n        hm[0]=-1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= count[s[i]-\\'a\\'];\\n            \\n            if (mask != 0 && hm.find(mask) == hm.end())\\n                hm[mask] = i;\\n            \\n            res = max(res, i-hm[mask]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int mask = 0, res = 0;\\n        vector<int>count = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        unordered_map<int, int>hm;\\n        hm[0]=-1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= count[s[i]-\\'a\\'];\\n            \\n            if (mask != 0 && hm.find(mask) == hm.end())\\n                hm[mask] = i;\\n            \\n            res = max(res, i-hm[mask]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531829,
                "title": "python-bit-mask-one-pass-prefix-hashtable",
                "content": "```\\n  \\n  def findTheLongestSubstring(self, s: str) -> int:\\n\\t\\t\\n\\t\\tlookup={\\'a\\':4,\\'e\\':3,\\'i\\':2,\\'o\\':1,\\'u\\':0}\\n        maxLen=0\\n        prefix={}\\n        prefix[0]=-1\\n        cur=0\\n        for i,ch in enumerate(s):\\n            if ch in lookup:\\n                cur^=(1<<lookup[ch])\\n            if cur in prefix:\\n                maxLen=max(maxLen,i-prefix[cur])\\n            else:\\n\\t\\t\\t\\tprefix[cur]=i\\n        return maxLen\\n",
                "solutionTags": [],
                "code": "```\\n  \\n  def findTheLongestSubstring(self, s: str) -> int:\\n\\t\\t\\n\\t\\tlookup={\\'a\\':4,\\'e\\':3,\\'i\\':2,\\'o\\':1,\\'u\\':0}\\n        maxLen=0\\n        prefix={}\\n        prefix[0]=-1\\n        cur=0\\n        for i,ch in enumerate(s):\\n            if ch in lookup:\\n                cur^=(1<<lookup[ch])\\n            if cur in prefix:\\n                maxLen=max(maxLen,i-prefix[cur])\\n            else:\\n\\t\\t\\t\\tprefix[cur]=i\\n        return maxLen\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2596808,
                "title": "c-easy-to-understand-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }\\n            else\\n                mp[cnt]=i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1125562,
                "title": "python3-bitmask",
                "content": "\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        ans = mask = 0 \\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\": \\n                mask ^= 1 << (\"aeiou\".find(c))\\n            if mask in seen: ans = max(ans, i - seen[mask])\\n            seen.setdefault(mask, i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        ans = mask = 0 \\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\": \\n                mask ^= 1 << (\"aeiou\".find(c))\\n            if mask in seen: ans = max(ans, i - seen[mask])\\n            seen.setdefault(mask, i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 532958,
                "title": "easy-solution-using-sliding-window-in-java",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'a\\',0); map.put(\\'e\\',0); map.put(\\'i\\',0); map.put(\\'o\\',0); map.put(\\'u\\',0);\\n        int l=0,maxlen=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            char curr=s.charAt(r);\\n            if(map.containsKey(curr))\\n            {\\n                map.put(curr,map.get(curr)+1);\\n            }\\n            Map<Character,Integer>temp=new HashMap<>();\\n            \\n            temp.put(\\'a\\',map.get(\\'a\\')); \\n            temp.put(\\'e\\',map.get(\\'e\\')); \\n            temp.put(\\'i\\',map.get(\\'i\\')); \\n            temp.put(\\'o\\',map.get(\\'o\\')); \\n            temp.put(\\'u\\',map.get(\\'u\\'));\\n            \\n            while(temp.get(\\'a\\')%2==1||temp.get(\\'e\\')%2==1||temp.get(\\'i\\')%2==1||temp.get(\\'o\\')%2==1||temp.get(\\'u\\')%2==1)\\n            {\\n                char left=s.charAt(l);\\n                if(temp.containsKey(left))\\n                {\\n                    temp.put(left,temp.get(left)-1);\\n                }\\n                l++;\\n            }\\n           maxlen=Math.max(maxlen,r-l+1);\\n           l=0;\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'a\\',0); map.put(\\'e\\',0); map.put(\\'i\\',0); map.put(\\'o\\',0); map.put(\\'u\\',0);\\n        int l=0,maxlen=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            char curr=s.charAt(r);\\n            if(map.containsKey(curr))\\n            {\\n                map.put(curr,map.get(curr)+1);\\n            }\\n            Map<Character,Integer>temp=new HashMap<>();\\n            \\n            temp.put(\\'a\\',map.get(\\'a\\')); \\n            temp.put(\\'e\\',map.get(\\'e\\')); \\n            temp.put(\\'i\\',map.get(\\'i\\')); \\n            temp.put(\\'o\\',map.get(\\'o\\')); \\n            temp.put(\\'u\\',map.get(\\'u\\'));\\n            \\n            while(temp.get(\\'a\\')%2==1||temp.get(\\'e\\')%2==1||temp.get(\\'i\\')%2==1||temp.get(\\'o\\')%2==1||temp.get(\\'u\\')%2==1)\\n            {\\n                char left=s.charAt(l);\\n                if(temp.containsKey(left))\\n                {\\n                    temp.put(left,temp.get(left)-1);\\n                }\\n                l++;\\n            }\\n           maxlen=Math.max(maxlen,r-l+1);\\n           l=0;\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377562,
                "title": "xor-operation-c",
                "content": "```\\n//When the xor of all the even times numbers are done it results in 0. The xor of the vowels are done by indicating \\n//them with a single digit and the xor value is stored in a map\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int x= 0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int n=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                x^= (s[i]-\\'a\\'+1);\\n               if(mp.find(x)==mp.end())\\n                  mp[x]=i;\\n            }\\n            if(mp.find(x)!=mp.end())\\n                n= max(n,i-mp[x]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n//When the xor of all the even times numbers are done it results in 0. The xor of the vowels are done by indicating \\n//them with a single digit and the xor value is stored in a map\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int x= 0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int n=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                x^= (s[i]-\\'a\\'+1);\\n               if(mp.find(x)==mp.end())\\n                  mp[x]=i;\\n            }\\n            if(mp.find(x)!=mp.end())\\n                n= max(n,i-mp[x]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859014,
                "title": "simple-and-logical-approach-one-pass-easy-to-understand",
                "content": "### Idea behind the solution:\\n- We are concerned about whether the particular vowel is occuring even or odd number of times.\\n- We don\\'t bother about the count of each vowles\\n- Now suppose we want to deal with only one vowel, lets say we take \\'a\\' now whether \\'a\\' has occured even or odd times, we can find it by just triggering a bit, that\\'s where bit manipulation comes in.\\n- Now to trigger the bit we can use xor as for the xor property 0^a=a(odd times \\'a\\') and a^a=0(even times \\'a\\')\\n\\nnow there are 5 vowels:\\n- to trigger  \\'a\\' we can xor with the 1st bit\\n- to trigger  \\'e\\' we can xor with the 5th bit\\n- to trigger  \\'i\\' we can xor with 9th bit\\n- to trigger \\'o\\' we can xor with 15th bit\\n- to trigger \\'u\\' we can xor with 21st bit\\n\\nnow at any particular point if we have countered same xor that means previously we had a substring for which we had even number of vowels.\\n\\nlets take the example of\\ne l e e t m i n i c o w o r o e p\\n\\ninitially we have even count for all vowels so we take the xor value as 0\\nnow at index 0 we encounter \\'e\\'(vowel) so xor = xor^e=0^e=e\\nwe didnt come across xor=e before so we continue but to maintain the search we maintain a hashmap of integer and integer where key is xor and value is the first index(as we want to take the longest substring)\\nmap: {0:-1}, {e:0}\\n\\nthen we come to index 1 we encounter \\'l\\'(consonent) so for consonents we will take xor with 0. therefor, xor=xor^0=e^0=e\\nnow we came across e before so longest length substring now will be current index-starting index of \\'e\\'=1-0=1\\n\\nthen we come to index 2 we encounter \\'e\\'(vowel), xor=xor^e=e^e=0\\nwe had put key 0 with value -1 as indexcause if our xor value is 0 again then it means we have a substring right from the start, so longestsubstring= max(1, 2-(-1))=max(0, 3)=3\\n\\n\\nHere is a simple java code for same\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        // storing the vowels for checking\\n\\t\\tHashSet<Character> set= new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n\\t\\t\\n\\t\\t// hash map to maintain the xor and their respective first occurence index\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\t\\t\\n\\t\\t// for the substrings for which it starts from 0\\n        map.put(0, -1);\\n\\t\\t\\n\\t\\t// initially all the vowels are 0count which is even\\n        int xor=0;\\n\\t\\t\\n        // longest substring initailly is 0\\n\\t\\tint maxLen=0;\\n        \\n\\t\\t// traversing the array\\n\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t    // checking if the character is vowel or not\\n            if(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t// if it is vowel then we xor(trigger) the respective bit of the vowel and we ignore for the consonent as xor=xor^0=xor\\n                xor^=(s.charAt(i)-\\'a\\'+1);   \\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if we didnt come across the same xor that means there are no even valued vowels as of now\\n            if(!map.containsKey(xor)){\\n\\t\\t\\t\\t// we encounter the xor first time so we put their first index of occurence\\n                map.put(xor, i);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// NOTE: we could have put this in else part but if we have no even valued vowels so the maxlength will be i-i=0\\n\\t\\t\\t// here we update if we had any xor value that we encountered before then \\n\\t\\t\\t// we check the longest substring which have even counts of vowels.\\n            maxLen=Math.max(maxLen, i-map.get(xor));\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        // storing the vowels for checking\\n\\t\\tHashSet<Character> set= new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n\\t\\t\\n\\t\\t// hash map to maintain the xor and their respective first occurence index\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\t\\t\\n\\t\\t// for the substrings for which it starts from 0\\n        map.put(0, -1);\\n\\t\\t\\n\\t\\t// initially all the vowels are 0count which is even\\n        int xor=0;\\n\\t\\t\\n        // longest substring initailly is 0\\n\\t\\tint maxLen=0;\\n        \\n\\t\\t// traversing the array\\n\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t    // checking if the character is vowel or not\\n            if(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t// if it is vowel then we xor(trigger) the respective bit of the vowel and we ignore for the consonent as xor=xor^0=xor\\n                xor^=(s.charAt(i)-\\'a\\'+1);   \\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if we didnt come across the same xor that means there are no even valued vowels as of now\\n            if(!map.containsKey(xor)){\\n\\t\\t\\t\\t// we encounter the xor first time so we put their first index of occurence\\n                map.put(xor, i);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// NOTE: we could have put this in else part but if we have no even valued vowels so the maxlength will be i-i=0\\n\\t\\t\\t// here we update if we had any xor value that we encountered before then \\n\\t\\t\\t// we check the longest substring which have even counts of vowels.\\n            maxLen=Math.max(maxLen, i-map.get(xor));\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428517,
                "title": "python-3-hash-table-bitmask-tuple-o-n-two-implementations-explanation",
                "content": "### Approach #1 Masking with Tuple\\n- There are 5 vowels, and we only care whether the substring contains even or odd number of same vowel. That being said:\\n\\t- `\\'aabc\\'` is essentially same as `\\'aabcaa\\'`, because there are even numbers of  `a` in both string\\n- Say `0` means even number of a vowel and `1` means odd numbers of a vowel, given 5 vowels, there are only 32 different permutations of a length 5 tuple with only `0` and `1` in it. We will call any of the permutation `mask`.\\n- Anyhow, we will run a prefix count on substring vowels, to calculate the result, we need to take the index of the current `mask` minus the lowest index of the same `mask`\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = collections.defaultdict(lambda: sys.maxsize)\\n        cur = (0, 0, 0, 0, 0)                            # current mask\\n        ans = d[cur] = -1                                # initialize result\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4} # index mapping\\n        for i, c in enumerate(s):\\n            if c in vowel:                               # if `c` is a vowel, update the `cur` (mask)\\n                idx = vowel[c]\\n                cur = cur[:idx] + (1-cur[idx],) + cur[idx+1:]\\n            if d[cur] == sys.maxsize: \\n                d[cur] = i                               # if mask is never recorded, recorded it since it\\'s the lowest index of this current mask\\n            ans = max(ans, i - d[cur])                   # update `ans` by calculating `i - lower_idx_of_mask`\\n        return ans\\n```\\n### Approach #2 Bitmasking\\n- As you can see, this method is essentially the same as the previous\\n- From time complexity perspective, both are `O(N)`, where `N` is the length of `s`\\n- However, with bit manipulation, the performance of this method will be slightly better than __*approach #1*__\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = {0: -1}\\n        ans = cur = 0\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        for i, c in enumerate(s):\\n            if c in vowel:\\n                cur ^= 1 << vowel[c]\\n            if cur not in d:\\n                d[cur] = i\\n            ans = max(ans, i - d[cur]) \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = collections.defaultdict(lambda: sys.maxsize)\\n        cur = (0, 0, 0, 0, 0)                            # current mask\\n        ans = d[cur] = -1                                # initialize result\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4} # index mapping\\n        for i, c in enumerate(s):\\n            if c in vowel:                               # if `c` is a vowel, update the `cur` (mask)\\n                idx = vowel[c]\\n                cur = cur[:idx] + (1-cur[idx],) + cur[idx+1:]\\n            if d[cur] == sys.maxsize: \\n                d[cur] = i                               # if mask is never recorded, recorded it since it\\'s the lowest index of this current mask\\n            ans = max(ans, i - d[cur])                   # update `ans` by calculating `i - lower_idx_of_mask`\\n        return ans\\n```\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = {0: -1}\\n        ans = cur = 0\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        for i, c in enumerate(s):\\n            if c in vowel:\\n                cur ^= 1 << vowel[c]\\n            if cur not in d:\\n                d[cur] = i\\n            ans = max(ans, i - d[cur]) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757131,
                "title": "c-o-n-bitmask-and-hashmap",
                "content": "\\n```\\nint findTheLongestSubstring(string s) {\\n        \\n        string vowels = \"aeiou\";\\n        unordered_map<int, int> umap{{0,-1}};   //mask=>index when it first occurred\\n        int res=0, mask=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(vowels.find(s[i])!=string::npos)\\n                mask ^= 1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\n            if(umap.count(mask))\\n                res = max(res, i-umap[mask]);\\n            else\\n                umap[mask]=i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheLongestSubstring(string s) {\\n        \\n        string vowels = \"aeiou\";\\n        unordered_map<int, int> umap{{0,-1}};   //mask=>index when it first occurred\\n        int res=0, mask=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(vowels.find(s[i])!=string::npos)\\n                mask ^= 1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\n            if(umap.count(mask))\\n                res = max(res, i-umap[mask]);\\n            else\\n                umap[mask]=i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718813,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int status = 0;\\n        int ans = 0;\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(status, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            status ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1) >> 1; // in case char is not vowel\\n            if (!seen.containsKey(status)) {\\n                seen.put(status, i);  // record earliest index\\n            }\\n            ans = Math.max(ans, i - seen.get(status));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int status = 0;\\n        int ans = 0;\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(status, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            status ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1) >> 1; // in case char is not vowel\\n            if (!seen.containsKey(status)) {\\n                seen.put(status, i);  // record earliest index\\n            }\\n            ans = Math.max(ans, i - seen.get(status));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578071,
                "title": "python-solution-sliding-window-easy-to-read",
                "content": "So I saw a lot of the solutions are great and make a lot of sense, but I wanted to make it more reader friendly so I took some inspiration from the solutions and did this. I notice that LC is great for practicing and really honing your skills but most of the code here at times aren\\'t readable and I hope in the future if you have an answer / idea to try to be more legibile for the new comers :). Notice that the problem is like a sliding window but not the one\\'s we\\'re used to. You look for the max length so why not start at the max and contract the window from there. Your RHS of window is your end of your string where you try to remove each letter 1 by 1. Since we are assuming that every string we\\'ve seen so far is \"valid\" almost. Our code is \"almost\" going to try to break you. If our code tried and still couldn\\'t break you then we know you\\'re an even length and since we started from the max and are decrementing we know it\\'s the best length.\\nI wanted to specifically talk about this piece. \\n` sub_str = s[start:start + substr_len]`\\nUnderstand that this code of our start is us trying the \"combinations from the beginning (until end_remove) because we want to make sure to \"break said code\". So understand this sub_str literally tries all the ones and for every deletion of the front we add back to the end since we want to try it specifically for the position try the combinations given the length we have. If you\\'re discouraged by this problem don\\'t be :). I am working at a Big N and this one gave me trouble. Time to dust off the old LC hat :P \\n```\\nimport collections \\nclass Solution:\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        for substr_len in range(len(s), -1, -1): #dynamic sliding window []\\n            end_remove = len(s) - substr_len + 1 \\n            \\n            for start in range(end_remove):\\n                even = True #Let\\'s assume everything is true so far (our code is going to try to break you)\\n                sub_str = s[start:start + substr_len]\\n                \\n                for vowel in \\'aeiou\\': \\n                    if sub_str.count(vowel) % 2 != 0:\\n                        even = False #means we\\'re odd length c\\n                        break\\n                if even == True: #counter == 0 is saying all are odd \\n                    return substr_len\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport collections \\nclass Solution:\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        for substr_len in range(len(s), -1, -1): #dynamic sliding window []\\n            end_remove = len(s) - substr_len + 1 \\n            \\n            for start in range(end_remove):\\n                even = True #Let\\'s assume everything is true so far (our code is going to try to break you)\\n                sub_str = s[start:start + substr_len]\\n                \\n                for vowel in \\'aeiou\\': \\n                    if sub_str.count(vowel) % 2 != 0:\\n                        even = False #means we\\'re odd length c\\n                        break\\n                if even == True: #counter == 0 is saying all are odd \\n                    return substr_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532459,
                "title": "c-dp-solution",
                "content": "Rolling dp. The every integer in the dp map represents a state that can be formed so far, where each state is of the form {#a%2, #e%2, #i%2, #o%2, #u%2}. \\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> dp, dp2;\\n        vector<int> m(256, 0);\\n        m[\\'a\\'] = 0;\\n        m[\\'e\\'] = 1;\\n        m[\\'i\\'] = 2;\\n        m[\\'o\\'] = 3;\\n        m[\\'u\\'] = 4;\\n        \\n        dp[0] = 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (const auto c: s) {\\n            if (c == \\'a\\'|| c == \\'e\\'|| c == \\'i\\'|| c == \\'o\\'|| c == \\'u\\') {\\n                dp2.clear();\\n                for (const auto& kv: dp) {\\n                    int mask = 1<<m[c];\\n                    dp2[kv.first^mask] = kv.second+1+cnt;\\n                }\\n                dp = dp2;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n\\n            ans = max(dp[0]+cnt, ans);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> dp, dp2;\\n        vector<int> m(256, 0);\\n        m[\\'a\\'] = 0;\\n        m[\\'e\\'] = 1;\\n        m[\\'i\\'] = 2;\\n        m[\\'o\\'] = 3;\\n        m[\\'u\\'] = 4;\\n        \\n        dp[0] = 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (const auto c: s) {\\n            if (c == \\'a\\'|| c == \\'e\\'|| c == \\'i\\'|| c == \\'o\\'|| c == \\'u\\') {\\n                dp2.clear();\\n                for (const auto& kv: dp) {\\n                    int mask = 1<<m[c];\\n                    dp2[kv.first^mask] = kv.second+1+cnt;\\n                }\\n                dp = dp2;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n\\n            ans = max(dp[0]+cnt, ans);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531872,
                "title": "concise-c-and-java-solutions-with-explanation-o-n-o-1-time-space",
                "content": "You can represent odd/even using 0 and 1. As you iterate over the input string, when you arrive at some index, say index \"t\", you can represent whether the number of each vowel which has been seen up to and including index \"t\", is odd or even, using a 5 bit binary number, for example 01101. The number 01101 (13) represents that the number of a\\'s and o\\'s seen is even, while the number of e\\'s, i\\'s and u\\'s seen is odd. \\n\\nThe longest substring with even number of vowels which ends at index \"t\", is going to begin at the index after the lowest index you\\'ve seen the binary number at index \"t\". So, the idea here, is to track the first time you see these numbers and use these numbers to determine the longest substring ending at each index of the input string. By the time you\\'ve iterated over the string once, you\\'ll have the result, which is simply the maximum length you found while iterating over the string. Since these binary numbers are 5 bits, there are at most 32 of them, which is very manageable. \\n\\nThis is a nice situation to use the XOR operator as well. You can derive the binary number at index \"t\" very easily using a XOR operator, if you give each vowel a binary representation with only one bit set to 1. I chose \\'a\\'=10000=16, \\'e\\'=01000=8, etc... This is what is going on in my chrToBin array below. If you XOR this with the binary number from index \"t - 1\", you will have the new binary representation for index \"t\" telling you exactly whether the number of each vowel up to and including index \"t\" is even or odd.\\n\\n**Example C# solution:**\\n```\\n    public int FindTheLongestSubstring(string s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Array.Fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            last ^= chrToBin[s[i] - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.Max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Example Java solution:**\\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Arrays.fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            last ^= chrToBin[s.charAt(i) - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int FindTheLongestSubstring(string s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Array.Fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            last ^= chrToBin[s[i] - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.Max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Arrays.fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            last ^= chrToBin[s.charAt(i) - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287047,
                "title": "fully-commented-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        //final ans to be retruned from the function\\n        int ans = 0;\\n\\n        //the count of the vowel must be even number of times \\n        //vowels can occur even number of times..0 , 2 , 4 , 6...2(n)  \\n\\n        //to maintain the bit mask we will have a count \\n        int num = 0;\\n\\n        //we are going to store the number in a unordered_map\\n        unordered_map<int,int>mp;    \\n\\n        //an idx to iterate over the string\\n        int idx = 0;\\n        \\n        //storing the inital count in the map\\n        mp[num] = -1;\\n\\n        //basically the consonant will help to increase the length of the string\\n        while(idx < s.length())\\n        {\\n            char ch = s[idx];\\n            \\n            if(isVowel(ch) == true)\\n            {\\n                char ch = s[idx];\\n                int pos = ch - \\'a\\';\\n\\n                //we will toggle the bit to the currosponding pos of the char\\n                num = (num ^ (1<<pos));\\n\\n                if(mp.find(num) != mp.end())\\n                {\\n                    //previously we have encountred the num before also\\n                    int start = mp[num]+1;\\n                    int end   = idx;\\n                    int wind_size = (end - start + 1);\\n\\n                    if(wind_size > ans)\\n                    ans = wind_size;\\n                }\\n            }\\n            else\\n            {\\n                //consonant will only help to increase the length of the substring\\n                //in which the count of the vowel is even number of times\\n              \\n                //consonant will not contribute any value to the num\\n                int start = mp[num]+1;\\n                int end   = idx;\\n                int wind_size = (end - start + 1);\\n\\n                if(wind_size > ans)\\n                ans = wind_size;\\n            }\\n            if(mp.find(num) == mp.end())\\n            {\\n                mp[num] = idx;\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\') return true;\\n        if(ch == \\'e\\') return true;\\n        if(ch == \\'i\\') return true;\\n        if(ch == \\'o\\') return true;\\n        if(ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        //final ans to be retruned from the function\\n        int ans = 0;\\n\\n        //the count of the vowel must be even number of times \\n        //vowels can occur even number of times..0 , 2 , 4 , 6...2(n)  \\n\\n        //to maintain the bit mask we will have a count \\n        int num = 0;\\n\\n        //we are going to store the number in a unordered_map\\n        unordered_map<int,int>mp;    \\n\\n        //an idx to iterate over the string\\n        int idx = 0;\\n        \\n        //storing the inital count in the map\\n        mp[num] = -1;\\n\\n        //basically the consonant will help to increase the length of the string\\n        while(idx < s.length())\\n        {\\n            char ch = s[idx];\\n            \\n            if(isVowel(ch) == true)\\n            {\\n                char ch = s[idx];\\n                int pos = ch - \\'a\\';\\n\\n                //we will toggle the bit to the currosponding pos of the char\\n                num = (num ^ (1<<pos));\\n\\n                if(mp.find(num) != mp.end())\\n                {\\n                    //previously we have encountred the num before also\\n                    int start = mp[num]+1;\\n                    int end   = idx;\\n                    int wind_size = (end - start + 1);\\n\\n                    if(wind_size > ans)\\n                    ans = wind_size;\\n                }\\n            }\\n            else\\n            {\\n                //consonant will only help to increase the length of the substring\\n                //in which the count of the vowel is even number of times\\n              \\n                //consonant will not contribute any value to the num\\n                int start = mp[num]+1;\\n                int end   = idx;\\n                int wind_size = (end - start + 1);\\n\\n                if(wind_size > ans)\\n                ans = wind_size;\\n            }\\n            if(mp.find(num) == mp.end())\\n            {\\n                mp[num] = idx;\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\') return true;\\n        if(ch == \\'e\\') return true;\\n        if(ch == \\'i\\') return true;\\n        if(ch == \\'o\\') return true;\\n        if(ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898302,
                "title": "python-javascript-efficient-solution-with-detailed-explanation",
                "content": "# Intuition\\n\\n## We are looking for the empty hashtable \\n\\nCounting vowels in \"abceiae\": { \"a\" : 2, \"e\" : 2, \"i\" : 1}.\\n\\n4 == 2 == 0. It\\'s all even.\\n5 == 3 == 1. It\\'s all odd.\\nSo \"abceiae\" is : { \"a\" : 0, \"e\" : 0, \"i\" : 1}.\\nOr better,  \"abceiae\" is : {\"i\" : 1}.\\nEncounting any vowel even times is as good as never encounting any \\u263A\\uFE0F\\n\\nTo summarize, vowels in \"abceiae\":\\n{\"a\" : 2, \"e\" : 2, \"i\" : 1} -> { \"a\" : 0, \"e\" : 0, \"i\" : 1} -> {\"i\" : 1}\\n\\nhashtable is empty** == **all vowel counts in that particular string are even\\n\\n## Equal hashtables == potential substring\\n\\nLet\\'s take a look at **\"ieaa\"**:\\n\\n0. In the start hashtable is empty.\\n1. on letter **i**: { \"i\": 1 }\\n2. on letter **e**: { \"i\": 1, \"e\" : 1 }\\n3. on letter **a**: { \"i\": 1, \"e\" : 1, \"a\" : 1 }\\n4. on letter **a**: { \"i\": 1, \"e\" : 1 }\\n\\nHashtables on step 2 and step 4 hashtable looks the same.\\nSubstract them from each other { \"i\": 1, \"e\" : 1 } -  { \"i\": 1, \"e\" : 1 } = {} \\nWe will get an empty hashtable = even vowel substring with length 4 - 2 = 2\\n\\n## Replace hashtable with bitmask\\nLet\\'s encode hashtable it a bitmask. \\n``a e i o u``\\n``0 1 1 0 0`` is a bitmask for { \"i\": 1, \"e\" : 1 }.\\n\\n``a e i o u``\\n``1 0 1 0 1`` is a bitmask for { \"a\": 1, \"i\" : 1, \"u\" : 1 }.\\n\\n``a e i o u``\\n``0 0 0 0 0`` is a bitmask for {}. So empty hashtable == 0.\\n\\nSpeaking binary:\\n1 == 0\\n2 == 10\\n4 == 100\\n8 == 1000\\n16 == 10000\\n\\nE.g. we encode { \"i\": 1, \"e\" : 1 } as 01100 = 1100 = 12\\n\\n## XOR operation\\n\\n^ is the binary operation of XOR. It\\'s perfect for the situation. \\uD83D\\uDC4C\\n\\n- 1 ^ 1 = 0 odd + odd = even\\n- 1 ^ 0 = 1 odd + even = odd\\n- 0 ^ 1 = 1 even + odd = odd\\n- 0 ^ 0 = 0 even + even = even\\n\\n# Approach\\n1. Go through the string recording current hashtable (bitmask) \\u2705 \\n2. If this hashtable (bitmask) was seen before, calculate potential substring length \\u2705 \\n\\n# Complexity\\n## Time complexity: O(n)\\nWe go through the string once.\\n\\n## Space complexity: O(1)\\nWe store the code for each letter and all the possible bitmasks. \\nAs we have only 5 letters, it\\'s 2^5 = 32 = constant complexy.\\n\\n# Code \\n## Python\\n```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        map = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16}\\n        first_time = { 0 : -1 } # first time we encounter 0 mask at index -1\\n        cur_mask = 0\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] in map:\\n                cur_mask ^= map[s[i]]\\n            if cur_mask in first_time:\\n                max_len = max(max_len, i - first_time[cur_mask])\\n            else:\\n                first_time[cur_mask] = i\\n        return max_len\\n```\\n## Javascript\\n```js\\nvar findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};\\n    let firstTime = new Map();\\n    firstTime.set(0, -1); // mask 0 has index -1\\n    let curMask = 0;\\n    let maxLen = 0;\\n\\n    for (let i in s) {\\n        if (s[i] in mapping) {\\n            curMask ^= mapping[s[i]];\\n        }\\n        if (firstTime.has(curMask)) {\\n            start = firstTime.get(curMask);\\n            maxLen = Math.max(i - start, maxLen);\\n        } else {\\n            firstTime.set(curMask, i);\\n        }   \\n    }\\n    return maxLen; \\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Hash Table",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        map = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16}\\n        first_time = { 0 : -1 } # first time we encounter 0 mask at index -1\\n        cur_mask = 0\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] in map:\\n                cur_mask ^= map[s[i]]\\n            if cur_mask in first_time:\\n                max_len = max(max_len, i - first_time[cur_mask])\\n            else:\\n                first_time[cur_mask] = i\\n        return max_len\\n```\n```js\\nvar findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};\\n    let firstTime = new Map();\\n    firstTime.set(0, -1); // mask 0 has index -1\\n    let curMask = 0;\\n    let maxLen = 0;\\n\\n    for (let i in s) {\\n        if (s[i] in mapping) {\\n            curMask ^= mapping[s[i]];\\n        }\\n        if (firstTime.has(curMask)) {\\n            start = firstTime.get(curMask);\\n            maxLen = Math.max(i - start, maxLen);\\n        } else {\\n            firstTime.set(curMask, i);\\n        }   \\n    }\\n    return maxLen; \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065640,
                "title": "c-solution-o-n-time",
                "content": "This problem is similar to Longest subarray of sum 0\\n\\nWe can take prefix xor and use mask to track even counts\\nMask = 0 represent all the vowels are even.\\nAlso, if mask at i == mask at j, then mask at i+1 to j = 0\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int map[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        unordered_map<int,int> um;\\n        um[0] = -1;\\n        int mask = 0,ans = 0;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mask ^= map[s[i]-\\'a\\'];\\n            if(um.find(mask)!=um.end())\\n                ans = max(ans,i-um[mask]);\\n            else\\n                um[mask] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int map[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        unordered_map<int,int> um;\\n        um[0] = -1;\\n        int mask = 0,ans = 0;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mask ^= map[s[i]-\\'a\\'];\\n            if(um.find(mask)!=um.end())\\n                ans = max(ans,i-um[mask]);\\n            else\\n                um[mask] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407696,
                "title": "simple-python-commented-line-by-line",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define a dict for number of left shifts for each vowel\\n        vowel2shift = {\\'a\\': 4, \\'e\\': 3, \\'i\\': 2, \\'o\\': 1, \\'u\\': 0}\\n        # define a dict for the index of first appearance of a specific parity\\n        parity2firstIdx = {0: -1}\\n        # parity initialized to 00000, each vowel appear 0 time which is even\\n        ret = parity = 0\\n        # iterate through each letter of s\\n        for i, letter in enumerate(s):\\n            # if letter is a vowel, swap/toggle its corresponding bit\\n            if letter in vowel2shift:\\n                parity ^= 1 << vowel2shift[letter]\\n            # if we\\'ve seen this particular parity before, it means each vowel \\n            # appeared an even number of time between now and then\\n            # odd + even = odd\\n            # even + even = even\\n            if parity in parity2firstIdx:\\n                ret = max(ret, i-parity2firstIdx[parity])\\n            # otherwise, record its index of first appearance\\n            else:\\n                parity2firstIdx[parity] = i\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define a dict for number of left shifts for each vowel\\n        vowel2shift = {\\'a\\': 4, \\'e\\': 3, \\'i\\': 2, \\'o\\': 1, \\'u\\': 0}\\n        # define a dict for the index of first appearance of a specific parity\\n        parity2firstIdx = {0: -1}\\n        # parity initialized to 00000, each vowel appear 0 time which is even\\n        ret = parity = 0\\n        # iterate through each letter of s\\n        for i, letter in enumerate(s):\\n            # if letter is a vowel, swap/toggle its corresponding bit\\n            if letter in vowel2shift:\\n                parity ^= 1 << vowel2shift[letter]\\n            # if we\\'ve seen this particular parity before, it means each vowel \\n            # appeared an even number of time between now and then\\n            # odd + even = odd\\n            # even + even = even\\n            if parity in parity2firstIdx:\\n                ret = max(ret, i-parity2firstIdx[parity])\\n            # otherwise, record its index of first appearance\\n            else:\\n                parity2firstIdx[parity] = i\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302845,
                "title": "python-bitmask-concise-solution-o-n",
                "content": "The algorithm is straightforward. \\n1. Update bitmask and remember the leftmost index of the mask only if the character belongs to \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n2. Get the maximum. If the mask is zero, it means the number of aeiou is even so far. Else, the length would be current index - last index\\nTime complexity O(n)\\nSpace complexity O(1)\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        m = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        cnt = [float(\\'inf\\')] * 32 # idx 0 to 31\\n        mask = maxval = 0 \\n        for i, c in enumerate(s):\\n            if c in m:\\n                mask ^= 1 << m[c] # update bit mask\\n                cnt[mask] = min(cnt[mask], i) # remember of leftmost index for same mask\\n            maxval = max(maxval, i + 1) if mask == 0 else max(maxval, i - cnt[mask]) \\n                \\n        return maxval\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        m = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        cnt = [float(\\'inf\\')] * 32 # idx 0 to 31\\n        mask = maxval = 0 \\n        for i, c in enumerate(s):\\n            if c in m:\\n                mask ^= 1 << m[c] # update bit mask\\n                cnt[mask] = min(cnt[mask], i) # remember of leftmost index for same mask\\n            maxval = max(maxval, i + 1) if mask == 0 else max(maxval, i - cnt[mask]) \\n                \\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258675,
                "title": "java-bit-masking-sliding-window-logic-o-n-solution",
                "content": "# Algorithm in words: \\nfor every character in the string we do the following :\\n\\nbitmasking : integer x to keep track of even or odd count of each vowel\\n\\t\\t\\t     \\t\\n\\t\\tx     ------------>\\t\\t\\t0      0      0      0     0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu      o      i      e     a\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t16     8      4      2     1\\n\\nif the current character is vowel and lets say it is equal to \\'o\\' we do xor of x and the value from \\'vowelMask\\' i.e, vowelMask.get(\\'o\\') .By doing xor we change the current bit position of \\'o\\' state in x to 1 if it was 0 otherwise to 0. \\nif current vowel posistion has bit 0, it has even count until now, otherwise it is odd\\n\\nAfter bitmasking, we check whether the current state - x is already present in the hashmap, if it is present, we get the index from the hashmap where it has occured 1st (Say j), which means in between indices j and i, we have vowel count as even. so we update maxLength by checking if j-i is greater than maxLength\\n\\nIf the current state - x is not present in the hashmap we add it to the hashmap as key and index as current index\\n\\n# Code\\n\\n```\\nclass Solution {\\n    HashMap<Character, Integer> vowelMask = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\',1);\\n            put(\\'e\\',2);\\n            put(\\'i\\',4);\\n            put(\\'o\\',8);\\n            put(\\'u\\',16);\\n        }\\n    };\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> hmap = new HashMap<Integer, Integer>();\\n        hmap.put(0,-1);\\n        int maxLength = 0;\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(vowelMask.containsKey(s.charAt(i))) {\\n                x = x ^ vowelMask.get(s.charAt(i));\\n            }\\n            if(hmap.containsKey(x)) {\\n                maxLength = Math.max(maxLength,i - hmap.get(x));\\n            }\\n            else {\\n                hmap.put(x, i);\\n            }\\n            \\n        }\\n        return maxLength; \\n    }\\n}\\n```\\n\\n# Tracing:\\n\\nExample : \"eleetminicoworoep\"\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvowelMask :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'a\\'  ----------->             1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'e\\'  ------------>           10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'i\\'  ------------>          100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'o\\'  ------------>         1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'u\\'  ------------>        10000\\n\\t\\t\\n\\tindex          vowel                     x value                                            hmap                                 maxLength\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   00000  : -1                              0\\n\\t0(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   hmap(00010) ---------  (not exists)   --------->    00010 :  0                              0\\n\\t1(l)               X                   hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = Maximum(0, 1 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1 \\n\\t2(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   =  00000  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(1, 2 - (-1))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t3(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 3 - 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t4(t)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 4 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4\\n\\t5(m)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(4, 5 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t6(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 00010 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 00110                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hmap(00110) ---------   (not exists)   --------->    00110 :  6                           5\\n\\t7(n)               X                     hmap(00110)               ---------------            (exists)                          Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     = Maximum(5, 7 - 6))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t8(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      x = 00110 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(00010)                ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(5, 8 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   8 \\n\\t9(c)               X                      hmap(00010)               ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         = Maximum(8, 9 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n    10(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(01010) ---------   (not exists)   --------->    01010 :  10                         9\\n\\t11(w)              X                      hmap(01010)              ----------------            (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = aximum(8, 11 - 10))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n\\t12(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       x = 01010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   map(00010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(9, 12 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12\\n\\t13(r)              X                       hmap(00010)                 ---------------         (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(12, 13 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t13\\n    14(o)              O                             x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(01010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 14- 10)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    13\\n\\t15(e)              O                              x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 01010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 01000                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(01000) ---------   (not exists)   --------->  01010 :  15                          13\\n\\t16(p)              X                         hmap(01000)                ---------------           (exists)                       Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 16 - 15))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 13\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character, Integer> vowelMask = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\',1);\\n            put(\\'e\\',2);\\n            put(\\'i\\',4);\\n            put(\\'o\\',8);\\n            put(\\'u\\',16);\\n        }\\n    };\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> hmap = new HashMap<Integer, Integer>();\\n        hmap.put(0,-1);\\n        int maxLength = 0;\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(vowelMask.containsKey(s.charAt(i))) {\\n                x = x ^ vowelMask.get(s.charAt(i));\\n            }\\n            if(hmap.containsKey(x)) {\\n                maxLength = Math.max(maxLength,i - hmap.get(x));\\n            }\\n            else {\\n                hmap.put(x, i);\\n            }\\n            \\n        }\\n        return maxLength; \\n    }\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvowelMask :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'a\\'  ----------->             1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'e\\'  ------------>           10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'i\\'  ------------>          100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'o\\'  ------------>         1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'u\\'  ------------>        10000\\n\\t\\t\\n\\tindex          vowel                     x value                                            hmap                                 maxLength\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   00000  : -1                              0\\n\\t0(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   hmap(00010) ---------  (not exists)   --------->    00010 :  0                              0\\n\\t1(l)               X                   hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = Maximum(0, 1 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1 \\n\\t2(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   =  00000  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(1, 2 - (-1))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t3(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 3 - 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t4(t)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 4 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4\\n\\t5(m)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(4, 5 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t6(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 00010 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 00110                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hmap(00110) ---------   (not exists)   --------->    00110 :  6                           5\\n\\t7(n)               X                     hmap(00110)               ---------------            (exists)                          Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     = Maximum(5, 7 - 6))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t8(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      x = 00110 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(00010)                ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(5, 8 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   8 \\n\\t9(c)               X                      hmap(00010)               ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         = Maximum(8, 9 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n    10(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(01010) ---------   (not exists)   --------->    01010 :  10                         9\\n\\t11(w)              X                      hmap(01010)              ----------------            (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = aximum(8, 11 - 10))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n\\t12(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       x = 01010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   map(00010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(9, 12 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12\\n\\t13(r)              X                       hmap(00010)                 ---------------         (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(12, 13 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t13\\n    14(o)              O                             x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(01010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 14- 10)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    13\\n\\t15(e)              O                              x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 01010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 01000                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(01000) ---------   (not exists)   --------->  01010 :  15                          13\\n\\t16(p)              X                         hmap(01000)                ---------------           (exists)                       Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 16 - 15))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 13\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921145,
                "title": "o-n-solution-in-c-without-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef unordered_map<string, int> posMap;\\n    typedef unordered_map<char, int> cMap;\\n    \\n    // mark every position with 010101: 0 -> even, 1 -> odd\\n    // for every position, find the smallest matching string\\n    int findTheLongestSubstring(string s) {\\n        posMap indexes;\\n        cMap chars({{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}});\\n        string evenOdd = \"00000\";\\n        indexes[evenOdd] = -1;\\n        \\n        int length = 0;\\n        for (int i=0; i<s.size(); ++i) {\\n            char c = s[i];\\n            \\n            auto it = chars.find(c);\\n            if (it != chars.end()) {  // vowel\\n                evenOdd[it->second] = evenOdd[it->second] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n            \\n            auto lastIndex = indexes.find(evenOdd);\\n            if (lastIndex == indexes.end()) {\\n                indexes[evenOdd] = i;\\n            } else {\\n                length = max(length, i - lastIndex->second);\\n            }\\n        }\\n        return length;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef unordered_map<string, int> posMap;\\n    typedef unordered_map<char, int> cMap;\\n    \\n    // mark every position with 010101: 0 -> even, 1 -> odd\\n    // for every position, find the smallest matching string\\n    int findTheLongestSubstring(string s) {\\n        posMap indexes;\\n        cMap chars({{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}});\\n        string evenOdd = \"00000\";\\n        indexes[evenOdd] = -1;\\n        \\n        int length = 0;\\n        for (int i=0; i<s.size(); ++i) {\\n            char c = s[i];\\n            \\n            auto it = chars.find(c);\\n            if (it != chars.end()) {  // vowel\\n                evenOdd[it->second] = evenOdd[it->second] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n            \\n            auto lastIndex = indexes.find(evenOdd);\\n            if (lastIndex == indexes.end()) {\\n                indexes[evenOdd] = i;\\n            } else {\\n                length = max(length, i - lastIndex->second);\\n            }\\n        }\\n        return length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917460,
                "title": "c-easy-solution-using-map-single-parse-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        string val = \"00000\"; // This string denotes (number of occurence%2) of each vowel. Set all as 0 initially\\n        map<char, int> vowels = {{\\'a\\', 0},\\n                          {\\'e\\', 1},\\n                          {\\'i\\', 2},\\n                          {\\'o\\', 3},\\n                          {\\'u\\', 4}};\\n\\t\\t// The map indicates index of vowel in string val\\n        map<string, int> dict;\\n        int answer = 0, i = 0, size = s.length();\\n        if (size == 1) {\\n\\t\\t\\t// If size = 1; check if it is a vowel. If yes return 0, else 1\\n            if (vowels.find(s[0]) != vowels.end() ) return 0;\\n            return 1;\\n        }\\n        dict[val] = -1; // Set dict[\"00000\"] = -1 \\n        while (i < size) {\\n            if (vowels.find(s[i]) != vowels.end()) {\\n\\t\\t\\t\\t// if current element is a vowel, mark the bit in string val accordingly.\\n                int ind = vowels[s[i]];\\n                if (val[ind] == \\'0\\') {\\n\\t\\t\\t\\t\\t// This represents odd number of occurence\\n                    val[ind] = \\'1\\';\\n                } else {\\n\\t\\t\\t\\t\\t// This represents even number of occurence\\n                    if (val[ind] == \\'1\\') val[ind] = \\'0\\';\\n                }\\n            }\\n            if (dict.find(val) != dict.end()) {\\n\\t\\t\\t\\t// If the string val already exists in dict map, the string between first occurence and current index will have even occurence of vowels.\\n                answer = max(answer, i - dict[val]);\\n            } else {\\n\\t\\t\\t\\t// This combination has not been seen before. Store the index in dict.\\n                dict[val] = i;\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        string val = \"00000\"; // This string denotes (number of occurence%2) of each vowel. Set all as 0 initially\\n        map<char, int> vowels = {{\\'a\\', 0},\\n                          {\\'e\\', 1},\\n                          {\\'i\\', 2},\\n                          {\\'o\\', 3},\\n                          {\\'u\\', 4}};\\n\\t\\t// The map indicates index of vowel in string val\\n        map<string, int> dict;\\n        int answer = 0, i = 0, size = s.length();\\n        if (size == 1) {\\n\\t\\t\\t// If size = 1; check if it is a vowel. If yes return 0, else 1\\n            if (vowels.find(s[0]) != vowels.end() ) return 0;\\n            return 1;\\n        }\\n        dict[val] = -1; // Set dict[\"00000\"] = -1 \\n        while (i < size) {\\n            if (vowels.find(s[i]) != vowels.end()) {\\n\\t\\t\\t\\t// if current element is a vowel, mark the bit in string val accordingly.\\n                int ind = vowels[s[i]];\\n                if (val[ind] == \\'0\\') {\\n\\t\\t\\t\\t\\t// This represents odd number of occurence\\n                    val[ind] = \\'1\\';\\n                } else {\\n\\t\\t\\t\\t\\t// This represents even number of occurence\\n                    if (val[ind] == \\'1\\') val[ind] = \\'0\\';\\n                }\\n            }\\n            if (dict.find(val) != dict.end()) {\\n\\t\\t\\t\\t// If the string val already exists in dict map, the string between first occurence and current index will have even occurence of vowels.\\n                answer = max(answer, i - dict[val]);\\n            } else {\\n\\t\\t\\t\\t// This combination has not been seen before. Store the index in dict.\\n                dict[val] = i;\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862660,
                "title": "straightforward-js-solution",
                "content": "```\\nvar findTheLongestSubstring = function(s) {\\n    for (let k = s.length-1; k >= 0; k--) {\\n        let i = 0, j = k;\\n        while (j < s.length) {\\n            if (evenVowels(s.substring(i,j+1))) return j-i+1;\\n            i++, j++;\\n        }\\n    }\\n    return 0;\\n    // Time Complexity: O(n^2)\\n    // Space Complexity: O(n)\\n};\\n\\nvar evenVowels = function(str) {\\n    let m = new Map();\\n    let vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'];\\n    for (let letter of str) {\\n        if (vowels.includes(letter)) m.set(letter, m.get(letter)+1 || 1);\\n    }\\n    let occurrences = Array.from(m.values()).filter(num => (num%2) === 1);\\n    return occurrences.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findTheLongestSubstring = function(s) {\\n    for (let k = s.length-1; k >= 0; k--) {\\n        let i = 0, j = k;\\n        while (j < s.length) {\\n            if (evenVowels(s.substring(i,j+1))) return j-i+1;\\n            i++, j++;\\n        }\\n    }\\n    return 0;\\n    // Time Complexity: O(n^2)\\n    // Space Complexity: O(n)\\n};\\n\\nvar evenVowels = function(str) {\\n    let m = new Map();\\n    let vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'];\\n    for (let letter of str) {\\n        if (vowels.includes(letter)) m.set(letter, m.get(letter)+1 || 1);\\n    }\\n    let occurrences = Array.from(m.values()).filter(num => (num%2) === 1);\\n    return occurrences.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802423,
                "title": "java-masking-o-n",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Character,Integer> mp = new HashMap();\\n        mp.put(\\'a\\',0);mp.put(\\'e\\',1);mp.put(\\'i\\',2);mp.put(\\'o\\',3);mp.put(\\'u\\',4);\\n        HashMap<Integer, Integer> mps = new HashMap();\\n        mps.put(0,-1);\\n        int msk=0, ans =0;\\n        for(int i=0;i<s.length();i++){\\n            if(mp.containsKey(s.charAt(i)))\\n                msk = msk^(1<<(mp.get(s.charAt(i))+1));\\n            if(mps.containsKey(msk))\\n                ans= Math.max(ans,i-mps.get(msk));\\n            else\\n                mps.put(msk,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Character,Integer> mp = new HashMap();\\n        mp.put(\\'a\\',0);mp.put(\\'e\\',1);mp.put(\\'i\\',2);mp.put(\\'o\\',3);mp.put(\\'u\\',4);\\n        HashMap<Integer, Integer> mps = new HashMap();\\n        mps.put(0,-1);\\n        int msk=0, ans =0;\\n        for(int i=0;i<s.length();i++){\\n            if(mp.containsKey(s.charAt(i)))\\n                msk = msk^(1<<(mp.get(s.charAt(i))+1));\\n            if(mps.containsKey(msk))\\n                ans= Math.max(ans,i-mps.get(msk));\\n            else\\n                mps.put(msk,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724007,
                "title": "sliding-window-technique-quite-easy-to-read",
                "content": "\\n\\nclass Solution {\\n\\n    public int findTheLongestSubstring(String s) {\\n        \\n        int[] map=new int[26];\\n        int[] vov={0,4,8,14,20};\\n        \\n        char[] ar=s.toCharArray();\\n        int n=ar.length;\\n        int l=0,maxlen=-1;\\n        \\n        \\n        for (int i=0;i<n;i++){\\n\\n            int v=ar[i]-\\'a\\';\\n            if (v==0 || v==4 || v==8 || v==14 || v==20){\\n                map[v]++;\\n            }\\n            int[] temp= Arrays.copyOf(map,map.length);\\n            while (temp[0]%2==1 || temp[4]%2==1||temp[8]%2==1||temp[14]%2==1 || temp[20]%2==1){\\n                int left=ar[l]-\\'a\\';\\n                if(left==0 || left==4 || left==8 ||left==14 ||left==20){\\n                    temp[left]--;\\n                }\\n                l++;\\n            }\\n            maxlen=Math.max(maxlen,i-l+1);\\n            l=0;\\n\\n        }\\n        \\n        return maxlen;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int findTheLongestSubstring(String s) {\\n        \\n        int[] map=new int[26];\\n        int[] vov={0,4,8,14,20}",
                "codeTag": "Java"
            },
            {
                "id": 722093,
                "title": "java-o-n-one-pass-solution-with-maps-with-string-keys",
                "content": "Use a String key to represent the state of all vowels (even or odd)\\nsubarray satisfying condition will be when the same exact state was first found\\n```\\nclass Solution {\\n    \\n    Map<Character, Integer> charToPosition = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 0); put(\\'e\\', 1); put(\\'i\\', 2); put(\\'o\\', 3); put(\\'u\\', 4);\\n        }\\n    };\\n    \\n    private String transition(String state, char vowel) {\\n        int position = charToPosition.get(vowel);\\n        String newBit = state.charAt(position) == \\'0\\' ? \"1\" : \"0\";\\n        StringBuffer sb = new StringBuffer(state);\\n        sb.replace(position, position + 1, newBit);\\n        return sb.toString();\\n    }\\n    \\n    public int findTheLongestSubstring(String s) {\\n        int answer = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        String state = \"00000\";\\n        map.put(state, -1);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (charToPosition.containsKey(c)) {\\n                state = transition(state, c);\\n                if (!map.containsKey(state)) {\\n                    map.put(state, i);\\n                }\\n            }\\n            answer = Math.max(answer, i - map.get(state));\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Map<Character, Integer> charToPosition = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 0); put(\\'e\\', 1); put(\\'i\\', 2); put(\\'o\\', 3); put(\\'u\\', 4);\\n        }\\n    };\\n    \\n    private String transition(String state, char vowel) {\\n        int position = charToPosition.get(vowel);\\n        String newBit = state.charAt(position) == \\'0\\' ? \"1\" : \"0\";\\n        StringBuffer sb = new StringBuffer(state);\\n        sb.replace(position, position + 1, newBit);\\n        return sb.toString();\\n    }\\n    \\n    public int findTheLongestSubstring(String s) {\\n        int answer = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        String state = \"00000\";\\n        map.put(state, -1);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (charToPosition.containsKey(c)) {\\n                state = transition(state, c);\\n                if (!map.containsKey(state)) {\\n                    map.put(state, i);\\n                }\\n            }\\n            answer = Math.max(answer, i - map.get(state));\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588983,
                "title": "convert-this-to-max-subarray-of-sum-equal-to-0",
                "content": "Well this is what i could come up with :), tired to write the explanation. however if u have any doubts or want an explanation feel free to ask in the comments.\\nThanks\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n       //convert the vowels in the string to 1 and -1 alternatively and we want the max substring length with sum equal to 0\\n        unordered_set<int> vowel;\\n        vector<int> arr;\\n        vowel.insert(\\'a\\');\\n        vowel.insert(\\'e\\');\\n        vowel.insert(\\'i\\');\\n        vowel.insert(\\'o\\');\\n        vowel.insert(\\'u\\');\\n        int a=1,e=10,i=100,o=1000,u=10000;\\n        for(auto x:s){\\n            if(vowel.find(x)!=vowel.end())\\n            {   if(x==\\'a\\')\\n                {\\n                  arr.push_back(a*1);\\n                  a*=-1;\\n                }\\n               if(x==\\'e\\')\\n                {\\n                  arr.push_back(e*1);\\n                  e*=-1;\\n                }\\n             if(x==\\'i\\')\\n                {\\n                  arr.push_back(i*1);\\n                  i*=-1;\\n                }\\n             if(x==\\'o\\')\\n                {\\n                  arr.push_back(o*1);\\n                  o*=-1;\\n                }\\n             if(x==\\'u\\')\\n                {\\n                  arr.push_back(u*1);\\n                  u*=-1;\\n                }\\n            \\n            }\\n            else\\n                arr.push_back(0);\\n        }\\n        //https://www.***.org/find-the-largest-subarray-with-0-sum/\\n        unordered_map<int, int> presum; \\n        int sum = 0; // Initialize the sum of elements \\n        int max_len = 0; // Initialize result \\n    // Traverse through the given array \\n        for (int i = 0; i <arr.size(); i++) { \\n        // Add current element to sum \\n            sum += arr[i]; \\n            if (arr[i] == 0 && max_len == 0) \\n                max_len = 1; \\n            if (sum == 0) \\n                max_len = i + 1; \\n            // Look for this sum in Hash table \\n            if (presum.find(sum) != presum.end()) { \\n                // If this sum is seen before, then update max_len \\n                max_len = max(max_len, i - presum[sum]); \\n            } \\n            else { \\n                // Else insert this sum with index in hash table \\n                presum[sum] = i; } } \\n    return max_len; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n       //convert the vowels in the string to 1 and -1 alternatively and we want the max substring length with sum equal to 0\\n        unordered_set<int> vowel;\\n        vector<int> arr;\\n        vowel.insert(\\'a\\');\\n        vowel.insert(\\'e\\');\\n        vowel.insert(\\'i\\');\\n        vowel.insert(\\'o\\');\\n        vowel.insert(\\'u\\');\\n        int a=1,e=10,i=100,o=1000,u=10000;\\n        for(auto x:s){\\n            if(vowel.find(x)!=vowel.end())\\n            {   if(x==\\'a\\')\\n                {\\n                  arr.push_back(a*1);\\n                  a*=-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 550370,
                "title": "c-concise-solution-using-bitmask-and-explained-thought-process",
                "content": "I was just revisiting another problem which is very similar in implementation before moving on to this problem: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n\\nI was initially completely stuck on this problem and thought it\\'s supposed to be a \"hard\" problem. I started with greedy, consider if one longest substring must be prefix and suffix but don\\'t think that\\'s the case.\\n\\nI then **simplified** the problem and think of only two digits 0 and 1, you would like to get longest consecutive subarray with even number of 1s. This is very classic problem and obviously we can consider the prefix sum of this array, and would like to pick two numbers with same parity that are farthest apart. We can implement with an index from parity (0, 1) to leftmost index, and check whenever current prefix sum parity matches that index, record its sum.\\n\\nThen it instantly strikes me that I can generalize it to a (parity count of \\'a\\', parity count of \\'e\\', ...) profile for each prefix. And it essentially become the simplified problem. The implementation is just the standard part. You can even consider using a hash map from \\'ae\\' (representing odd number of a and e, even number of i, o, u) to leftmost index of this prefix pattern\\'s occurrence.\\n\\nHope this thought process helps. My general recommendation is to simplify a problem whenever you can, and also identify similar patterns in other problems, convert the problem statement from string to array and vice versa.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> map = {\\n            {\\'a\\', 0},\\n            {\\'e\\', 1},\\n            {\\'i\\', 2},\\n            {\\'o\\', 3},\\n            {\\'u\\', 4},\\n        };\\n        int n = s.size();\\n        int best_l = 0;\\n        int mask = 0;\\n        unordered_map<int, int> index;\\n        index[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (map.find(s[i]) != map.end()) {\\n                mask ^= (1 << map.at(s[i]));\\n            }\\n            if (index.find(mask) != index.end()) {\\n                best_l = max(best_l, i - index.at(mask));\\n            } else index[mask] = i;\\n        }\\n        return best_l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> map = {\\n            {\\'a\\', 0},\\n            {\\'e\\', 1},\\n            {\\'i\\', 2},\\n            {\\'o\\', 3},\\n            {\\'u\\', 4},\\n        };\\n        int n = s.size();\\n        int best_l = 0;\\n        int mask = 0;\\n        unordered_map<int, int> index;\\n        index[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (map.find(s[i]) != map.end()) {\\n                mask ^= (1 << map.at(s[i]));\\n            }\\n            if (index.find(mask) != index.end()) {\\n                best_l = max(best_l, i - index.at(mask));\\n            } else index[mask] = i;\\n        }\\n        return best_l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531956,
                "title": "c-o-n-find-the-complementary-states-to-get-even-counts",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int FindTheLongestSubstring(string s)\\n    {\\n        Dictionary<char, int> vowels = new Dictionary<char, int>()\\n        {\\n            [\\'a\\'] = 1,\\n            [\\'e\\'] = 2,\\n            [\\'i\\'] = 4,\\n            [\\'o\\'] = 8,\\n            [\\'u\\'] = 16\\n        };\\n\\n        // Sum of all vowels visited once - max possible count of states\\n        int[] firstStateVisited = new int[32];\\n        for (int i = 0; i < firstStateVisited.Length; i++)\\n        {\\n            firstStateVisited[i] = -1;\\n        }\\n        firstStateVisited[0] = 0;\\n        int maxLength = 0;\\n        int currentState = 0;\\n\\n        for (int current = 0; current < s.Length; current++)\\n        {\\n            if (vowels.ContainsKey(s[current]))\\n            {\\n                currentState ^= vowels[s[current]];\\n            }\\n\\n            if (firstStateVisited[currentState] == -1)\\n            {\\n                firstStateVisited[currentState] = current + 1;\\n            }\\n\\n            maxLength = Math.Max(maxLength, current - firstStateVisited[currentState] + 1);                \\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int FindTheLongestSubstring(string s)\\n    {\\n        Dictionary<char, int> vowels = new Dictionary<char, int>()\\n        {\\n            [\\'a\\'] = 1,\\n            [\\'e\\'] = 2,\\n            [\\'i\\'] = 4,\\n            [\\'o\\'] = 8,\\n            [\\'u\\'] = 16\\n        };\\n\\n        // Sum of all vowels visited once - max possible count of states\\n        int[] firstStateVisited = new int[32];\\n        for (int i = 0; i < firstStateVisited.Length; i++)\\n        {\\n            firstStateVisited[i] = -1;\\n        }\\n        firstStateVisited[0] = 0;\\n        int maxLength = 0;\\n        int currentState = 0;\\n\\n        for (int current = 0; current < s.Length; current++)\\n        {\\n            if (vowels.ContainsKey(s[current]))\\n            {\\n                currentState ^= vowels[s[current]];\\n            }\\n\\n            if (firstStateVisited[currentState] == -1)\\n            {\\n                firstStateVisited[currentState] = current + 1;\\n            }\\n\\n            maxLength = Math.Max(maxLength, current - firstStateVisited[currentState] + 1);                \\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531916,
                "title": "c-o-n-bitmask-solution-similar-to-longest-subarray-w-sum-k",
                "content": "We use a bitmask to represent a state for whether each  vowel count is even or odd. Then, we just have to check if we have seen the same mask previously (if they subtract, we get all 0s, so the substring between these two indices is a valid substring). If we have, then we get the difference between the two, and check if it is greater than max. \\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(const string& s) {\\n        int max_ = 0;\\n        unordered_map<int, int> m = {{0,-1}};\\n        for(int i = 0, mask = 0, size = s.size(); i < size; ++i) {\\n            mask ^= (1<<(s[i]-\\'a\\'))&vowels;\\n            if(m.count(mask)) max_ = max(max_, i-m[mask]);\\n            else m[mask] = i;\\n        }\\n        return max_;\\n    }\\n    static const int vowels = 0 | (1<<(\\'a\\'-\\'a\\')) | (1<<(\\'e\\'-\\'a\\')) | (1<<(\\'i\\'-\\'a\\')) | (1<<(\\'o\\'-\\'a\\')) | (1<<(\\'u\\'-\\'a\\'));\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(const string& s) {\\n        int max_ = 0;\\n        unordered_map<int, int> m = {{0,-1}};\\n        for(int i = 0, mask = 0, size = s.size(); i < size; ++i) {\\n            mask ^= (1<<(s[i]-\\'a\\'))&vowels;\\n            if(m.count(mask)) max_ = max(max_, i-m[mask]);\\n            else m[mask] = i;\\n        }\\n        return max_;\\n    }\\n    static const int vowels = 0 | (1<<(\\'a\\'-\\'a\\')) | (1<<(\\'e\\'-\\'a\\')) | (1<<(\\'i\\'-\\'a\\')) | (1<<(\\'o\\'-\\'a\\')) | (1<<(\\'u\\'-\\'a\\'));\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4107053,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // taken help as for my code TLE T.C = (n^2);\\n\\n/*    static boolean check(String s){\\n        int n = s.length();\\n\\n        int arr[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            int a = s.charAt(i)-97;\\n            arr[a]++;\\n        }\\n\\n        if(arr[0]%2!=0 || arr[4]%2!=0 || arr[8]%2!=0 || arr[14]%2!=0 ||arr[20]%2!=0) return false;\\n        else return true; \\n    }\\n\\n    static int helper(String str){\\n        int ans = 0;\\n        int n = str.length();\\n        StringBuilder s = new StringBuilder(str);\\n\\n        for(int k=1; k<=n; k++){\\n            for(int i=0; i<=n-k; i++){\\n                String x = s.substring(i,i+k);\\n                if(check(x)){\\n                    ans = Math.max(ans,k);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int findTheLongestSubstring(String s) {\\n\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // taken help as for my code TLE T.C = (n^2);\\n\\n/*    static boolean check(String s){\\n        int n = s.length();\\n\\n        int arr[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            int a = s.charAt(i)-97;\\n            arr[a]++;\\n        }\\n\\n        if(arr[0]%2!=0 || arr[4]%2!=0 || arr[8]%2!=0 || arr[14]%2!=0 ||arr[20]%2!=0) return false;\\n        else return true; \\n    }\\n\\n    static int helper(String str){\\n        int ans = 0;\\n        int n = str.length();\\n        StringBuilder s = new StringBuilder(str);\\n\\n        for(int k=1; k<=n; k++){\\n            for(int i=0; i<=n-k; i++){\\n                String x = s.substring(i,i+k);\\n                if(check(x)){\\n                    ans = Math.max(ans,k);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int findTheLongestSubstring(String s) {\\n\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854980,
                "title": "java-fastest-solution-beats-100-xor",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026617,
                "title": "easy-c-intuitive-subarray-approach-unordered-map",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s)\\n    {\\n\\t\\n\\t\\n        //true - even\\n        //false - odd\\n        unordered_map<vector<bool>, int>mp;\\n\\t\\t//           [0s & 1s],  index\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        int a = 0;\\n        int e = 0;\\n        int i = 0;\\n        int o = 0;\\n        int u = 0;\\n        \\n        for(int j = 0; j<s.size(); j++)\\n        {\\n            if(s[j] == \\'a\\')\\n            {\\n                a++;\\n            }\\n            if(s[j] == \\'e\\')\\n            {\\n                e++;\\n            }\\n            if(s[j] == \\'i\\')\\n            {\\n                i++;\\n            }\\n            if(s[j] == \\'o\\')\\n            {\\n                o++;\\n            }\\n            if(s[j] == \\'u\\')\\n            {\\n                u++;\\n            }\\n            \\n            vector<bool>temp;\\n            temp.push_back(a%2);\\n            temp.push_back(e%2);\\n            temp.push_back(i%2);\\n            temp.push_back(o%2);\\n            temp.push_back(u%2);\\n            \\n            \\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n            {\\n\\t\\t\\t// if all evens \\n                ans = j+1;\\n            }\\n            else if(mp.find(temp) != mp.end())\\n            {\\n\\t\\t\\t// if patteren of odds and evens already present \\n                ans = max(ans, j - mp[temp]);\\n            }\\n            else\\n\\t\\t\\t// to store every unique pattern\\n                mp[temp] = j;\\n            \\n        }\\n\\t\\t\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s)\\n    {\\n\\t\\n\\t\\n        //true - even\\n        //false - odd\\n        unordered_map<vector<bool>, int>mp;\\n\\t\\t//           [0s & 1s],  index\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        int a = 0;\\n        int e = 0;\\n        int i = 0;\\n        int o = 0;\\n        int u = 0;\\n        \\n        for(int j = 0; j<s.size(); j++)\\n        {\\n            if(s[j] == \\'a\\')\\n            {\\n                a++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2291321,
                "title": "c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    //This problem is very much similar to \\'Subarray Sum equals k\\'\\n    //What we will try to do is :\\n    //1. we will create a bitmask that will signify us that whether the count of vowels is even or odd\\n    //2. we will store the index of first occurence of every unique bitmask in map\\n    //3. by using the idea in 2nd point while moving ahead if a bitmask repeats that means there is a substring that has even count of all the vowels b/w the curr index and the first occurence that was stored in the map, so we can simply update our answer by comparing the previous answer from such string\\n    \\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        unordered_map<char,int> bitvalue ={\\n            {\\'a\\',1},\\n            {\\'e\\',2},\\n            {\\'i\\',4},\\n            {\\'o\\',8},\\n            {\\'u\\',16}\\n        };\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            mask ^= bitvalue[s[i]];\\n            if(mask!=0 && !m.count(mask)){\\n                m[mask] = i;\\n            }\\n            ans = max(ans,i-m[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote** if you find this post useful",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //This problem is very much similar to \\'Subarray Sum equals k\\'\\n    //What we will try to do is :\\n    //1. we will create a bitmask that will signify us that whether the count of vowels is even or odd\\n    //2. we will store the index of first occurence of every unique bitmask in map\\n    //3. by using the idea in 2nd point while moving ahead if a bitmask repeats that means there is a substring that has even count of all the vowels b/w the curr index and the first occurence that was stored in the map, so we can simply update our answer by comparing the previous answer from such string\\n    \\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        unordered_map<char,int> bitvalue ={\\n            {\\'a\\',1},\\n            {\\'e\\',2},\\n            {\\'i\\',4},\\n            {\\'o\\',8},\\n            {\\'u\\',16}\\n        };\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            mask ^= bitvalue[s[i]];\\n            if(mask!=0 && !m.count(mask)){\\n                m[mask] = i;\\n            }\\n            ans = max(ans,i-m[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242173,
                "title": "simple-c-code-75-time-90-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool CheckVowels(char &m)\\n    {\\n        if(m == \\'a\\' || m == \\'e\\' || m == \\'i\\' || m == \\'o\\' || m == \\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> um;\\n        um[0] = 0;\\n        int curr = 0;\\n        int i = 1, ans = 0;\\n        for(char &ch : s)\\n        {\\n            if(CheckVowels(ch))\\n            {\\n                curr ^= ch;   \\n            }\\n            if(um.count(curr))\\n            {\\n                ans = max(i-um[curr], ans);\\n            }\\n            else\\n            {\\n                um[curr] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    bool CheckVowels(char &m)\\n    {\\n        if(m == \\'a\\' || m == \\'e\\' || m == \\'i\\' || m == \\'o\\' || m == \\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> um;\\n        um[0] = 0;\\n        int curr = 0;\\n        int i = 1, ans = 0;\\n        for(char &ch : s)\\n        {\\n            if(CheckVowels(ch))\\n            {\\n                curr ^= ch;   \\n            }\\n            if(um.count(curr))\\n            {\\n                ans = max(i-um[curr], ans);\\n            }\\n            else\\n            {\\n                um[curr] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192176,
                "title": "most-simple-and-easy-solution-bit-mask",
                "content": "```\\nclass Solution {\\n     public int findTheLongestSubstring(String s) {\\n        int res = 0 , mask = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();// key--> Mask, value--> Index\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){ // check only vowels and skip consonant\\n                int c=s.charAt(i);\\n                mask=mask ^ c;\\n                seen.putIfAbsent(mask, i);\\n            }            \\n            res = Math.max(res, i - seen.get(mask));\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int findTheLongestSubstring(String s) {\\n        int res = 0 , mask = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();// key--> Mask, value--> Index\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){ // check only vowels and skip consonant\\n                int c=s.charAt(i);\\n                mask=mask ^ c;\\n                seen.putIfAbsent(mask, i);\\n            }            \\n            res = Math.max(res, i - seen.get(mask));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155290,
                "title": "step-by-step-c-solution",
                "content": "* Do Xor with the mask if the character is vowel \\n* for others do nothing as (0 ^ a =a)\\n* use prefix sum concept and you will make it\\n```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0,ans=0;\\n        unordered_map<int,int>m;\\n        m[mask]=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(isvowel(s[i])){\\n                mask^=s[i];\\n            }\\n            if(m.count(mask)==0){\\n                m[mask]=i;\\n            }\\n            else{\\n                ans=max(ans,i-m[mask]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0,ans=0;\\n        unordered_map<int,int>m;\\n        m[mask]=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(isvowel(s[i])){\\n                mask^=s[i];\\n            }\\n            if(m.count(mask)==0){\\n                m[mask]=i;\\n            }\\n            else{\\n                ans=max(ans,i-m[mask]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141578,
                "title": "java-simple-and-elegant-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    int getVowelIndex(char ch){\\n        switch(ch){\\n            case \\'a\\' : return 0;\\n            case \\'e\\' : return 1;\\n            case \\'i\\' : return 2;\\n            case \\'o\\' : return 3;\\n            case \\'u\\' : return 4;\\n            default : return -1;\\n        }\\n    }\\n    public int findTheLongestSubstring(String s) {\\n        int mask = 32-1;\\n        int n = s.length(),res = 0;\\n        int dp[] = new int[mask+1];\\n        Arrays.fill(dp,-2);\\n        dp[mask] = -1;\\n        for(int i = 0 ; i<n ; i++){\\n            int idx = getVowelIndex(s.charAt(i));\\n            if(idx!=-1){\\n                mask^=(1<<idx);\\n            }\\n            if(dp[mask]!=-2){\\n                res = Math.max(res,i-dp[mask]);\\n            }else{\\n                dp[mask] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int getVowelIndex(char ch){\\n        switch(ch){\\n            case \\'a\\' : return 0;\\n            case \\'e\\' : return 1;\\n            case \\'i\\' : return 2;\\n            case \\'o\\' : return 3;\\n            case \\'u\\' : return 4;\\n            default : return -1;\\n        }\\n    }\\n    public int findTheLongestSubstring(String s) {\\n        int mask = 32-1;\\n        int n = s.length(),res = 0;\\n        int dp[] = new int[mask+1];\\n        Arrays.fill(dp,-2);\\n        dp[mask] = -1;\\n        for(int i = 0 ; i<n ; i++){\\n            int idx = getVowelIndex(s.charAt(i));\\n            if(idx!=-1){\\n                mask^=(1<<idx);\\n            }\\n            if(dp[mask]!=-2){\\n                res = Math.max(res,i-dp[mask]);\\n            }else{\\n                dp[mask] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646106,
                "title": "c-prefix-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<pair<int, int>> c;// storing vowels ans corresponding index in vector c\\n        vector<int >  t;\\n        int n = s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            {\\n                c.push_back({s[i],i});\\n                t.push_back(0);\\n            }\\n            else\\n                t.push_back(1);\\n        }\\n        \\n        // when there is no vowel, return s.length()\\n        if(c.size()==0)\\n            return n;\\n        //when there is only one vowel, return maximum of left and right substring of vowel length\\n        if(c.size()==1)\\n            return max(c[0].second,n-c[0].second-1);\\n        \\n        int max1 = INT_MIN;\\n        \\n        //considering only consonants, with 0 vowels means even vowels\\n        max1 = max(c[0].second, n-c.back().second-1);\\n        for(int i=1;i<c.size();i++)\\n            max1 = max(max1,c[i].second-c[i-1].second-1);\\n        \\n        // doing prefix XOR of vowels stored in vector c\\n        for(int i=1;i<c.size();i++)\\n            c[i].first^=c[i-1].first;\\n        \\n        // consdering vowels\\n        //calculating consonants before and after each vowel\\n        vector<int > left=t, right=t;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(left[i]==1)\\n                left[i]+=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(right[i]==1)\\n                right[i]+=right[i+1];\\n        }\\n        \\n        // sotring each prefix XOR in map with corresponding vector of index\\n        map<int, vector<int >> mp;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i].first].push_back(c[i].second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)// when prefix XOR is 0, means there is even count of all vowels from starting of string till index\\n            {\\n                int idx = it.second[it.second.size()-1];\\n                int sum1 = idx+1;\\n                if(idx<n-1)\\n                    sum1+=right[idx+1];\\n                max1 = max(max1,sum1);\\n            }\\n            else if(it.first!=0 && it.second.size()>1)// else when prefix XOR are equal\\n            {\\n                int idx1 = it.second[0],idx2 = it.second[it.second.size()-1];\\n                int sum1 = (idx2-idx1);\\n                if(idx2<n-1)\\n                    sum1+=right[idx2+1];\\n                max1 = max(max1, sum1);\\n            }\\n        }\\n        return max1;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<pair<int, int>> c;// storing vowels ans corresponding index in vector c\\n        vector<int >  t;\\n        int n = s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            {\\n                c.push_back({s[i],i});\\n                t.push_back(0);\\n            }\\n            else\\n                t.push_back(1);\\n        }\\n        \\n        // when there is no vowel, return s.length()\\n        if(c.size()==0)\\n            return n;\\n        //when there is only one vowel, return maximum of left and right substring of vowel length\\n        if(c.size()==1)\\n            return max(c[0].second,n-c[0].second-1);\\n        \\n        int max1 = INT_MIN;\\n        \\n        //considering only consonants, with 0 vowels means even vowels\\n        max1 = max(c[0].second, n-c.back().second-1);\\n        for(int i=1;i<c.size();i++)\\n            max1 = max(max1,c[i].second-c[i-1].second-1);\\n        \\n        // doing prefix XOR of vowels stored in vector c\\n        for(int i=1;i<c.size();i++)\\n            c[i].first^=c[i-1].first;\\n        \\n        // consdering vowels\\n        //calculating consonants before and after each vowel\\n        vector<int > left=t, right=t;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(left[i]==1)\\n                left[i]+=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(right[i]==1)\\n                right[i]+=right[i+1];\\n        }\\n        \\n        // sotring each prefix XOR in map with corresponding vector of index\\n        map<int, vector<int >> mp;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i].first].push_back(c[i].second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)// when prefix XOR is 0, means there is even count of all vowels from starting of string till index\\n            {\\n                int idx = it.second[it.second.size()-1];\\n                int sum1 = idx+1;\\n                if(idx<n-1)\\n                    sum1+=right[idx+1];\\n                max1 = max(max1,sum1);\\n            }\\n            else if(it.first!=0 && it.second.size()>1)// else when prefix XOR are equal\\n            {\\n                int idx1 = it.second[0],idx2 = it.second[it.second.size()-1];\\n                int sum1 = (idx2-idx1);\\n                if(idx2<n-1)\\n                    sum1+=right[idx2+1];\\n                max1 = max(max1, sum1);\\n            }\\n        }\\n        return max1;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530785,
                "title": "python-o-n-time-one-pass-solution",
                "content": "Use five bits to represent the vowels that have odd count, and record the left-most index for each status when they first show. Here is my code:\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        indices = {a:i for i, a in enumerate(\\'aeiou\\')}\\n        lefts = {0:-1}\\n        res = status = 0\\n        for right, a in enumerate(s):\\n            if a in indices:\\n                status ^= 1 << indices[a]\\n                if status not in lefts:\\n                    lefts[status] = right\\n            res = max(res, right - lefts[status])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        indices = {a:i for i, a in enumerate(\\'aeiou\\')}\\n        lefts = {0:-1}\\n        res = status = 0\\n        for right, a in enumerate(s):\\n            if a in indices:\\n                status ^= 1 << indices[a]\\n                if status not in lefts:\\n                    lefts[status] = right\\n            res = max(res, right - lefts[status])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428653,
                "title": "c-mask-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n      unordered_map<int,int> mp;\\n        int ans=0;\\n        int mask=0;\\n        mp[0]=-1;\\n        vector<int> v(27,0);\\n        v[\\'a\\'-97]=0;v[\\'e\\'-97]=1;v[\\'i\\'-97]=2;v[\\'o\\'-97]=3;v[\\'u\\'-97]=4;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int pos=v[s[i]-97];\\n                \\n                if(mask && (1<<pos))\\n                    mask=(mask^(1<<pos));\\n                else\\n                    mask=(mask|(1<<pos));\\n            }\\n            \\n            if(mp.count(mask))\\n              ans=max(ans,i-mp[mask]);  \\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n      unordered_map<int,int> mp;\\n        int ans=0;\\n        int mask=0;\\n        mp[0]=-1;\\n        vector<int> v(27,0);\\n        v[\\'a\\'-97]=0;v[\\'e\\'-97]=1;v[\\'i\\'-97]=2;v[\\'o\\'-97]=3;v[\\'u\\'-97]=4;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int pos=v[s[i]-97];\\n                \\n                if(mask && (1<<pos))\\n                    mask=(mask^(1<<pos));\\n                else\\n                    mask=(mask|(1<<pos));\\n            }\\n            \\n            if(mp.count(mask))\\n              ans=max(ans,i-mp[mask]);  \\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394700,
                "title": "c-solution-o-n",
                "content": "Runtime: 52 ms, faster than 91.94% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16 MB, less than 97.48% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n\\nNote: Solution taken from other post.\\n\\nThe solution of the problem uses the same technique as the solution of [525. Contiguous Array](https://leetcode.com/problems/contiguous-array/).\\n\\n```\\nHere we need to find the longest subarray containing even count of vowels only. We do not need to count\\nvowel occuerence but we need to track if the count is even or odd which we can do using bit mask. \\nAs there are 5 vowels so 00000 5 bit can have 2^5 combinations = 32 for the bit mask. 0 to 4th bit represents\\nthe even 0 or odd 1 count state of vowel a,e,i,o,u respectively. Now if the bit mask is zero then there is \\neven number of all vowels in substring range from 0 to ith index but if it is not zero then we have to \\nfind the previous occuerence of the current mask and the valid substring length will be the difference\\nbetween current index and previous occuerence of current mask index. As we found the mask again \\nthere is definately even count of vowels in between the range of previous occuerence index and current \\nindex as , previous mask + 0 = current mask. So, we store the index of mask when first time it occurs.\\nMask value can only be zero when substring occurs from the 0th index and so we do not update the \\nindex of Mask 0.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int sl = s.length();\\n        \\n        // track the first occuerence of mask\\n        vector<int> track(32,-1);\\n        \\n        // map vector for mask of vowels and non-vowels\\n        vector<int> v_map = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        // max substring length\\n        int maxL = 0;\\n        \\n        // current mask\\n        int mask = 0;\\n        \\n        // loop through item and update current mask from map vector\\n        // store the index of non-zero mask if it occurs first\\n        // calculate length of substring from previous mask index and update maxL \\n        for(int i=0;i<sl;i++)\\n        {\\n            mask^= v_map[s[i]-\\'a\\'];\\n            if(mask > 0 && track[mask]==-1)track[mask]=i;\\n            \\n            maxL = max(maxL,i-track[mask]);\\n        }        \\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we need to find the longest subarray containing even count of vowels only. We do not need to count\\nvowel occuerence but we need to track if the count is even or odd which we can do using bit mask. \\nAs there are 5 vowels so 00000 5 bit can have 2^5 combinations = 32 for the bit mask. 0 to 4th bit represents\\nthe even 0 or odd 1 count state of vowel a,e,i,o,u respectively. Now if the bit mask is zero then there is \\neven number of all vowels in substring range from 0 to ith index but if it is not zero then we have to \\nfind the previous occuerence of the current mask and the valid substring length will be the difference\\nbetween current index and previous occuerence of current mask index. As we found the mask again \\nthere is definately even count of vowels in between the range of previous occuerence index and current \\nindex as , previous mask + 0 = current mask. So, we store the index of mask when first time it occurs.\\nMask value can only be zero when substring occurs from the 0th index and so we do not update the \\nindex of Mask 0.\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int sl = s.length();\\n        \\n        // track the first occuerence of mask\\n        vector<int> track(32,-1);\\n        \\n        // map vector for mask of vowels and non-vowels\\n        vector<int> v_map = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        // max substring length\\n        int maxL = 0;\\n        \\n        // current mask\\n        int mask = 0;\\n        \\n        // loop through item and update current mask from map vector\\n        // store the index of non-zero mask if it occurs first\\n        // calculate length of substring from previous mask index and update maxL \\n        for(int i=0;i<sl;i++)\\n        {\\n            mask^= v_map[s[i]-\\'a\\'];\\n            if(mask > 0 && track[mask]==-1)track[mask]=i;\\n            \\n            maxL = max(maxL,i-track[mask]);\\n        }        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960820,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nSince there are 26 English letters in total, we can assign each bit of a 32-bit integer number to a letter. We deal with lower case English letters which means that `\"a\"` has a unicode value of `97` which is the smallest. If we subtract `97` from the unicode value of a vowel, we will be able to determine its corresponding bit in our number. If such a bit is set, the number of occurrences for the corresponding vowel in a substring starting from `0` and ending in a given position is odd. If it is unset, the occurrences are even.\\nSo in order to obtain a maximum length substring containing an even number of vowels which ends in a given position, we need to exclude the substring starting in position `0` and ending in the smallest position possible (it will be of the smallest length then) with the same vowel counts and therefore the same integer number. Subtracting an even number from an even numer and subtracting an odd number from an odd number will always lead to an even number. If there is a substring with this integer number, subtracting their vowel counts would lead to even counts only.\\n\\nIf an entry exists, we will be able to subtract the given index from the one stored in the hashmap to obtain the length of the maximum length substring. \\nHowever, if the integer number has occurred for the first time, it will be stored in the hashmap with the given index for further examinations.\\n\\nWe loop through each letter in `s` and determine, if possible, the length of the maximum substring ending in each position and store the highest one.\\n_____________________________\\n**Runtime Complexity**\\n`O(n)` for examining each input letter once (hashset and hashmap lookup and insertion is expected to be in `O(1)`).\\n____________________________\\n**Space Complexity**\\n`O(1)` for storing at maximum `2^5` numbers in the hashmap.\\n___________________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowel_counter_bit_mask = 0\\n        vowel_counter_bit_mask_to_index = {0: -1}\\n        ret = 0\\n        vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])        \\n        \\n        for i in range(len(s)):\\n            if (s[i] in vowels):\\n                vowel_counter_bit_mask ^= 1 << (ord(s[i]) - 97)\\n            \\n            if (vowel_counter_bit_mask in vowel_counter_bit_mask_to_index):\\n                ret = max(ret, i - vowel_counter_bit_mask_to_index[vowel_counter_bit_mask])\\n            else:\\n                vowel_counter_bit_mask_to_index[vowel_counter_bit_mask] = i\\n                \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowel_counter_bit_mask = 0\\n        vowel_counter_bit_mask_to_index = {0: -1}\\n        ret = 0\\n        vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])        \\n        \\n        for i in range(len(s)):\\n            if (s[i] in vowels):\\n                vowel_counter_bit_mask ^= 1 << (ord(s[i]) - 97)\\n            \\n            if (vowel_counter_bit_mask in vowel_counter_bit_mask_to_index):\\n                ret = max(ret, i - vowel_counter_bit_mask_to_index[vowel_counter_bit_mask])\\n            else:\\n                vowel_counter_bit_mask_to_index[vowel_counter_bit_mask] = i\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852187,
                "title": "c-solution-to-the-problem",
                "content": "\\n/*\\n\\'a\\':0\\n\\'e\\':1\\n\\'i\\':2\\n\\'o\\':3\\n\\'u\\':4\\n*/\\nTips:\\nFirst of all , we can  put this question in a different way: find the longest substring from index i to j in the  given string that has vowels in even counts.\\nif [i,j] meets the requirement, it means that s[i]  is in accordance with s[j]  with regard to the vowels in odd or even counts -- if vowels before  both\\ns[i] and s[j] are either even or odd, then j-i+1 is the the substring that meets our requirement. Then we can compare the result of j-i+1 with the current max substring \\n, if the former is greater, then we will update the current max substring, otherwise, continue.\\n\\nSecond of all, there are five vowels, so the combination of bitmap to illustrate their odd or even situation will be up to 32, that is, 00000- 11111, which is why we define an\\narray with 32 int elements, which is used to store the index of i for the first occurence of one of the odd or even situations while we scan the given string.\\n\\nLast but not the least,  while we scan the given string ,  we will see that if the index of status is -1, it means the first occurence of the situation, the index will be stored \\nin the array, otherwise, we will compare and update the current max substring.\\n\\n#define MAX(a,b) ((a>b)?a:b)\\nint findTheLongestSubstring(char * s){\\n\\n\\t\\tint result=0;\\n\\t\\tint s_len=strlen(s);\\n\\t\\tint status=0;\\n\\t\\tint position[32];\\n\\t\\tint ii;\\n\\t\\tfor(ii=0;ii<32;ii++){\\n\\t\\t\\tposition[ii]=-1;\\n\\t\\t}\\n\\t\\tposition[0]=0;\\n\\t\\tfor(ii=0;ii<s_len;ii++){\\t\\n\\t\\t\\t\\n\\t\\t\\tif(s[ii]==\\'a\\'){\\n\\t\\t\\t\\tstatus ^=(1<<0);\\n\\t\\t\\t}else if(s[ii] ==\\'e\\'){\\n\\t\\t\\t\\tstatus ^=(1<<1);\\n\\t\\t\\t}else if(s[ii] == \\'i\\'){\\n\\t\\t\\t\\tstatus ^=(1<<2);\\n\\t\\t\\t}else if(s[ii] == \\'o\\'){\\n\\t\\t\\t\\tstatus ^=(1<<3);\\n\\t\\t\\t}else if(s[ii] == \\'u\\'){\\n\\t\\t\\t\\tstatus ^=(1<<4);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(position[status] != -1){\\n\\t\\t\\t\\tresult=MAX(result, ii+1- position[status]);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tposition[status]=ii+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n}",
                "solutionTags": [],
                "code": "\\n/*\\n\\'a\\':0\\n\\'e\\':1\\n\\'i\\':2\\n\\'o\\':3\\n\\'u\\':4\\n*/\\nTips:\\nFirst of all , we can  put this question in a different way: find the longest substring from index i to j in the  given string that has vowels in even counts.\\nif [i,j] meets the requirement, it means that s[i]  is in accordance with s[j]  with regard to the vowels in odd or even counts -- if vowels before  both\\ns[i] and s[j] are either even or odd, then j-i+1 is the the substring that meets our requirement. Then we can compare the result of j-i+1 with the current max substring \\n, if the former is greater, then we will update the current max substring, otherwise, continue.\\n\\nSecond of all, there are five vowels, so the combination of bitmap to illustrate their odd or even situation will be up to 32, that is, 00000- 11111, which is why we define an\\narray with 32 int elements, which is used to store the index of i for the first occurence of one of the odd or even situations while we scan the given string.\\n\\nLast but not the least,  while we scan the given string ,  we will see that if the index of status is -1, it means the first occurence of the situation, the index will be stored \\nin the array, otherwise, we will compare and update the current max substring.\\n\\n#define MAX(a,b) ((a>b)?a:b)\\nint findTheLongestSubstring(char * s){\\n\\n\\t\\tint result=0;\\n\\t\\tint s_len=strlen(s);\\n\\t\\tint status=0;\\n\\t\\tint position[32];\\n\\t\\tint ii;\\n\\t\\tfor(ii=0;ii<32;ii++){\\n\\t\\t\\tposition[ii]=-1;\\n\\t\\t}\\n\\t\\tposition[0]=0;\\n\\t\\tfor(ii=0;ii<s_len;ii++){\\t\\n\\t\\t\\t\\n\\t\\t\\tif(s[ii]==\\'a\\'){\\n\\t\\t\\t\\tstatus ^=(1<<0);\\n\\t\\t\\t}else if(s[ii] ==\\'e\\'){\\n\\t\\t\\t\\tstatus ^=(1<<1);\\n\\t\\t\\t}else if(s[ii] == \\'i\\'){\\n\\t\\t\\t\\tstatus ^=(1<<2);\\n\\t\\t\\t}else if(s[ii] == \\'o\\'){\\n\\t\\t\\t\\tstatus ^=(1<<3);\\n\\t\\t\\t}else if(s[ii] == \\'u\\'){\\n\\t\\t\\t\\tstatus ^=(1<<4);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(position[status] != -1){\\n\\t\\t\\t\\tresult=MAX(result, ii+1- position[status]);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tposition[status]=ii+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 841821,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def countVowels(ct):\\n            if not ct[\\'a\\'] % 2 and not ct[\\'e\\'] % 2 and not ct[\\'i\\'] % 2 and not ct[\\'o\\'] % 2 and not ct[\\'u\\'] % 2:\\n                return True\\n            return False\\n\\n        #Reducer\\n            #Slider\\n            #0 - len(s)\\n            #0 - len(s) -1 -> 1 - len(s)\\n        for i in range(len(s)):\\n            ctr = collections.Counter(s[:len(s) - i])\\n            for j in range(i+1):\\n                #window = s[j:(len(s)+j) - i]\\n                if j != 0:\\n                    ctr[s[j - 1]] -= 1\\n                    ctr[s[len(s)+j - i - 1]] += 1\\n                if countVowels(ctr):\\n                    return sum(ctr.values())\\n        return 0\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def countVowels(ct):\\n            if not ct[\\'a\\'] % 2 and not ct[\\'e\\'] % 2 and not ct[\\'i\\'] % 2 and not ct[\\'o\\'] % 2 and not ct[\\'u\\'] % 2:\\n                return True\\n            return False\\n\\n        #Reducer\\n            #Slider\\n            #0 - len(s)\\n            #0 - len(s) -1 -> 1 - len(s)\\n        for i in range(len(s)):\\n            ctr = collections.Counter(s[:len(s) - i])\\n            for j in range(i+1):\\n                #window = s[j:(len(s)+j) - i]\\n                if j != 0:\\n                    ctr[s[j - 1]] -= 1\\n                    ctr[s[len(s)+j - i - 1]] += 1\\n                if countVowels(ctr):\\n                    return sum(ctr.values())\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 797518,
                "title": "could-i-be-more-simpler-c-beats-91",
                "content": "> Appraoch\\n1. We count the vowels using xor and bitmask\\n2. for a particular vowel the corresponding bit is set( = 1 in mask) if its count is odd uptill now and \\n3. bit is unset ( = 0 in mask) if its count is even \\n4. we store the odd/even count as bit mask\\n5. there can be at max 32 states \\n\\n> Algorithm\\n\\n```\\n\\tbool isVowel(char &c) {\\n        return (c == \\'a\\'||c == \\'e\\'||c == \\'i\\'||c == \\'o\\'||c == \\'u\\');\\n    }\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> pos;\\n\\t\\t// we map the character to bit positions\\n        pos[\\'a\\'] = 0, pos[\\'e\\'] = 1, pos[\\'i\\'] = 2, pos[\\'o\\'] = 3, pos[\\'u\\'] = 4;\\n        \\n        int n = s.length();\\n\\t\\t// array to store first occurance of a mask\\n        vector<int> firstOcc(64, n);\\n\\t\\t// first occurance of mask 0 is at -1\\n        firstOcc[0] = -1;\\n        int mask = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update mask\\n                mask ^= (1 << pos[s[i]]);\\n            }\\n\\t\\t\\t// update ans \\n            ans = max(ans, i - firstOcc[mask]);\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update the first occurance of the mask\\n                firstOcc[mask] = min(firstOcc[mask], i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool isVowel(char &c) {\\n        return (c == \\'a\\'||c == \\'e\\'||c == \\'i\\'||c == \\'o\\'||c == \\'u\\');\\n    }\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> pos;\\n\\t\\t// we map the character to bit positions\\n        pos[\\'a\\'] = 0, pos[\\'e\\'] = 1, pos[\\'i\\'] = 2, pos[\\'o\\'] = 3, pos[\\'u\\'] = 4;\\n        \\n        int n = s.length();\\n\\t\\t// array to store first occurance of a mask\\n        vector<int> firstOcc(64, n);\\n\\t\\t// first occurance of mask 0 is at -1\\n        firstOcc[0] = -1;\\n        int mask = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update mask\\n                mask ^= (1 << pos[s[i]]);\\n            }\\n\\t\\t\\t// update ans \\n            ans = max(ans, i - firstOcc[mask]);\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update the first occurance of the mask\\n                firstOcc[mask] = min(firstOcc[mask], i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781672,
                "title": "c-one-pass-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        int mask = 0;\\n        vector<int> dp(32, s.length());\\n        map<char,int> vo_map = {{\\'a\\',0},{\\'e\\',1},{\\'i\\',2},{\\'o\\',3},{\\'u\\',4}};\\n        dp[0] = -1;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (vo_map.find(s[i]) == vo_map.end()) {\\n                ans = max(ans, i - dp[mask]);\\n                continue;\\n            }\\n            mask ^= (1 << vo_map[s[i]]);\\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        int mask = 0;\\n        vector<int> dp(32, s.length());\\n        map<char,int> vo_map = {{\\'a\\',0},{\\'e\\',1},{\\'i\\',2},{\\'o\\',3},{\\'u\\',4}};\\n        dp[0] = -1;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (vo_map.find(s[i]) == vo_map.end()) {\\n                ans = max(ans, i - dp[mask]);\\n                continue;\\n            }\\n            mask ^= (1 << vo_map[s[i]]);\\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767408,
                "title": "the-key-idea-is-to-use-5-bit-to-store-the-odd-even-state-for-5-vowels",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        int state = 0;\\n        static string vowels(\"aeiou\");\\n        static unordered_map<char, int> masks{{\\'a\\', 1}, {\\'e\\', 2}, {\\'i\\', 4}, {\\'o\\', 8}, {\\'u\\', 16}};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (vowels.find(s[i]) != string::npos) {\\n                state ^= masks[s[i]];\\n            }\\n            if (states[state] == -2) {\\n                states[state] = i;\\n            } else {\\n                ans = max(ans, i - states[state]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        int state = 0;\\n        static string vowels(\"aeiou\");\\n        static unordered_map<char, int> masks{{\\'a\\', 1}, {\\'e\\', 2}, {\\'i\\', 4}, {\\'o\\', 8}, {\\'u\\', 16}};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (vowels.find(s[i]) != string::npos) {\\n                state ^= masks[s[i]];\\n            }\\n            if (states[state] == -2) {\\n                states[state] = i;\\n            } else {\\n                ans = max(ans, i - states[state]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661453,
                "title": "simple-and-concise-solution-java",
                "content": "```\\npublic int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'a\\':\\n                    state ^= 1 << 0;\\n                    break;\\n                case \\'e\\':\\n                    state ^= 1 << 1;\\n                    break;\\n                case \\'i\\':\\n                    state ^= 1 << 2;\\n                    break;\\n                case \\'o\\':\\n                    state ^= 1 << 3;\\n                    break;\\n                case \\'u\\':\\n                    state ^= 1 << 4;\\n                    break;\\n                default:\\n                    break;\\n            }\\n            if (map.containsKey(state)) {\\n                res = Math.max(res, i - map.get(state)); \\n            } else {\\n                map.put(state, i);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'a\\':\\n                    state ^= 1 << 0;\\n                    break;\\n                case \\'e\\':\\n                    state ^= 1 << 1;\\n                    break;\\n                case \\'i\\':\\n                    state ^= 1 << 2;\\n                    break;\\n                case \\'o\\':\\n                    state ^= 1 << 3;\\n                    break;\\n                case \\'u\\':\\n                    state ^= 1 << 4;\\n                    break;\\n                default:\\n                    break;\\n            }\\n            if (map.containsKey(state)) {\\n                res = Math.max(res, i - map.get(state)); \\n            } else {\\n                map.put(state, i);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 602701,
                "title": "1371-find-the-longest-substring-containing-vowels-in-even-counts-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Prefix State with HashMap**\\n| O(T): O(n) | O(S): O(1) | Rt: 2736ms | \\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        last, dt = {\\'00000\\': -1}, {i: 0 for i in \\'aeiou\\'}\\n        for i in range(l):\\n            if s[i] in dt: dt[s[i]] ^= 1\\n            k = \\'\\'.join(str(dt[k]) for k in \\'aeiou\\')\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\\n\\nAlternative: | Rt: 436ms |\\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        k, last, mask = 0, {0: -1}, {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n        for i in range(l):\\n            if s[i] in mask: k ^= mask[s[i]]\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\\nReferrence: https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531850/Python-solution-in-O(n)-time-and-O(1)-space-explained",
                "solutionTags": [],
                "code": "```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        last, dt = {\\'00000\\': -1}, {i: 0 for i in \\'aeiou\\'}\\n        for i in range(l):\\n            if s[i] in dt: dt[s[i]] ^= 1\\n            k = \\'\\'.join(str(dt[k]) for k in \\'aeiou\\')\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        k, last, mask = 0, {0: -1}, {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n        for i in range(l):\\n            if s[i] in mask: k ^= mask[s[i]]\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 578155,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nUse a bitmask to encode the vowel state per index as a single integer value.  Either there are an even or odd amount of each vowel, the following values are added when there is an odd amount and removed when there is an even amount per each vowel.\\n```\\na == 1\\ne == 2\\ni == 4\\no == 8\\nu == 16\\n```\\n\\nUse an array `A` to create an ongoing prefix-xor sum of encoded vowel states.  xor is used because we only care about even amounts of vowels, thus xor acts as a toggle to add/remove vowels from the ongoing prefix-xor sum.  For each character in `S`, there are 2 cases to consider:\\n\\n* **Case 1:** if the character is a *not* vowel, then set the ongoing prefix-xor sum `A[i]` equal to the previous prefix-xor sum `A[i - 1]`.  (Since there are no additional vowels to add/remove, the prefix-xor sum for `A[i]` remains the same as it\\'s previous prefix-xor sum `A[i - 1]`.)\\n* **Case 2:** if the character is a vowel, then set the ongoing prefix-xor sum `A[i]` equal to the previous prefix-xor sum `A[i - 1]` xor\\'ed with the encoded vowel value.  (This xor either adds or removes the vowel from the ongoing prefix-xor sum).\\n\\nTrack the index of each `first` `seen` prefix-xor sum `A[i]` to find and return the maximum delta between the current index `i` and each `first` `seen` prefix-xor sum `A[i]`.\\n\\n**Examples:**\\n\\n*Example 0:*\\n\\nIf input = \"leet\", notice how `2` is added for the first `e` since the count of `e` is odd, and notice how `2` is removed for the second `e` since the count of `e` is even:\\n\\n```\\n      l e e t\\n      0 1 2 3 4\\nA = 0 0 2 0 0\\n    0 1 2 3 4 5\\n```\\n\\nThe answer is the index of the right-most `0` minus the index of the left-most `0`, ie. `4 - 0 = 4`.\\n\\n*Example 1:* note the value `X` in `A` is actually `10`, I wrote `X` since its a single character which aligns better for readability:\\n\\n```\\n      e l e e t m i n i c o w o r o e p\\n\\t  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\\nA = 0 2 2 0 2 2 2 6 6 2 2 X X 2 2 X 8 8 \\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\\n```\\n\\nThe answer is the index of the right-most `2` minus the index of the left-most `2`, ie. `14 - 1 = 13`.\\n\\n**Versbose Solutions:** this solution may be easier to \"see\" with verbose code\\n\\n*Javascript*\\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => 1 << V.indexOf(c);\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        if (V.indexOf(S[i - 1]) == -1) // A[i] is not a vowel\\n            A[i] = A[i - 1];\\n        else                           // A[i] is a vowel\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        if (seen.has(A[i]))\\n            max = Math.max(max, i - seen.get(A[i])); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        else\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n    }\\n    return max;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) { return 1 << V.find(c); };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            if (V.find(S[i - 1]) == string::npos) // A[i] is not a vowel\\n                A[i] = A[i - 1];\\n            else                                  // A[i] is a vowel\\n                A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            if (seen.find(A[i]) != seen.end())\\n                max = std::max(max, i - seen[A[i]]); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n            else\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```\\n\\n**Concise Solutions:** note `x ^ 0 == x`, thus we can encode non-vowels as `0`\\n\\n*Javascript:*\\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => {\\n        let i = V.indexOf(c);\\n        return i == -1 ? 0 : 1 << i;\\n    };\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        let first = seen.has(A[i]) ? seen.get(A[i]) : i;\\n        if (first == i)\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n        max = Math.max(max, i - first);  // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n    }\\n    return max;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) {\\n            auto i = V.find(c);\\n            return i == string::npos ? 0 : 1 << i;\\n        };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            auto first = seen.find(A[i]) != seen.end() ? seen[A[i]] : i;\\n            if (first == i)\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n            max = std::max(max, i - first); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\na == 1\\ne == 2\\ni == 4\\no == 8\\nu == 16\\n```\n```\\n      l e e t\\n      0 1 2 3 4\\nA = 0 0 2 0 0\\n    0 1 2 3 4 5\\n```\n```\\n      e l e e t m i n i c o w o r o e p\\n\\t  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\\nA = 0 2 2 0 2 2 2 6 6 2 2 X X 2 2 X 8 8 \\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\\n```\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => 1 << V.indexOf(c);\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        if (V.indexOf(S[i - 1]) == -1) // A[i] is not a vowel\\n            A[i] = A[i - 1];\\n        else                           // A[i] is a vowel\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        if (seen.has(A[i]))\\n            max = Math.max(max, i - seen.get(A[i])); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        else\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) { return 1 << V.find(c); };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            if (V.find(S[i - 1]) == string::npos) // A[i] is not a vowel\\n                A[i] = A[i - 1];\\n            else                                  // A[i] is a vowel\\n                A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            if (seen.find(A[i]) != seen.end())\\n                max = std::max(max, i - seen[A[i]]); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n            else\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => {\\n        let i = V.indexOf(c);\\n        return i == -1 ? 0 : 1 << i;\\n    };\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        let first = seen.has(A[i]) ? seen.get(A[i]) : i;\\n        if (first == i)\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n        max = Math.max(max, i - first);  // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) {\\n            auto i = V.find(c);\\n            return i == string::npos ? 0 : 1 << i;\\n        };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            auto first = seen.find(A[i]) != seen.end() ? seen[A[i]] : i;\\n            if (first == i)\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n            max = std::max(max, i - first); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539657,
                "title": "java-beats-100-memory-usage-o-n-time-complexity",
                "content": "The solution is inspired by other discussions in the forum and my thanks and credits to them.\\n\\nExplanation :\\na. Using last 5 bits of an integer is like maintaining  5 booleans to mark if the state.\\nb. when the state of all 5 booleans are same at 2 different spots in parsing a string s, then those 2 spots potentially have even number of vowles in between. \\nc. better explanation and inspiration to this code\\nhttps://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534210/Dew-It-or-Simple-illustration-for-THE-trick\\n\\n\\nCode:\\n```\\npublic int findTheLongestSubstring(String s) {\\n\\n        List<String> vowles = new ArrayList<>(Arrays.asList(\"a\", \"e\", \"i\", \"o\", \"u\"));\\n        List<String> splitInputString = IntStream.range(0, s.length()).mapToObj(x -> String.valueOf(s.charAt(x))).collect(Collectors.toList());\\n        Map<Integer, Integer> maskToIndexMap = new HashMap<>();\\n        maskToIndexMap.put(0, -1);\\n        int mask = 0;\\n        int result = 0;\\n        for (int i = 0; i < splitInputString.size(); i++) {\\n            if (vowles.contains(splitInputString.get(i))) {\\n                mask = mask ^ (1 << vowles.indexOf(splitInputString.get(i)) + 1);\\n            }\\n            if (!maskToIndexMap.containsKey(mask)) {\\n                maskToIndexMap.put(mask, i);\\n            }\\n            result = Math.max(i - maskToIndexMap.get(mask), result);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n\\n        List<String> vowles = new ArrayList<>(Arrays.asList(\"a\", \"e\", \"i\", \"o\", \"u\"));\\n        List<String> splitInputString = IntStream.range(0, s.length()).mapToObj(x -> String.valueOf(s.charAt(x))).collect(Collectors.toList());\\n        Map<Integer, Integer> maskToIndexMap = new HashMap<>();\\n        maskToIndexMap.put(0, -1);\\n        int mask = 0;\\n        int result = 0;\\n        for (int i = 0; i < splitInputString.size(); i++) {\\n            if (vowles.contains(splitInputString.get(i))) {\\n                mask = mask ^ (1 << vowles.indexOf(splitInputString.get(i)) + 1);\\n            }\\n            if (!maskToIndexMap.containsKey(mask)) {\\n                maskToIndexMap.put(mask, i);\\n            }\\n            result = Math.max(i - maskToIndexMap.get(mask), result);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537171,
                "title": "rust-solution-24ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let m: HashMap<char, i32> = [(\\'a\\', 1), (\\'e\\', 2), (\\'i\\', 4), (\\'o\\', 8), (\\'u\\', 16)]\\n            .iter()\\n            .cloned()\\n            .collect();\\n        let (mut res, mut mask) = (0, 0);\\n        let mut last = vec![-1; 32];\\n\\n        for (i, c) in s.chars().enumerate() {\\n            if m.contains_key(&c) {\\n                mask ^= m[&c];\\n            }\\n\\n            if mask == 0 {\\n                res = i as i32 + 1;\\n            } else if last[mask as usize] == -1 {\\n                last[mask as usize] = i as i32;\\n            } else {\\n                res = std::cmp::max(res, i as i32 - last[mask as usize]);\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let m: HashMap<char, i32> = [(\\'a\\', 1), (\\'e\\', 2), (\\'i\\', 4), (\\'o\\', 8), (\\'u\\', 16)]\\n            .iter()\\n            .cloned()\\n            .collect();\\n        let (mut res, mut mask) = (0, 0);\\n        let mut last = vec![-1; 32];\\n\\n        for (i, c) in s.chars().enumerate() {\\n            if m.contains_key(&c) {\\n                mask ^= m[&c];\\n            }\\n\\n            if mask == 0 {\\n                res = i as i32 + 1;\\n            } else if last[mask as usize] == -1 {\\n                last[mask as usize] = i as i32;\\n            } else {\\n                res = std::cmp::max(res, i as i32 - last[mask as usize]);\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532880,
                "title": "java-o-n-solution-using-hashmap",
                "content": "Concept: Since there are 5 vowels, so there can be 2^5=32 states (each vowel is repeated either odd or even times). Frame a hashmap with key as a string consisting of the states of each vowel (true if even, false if odd) and value as an arraylist of indices of the given string at which this state is achieved. Since initially all the vowels are 0(even), first store -1 in \\'all true\\' state, then iterate each character on-by-one. Then subtract the minimum value from the maximum value of each of the arraylists of the hashset and find the maximum difference.\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char c;\\n        boolean arr[]=new boolean [5]; // state storing array.\\n        HashMap<String,ArrayList<Integer>>hmap=new HashMap<>();\\n        Arrays.fill(arr,true); // initially all are true.\\n        String str; // to frame the key for the hashmap.\\n        str=\"true true true true true\";\\n        hmap.put(str,new ArrayList<>());\\n        hmap.get(str).add(-1); // add -1 initially to the \\'all true\\' state arraylist.\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n\\t\\t\\t// filp each state accordingly.\\n            if(c==\\'a\\')\\n                arr[0]=!arr[0];\\n            else if(c==\\'e\\')\\n                arr[1]=!arr[1];\\n            else if(c==\\'i\\')\\n                arr[2]=!arr[2];\\n            else if(c==\\'o\\')\\n                arr[3]=!arr[3];\\n            else if(c==\\'u\\')\\n                arr[4]=!arr[4];         \\n\\t\\t\\t\\t\\n            str=arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]+\" \"+arr[4]; // frame key.\\n            hmap.putIfAbsent(str,new ArrayList<>()); \\n            hmap.get(str).add(i); // add the index.\\n        }\\n        int max=0; // to store the maximum length.\\n        ArrayList<Integer> list;\\n        for(String p:hmap.keySet()){\\n            list=hmap.get(p);\\n\\t\\t\\t// subtract the minimum index from the maximum index.\\n            max=Math.max(max,list.get(list.size()-1)-list.get(0));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char c;\\n        boolean arr[]=new boolean [5]; // state storing array.\\n        HashMap<String,ArrayList<Integer>>hmap=new HashMap<>();\\n        Arrays.fill(arr,true); // initially all are true.\\n        String str; // to frame the key for the hashmap.\\n        str=\"true true true true true\";\\n        hmap.put(str,new ArrayList<>());\\n        hmap.get(str).add(-1); // add -1 initially to the \\'all true\\' state arraylist.\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n\\t\\t\\t// filp each state accordingly.\\n            if(c==\\'a\\')\\n                arr[0]=!arr[0];\\n            else if(c==\\'e\\')\\n                arr[1]=!arr[1];\\n            else if(c==\\'i\\')\\n                arr[2]=!arr[2];\\n            else if(c==\\'o\\')\\n                arr[3]=!arr[3];\\n            else if(c==\\'u\\')\\n                arr[4]=!arr[4];         \\n\\t\\t\\t\\t\\n            str=arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]+\" \"+arr[4]; // frame key.\\n            hmap.putIfAbsent(str,new ArrayList<>()); \\n            hmap.get(str).add(i); // add the index.\\n        }\\n        int max=0; // to store the maximum length.\\n        ArrayList<Integer> list;\\n        for(String p:hmap.keySet()){\\n            list=hmap.get(p);\\n\\t\\t\\t// subtract the minimum index from the maximum index.\\n            max=Math.max(max,list.get(list.size()-1)-list.get(0));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532326,
                "title": "java-bit-mask-solution-with-explaination",
                "content": "```\\nclass Solution {\\n    /**\\n    for each odd number, there just two kinds of times, \\n    times%2==1, times%2==0  (the arg is notEven)\\n    \\n    if times%2==1 that means if we mask the bit for each vow(a->0. e->1, i->2, o->3, u->4), must be one vow\\n    take \\'^\\' times is not even\\n    i- NotEvenIdx, means we get len as abstract the even not even number happened at notEven index\\n    that means, if we get a odd times if vow, like 5, and first time happen at 3, then 3rd happens at 5\\n    we can get the len as 5-3=2, it is equals we count as 5,4\\n    \\n    if notEven is even, that means every vow is on even times from the start\\n    **/\\n    public int findTheLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>(7);\\n        map.put(\\'a\\', 0);\\n        map.put(\\'e\\', 1);\\n        map.put(\\'i\\', 2);\\n        map.put(\\'o\\', 3);\\n        map.put(\\'u\\', 4);\\n        int len=0;\\n        Map<Integer, Integer> notEvenHappens = new HashMap<>(22);\\n        int notEven=0;\\n        //init for length cal\\n        notEvenHappens.put(0, -1);\\n        for(int i=0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)) notEven ^= 1<<map.get(ch);\\n            notEvenHappens.putIfAbsent(notEven, i);\\n            len=Math.max(len, i-notEvenHappens.get(notEven));\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n    for each odd number, there just two kinds of times, \\n    times%2==1, times%2==0  (the arg is notEven)\\n    \\n    if times%2==1 that means if we mask the bit for each vow(a->0. e->1, i->2, o->3, u->4), must be one vow\\n    take \\'^\\' times is not even\\n    i- NotEvenIdx, means we get len as abstract the even not even number happened at notEven index\\n    that means, if we get a odd times if vow, like 5, and first time happen at 3, then 3rd happens at 5\\n    we can get the len as 5-3=2, it is equals we count as 5,4\\n    \\n    if notEven is even, that means every vow is on even times from the start\\n    **/\\n    public int findTheLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>(7);\\n        map.put(\\'a\\', 0);\\n        map.put(\\'e\\', 1);\\n        map.put(\\'i\\', 2);\\n        map.put(\\'o\\', 3);\\n        map.put(\\'u\\', 4);\\n        int len=0;\\n        Map<Integer, Integer> notEvenHappens = new HashMap<>(22);\\n        int notEven=0;\\n        //init for length cal\\n        notEvenHappens.put(0, -1);\\n        for(int i=0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)) notEven ^= 1<<map.get(ch);\\n            notEvenHappens.putIfAbsent(notEven, i);\\n            len=Math.max(len, i-notEvenHappens.get(notEven));\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531940,
                "title": "c-o-n-solution-with-state-compression-32-states",
                "content": "0 means the number of occurrence of the vowel is even\\n1 means the number of occurrence of the vowel is odd\\n32 states:\\na:0,e:0,i:0,o:0,u:0\\na:1,e:0,i:0,o:0,u:0\\n......\\na:1,e:1,i:1,o:1,u:1\\n\\n```\\nclass Solution \\n{\\n    public:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int result=0;\\n        int n=s.length();\\n        int current=0;\\n        unordered_map<char,int> m;\\n        m[\\'a\\']=0;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=2;\\n        m[\\'o\\']=3;\\n        m[\\'u\\']=4;\\n        int overall[32];\\n        for(int i=0;i<32;i++)\\n            overall[i]=-1;\\n       \\n        overall[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m.find(s[i])!=m.end())\\n                current=current^((int)pow(2,m[s[i]]));\\n        \\n            if(overall[current]!=-1)\\n                result=max(result,i+1-overall[current]);\\n            else\\n                overall[current]=i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int result=0;\\n        int n=s.length();\\n        int current=0;\\n        unordered_map<char,int> m;\\n        m[\\'a\\']=0;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=2;\\n        m[\\'o\\']=3;\\n        m[\\'u\\']=4;\\n        int overall[32];\\n        for(int i=0;i<32;i++)\\n            overall[i]=-1;\\n       \\n        overall[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m.find(s[i])!=m.end())\\n                current=current^((int)pow(2,m[s[i]]));\\n        \\n            if(overall[current]!=-1)\\n                result=max(result,i+1-overall[current]);\\n            else\\n                overall[current]=i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531835,
                "title": "easy-c-solution-with-dictionary",
                "content": "```\\n    public class Solution\\n    {\\n        public int FindTheLongestSubstring(string s)\\n        {\\n            int res = 0;\\n            ISet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n            \\n            IDictionary<char, int> vowel2Count = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},\\n                {\\'e\\', 0},\\n                {\\'i\\', 0},\\n                {\\'o\\', 0},\\n                {\\'u\\', 0}\\n            };\\n\\n            IDictionary<string, int> key2Index = new Dictionary<string, int>()\\n            {\\n                {\"a0e0i0o0u0\", -1 }\\n            };\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                var c = s[i];\\n                if (vowels.Contains(c))\\n                {\\n                    vowel2Count[c]++;\\n                }\\n\\n                string key = $\"a{vowel2Count[\\'a\\'] % 2}e{vowel2Count[\\'e\\'] % 2}i{vowel2Count[\\'i\\'] % 2}o{vowel2Count[\\'o\\'] % 2}u{vowel2Count[\\'u\\'] % 2}\";\\n\\n                if (key2Index.ContainsKey(key))\\n                {\\n                    res = Math.Max(res, i - (key2Index[key]));\\n                }\\n\\t\\t\\t\\telse\\n                {\\n                    key2Index[key] = i;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int FindTheLongestSubstring(string s)\\n        {\\n            int res = 0;\\n            ISet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n            \\n            IDictionary<char, int> vowel2Count = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},\\n                {\\'e\\', 0},\\n                {\\'i\\', 0},\\n                {\\'o\\', 0},\\n                {\\'u\\', 0}\\n            };\\n\\n            IDictionary<string, int> key2Index = new Dictionary<string, int>()\\n            {\\n                {\"a0e0i0o0u0\", -1 }\\n            };\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                var c = s[i];\\n                if (vowels.Contains(c))\\n                {\\n                    vowel2Count[c]++;\\n                }\\n\\n                string key = $\"a{vowel2Count[\\'a\\'] % 2}e{vowel2Count[\\'e\\'] % 2}i{vowel2Count[\\'i\\'] % 2}o{vowel2Count[\\'o\\'] % 2}u{vowel2Count[\\'u\\'] % 2}\";\\n\\n                if (key2Index.ContainsKey(key))\\n                {\\n                    res = Math.Max(res, i - (key2Index[key]));\\n                }\\n\\t\\t\\t\\telse\\n                {\\n                    key2Index[key] = i;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012132,
                "title": "recall-in-your-mind-longest-length-subarray-having-0-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# ***if sum already exsit at i\\'th positin and again another u found it j\\'th position then it\\'s show that sum of substring from i+1, to j is 0.***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. cur =0, map for store cur and it\\'s position \\n1. if a, e, i, o, u found flip bitposition of cur 0, 1, 2, 3, 4 respectively.\\n2. if cur already exist in map then ans=max(ans, curIndex-mp[cur]).\\n3. else store curIndex in map , map[cur]=curIndex.  \\n   \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(32)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\n        unordered_map<int,int>mp;\\n        \\n        int p=0, ans=0, i=0;\\n        mp[0]=-1;\\n        for(auto x: s)\\n        {\\n            if(x==\\'a\\') p=p^(1<<0);\\n            if(x==\\'e\\') p=p^(1<<1);\\n            if(x==\\'i\\') p=p^(1<<2);\\n            if(x==\\'o\\') p=p^(1<<3);\\n            if(x==\\'u\\') p=p^(1<<4);\\n\\n            if(mp.count(p))\\n              ans=max(ans, i-mp[p]);\\n            else\\n              mp[p]=i;\\n            \\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\n        unordered_map<int,int>mp;\\n        \\n        int p=0, ans=0, i=0;\\n        mp[0]=-1;\\n        for(auto x: s)\\n        {\\n            if(x==\\'a\\') p=p^(1<<0);\\n            if(x==\\'e\\') p=p^(1<<1);\\n            if(x==\\'i\\') p=p^(1<<2);\\n            if(x==\\'o\\') p=p^(1<<3);\\n            if(x==\\'u\\') p=p^(1<<4);\\n\\n            if(mp.count(p))\\n              ans=max(ans, i-mp[p]);\\n            else\\n              mp[p]=i;\\n            \\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992674,
                "title": "almost-branchless-100-fast-solution-in-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define FLIPBIT(bitmap, index) ((bitmap) ^ ((1) << (index)))\\n\\nint vowelIndex (char vowel)\\n{\\n    switch (vowel)\\n    {\\n        case \\'a\\': return 1;\\n        case \\'e\\': return 2;\\n        case \\'i\\': return 3;\\n        case \\'o\\': return 4;\\n        case \\'u\\': return 5;\\n        default: return 0;\\n    }\\n}\\n\\nint slen (char* s)\\n{\\n    int len = 0;\\n    while (*(s + len) != \\'\\\\0\\') ++len;\\n    return len;\\n}\\n\\nint findTheLongestSubstring (char* s)\\n{\\n    int len = slen(s);\\n    unsigned char bitmap = 0;\\n    int memo[64] = { [0 ... 63] = -1 };\\n    int currlen = 0, maxlen = 0;\\n    for (int i = 0; i < len; ++i)\\n    {\\n        bitmap = FLIPBIT(bitmap, vowelIndex(*(s + i))) & -2;\\n        if (bitmap && *(memo + bitmap) < 0) *(memo + bitmap) = i;\\n        currlen = i - *(memo + bitmap);\\n        maxlen = currlen >= maxlen ? currlen : maxlen;\\n    }\\n    return maxlen;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define FLIPBIT(bitmap, index) ((bitmap) ^ ((1) << (index)))\\n\\nint vowelIndex (char vowel)\\n{\\n    switch (vowel)\\n    {\\n        case \\'a\\': return 1;\\n        case \\'e\\': return 2;\\n        case \\'i\\': return 3;\\n        case \\'o\\': return 4;\\n        case \\'u\\': return 5;\\n        default: return 0;\\n    }\\n}\\n\\nint slen (char* s)\\n{\\n    int len = 0;\\n    while (*(s + len) != \\'\\\\0\\') ++len;\\n    return len;\\n}\\n\\nint findTheLongestSubstring (char* s)\\n{\\n    int len = slen(s);\\n    unsigned char bitmap = 0;\\n    int memo[64] = { [0 ... 63] = -1 };\\n    int currlen = 0, maxlen = 0;\\n    for (int i = 0; i < len; ++i)\\n    {\\n        bitmap = FLIPBIT(bitmap, vowelIndex(*(s + i))) & -2;\\n        if (bitmap && *(memo + bitmap) < 0) *(memo + bitmap) = i;\\n        currlen = i - *(memo + bitmap);\\n        maxlen = currlen >= maxlen ? currlen : maxlen;\\n    }\\n    return maxlen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975040,
                "title": "c-hash-table-bit-masking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        unordered_map<char,int> val;\\n        val[\\'a\\'] = 0;\\n        val[\\'e\\'] = 1;\\n        val[\\'i\\'] = 2;\\n        val[\\'o\\'] = 3;\\n        val[\\'u\\'] = 4;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(val.find(s[i])!=val.end())\\n            mask^=(1<<val[s[i]]);\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        unordered_map<char,int> val;\\n        val[\\'a\\'] = 0;\\n        val[\\'e\\'] = 1;\\n        val[\\'i\\'] = 2;\\n        val[\\'o\\'] = 3;\\n        val[\\'u\\'] = 4;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(val.find(s[i])!=val.end())\\n            mask^=(1<<val[s[i]]);\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918071,
                "title": "o-n-python-solution",
                "content": "# Intuition\\ncalculated xor of everything, if xor is 0 then elements upto that index then we have even vowels and length of the substring will be index + 1 , but there is one another way of finding a substring with even vowels (if xor of elements from 0 to a has xor = y and xor from 0 to b has also xor = y, such that a < b, then elements from index a to b has even number of vowels and their length would be b-a)\\n\\n# Approach\\ni return index + 1 if i had 0 any time, meaning xor of elements from 0 to that index even have vowels and the length of the substring is index + 1, and i stored every other xor in a dictionary and the value had a list containing the first and last occurrence(index) of that xor, as i explained earlier b-a is also a possible substring with even number of vowels.\\n\\n# Complexity\\n- Time complexity:\\nsince the vowels are only 5 and the number of combinations that can be made of it and possible xor are also constant the complexity turns out to be O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        l={}\\n        x=0\\n        #print(len(s))\\n        m=-1\\n        for i in range(len(s)):\\n            if s[i] in [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']:\\n                x^=ord(s[i])\\n            if x not in l:\\n                l[x]=[i,-1]\\n            else:\\n                l[x][1]=i\\n            if x==0:\\n                m=max(m,i+1)\\n            if l[x][1]!=-1:\\n                m=max(m,l[x][1]-l[x][0])\\n\\n            \\n            #print(x,end=\",\")\\n        if m==-1:\\n            return 0\\n        return m\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        l={}\\n        x=0\\n        #print(len(s))\\n        m=-1\\n        for i in range(len(s)):\\n            if s[i] in [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']:\\n                x^=ord(s[i])\\n            if x not in l:\\n                l[x]=[i,-1]\\n            else:\\n                l[x][1]=i\\n            if x==0:\\n                m=max(m,i+1)\\n            if l[x][1]!=-1:\\n                m=max(m,l[x][1]-l[x][0])\\n\\n            \\n            #print(x,end=\",\")\\n        if m==-1:\\n            return 0\\n        return m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909677,
                "title": "very-clean-and-simple-code-bits-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it is given in question the frequency of vowels should be even in subarray. We can think of counting number of vowels at every index and think of subtracting from previous indexes to get max subarray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The given intution will give n^2 approach, so instead of that we thought of storing whether at that index frequency of each vowel is odd or even.\\n- So we used 5 bits to store whether the frequency is odd or even,which is intialised as 0 in decimal or \"00000\" in binary.\\n- Every time we encounter the same vowel we flip the bit corresponding to it.\\n- As we know that we will get answer when we reach to same state again for eg if we are on state \"10010\" we need to be in same state in future to have frequency of every element as even.(This point might be little hard to understand just go through this once again)\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) Constant extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int num=0; // It stores current state at every index\\n       vector<int> v(32,-1); //For storing first index of that state\\n       int i=0;\\n        for(auto a:s){\\n            if(a==\\'a\\')\\n                num = (num ^ (1 << 0)); //Code for flipping bit\\n             if(a==\\'e\\')\\n                num = (num ^ (1 << 1)); //Code for flipping bit\\n             if(a==\\'i\\')\\n                num = (num ^ (1 << 2)); //Code for flipping bit\\n             if(a==\\'o\\')\\n                num = (num ^ (1 << 3)); //Code for flipping bit\\n             if(a==\\'u\\')\\n                num = (num ^ (1 << 4)); //Code for flipping bit\\n\\n           if(v[num]==-1){\\n               v[num]=i; // first encounter of state\\n           }\\n           else{\\n               ans=max(ans,i-v[num]); //second and after encounters\\n           }\\n           if(num==0){\\n               ans=i+1; //becuase initially state or num is 0\\n           }\\n           i++;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int num=0; // It stores current state at every index\\n       vector<int> v(32,-1); //For storing first index of that state\\n       int i=0;\\n        for(auto a:s){\\n            if(a==\\'a\\')\\n                num = (num ^ (1 << 0)); //Code for flipping bit\\n             if(a==\\'e\\')\\n                num = (num ^ (1 << 1)); //Code for flipping bit\\n             if(a==\\'i\\')\\n                num = (num ^ (1 << 2)); //Code for flipping bit\\n             if(a==\\'o\\')\\n                num = (num ^ (1 << 3)); //Code for flipping bit\\n             if(a==\\'u\\')\\n                num = (num ^ (1 << 4)); //Code for flipping bit\\n\\n           if(v[num]==-1){\\n               v[num]=i; // first encounter of state\\n           }\\n           else{\\n               ans=max(ans,i-v[num]); //second and after encounters\\n           }\\n           if(num==0){\\n               ans=i+1; //becuase initially state or num is 0\\n           }\\n           i++;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885926,
                "title": "c-dp-solution",
                "content": "# Intuition\\nThe sliding window is fast and nice but I\\'d like to share an alternative solution with dynamic programming. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We maintain a dp array to record the maximum length of the substring with different vowel states ending with the position `i` of the string `s`.\\n- We keep adding new characters and toggling these states until we reach the end of the string `s`.\\n- Record the maximum substring length of state 0 (all vowels are even)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n    - We need to track the maximum length of $2^5=32$ states in each cycle. Although this is considered a constant factor, it\\'s still expensive compared with the sliding window solution.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - First Version: $$O(N)$$\\n    - Space Optimized Version: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n#### DP\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[size + 1][32];       // dp[i + 1][state]: longest substring with state that ends with s[i]\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;     // mark all states unavailable\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;  // if we have odd number of \\'a\\'s, state & 1 == 1\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask) {\\n                    // toggle the even/odd state\\n                    // if it can be transferred from a previous state, we extend its length by 1\\n                    // otherwise, we initiate it with length 1\\n                    dp[i + 1][state] = max(dp[i][state ^ mask] + 1, 1);\\n                } else {\\n                    // same thing but if the previous state is not found, we leave it unavailable\\n                    dp[i + 1][state] = (dp[i][state ^ mask] >= 0) ? dp[i][state ^ mask] + 1 : INT_MIN;\\n                }\\n            }\\n            res = max(res, dp[i + 1][0]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### DP with Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[2][32] = {0};\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask)\\n                    dp[curr][state] = max(dp[prev][state ^ mask] + 1, 1);\\n                else\\n                    dp[curr][state] = (dp[prev][state ^ mask] >= 0) ? dp[prev][state ^ mask] + 1 : INT_MIN;\\n            }\\n            res = max(res, dp[curr][0]);\\n            swap(prev, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[size + 1][32];       // dp[i + 1][state]: longest substring with state that ends with s[i]\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;     // mark all states unavailable\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;  // if we have odd number of \\'a\\'s, state & 1 == 1\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask) {\\n                    // toggle the even/odd state\\n                    // if it can be transferred from a previous state, we extend its length by 1\\n                    // otherwise, we initiate it with length 1\\n                    dp[i + 1][state] = max(dp[i][state ^ mask] + 1, 1);\\n                } else {\\n                    // same thing but if the previous state is not found, we leave it unavailable\\n                    dp[i + 1][state] = (dp[i][state ^ mask] >= 0) ? dp[i][state ^ mask] + 1 : INT_MIN;\\n                }\\n            }\\n            res = max(res, dp[i + 1][0]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[2][32] = {0};\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask)\\n                    dp[curr][state] = max(dp[prev][state ^ mask] + 1, 1);\\n                else\\n                    dp[curr][state] = (dp[prev][state ^ mask] >= 0) ? dp[prev][state ^ mask] + 1 : INT_MIN;\\n            }\\n            res = max(res, dp[curr][0]);\\n            swap(prev, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855763,
                "title": "fastest-c-100-speed",
                "content": "# Intuition\\nThe 5 vowels can only be either odd or even, therefore there are only 32 states (2^5). If we store the values of the first appearance of each state, whenever we encounter that state, we can simply take the difference between their indices to find the length.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo represent the state, we can use the first few bits of an integer to represent the parity of each vowel. Making an array containing all 26 letters and using the ascii values of each letter index into the array which will then will retrieve the bits assigned to the vowels which updates the parity of that vowel in the state using an xor. If the state did not yet exist, store the occurance of the index of state.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//You can use char instead of int for the letters and state\\n//Used int hoping it was faster\\n//Wrote out all the arrays to try to squeeze out every last bit of speed\\n    int letters[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n    int findTheLongestSubstring(string s) {\\n        int pos[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\\n        int maxLen = 0;\\n        int state = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            state ^= letters[s.at(i)-\\'a\\'];\\n            if (pos[state] == -1 && state) { //pos[0] needs to be -1\\n                pos[state] = i;\\n            }\\n            maxLen = max(maxLen, i-pos[state]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//You can use char instead of int for the letters and state\\n//Used int hoping it was faster\\n//Wrote out all the arrays to try to squeeze out every last bit of speed\\n    int letters[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n    int findTheLongestSubstring(string s) {\\n        int pos[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\\n        int maxLen = 0;\\n        int state = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            state ^= letters[s.at(i)-\\'a\\'];\\n            if (pos[state] == -1 && state) { //pos[0] needs to be -1\\n                pos[state] = i;\\n            }\\n            maxLen = max(maxLen, i-pos[state]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839623,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n#define IS_VOWEL(c) (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        vector<int> prefix;\\n        prefix.reserve(n + 1);\\n        prefix.push_back(0);\\n\\n        for (int i {}; i < n; i++) {\\n            int x = IS_VOWEL(s[i]) ? 1 << (s[i] - \\'a\\') : 0;\\n            prefix.push_back(prefix.back() ^ x);\\n        }\\n\\n        if (prefix.back() == 0) return n;\\n\\n        unordered_map<int, int> idx;\\n        for (int j {}; j < n; ++j) {\\n            idx[prefix[j + 1]] = j;\\n        }\\n\\n        int res = -1;\\n        for (int k {}; k < n; k++) {\\n            auto it = idx.find(prefix[k]);\\n            if (it != idx.end()) res = max(res, it->second - k);\\n        }\\n\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define IS_VOWEL(c) (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        vector<int> prefix;\\n        prefix.reserve(n + 1);\\n        prefix.push_back(0);\\n\\n        for (int i {}; i < n; i++) {\\n            int x = IS_VOWEL(s[i]) ? 1 << (s[i] - \\'a\\') : 0;\\n            prefix.push_back(prefix.back() ^ x);\\n        }\\n\\n        if (prefix.back() == 0) return n;\\n\\n        unordered_map<int, int> idx;\\n        for (int j {}; j < n; ++j) {\\n            idx[prefix[j + 1]] = j;\\n        }\\n\\n        int res = -1;\\n        for (int k {}; k < n; k++) {\\n            auto it = idx.find(prefix[k]);\\n            if (it != idx.end()) res = max(res, it->second - k);\\n        }\\n\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836482,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn find_the_longest_substring(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n    let limit = 1 << 5;\\n    let mut memo = vec![vec![];limit];\\n    \\n    let dict = [\\'a\\',\\'i\\',\\'u\\',\\'e\\',\\'o\\'];\\n    let mut now = 0;\\n    for i in 0..n {\\n      memo[now].push(i);\\n      for j in 0..5 {\\n        if s[i] == dict[j] {\\n          let v = 1 << j;\\n          now ^= v;\\n          break\\n        }\\n      }\\n    }\\n    memo[now].push(n);\\n\\n    let mut result = 0;\\n    let mut i = 0;\\n    for arr in memo {\\n      if arr.len() >= 2 {\\n        result = result.max(arr[arr.len()-1] - arr[0]);\\n      }\\n      i += 1;\\n    }\\n    \\n    result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn find_the_longest_substring(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n    let limit = 1 << 5;\\n    let mut memo = vec![vec![];limit];\\n    \\n    let dict = [\\'a\\',\\'i\\',\\'u\\',\\'e\\',\\'o\\'];\\n    let mut now = 0;\\n    for i in 0..n {\\n      memo[now].push(i);\\n      for j in 0..5 {\\n        if s[i] == dict[j] {\\n          let v = 1 << j;\\n          now ^= v;\\n          break\\n        }\\n      }\\n    }\\n    memo[now].push(n);\\n\\n    let mut result = 0;\\n    let mut i = 0;\\n    for arr in memo {\\n      if arr.len() >= 2 {\\n        result = result.max(arr[arr.len()-1] - arr[0]);\\n      }\\n      i += 1;\\n    }\\n    \\n    result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795113,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int mask=0,mx=0;\\n        string v=\"aeiou\";\\n        for(int i=0;i<size(s);++i){\\n            mask^=(1<<(v.find(s[i])+1))>>1;\\n            if(!mp.count(mask))mp[mask]=i;\\n            mx=max(mx,i-mp[mask]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int mask=0,mx=0;\\n        string v=\"aeiou\";\\n        for(int i=0;i<size(s);++i){\\n            mask^=(1<<(v.find(s[i])+1))>>1;\\n            if(!mp.count(mask))mp[mask]=i;\\n            mx=max(mx,i-mp[mask]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700516,
                "title": "c-bitmask-and-prefix-sum",
                "content": "# Intuition\\nthere is a trick which we can use to count substrings satisfying the condition that vowwls should appear even no. of times \\nNote that parity of a character in a string can be reflected by only one bit 0/1 so we use a mask to represent the parity of each character in the prefix;\\n\\ncalculate the mask for each of the prefix of the string and increase its count\\n\\nres += dp[mask] gives the no. of prefixes havign same  mask fo substring (i+1, j) is the string with even parity\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // we need to find the maximum distance between the first and last index for each mask combination.\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        // unordered_map<int, int> seen;\\n        // seen[0] = -1;\\n        mp[\\'a\\'] = 1;\\n        mp[\\'e\\'] = 2;\\n        mp[\\'i\\'] = 3;\\n        mp[\\'o\\'] = 4;\\n        mp[\\'u\\'] = 5;\\n        int n = s.length();\\n        //dp[mask] --> gives the min index for the particular mask\\n        //mask is defined for each prefic of the string \\n        vector<int> dp(1<<6, -1); \\n        dp[0] = -1;\\n        int res = 0, mask=0;//maintain a mask for prefix\\n        for(int i=0; i<n; i++){\\n            mask ^= (1<<mp[s[i]]>>1);\\n            //update the dp[i] is its -1;\\n            if(mask != 0 && dp[mask] == -1)dp[mask] = i;\\n            res = max(res, i-dp[mask]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // we need to find the maximum distance between the first and last index for each mask combination.\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        // unordered_map<int, int> seen;\\n        // seen[0] = -1;\\n        mp[\\'a\\'] = 1;\\n        mp[\\'e\\'] = 2;\\n        mp[\\'i\\'] = 3;\\n        mp[\\'o\\'] = 4;\\n        mp[\\'u\\'] = 5;\\n        int n = s.length();\\n        //dp[mask] --> gives the min index for the particular mask\\n        //mask is defined for each prefic of the string \\n        vector<int> dp(1<<6, -1); \\n        dp[0] = -1;\\n        int res = 0, mask=0;//maintain a mask for prefix\\n        for(int i=0; i<n; i++){\\n            mask ^= (1<<mp[s[i]]>>1);\\n            //update the dp[i] is its -1;\\n            if(mask != 0 && dp[mask] == -1)dp[mask] = i;\\n            res = max(res, i-dp[mask]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670224,
                "title": "amazing-problem-c-bitmasking",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(32)\\n\\n# Code\\n## Please Upvote if u found my Solution useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(),mask = 0, maxi = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(check(s[i]))\\n                mask ^= 1 << (s[i] - \\'a\\');\\n            if(mask == 0){\\n                maxi = i + 1;\\n                continue;\\n            }\\n            if(mp.find(mask) == mp.end())\\n                mp[mask] = i;\\n            else\\n                maxi = max(maxi,i - mp[mask]);\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(),mask = 0, maxi = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(check(s[i]))\\n                mask ^= 1 << (s[i] - \\'a\\');\\n            if(mask == 0){\\n                maxi = i + 1;\\n                continue;\\n            }\\n            if(mp.find(mask) == mp.end())\\n                mp[mask] = i;\\n            else\\n                maxi = max(maxi,i - mp[mask]);\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663789,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    map<int,int>mp;\\n    int mask=0,mx=0;\\n    mp[0]=-1;\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            if(mp.find(mask)==mp.end()){\\n                mp[mask]=i;\\n            }\\n        } \\n         mx=max(mx,i-mp[mask]);\\n    }  \\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    map<int,int>mp;\\n    int mask=0,mx=0;\\n    mp[0]=-1;\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            if(mp.find(mask)==mp.end()){\\n                mp[mask]=i;\\n            }\\n        } \\n         mx=max(mx,i-mp[mask]);\\n    }  \\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640429,
                "title": "go-15ms-linear-bitmask",
                "content": "# Intuition\\nThe idea is to store the state: current parity for every vowel.\\nWe store it as masks: for i-th bit it means ith vowel count is odd.\\n\\nWe shall maintain the state on array $$[0:i]$$, but also for every possible state (2^5 = 32 states) the smallest prefix $$[0:j]$$, with this state. Indeed, if the count is odd on $$[0:i]$$, and it is odd on $$[0:j]$$, then it is even on $$[i:j]$$.\\n\\nThus, the answer is $$i-j$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc toIdx(c byte) int {\\n    switch c {\\n        case \\'a\\':\\n            return 0\\n        case \\'e\\':\\n            return 1\\n        case \\'i\\':\\n            return 2\\n        case \\'o\\':\\n            return 3\\n        case \\'u\\':\\n            return 4\\n    }\\n    return -1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc findTheLongestSubstring(s string) int {\\n    var shortestPrefix [32]int\\n    var state uint\\n    shortestPrefix[state] = 0\\n    ans := 0\\n    for i := 0; i < len(s); i++ {\\n        idx := toIdx(s[i])\\n        if idx >= 0 {\\n            state ^= 1 << idx \\n        }\\n        startIdx := shortestPrefix[state]\\n        if state == 0 || startIdx != 0 {\\n            ans = max(ans, i+1-startIdx)\\n            continue\\n        }\\n        shortestPrefix[state] = i+1\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc toIdx(c byte) int {\\n    switch c {\\n        case \\'a\\':\\n            return 0\\n        case \\'e\\':\\n            return 1\\n        case \\'i\\':\\n            return 2\\n        case \\'o\\':\\n            return 3\\n        case \\'u\\':\\n            return 4\\n    }\\n    return -1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc findTheLongestSubstring(s string) int {\\n    var shortestPrefix [32]int\\n    var state uint\\n    shortestPrefix[state] = 0\\n    ans := 0\\n    for i := 0; i < len(s); i++ {\\n        idx := toIdx(s[i])\\n        if idx >= 0 {\\n            state ^= 1 << idx \\n        }\\n        startIdx := shortestPrefix[state]\\n        if state == 0 || startIdx != 0 {\\n            ans = max(ans, i+1-startIdx)\\n            continue\\n        }\\n        shortestPrefix[state] = i+1\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3629984,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nint findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }\\n        for ( int j = i ; j < strlen(s) ; j++ ){\\n            sum ^= ( 1 << ( s[j] - \\'a\\' ));\\n            if ( (sum & mask) == 0 && (j - i + 1) > max ){\\n                max = j - i + 1;\\n            } \\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }\\n        for ( int j = i ; j < strlen(s) ; j++ ){\\n            sum ^= ( 1 << ( s[j] - \\'a\\' ));\\n            if ( (sum & mask) == 0 && (j - i + 1) > max ){\\n                max = j - i + 1;\\n            } \\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611931,
                "title": "hashmap-prefix-sum-status-compression-golang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHashMap + prefix sum + status compression\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc findTheLongestSubstring(s string) int {\\n    cnt := make([]int, 5);\\n    key2idx := make(map[int]int)\\n    key2idx[0] = -1\\n    res := 0\\n    for i, ch := range s {\\n        if ch == \\'a\\' {\\n            cnt[0]++\\n        } else if ch == \\'e\\' {\\n            cnt[1]++\\n        } else if ch == \\'i\\' {\\n            cnt[2]++\\n        } else if ch == \\'o\\' {\\n            cnt[3]++\\n        } else if ch == \\'u\\' {\\n            cnt[4]++\\n        }\\n        key := cnt2key(cnt)\\n        if idx, ok := key2idx[key]; ok {\\n            res = max(res, i - idx)\\n        } else {\\n            key2idx[key] = i\\n        }\\n    }\\n    return res\\n}\\n\\nfunc cnt2key(cnt []int) int {\\n    key := 0\\n    for i, n := range cnt {\\n        if n % 2 == 1 {\\n            key += (1 << i)\\n        }\\n    }\\n    return key\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findTheLongestSubstring(s string) int {\\n    cnt := make([]int, 5);\\n    key2idx := make(map[int]int)\\n    key2idx[0] = -1\\n    res := 0\\n    for i, ch := range s {\\n        if ch == \\'a\\' {\\n            cnt[0]++\\n        } else if ch == \\'e\\' {\\n            cnt[1]++\\n        } else if ch == \\'i\\' {\\n            cnt[2]++\\n        } else if ch == \\'o\\' {\\n            cnt[3]++\\n        } else if ch == \\'u\\' {\\n            cnt[4]++\\n        }\\n        key := cnt2key(cnt)\\n        if idx, ok := key2idx[key]; ok {\\n            res = max(res, i - idx)\\n        } else {\\n            key2idx[key] = i\\n        }\\n    }\\n    return res\\n}\\n\\nfunc cnt2key(cnt []int) int {\\n    key := 0\\n    for i, n := range cnt {\\n        if n % 2 == 1 {\\n            key += (1 << i)\\n        }\\n    }\\n    return key\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592855,
                "title": "c-hash-the-even-and-odd-count-of-vowels-using-the-bits-0-means-even-count-and-1-is-odd",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) because there can be at max (11111) no i.e. 31 numbers in the hashmap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = 0;\\n        unordered_map<char,int>vovelmp = {{\\'a\\',0}, {\\'e\\',1}, {\\'i\\',2}, {\\'o\\',3},{\\'u\\',4}};\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<s.size(); i++){\\n            if(vovelmp.count(s[i])){\\n                n^=(1<<vovelmp[s[i]]);\\n            }\\n            // cout<<n<<endl;\\n            if(n == 0){\\n                ans = max(ans, i+1);\\n            }\\n\\n            else{\\n                if(mp.count(n)){\\n                    ans = max(ans, i-mp[n]);\\n                }\\n                else{\\n                    mp[n] = i;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = 0;\\n        unordered_map<char,int>vovelmp = {{\\'a\\',0}, {\\'e\\',1}, {\\'i\\',2}, {\\'o\\',3},{\\'u\\',4}};\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<s.size(); i++){\\n            if(vovelmp.count(s[i])){\\n                n^=(1<<vovelmp[s[i]]);\\n            }\\n            // cout<<n<<endl;\\n            if(n == 0){\\n                ans = max(ans, i+1);\\n            }\\n\\n            else{\\n                if(mp.count(n)){\\n                    ans = max(ans, i-mp[n]);\\n                }\\n                else{\\n                    mp[n] = i;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3496683,
                "title": "find-the-longest-substring-containing-vowels-in-even-counts",
                "content": "----------------- Easy C++ Solution ------------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    int ans = 0;\\n    int prefix = 0;\\n    unordered_map<int, int> preIndex{{0, -1}};\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = string(\"aeiou\").find(s[i]);\\n      if (index != -1)\\n        prefix ^= 1 << index;\\n      if (!preIndex.count(prefix))\\n        preIndex[prefix] = i;\\n      else\\n        ans = max(ans, i - preIndex[prefix]);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    int ans = 0;\\n    int prefix = 0;\\n    unordered_map<int, int> preIndex{{0, -1}};\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = string(\"aeiou\").find(s[i]);\\n      if (index != -1)\\n        prefix ^= 1 << index;\\n      if (!preIndex.count(prefix))\\n        preIndex[prefix] = i;\\n      else\\n        ans = max(ans, i - preIndex[prefix]);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477581,
                "title": "java-easy-to-understand-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public void check(boolean b[],String s,int in,int n){\\n             int a=0,e=0,i=0,o=0,u=0;\\n       for(int k=in;k<n;k++){\\n           if(s.charAt(k)==\\'a\\')\\n                a++;\\n           else if(s.charAt(k)==\\'e\\')\\n                e++;\\n           else if(s.charAt(k)==\\'i\\')\\n                i++;\\n           else if(s.charAt(k)==\\'o\\')\\n                o++;\\n            else if(s.charAt(k)==\\'u\\')\\n                u++;\\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n                b[k]=true;\\n       }\\n        }\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n       boolean[] b=new boolean[n];\\n       check(b,s,0,n);\\n    //    System.out.println(Arrays.toString(b));\\n       int ans=0,i=0;\\n       while(i<n){\\n           int j=n-1;\\n           if(j-i>ans){\\n           while(i<j && !b[j])\\n                j--;\\n            ans=Math.max(ans,j-i+1);\\n            i++;\\n            check(b,s,i,n);\\n       }\\n       else return ans;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n     public void check(boolean b[],String s,int in,int n){\\n             int a=0,e=0,i=0,o=0,u=0;\\n       for(int k=in;k<n;k++){\\n           if(s.charAt(k)==\\'a\\')\\n                a++;\\n           else if(s.charAt(k)==\\'e\\')\\n                e++;\\n           else if(s.charAt(k)==\\'i\\')\\n                i++;\\n           else if(s.charAt(k)==\\'o\\')\\n                o++;\\n            else if(s.charAt(k)==\\'u\\')\\n                u++;\\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n                b[k]=true;\\n       }\\n        }\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n       boolean[] b=new boolean[n];\\n       check(b,s,0,n);\\n    //    System.out.println(Arrays.toString(b));\\n       int ans=0,i=0;\\n       while(i<n){\\n           int j=n-1;\\n           if(j-i>ans){\\n           while(i<j && !b[j])\\n                j--;\\n            ans=Math.max(ans,j-i+1);\\n            i++;\\n            check(b,s,i,n);\\n       }\\n       else return ans;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404413,
                "title": "slid-window-zig-zag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncount the vowels in a slid window\\nto make it more efficient, it slid from left to right then right to left \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        C = Counter(s)\\n        d = True\\n        for i in range(len(s), -1, -1):\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i\\n            if d:\\n                C[s[i-1]] -= 1\\n                irange = range(len(s) - i + 1)\\n                jrange = range(i - 1, len(s))\\n            else:\\n                C[s[-i]] -= 1\\n                irange = reversed(range(i - 1, len(s)))\\n                jrange = reversed(range(len(s) - i + 1))\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i - 1\\n            for l, r in zip(irange, jrange):\\n                # print(l,r, i)\\n                C[s[l]] -= 1\\n                C[s[r]] += 1\\n                if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                    return i - 1\\n            d = not d\\n            # print(d)\\n        return 0\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        C = Counter(s)\\n        d = True\\n        for i in range(len(s), -1, -1):\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i\\n            if d:\\n                C[s[i-1]] -= 1\\n                irange = range(len(s) - i + 1)\\n                jrange = range(i - 1, len(s))\\n            else:\\n                C[s[-i]] -= 1\\n                irange = reversed(range(i - 1, len(s)))\\n                jrange = reversed(range(len(s) - i + 1))\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i - 1\\n            for l, r in zip(irange, jrange):\\n                # print(l,r, i)\\n                C[s[l]] -= 1\\n                C[s[r]] += 1\\n                if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                    return i - 1\\n            d = not d\\n            # print(d)\\n        return 0\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340955,
                "title": "java-bitmask-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length();\\n        int[] dp = new int[32];\\n        Arrays.fill(dp, -1);\\n        int[] countArr = new int[5];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            var index = toIndex(s.charAt(i));\\n            if (index != -1) {\\n                countArr[index]++;\\n            }\\n            int mask = 0;\\n            for (int j = 0; j < 5; j++) {\\n                if (countArr[j] % 2 == 1) {\\n                    mask += 1 << j;\\n                }\\n            }\\n            if (mask == 0) {\\n                max = Math.max(max, i + 1);\\n            } else {\\n                if (dp[mask] != -1) {\\n                    max = Math.max(max, i - dp[mask]);\\n                } else {\\n                    dp[mask] = i;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n\\n    private int toIndex(char c) {\\n        switch(c) {\\n            case \\'a\\':\\n                return 0;   \\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            default:\\n                return -1;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length();\\n        int[] dp = new int[32];\\n        Arrays.fill(dp, -1);\\n        int[] countArr = new int[5];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            var index = toIndex(s.charAt(i));\\n            if (index != -1) {\\n                countArr[index]++;\\n            }\\n            int mask = 0;\\n            for (int j = 0; j < 5; j++) {\\n                if (countArr[j] % 2 == 1) {\\n                    mask += 1 << j;\\n                }\\n            }\\n            if (mask == 0) {\\n                max = Math.max(max, i + 1);\\n            } else {\\n                if (dp[mask] != -1) {\\n                    max = Math.max(max, i - dp[mask]);\\n                } else {\\n                    dp[mask] = i;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n\\n    private int toIndex(char c) {\\n        switch(c) {\\n            case \\'a\\':\\n                return 0;   \\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            default:\\n                return -1;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334629,
                "title": "easy-solution-using-bitmask",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To check if count of all vowels in the string till now is even or not, we will use a mask. If ith bit is set in mask, then that it means that count of ith vowel is odd and it the ith bit is 0, then it means the count is even.\\n2. We will use a map to store the smallest index for a particular mask.\\n3. Now we will iterate through the string and :\\n    1. update the mask if the current character is vowel.\\n    2. if the value of mask if 0, then it means that count of all vowels is even and we will update our ans to i + 1. \\n    3. if the mask it not 0, then we will check if the mask exist in the map or not. \\n        1. If it exists, then ans = max(ans, i - m[mask]). We do this because if the current mask value is 00001, it indicates an odd count of \\'a\\'. And if m[mask] equals 2, then it means the count of \\'a\\' was also odd at the 2nd index, making the count of \\'a\\' in the substring from 2 to i even.\\n        2. if it does not exists, then we will update m[mask] = i\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char, int>vowels = {{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}};\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(), ans = 0, mask = 0;\\n        unordered_map<int, int>m;\\n    \\n        for(int i = 0; i < n; i++) {\\n            if(vowels.find(s[i]) != vowels.end()) mask ^= (1 << vowels[s[i]]);\\n            if(mask == 0) ans = i + 1;\\n            if(m.find(mask) != m.end()) ans = max(ans, i - m[mask]);\\n            else m[mask] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char, int>vowels = {{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}};\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(), ans = 0, mask = 0;\\n        unordered_map<int, int>m;\\n    \\n        for(int i = 0; i < n; i++) {\\n            if(vowels.find(s[i]) != vowels.end()) mask ^= (1 << vowels[s[i]]);\\n            if(mask == 0) ans = i + 1;\\n            if(m.find(mask) != m.end()) ans = max(ans, i - m[mask]);\\n            else m[mask] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334081,
                "title": "java-bitmasking",
                "content": "public int findTheLongestSubstring(String s) {\\n        Map<Character,Integer>hm=new HashMap<>();\\n        hm.put(\\'a\\',0);\\n        hm.put(\\'e\\',1);\\n        hm.put(\\'i\\',2);\\n        hm.put(\\'o\\',3);\\n        hm.put(\\'u\\',4);\\n        int len=0;\\n        Map<Integer,Integer>hm2=new HashMap<>(22);\\n        int odd=0;\\n        hm2.put(0,-1);\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(hm.containsKey(ch)) \\n            odd =(odd)^(1<<hm.get(ch));\\n            hm2.putIfAbsent(odd, i);\\n            len=Math.max(len, i-hm2.get(odd));\\n        }\\n        return len;\\n    }",
                "solutionTags": [],
                "code": "public int findTheLongestSubstring(String s) {\\n        Map<Character,Integer>hm=new HashMap<>();\\n        hm.put(\\'a\\',0);\\n        hm.put(\\'e\\',1);\\n        hm.put(\\'i\\',2);\\n        hm.put(\\'o\\',3);\\n        hm.put(\\'u\\',4);\\n        int len=0;\\n        Map<Integer,Integer>hm2=new HashMap<>(22);\\n        int odd=0;\\n        hm2.put(0,-1);\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(hm.containsKey(ch)) \\n            odd =(odd)^(1<<hm.get(ch));\\n            hm2.putIfAbsent(odd, i);\\n            len=Math.max(len, i-hm2.get(odd));\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3270987,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int>Map ;\\n        int ans = 0;\\n        Map[0] = -1 ;\\n        int cur = 0 ;\\n        for(int i = 0; i < s.length();i++){\\n            char c = s[i] ;\\n            switch (c) {\\n                case \\'a\\':\\n                    cur ^= 1 ;\\n                    break;\\n                case \\'e\\':\\n                    cur ^= 2 ;\\n                    break;\\n                case \\'i\\':\\n                    cur ^= 4 ;\\n                    break;\\n                case \\'o\\':\\n                    cur ^= 8 ;\\n                    break;\\n                case \\'u\\':\\n                    cur ^= 16 ;\\n                    break;\\n                default:\\n                    break;\\n            }\\n          if (!Map.count(cur))\\n                Map[cur] = i;\\n          ans = max(ans, i - Map[cur]);            \\n        } \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int>Map ;\\n        int ans = 0;\\n        Map[0] = -1 ;\\n        int cur = 0 ;\\n        for(int i = 0; i < s.length();i++){\\n            char c = s[i] ;\\n            switch (c) {\\n                case \\'a\\':\\n                    cur ^= 1 ;\\n                    break;\\n                case \\'e\\':\\n                    cur ^= 2 ;\\n                    break;\\n                case \\'i\\':\\n                    cur ^= 4 ;\\n                    break;\\n                case \\'o\\':\\n                    cur ^= 8 ;\\n                    break;\\n                case \\'u\\':\\n                    cur ^= 16 ;\\n                    break;\\n                default:\\n                    break;\\n            }\\n          if (!Map.count(cur))\\n                Map[cur] = i;\\n          ans = max(ans, i - Map[cur]);            \\n        } \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247928,
                "title": "o-n-maintain-state-without-bitmasks",
                "content": "Since most other solutions use bitmasks/bit operations I thought of implementing the same algorithm without using bitmasks.\\n\\nHere I have a class `State` which stores a boolean array called even. The vowels are mapped to the following position in the array:\\na => 0, e => 1, i => 2, o => 3, u => 4\\n\\nThe boolean array stores for a given index ending in `i`, if the count of each vowel was even or odd upto and including that index. If the count is even for a specific vowel, we store true at the corresponding vowel position, else we store false\\n\\nThe rest of the implementation uses the typical Prefix sum + HashMap approach. \\n\\nWhile using bitmasks is faster, this approach explains the overall idea behind the bitmask approach in a simpler fashion. Hopefully might help you understand the bitmask approach more easily.\\n\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        Map<State, Integer> pos = new HashMap<State, Integer>();\\n        boolean[] even = new boolean[5];\\n\\t\\t// Initially the count of vowels is even. Pre-fill each index position to true\\n        Arrays.fill(even, true);\\n        pos.put(new State(even), -1);\\n        int longest = 0;\\n        char[] c = s.toCharArray();\\n\\t\\t\\n        Map<Character, Integer> vowelPos = new HashMap<Character, Integer>();\\n        vowelPos.put(\\'a\\', 0);\\n        vowelPos.put(\\'e\\', 1);\\n        vowelPos.put(\\'i\\', 2);\\n        vowelPos.put(\\'o\\', 3);\\n        vowelPos.put(\\'u\\', 4);\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (isVowel(c[i])) {\\n                int vpos = vowelPos.get(c[i]);\\n                even[vpos] = !even[vpos];\\n            }\\n            State key = new State(even);\\n            if (pos.containsKey(key)) {\\n                longest = Math.max(longest, i - pos.get(key));\\n            } else {\\n                pos.put(key, i);\\n            }          \\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\nclass State {\\n    boolean[] even;\\n    \\n    public State(boolean[] even) {\\n        this.even = even;\\n    }\\n    \\n    public boolean equals(Object o) {\\n        if (o == null || !(o instanceof State)) {\\n            return false;\\n        }\\n        \\n        State that = (State)o;\\n        \\n        if (even.length != that.even.length) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < even.length; i++) {\\n            if (even[i] != that.even[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int hashCode() {\\n        return Arrays.hashCode(even);\\n    }\\n}                                                              \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        Map<State, Integer> pos = new HashMap<State, Integer>();\\n        boolean[] even = new boolean[5];\\n\\t\\t// Initially the count of vowels is even. Pre-fill each index position to true\\n        Arrays.fill(even, true);\\n        pos.put(new State(even), -1);\\n        int longest = 0;\\n        char[] c = s.toCharArray();\\n\\t\\t\\n        Map<Character, Integer> vowelPos = new HashMap<Character, Integer>();\\n        vowelPos.put(\\'a\\', 0);\\n        vowelPos.put(\\'e\\', 1);\\n        vowelPos.put(\\'i\\', 2);\\n        vowelPos.put(\\'o\\', 3);\\n        vowelPos.put(\\'u\\', 4);\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (isVowel(c[i])) {\\n                int vpos = vowelPos.get(c[i]);\\n                even[vpos] = !even[vpos];\\n            }\\n            State key = new State(even);\\n            if (pos.containsKey(key)) {\\n                longest = Math.max(longest, i - pos.get(key));\\n            } else {\\n                pos.put(key, i);\\n            }          \\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\nclass State {\\n    boolean[] even;\\n    \\n    public State(boolean[] even) {\\n        this.even = even;\\n    }\\n    \\n    public boolean equals(Object o) {\\n        if (o == null || !(o instanceof State)) {\\n            return false;\\n        }\\n        \\n        State that = (State)o;\\n        \\n        if (even.length != that.even.length) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < even.length; i++) {\\n            if (even[i] != that.even[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int hashCode() {\\n        return Arrays.hashCode(even);\\n    }\\n}                                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239268,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findTheLongestSubstring(_ s: String) -> Int {\\n        \\n        let ss = Array(s)\\n        let cs = Array(\"aeiou\")\\n        var cm = Array(repeating: Array(repeating: true, count: cs.count), count: ss.count + 1)\\n\\n        var ii = [0]\\n        var la = cs.count\\n        var res = 0\\n\\n        for i in ss.indices {\\n            \\n            cm[i + 1] = cm[i]\\n\\n            guard let j = cs.firstIndex(of: ss[i]) else { continue }\\n            cm[i + 1][j] = !cm[i][j]\\n\\n            let nla = cm[i + 1].filter({ $0 }).count\\n            guard nla != la else { continue }\\n\\n            ii += [i - 1, i, i + 1].filter {\\n                $0 >= 0 && $0 < ss.count && (ii.isEmpty || $0 > ii.last!)\\n            }\\n\\n            la = nla\\n        }\\n\\n        if ii.last != ss.count - 1 { ii.append(ss.count - 1) }\\n\\n        for i in 0..<ii.count {\\n            \\n            let l = ii[i]\\n            guard l + res <= ss.count else { break }\\n\\n            for j in (i..<ii.count).reversed() {\\n                let r = ii[j]\\n                guard r - l >= res || res == 0 else { break }\\n\\n                guard cm[l] == cm[r + 1] else { continue }\\n                res = r - l + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheLongestSubstring(_ s: String) -> Int {\\n        \\n        let ss = Array(s)\\n        let cs = Array(\"aeiou\")\\n        var cm = Array(repeating: Array(repeating: true, count: cs.count), count: ss.count + 1)\\n\\n        var ii = [0]\\n        var la = cs.count\\n        var res = 0\\n\\n        for i in ss.indices {\\n            \\n            cm[i + 1] = cm[i]\\n\\n            guard let j = cs.firstIndex(of: ss[i]) else { continue }\\n            cm[i + 1][j] = !cm[i][j]\\n\\n            let nla = cm[i + 1].filter({ $0 }).count\\n            guard nla != la else { continue }\\n\\n            ii += [i - 1, i, i + 1].filter {\\n                $0 >= 0 && $0 < ss.count && (ii.isEmpty || $0 > ii.last!)\\n            }\\n\\n            la = nla\\n        }\\n\\n        if ii.last != ss.count - 1 { ii.append(ss.count - 1) }\\n\\n        for i in 0..<ii.count {\\n            \\n            let l = ii[i]\\n            guard l + res <= ss.count else { break }\\n\\n            for j in (i..<ii.count).reversed() {\\n                let r = ii[j]\\n                guard r - l >= res || res == 0 else { break }\\n\\n                guard cm[l] == cm[r + 1] else { continue }\\n                res = r - l + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184315,
                "title": "easy-c-solutions-for-beginners-using-masking",
                "content": "# Intuition\\nWe can make a mask of size 5 for \\'a\\', \\'e\\', \\'i\\', \\'o\\' & \\'u\\' respectively and we will update that mask on each iteration and we\\'ll check if that mask is present in our hash map if it is already present we will update our answer or else we\\'ll addd that mask in our map.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map< vector<int>, int> m;\\n        vector<int> v(5,0);\\n        m[v] = -1;\\n        int ans =0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\'){\\n                v[0] ^= 1;\\n            }\\n            else if(s[i]==\\'e\\'){\\n                v[1] ^= 1;\\n            }\\n            else if(s[i]==\\'i\\'){\\n                v[2] ^= 1;\\n            }\\n            else if(s[i]==\\'o\\'){\\n                v[3] ^= 1;\\n            }\\n            else if(s[i]==\\'u\\'){\\n                v[4] ^= 1;\\n            }\\n            if(m.find(v)!=m.end()){\\n                ans = max(ans,i-m[v]);\\n            }\\n            else m[v] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map< vector<int>, int> m;\\n        vector<int> v(5,0);\\n        m[v] = -1;\\n        int ans =0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\'){\\n                v[0] ^= 1;\\n            }\\n            else if(s[i]==\\'e\\'){\\n                v[1] ^= 1;\\n            }\\n            else if(s[i]==\\'i\\'){\\n                v[2] ^= 1;\\n            }\\n            else if(s[i]==\\'o\\'){\\n                v[3] ^= 1;\\n            }\\n            else if(s[i]==\\'u\\'){\\n                v[4] ^= 1;\\n            }\\n            if(m.find(v)!=m.end()){\\n                ans = max(ans,i-m[v]);\\n            }\\n            else m[v] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118634,
                "title": "72-15-faster-c-bitmask-hashmap-simple-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool isvowel(char c){\\n        return c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\';\\n    }\\n\\n    int findTheLongestSubstring(string s) {\\n        ll n=s.length(),mask=0,answer=0;\\n        unordered_map<ll,ll>mp;mp[0]=-1;\\n        unordered_map<char,ll>ss;ss[\\'a\\']=0;ss[\\'e\\']=1;ss[\\'i\\']=2;ss[\\'o\\']=3;ss[\\'u\\']=4;\\n        for(ll i=0;i<n;i++){\\n            if(isvowel(s[i])){\\n                mask=mask^(1<<(ss[s[i]]));\\n            }\\n            if(mp.find(mask)!=mp.end()){\\n                answer=max(answer,i-mp[mask]);\\n            }\\n            else{\\n                mp[mask]=i;\\n            }\\n        }\\n        return answer;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool isvowel(char c){\\n        return c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\';\\n    }\\n\\n    int findTheLongestSubstring(string s) {\\n        ll n=s.length(),mask=0,answer=0;\\n        unordered_map<ll,ll>mp;mp[0]=-1;\\n        unordered_map<char,ll>ss;ss[\\'a\\']=0;ss[\\'e\\']=1;ss[\\'i\\']=2;ss[\\'o\\']=3;ss[\\'u\\']=4;\\n        for(ll i=0;i<n;i++){\\n            if(isvowel(s[i])){\\n                mask=mask^(1<<(ss[s[i]]));\\n            }\\n            if(mp.find(mask)!=mp.end()){\\n                answer=max(answer,i-mp[mask]);\\n            }\\n            else{\\n                mp[mask]=i;\\n            }\\n        }\\n        return answer;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104482,
                "title": "faster-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let mut res = 0;\\n        let mut state = 0;\\n        let mut seen = vec![-1; 1 << 5];\\n        seen[0] = 0;\\n        for (i, c) in s.chars().enumerate() {\\n            match c {\\n                \\'a\\' => state ^= 1 << 0,\\n                \\'e\\' => state ^= 1 << 1,\\n                \\'i\\' => state ^= 1 << 2,\\n                \\'o\\' => state ^= 1 << 3,\\n                \\'u\\' => state ^= 1 << 4,\\n                _ => {}\\n            }\\n            if seen[state] >= 0 {\\n                res = res.max(i + 1 - seen[state] as usize);\\n            } else {\\n                seen[state] = i as i32 + 1;\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let mut res = 0;\\n        let mut state = 0;\\n        let mut seen = vec![-1; 1 << 5];\\n        seen[0] = 0;\\n        for (i, c) in s.chars().enumerate() {\\n            match c {\\n                \\'a\\' => state ^= 1 << 0,\\n                \\'e\\' => state ^= 1 << 1,\\n                \\'i\\' => state ^= 1 << 2,\\n                \\'o\\' => state ^= 1 << 3,\\n                \\'u\\' => state ^= 1 << 4,\\n                _ => {}\\n            }\\n            if seen[state] >= 0 {\\n                res = res.max(i + 1 - seen[state] as usize);\\n            } else {\\n                seen[state] = i as i32 + 1;\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001726,
                "title": "simple-logic-with-explanation",
                "content": "# Complexity\\n- Time complexity:O(n)  n is the length of string s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)     maximum value of n is 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWe are storing unique bit position of vowels.\\nSo that single bit is representing presence of that vowel and rest of the bit is zero\\n\\n00001 - a  -> 1\\n00010 - e  -> 1<<1\\n00100 - i  -> 1<<2\\n01000 - o  -> 1<<3\\n10000 - u  -> 1<<4\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        \\n         Dictionary<char,int> dic=new Dictionary<char,int>(){{\\'a\\',1},{\\'e\\',1<<1},{\\'i\\',1<<2},{\\'o\\',1<<3},{\\'u\\',1<<4}};\\n         HashSet<char> hs=new HashSet<char>{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n         int mask=0,max=int.MinValue;\\n         Dictionary<int,int> position=new();\\n         position.Add(0,-1);\\n\\n         for(int i=0;i<s.Length;i++)\\n         {\\n             if(hs.Contains(s[i]))\\n               mask=mask^dic[s[i]];\\n\\n            if(!position.ContainsKey(mask))\\n               position[mask]=i;\\n\\n            max=Math.Max(max,i-position[mask]);        \\n         }\\n         return max;\\n    }\\n}\\n\\n```\\n\\nIf you have any doubts please comment below.I will answer as soon as possible.\\n\\nThanks !!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        \\n         Dictionary<char,int> dic=new Dictionary<char,int>(){{\\'a\\',1},{\\'e\\',1<<1},{\\'i\\',1<<2},{\\'o\\',1<<3},{\\'u\\',1<<4}};\\n         HashSet<char> hs=new HashSet<char>{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n         int mask=0,max=int.MinValue;\\n         Dictionary<int,int> position=new();\\n         position.Add(0,-1);\\n\\n         for(int i=0;i<s.Length;i++)\\n         {\\n             if(hs.Contains(s[i]))\\n               mask=mask^dic[s[i]];\\n\\n            if(!position.ContainsKey(mask))\\n               position[mask]=i;\\n\\n            max=Math.Max(max,i-position[mask]);        \\n         }\\n         return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993458,
                "title": "op-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int returnbit(char c)\\n    {\\n        if (c==\\'a\\')\\n            return 1;\\n        else if (c==\\'e\\')\\n            return 2;\\n        else if (c==\\'i\\')\\n            return 4;\\n        else if (c==\\'o\\')\\n            return 8;\\n        else if (c==\\'u\\')\\n            return 16;\\n        else\\n            return -1;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            int r=returnbit(s[i]);\\n            if (r==-1)\\n            {\\n               r=0;\\n            }\\n            mask=mask^r;\\n            if (mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[mask]);\\n            }\\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int returnbit(char c)\\n    {\\n        if (c==\\'a\\')\\n            return 1;\\n        else if (c==\\'e\\')\\n            return 2;\\n        else if (c==\\'i\\')\\n            return 4;\\n        else if (c==\\'o\\')\\n            return 8;\\n        else if (c==\\'u\\')\\n            return 16;\\n        else\\n            return -1;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            int r=returnbit(s[i]);\\n            if (r==-1)\\n            {\\n               r=0;\\n            }\\n            mask=mask^r;\\n            if (mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[mask]);\\n            }\\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955714,
                "title": "easy-to-understand-solution-short-and-concise",
                "content": "Please Upvote! If you like it.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int mask = 0,maxLen = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                mask^=s[i];\\n                if(!mp.count(mask))\\n                    mp[mask] = i;\\n            }\\n            maxLen = max(maxLen,i-mp[mask]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int mask = 0,maxLen = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                mask^=s[i];\\n                if(!mp.count(mask))\\n                    mp[mask] = i;\\n            }\\n            maxLen = max(maxLen,i-mp[mask]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902875,
                "title": "renowned-approach-in-different-fashion",
                "content": "# **JAI HIND JAI BHARAT**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.)you should know xor usage.\\n2.)X-OR works for numbers only not for char.\\n3.) 0 ^ \\'a\\' is not correct ,hence assign numbers to these vowels\\n   like a->1,e->2,i->4,o->8,u->16.......\\n4.)through a for loop , move on string s & make a map for xor values you obtain.\\n5.)If seen before simply calculate the length.\\n6.)return max possible length.\\n\\nDO UPVOTE IF HAVE GOT THE LOGIC\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int>mp1;\\n        mp1[\\'a\\']=1;\\n        mp1[\\'e\\']=2;\\n        mp1[\\'i\\']=4;\\n        mp1[\\'o\\']=8;\\n        mp1[\\'u\\']=16;\\n        map<int,int>mp2;\\n        mp2[0]= -1;\\n        int len = 0;\\n        int demo = 0;\\n        for(int i = 0;i<s.size();++i)\\n        {\\n            demo = demo ^ mp1[s[i]];\\n            if(mp2.count(demo)==0)\\n            {\\n                mp2[demo] = i;\\n            }\\n            else\\n            {\\n                len = max(len,i - mp2[demo]);\\n            }\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int>mp1;\\n        mp1[\\'a\\']=1;\\n        mp1[\\'e\\']=2;\\n        mp1[\\'i\\']=4;\\n        mp1[\\'o\\']=8;\\n        mp1[\\'u\\']=16;\\n        map<int,int>mp2;\\n        mp2[0]= -1;\\n        int len = 0;\\n        int demo = 0;\\n        for(int i = 0;i<s.size();++i)\\n        {\\n            demo = demo ^ mp1[s[i]];\\n            if(mp2.count(demo)==0)\\n            {\\n                mp2[demo] = i;\\n            }\\n            else\\n            {\\n                len = max(len,i - mp2[demo]);\\n            }\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899038,
                "title": "simple-python-solution-using-rolling-and-prefix-counter-no-bit-manipulation",
                "content": "Idea is simple: we take a rolling counter and record the first time we see some encoding. To find the longest substring with even counts, we just look at the first time we saw the same encoding.\\n\\nWhy? Say we have some count like `a: 1, e: 3, i: 5, o: 4, u: 2`\\nThe encoding of this counter would be (odd, odd, odd, even, even)\\nHow can we make this counter all even?\\n\\nWell, we need to subtract an odd number of `a`, an odd number of `e`, an even odd number of `i`, an even number of `o`, and an even number of `u`. That\\'s the exact same encoding (odd, odd, odd, even, even). To get the longest such, we want the *first* time we saw this counter.\\n\\nHopefully you can see how this is similar to some prefix sum problems.\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def encode(c):\\n            return c[\\'a\\']%2, c[\\'e\\']%2, c[\\'i\\']%2, c[\\'o\\']%2, c[\\'u\\']%2\\n        \\n        longest = 0\\n        memo = {}\\n        counter = collections.Counter()\\n        memo[encode(counter)] = -1\\n        for i, char in enumerate(s):\\n            counter[char] += 1\\n            code = encode(counter)\\n            if code not in memo:\\n                memo[code] = i\\n            else:\\n                longest = max(longest, i-memo[code])\\n        return longest\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def encode(c):\\n            return c[\\'a\\']%2, c[\\'e\\']%2, c[\\'i\\']%2, c[\\'o\\']%2, c[\\'u\\']%2\\n        \\n        longest = 0\\n        memo = {}\\n        counter = collections.Counter()\\n        memo[encode(counter)] = -1\\n        for i, char in enumerate(s):\\n            counter[char] += 1\\n            code = encode(counter)\\n            if code not in memo:\\n                memo[code] = i\\n            else:\\n                longest = max(longest, i-memo[code])\\n        return longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876874,
                "title": "c-detailed-explanation-with-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is inspired by [this post](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solutions/534135/c-java-with-picture/?orderBy=most_votes).\\nThis question is an impletation of [560. Subarray Sum Equals K](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solutions/534135/c-java-with-picture/?orderBy=most_votes).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For every index \\'i\\' we need to see which vowels count are even and which vowels count are odd.\\n2. We use bit manipulation to see whether the count is even or odd since we don\\'t need the total count in this case. We use the least significant 5 bits to mark the 5 vowels.\\n3. If the current mask is 0 we can say that our substring from s[0 to i] contains only even characters since all the 5 least significant bits are set to 0.\\n4. We can also say that our substring s[i+1 to j] (where mask[i] = mask[j])\\ncontains only even vowels since at \\'i only those bits were set which are set at \\'j\\'.   eg - at mask[i] = 00101 and at index mask[j] = 00101, then that means s[i+1 to j] contains only even number of each vowels since we are discarding the previous occurences till index \\'i\\'.\\n# Complexity\\n- Time complexity: \\n O(n) {String is traversed only once.}\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n O(1) {Only constant extra space of O(128) is used which can be further reduced if required.}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //1 - (-1) , 5 - 1\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int , int>codeFirstSeen;\\n        vector<int>mask(128 , 0);\\n        mask[\\'a\\'] = 1 << 0;\\n        mask[\\'e\\'] = 1 << 1;\\n        mask[\\'i\\'] = 1 << 2;\\n        mask[\\'o\\'] = 1 << 3;\\n        mask[\\'u\\'] = 1 << 4;\\n        int currMask = 0;\\n        codeFirstSeen[currMask] = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            char ch = s[i];\\n            currMask = currMask ^ mask[ch];\\n            if(currMask != 0 and codeFirstSeen.find(currMask) == codeFirstSeen.end())\\n            {\\n                codeFirstSeen[currMask] = i;\\n            }\\n            ans = max(ans , i - codeFirstSeen[currMask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    //1 - (-1) , 5 - 1\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int , int>codeFirstSeen;\\n        vector<int>mask(128 , 0);\\n        mask[\\'a\\'] = 1 << 0;\\n        mask[\\'e\\'] = 1 << 1;\\n        mask[\\'i\\'] = 1 << 2;\\n        mask[\\'o\\'] = 1 << 3;\\n        mask[\\'u\\'] = 1 << 4;\\n        int currMask = 0;\\n        codeFirstSeen[currMask] = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            char ch = s[i];\\n            currMask = currMask ^ mask[ch];\\n            if(currMask != 0 and codeFirstSeen.find(currMask) == codeFirstSeen.end())\\n            {\\n                codeFirstSeen[currMask] = i;\\n            }\\n            ans = max(ans , i - codeFirstSeen[currMask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838505,
                "title": "easy-c-solution-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int bit=0;\\n        int ans=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                bit=bit^(1<<(s[i]-\\'a\\'));\\n            }\\n            if(mp.find(bit)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[bit]);\\n            }\\n            else\\n            {\\n                 mp[bit]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int bit=0;\\n        int ans=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                bit=bit^(1<<(s[i]-\\'a\\'));\\n            }\\n            if(mp.find(bit)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[bit]);\\n            }\\n            else\\n            {\\n                 mp[bit]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790093,
                "title": "clear-and-clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        int num = 0;\\n        mp[0] = -1;\\n        for(int i = 0; i < s.size(); i++){\\n             if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                 ans = ans ^ (1 << (s[i] - \\'a\\'));\\n            if(mp.find(ans) == mp.end())\\n                 mp[ans] = i;\\n            else\\n                num = max(num,i - mp[ans]);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        int num = 0;\\n        mp[0] = -1;\\n        for(int i = 0; i < s.size(); i++){\\n             if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                 ans = ans ^ (1 << (s[i] - \\'a\\'));\\n            if(mp.find(ans) == mp.end())\\n                 mp[ans] = i;\\n            else\\n                num = max(num,i - mp[ans]);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782593,
                "title": "easy-c-solution-bitmask",
                "content": "```\\nint findTheLongestSubstring(string s) {\\n       vector<int>mask(32,-1);\\n        int m=0;\\n        int maxlen=0;\\n      \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'i\\'){\\n                m=m^((s[i]-\\'a\\')+1);\\n            }\\n            else{\\n                m=m^0;\\n            }\\n            if(m!=0&&mask[m]==-1){\\n                mask[m]=i;\\n            }\\n            else{\\n                maxlen=max(maxlen,i-mask[m]);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint findTheLongestSubstring(string s) {\\n       vector<int>mask(32,-1);\\n        int m=0;\\n        int maxlen=0;\\n      \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'i\\'){\\n                m=m^((s[i]-\\'a\\')+1);\\n            }\\n            else{\\n                m=m^0;\\n            }\\n            if(m!=0&&mask[m]==-1){\\n                mask[m]=i;\\n            }\\n            else{\\n                maxlen=max(maxlen,i-mask[m]);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683023,
                "title": "python-solution-simple-bitmask-and-xor",
                "content": "2 notes:\\n1.  dict.get is slow. Use \"if key not in dict\" check instead\\n2.  We only the front and back of the indices. So keep only two indices for each state\\n```\\nclass Solution:\\n    # We do not care about non vowels\\n    # and there are only 5 vowels, aeiou\\n    # And we do not care about the exact number, but only if they are odd or even.\\n    # Therefore we might use a bitmask of length 5 to represent the vowels\\n    # The number of possible states is only 32\\n    # We can then iterate through s\\n    # If we see non vowels, we simply attach the current index to the XOR key\\n    # If we see vowels, we update the current key by applying ^ (1<<i)\\n    # Afterwards, we can easily find the longest substring by subtracting the last index of x and first index of x^0\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = \"aeiou\"\\n        vowels_map = {}\\n        for i, c in enumerate(vowels):\\n            vowels_map[c] = i\\n        \\n        hash_table, prefix = {}, 0\\n        hash_table[0] = [-1]\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                prefix ^= (1 << vowels_map[c])\\n            if prefix not in hash_table:\\n                hash_table[prefix] = []\\n            if len(hash_table[prefix]) <= 1:\\n                hash_table[prefix].append(i)\\n            else:\\n                hash_table[prefix][-1] = i\\n        \\n        result = 0\\n        for i in range(1<<5):\\n            if i in hash_table and i^0 in hash_table:\\n                result = max(result, hash_table[i][-1]-hash_table[i^0][0])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # We do not care about non vowels\\n    # and there are only 5 vowels, aeiou\\n    # And we do not care about the exact number, but only if they are odd or even.\\n    # Therefore we might use a bitmask of length 5 to represent the vowels\\n    # The number of possible states is only 32\\n    # We can then iterate through s\\n    # If we see non vowels, we simply attach the current index to the XOR key\\n    # If we see vowels, we update the current key by applying ^ (1<<i)\\n    # Afterwards, we can easily find the longest substring by subtracting the last index of x and first index of x^0\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = \"aeiou\"\\n        vowels_map = {}\\n        for i, c in enumerate(vowels):\\n            vowels_map[c] = i\\n        \\n        hash_table, prefix = {}, 0\\n        hash_table[0] = [-1]\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                prefix ^= (1 << vowels_map[c])\\n            if prefix not in hash_table:\\n                hash_table[prefix] = []\\n            if len(hash_table[prefix]) <= 1:\\n                hash_table[prefix].append(i)\\n            else:\\n                hash_table[prefix][-1] = i\\n        \\n        result = 0\\n        for i in range(1<<5):\\n            if i in hash_table and i^0 in hash_table:\\n                result = max(result, hash_table[i][-1]-hash_table[i^0][0])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581796,
                "title": "python-solution",
                "content": "```\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\': 16, \\'e\\': 8, \\'i\\': 4, \\'o\\': 2, \\'u\\': 1}\\n        vote_dict = {0: -1}\\n        vcount = 0\\n        ans = 0\\n        for idx, c in enumerate(s):\\n            if c in vowels.keys():\\n                vcount = vcount ^ vowels[c]\\n            \\n            if vcount in vote_dict.keys():\\n                ans = max(ans, idx - vote_dict[vcount])\\n            else:\\n                vote_dict[vcount] = idx\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\': 16, \\'e\\': 8, \\'i\\': 4, \\'o\\': 2, \\'u\\': 1}\\n        vote_dict = {0: -1}\\n        vcount = 0\\n        ans = 0\\n        for idx, c in enumerate(s):\\n            if c in vowels.keys():\\n                vcount = vcount ^ vowels[c]\\n            \\n            if vcount in vote_dict.keys():\\n                ans = max(ans, idx - vote_dict[vcount])\\n            else:\\n                vote_dict[vcount] = idx\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2556756,
                "title": "prefixsum-map-c-o-n-solution",
                "content": "```\\n int findTheLongestSubstring(string s) {\\n        \\n        //its like all those problems jisme map use krke hum previous positiom dekhte ki ye sum kaha pr aya previously us hisab se size nikalte bs  yaha sum ke bdle xor hoga xor kyu hoga ?? xor isliye hoga kuki yaa to koi vowel odd time(1) occur hoga ya even time(0) 0,1 values ki form me represent kr skte aur agar prefix xor krte krte hume same mask mila lets suppose 2nd position tk \\'e\\' odd numeber me the nd 9th pos me b \\'e\\' odd numbers me the to in dono ka mask ki \\'e-\\'0\\' th bit 1 hogi mtlb ki same mask vps mila to mtlb 2-9 ke bich me jo substring hai usme even number of \\'e\\' hoge . SO THIS QUESTION IS A MIXTURE OF BITMASK,PREFIX-SUM and MAP.\\n        map<int,int> m;\\n        int num=0,maxLen=0;\\n        m[num]=-1;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n              if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n                 num^=(1<<(s[i]-\\'a\\'));\\n            \\n            if(m.find(num)!=m.end()) //same mask have already occured before\\n                maxLen=max(maxLen,i-m[num]);\\n            else\\n                m[num]=i;\\n        }\\n        \\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "```\\n int findTheLongestSubstring(string s) {\\n        \\n        //its like all those problems jisme map use krke hum previous positiom dekhte ki ye sum kaha pr aya previously us hisab se size nikalte bs  yaha sum ke bdle xor hoga xor kyu hoga ?? xor isliye hoga kuki yaa to koi vowel odd time(1) occur hoga ya even time(0) 0,1 values ki form me represent kr skte aur agar prefix xor krte krte hume same mask mila lets suppose 2nd position tk \\'e\\' odd numeber me the nd 9th pos me b \\'e\\' odd numbers me the to in dono ka mask ki \\'e-\\'0\\' th bit 1 hogi mtlb ki same mask vps mila to mtlb 2-9 ke bich me jo substring hai usme even number of \\'e\\' hoge . SO THIS QUESTION IS A MIXTURE OF BITMASK,PREFIX-SUM and MAP.\\n        map<int,int> m;\\n        int num=0,maxLen=0;\\n        m[num]=-1;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n              if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n                 num^=(1<<(s[i]-\\'a\\'));\\n            \\n            if(m.find(num)!=m.end()) //same mask have already occured before\\n                maxLen=max(maxLen,i-m[num]);\\n            else\\n                m[num]=i;\\n        }\\n        \\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2541980,
                "title": "c-bit-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }\\n            else\\n                mp[cnt]=i;\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2505884,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int mask = 0, ans = 0, val;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            val = 0;\\n             \\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' ||\\n              s[i] == \\'u\\')\\n            {\\n                val = s[i];\\n            }\\n            \\n            mask = mask ^ val;\\n            \\n            if(!mp.count(mask))\\n            {\\n                mp[mask] = i;\\n            }\\n            \\n            ans = max(ans, i-mp[mask]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int mask = 0, ans = 0, val;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            val = 0;\\n             \\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' ||\\n              s[i] == \\'u\\')\\n            {\\n                val = s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2473378,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<char,int>c_m;\\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    c_m[\\'a\\']=1;\\n    c_m[\\'e\\']=2;\\n    c_m[\\'i\\']=3;\\n    c_m[\\'o\\']=4;\\n    c_m[\\'u\\']=5;\\n    unordered_map<int,int>m;\\n    m[0]=-1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= 1<<c_m[s[i]];\\n        int f=mask;\\n        f=f>>1;\\n       if(m.find(f)==m.end())\\n       {\\n           m[f]=i;\\n       }\\n        res = max(res, i - m[f]);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<char,int>c_m;\\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    c_m[\\'a\\']=1;\\n    c_m[\\'e\\']=2;\\n    c_m[\\'i\\']=3;\\n    c_m[\\'o\\']=4;\\n    c_m[\\'u\\']=5;\\n    unordered_map<int,int>m;\\n    m[0]=-1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= 1<<c_m[s[i]];\\n        int f=mask;\\n        f=f>>1;\\n       if(m.find(f)==m.end())\\n       {\\n           m[f]=i;\\n       }\\n        res = max(res, i - m[f]);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453095,
                "title": "easy-c-bitwise-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        //use bit mask of length 5\\n        vector<int> mp(40,-2);\\n        int mask=0;\\n        vector<int> arr(26,0);\\n        int res=0;\\n        arr[0]=4;\\n        arr[\\'e\\'-\\'a\\']=3;\\n        arr[\\'i\\'-\\'a\\']=2;\\n        arr[\\'o\\'-\\'a\\']=1;\\n        arr[\\'u\\'-\\'a\\']=0;\\n        mp[0]=-1;\\n        //the mask will be the sawe if some substring has even number of vowels\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isVowel(s[i]))\\n                mask=mask^(1<<arr[s[i]-\\'a\\']);\\n            if(mp[mask]!=-2)\\n                res=max(res,i-mp[mask]);\\n            if(mp[mask]==-2)\\n                mp[mask]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        //use bit mask of length 5\\n        vector<int> mp(40,-2);\\n        int mask=0;\\n        vector<int> arr(26,0);\\n        int res=0;\\n        arr[0]=4;\\n        arr[\\'e\\'-\\'a\\']=3;\\n        arr[\\'i\\'-\\'a\\']=2;\\n        arr[\\'o\\'-\\'a\\']=1;\\n        arr[\\'u\\'-\\'a\\']=0;\\n        mp[0]=-1;\\n        //the mask will be the sawe if some substring has even number of vowels\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isVowel(s[i]))\\n                mask=mask^(1<<arr[s[i]-\\'a\\']);\\n            if(mp[mask]!=-2)\\n                res=max(res,i-mp[mask]);\\n            if(mp[mask]==-2)\\n                mp[mask]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374990,
                "title": "c-easy-solu",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int n=s.size();\\n        int mask=0;\\n      unordered_map<int,set<int>>mp;\\n        mp[0].insert(-1);\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            if(s[i]==\\'a\\')\\n            {\\n                mask^=(1<<0);\\n            }\\n            else if(s[i]==\\'e\\')\\n            {\\n                mask^=(1<<1);\\n            }else if(s[i]==\\'i\\')\\n            {\\n                mask^=(1<<2);\\n            }\\n           else if(s[i]==\\'o\\')\\n            {\\n                mask^=(1<<3);\\n            }\\n            else if(s[i]==\\'u\\')\\n            {\\n                mask^=(1<<4);\\n            }\\n            if(mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-(*mp[mask].begin()));\\n            }\\n            \\n            mp[mask].insert(i);  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int n=s.size();\\n        int mask=0;\\n      unordered_map<int,set<int>>mp;\\n        mp[0].insert(-1);\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            if(s[i]==\\'a\\')\\n            {\\n                mask^=(1<<0);\\n            }\\n            else if(s[i]==\\'e\\')\\n            {\\n                mask^=(1<<1);\\n            }else if(s[i]==\\'i\\')\\n            {\\n                mask^=(1<<2);\\n            }\\n           else if(s[i]==\\'o\\')\\n            {\\n                mask^=(1<<3);\\n            }\\n            else if(s[i]==\\'u\\')\\n            {\\n                mask^=(1<<4);\\n            }\\n            if(mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-(*mp[mask].begin()));\\n            }\\n            \\n            mp[mask].insert(i);  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348372,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        D = {} \\n        numa = 0 \\n        nume = 0 \\n        numi = 0 \\n        numo = 0 \\n        numu = 0 \\n        \\n        ans = 0 \\n        for ind, c in enumerate(s):\\n            numa += c == \\'a\\'\\n            nume += c == \\'e\\' \\n            numi += c == \\'i\\'\\n            numo += c == \\'o\\'\\n            numu += c == \\'u\\'\\n            \\n            if (numa%2,nume%2,numi%2,numo%2,numu%2) not in D : \\n                D[(numa%2,nume%2,numi%2,numo%2,numu%2)] = ind \\n            else:\\n                ans = max(ans,ind -D[(numa%2,nume%2,numi%2,numo%2,numu%2)] )\\n            \\n            if numa%2==0 and nume%2==0 and numi%2==0 and numo%2==0 and numu%2==0:\\n                ans = max(ans,ind+1) \\n\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        D = {}",
                "codeTag": "Java"
            },
            {
                "id": 2321451,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int ans=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            String str=s.substring(0,i+1);\\n            int ch[]=new int[26];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                ch[str.charAt(j)-\\'a\\']++;\\n            }\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n            for(int j=1;j<s.length()-i;j++)\\n            {\\n                \\n                ch[s.charAt(j-1)-\\'a\\']--;\\n                ch[s.charAt(j+i)-\\'a\\']++;\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n          }\\n            if(ans!=0)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int ans=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            String str=s.substring(0,i+1);\\n            int ch[]=new int[26];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                ch[str.charAt(j)-\\'a\\']++;\\n            }\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n            for(int j=1;j<s.length()-i;j++)\\n            {\\n                \\n                ch[s.charAt(j-1)-\\'a\\']--;\\n                ch[s.charAt(j+i)-\\'a\\']++;\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n          }\\n            if(ans!=0)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319675,
                "title": "c-17-mapping-from-vowel-bitmask-to-the-left-most-position-of-its-occurrences",
                "content": "\\n\\n```\\n// Ideas / Approach: similar to LongestAwsomeSubstring.\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        // vowels: a e i o u\\n        // bit #:  0 1 2 3 4\\n\\n        // * because we care only about whether a vowel\\'s occurrences are even or odd, using a\\n        // single bit in a bitmask suffices the needs.\\n        // 5 vowels ==> 5 bits in a bitmask ==> 2^5 entries, ie 32 entries.\\n        // since the entries are just a small number, we can use an array to serve as the mapping.\\n\\n        // * because we wants the longest substring, in the mapping from vowel-bitmask to position,\\n        //   we\\'ll keep the position of the leftmost occurrence of a vowel-bitmask.\\n        // * at each iteration, we queries the mapping that wether the same bitmask occurred before.\\n        // If it does, then the distance between the leftmost occurrence and the current pos is a\\n        // candidate.\\n\\n        array<int, 32> m{}; //  leftMostPosForBitMask\\n        const int NotMeaningful = s.size();\\n        for (int i = 0; i < 32; ++i) {\\n            m[i] = NotMeaningful;\\n        }\\n\\n        m[0] = -1; // all-zero mask occurs before the s[0] is processed.\\n\\n        int best = 0;\\n        int8_t mask = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            int8_t vowelBit = VowelToBit(s[i]);\\n            if (vowelBit > 0) {\\n                mask ^= vowelBit;\\n            }\\n            if (m[mask] == NotMeaningful) { // not found\\n                m[mask] = i;\\n            } else {\\n                int len = i - m[mask];\\n                best = max(best, len);\\n            }\\n        }\\n\\n        return best;\\n    }\\n\\nprivate:\\n    static inline int8_t VowelToBit(char c) {\\n        switch (c) {\\n        case \\'a\\':\\n            return 1;\\n        case \\'e\\':\\n            return 1 << 1;\\n        case \\'i\\':\\n            return 1 << 2;\\n        case \\'o\\':\\n            return 1 << 3;\\n        case \\'u\\':\\n            return 1 << 4;\\n\\n        default:\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n// Ideas / Approach: similar to LongestAwsomeSubstring.\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        // vowels: a e i o u\\n        // bit #:  0 1 2 3 4\\n\\n        // * because we care only about whether a vowel\\'s occurrences are even or odd, using a\\n        // single bit in a bitmask suffices the needs.\\n        // 5 vowels ==> 5 bits in a bitmask ==> 2^5 entries, ie 32 entries.\\n        // since the entries are just a small number, we can use an array to serve as the mapping.\\n\\n        // * because we wants the longest substring, in the mapping from vowel-bitmask to position,\\n        //   we\\'ll keep the position of the leftmost occurrence of a vowel-bitmask.\\n        // * at each iteration, we queries the mapping that wether the same bitmask occurred before.\\n        // If it does, then the distance between the leftmost occurrence and the current pos is a\\n        // candidate.\\n\\n        array<int, 32> m{}; //  leftMostPosForBitMask\\n        const int NotMeaningful = s.size();\\n        for (int i = 0; i < 32; ++i) {\\n            m[i] = NotMeaningful;\\n        }\\n\\n        m[0] = -1; // all-zero mask occurs before the s[0] is processed.\\n\\n        int best = 0;\\n        int8_t mask = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            int8_t vowelBit = VowelToBit(s[i]);\\n            if (vowelBit > 0) {\\n                mask ^= vowelBit;\\n            }\\n            if (m[mask] == NotMeaningful) { // not found\\n                m[mask] = i;\\n            } else {\\n                int len = i - m[mask];\\n                best = max(best, len);\\n            }\\n        }\\n\\n        return best;\\n    }\\n\\nprivate:\\n    static inline int8_t VowelToBit(char c) {\\n        switch (c) {\\n        case \\'a\\':\\n            return 1;\\n        case \\'e\\':\\n            return 1 << 1;\\n        case \\'i\\':\\n            return 1 << 2;\\n        case \\'o\\':\\n            return 1 << 3;\\n        case \\'u\\':\\n            return 1 << 4;\\n\\n        default:\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316023,
                "title": "using-mapper-and-mask",
                "content": "```\\n\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        int mask = 0, res = 0;\\n        int[] m = new int[32];\\n        Array.Fill(m, -1);\\n        for (int i = 0; i < s.Length; ++i) {\\n            mask ^= mapper(s[i]);\\n            if (mask != 0 && m[mask] == -1)\\n                m[mask] = i;\\n            res = Math.Max(res, i - m[mask]);\\n        }\\n        return res;\\n    }\\n    private int mapper(char c){\\n        return c switch{\\n                \\'a\\' => 1,\\n                \\'e\\'=>2,\\n                \\'i\\'=>4,\\n                \\'o\\'=>8,\\n                \\'u\\'=>16,\\n                _=>0,\\n        };\\n    }\\n}\\n```\\nO(n)",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        int mask = 0, res = 0;\\n        int[] m = new int[32];\\n        Array.Fill(m, -1);\\n        for (int i = 0; i < s.Length; ++i) {\\n            mask ^= mapper(s[i]);\\n            if (mask != 0 && m[mask] == -1)\\n                m[mask] = i;\\n            res = Math.Max(res, i - m[mask]);\\n        }\\n        return res;\\n    }\\n    private int mapper(char c){\\n        return c switch{\\n                \\'a\\' => 1,\\n                \\'e\\'=>2,\\n                \\'i\\'=>4,\\n                \\'o\\'=>8,\\n                \\'u\\'=>16,\\n                _=>0,\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278647,
                "title": "python-100-time-commented",
                "content": "Small speedup by only updating the max substring length when a new vowel is seen, otherwise it\\'s just like everyone else\\'s solution.\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        #lookup table mapping vowels to bit locations for the XOR operation\\n        self.vowel_XOR_dict = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n\\n        \\n    def findTheLongestSubstring(self, s):        \\n        #min_index_list[vowel_parity = p] is the index of the min length prefix with vowel parity p\\n        #-1 corresponds to the empty prefix (which has parity 0), thus min_index_list[0]=-1\\n        min_index_list = {0:-1}\\n        \\n        #maximum length of substrings with even # of vowels\\n        max_length = 0\\n        \\n        #current vowel parity\\n        vowel_parity = 0\\n        \\n        #iterate through each character in s\\n        for i in range(len(s)):          \\n            #if we see a vowel...\\n            if s[i] in self.vowel_XOR_dict:\\n                #since the parity is changing at index i, \\n                #then index i-1 is the largest index seen so far at the previous parity\\n                #so, update the maximum length substring value\\n                max_length = max(max_length,i-1-min_index_list[vowel_parity])\\n                \\n                #update the current parity\\n                vowel_parity^=self.vowel_XOR_dict[s[i]]\\n                \\n                #if we have not seen this parity before, put it in the minimum index list\\n                if vowel_parity not in min_index_list:\\n                    min_index_list[vowel_parity] = i\\n                    \\n        #update the maximum length substring value for the parity of the last prefix (whole string)      \\n        max_length = max(max_length,len(s)-1-min_index_list[vowel_parity])\\n        return max_length\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def __init__(self):\\n        #lookup table mapping vowels to bit locations for the XOR operation\\n        self.vowel_XOR_dict = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}",
                "codeTag": "Java"
            },
            {
                "id": 2268777,
                "title": "java-bitmask-dp-solution-o-n-2-5",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length(), ans = 0;\\n        char[] vowels = new char[] {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // dp[i][mask] -> longest substring ends at i with the vowels occurred odd(bit value = 1)/even(bit value = 0) number of times\\n        int[][] dp = new int[n+1][1<<5];\\n        for (int i = 0; i <= n; i++) Arrays.fill(dp[i], -(1<<30));\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int j = idx(s.charAt(i-1), vowels);\\n            if (j!=-1) dp[i][1<<j] = 1;\\n            else dp[i][0] = 1;\\n            for (int msk = 0; msk < 1<<5; msk++) {\\n                if (j!=-1) {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk^(1<<j)] + 1);\\n                }\\n                else {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk] + 1);\\n                }\\n            }\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int idx(char c, char[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            if (vowels[i] == c) return vowels.length-i-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length(), ans = 0;\\n        char[] vowels = new char[] {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // dp[i][mask] -> longest substring ends at i with the vowels occurred odd(bit value = 1)/even(bit value = 0) number of times\\n        int[][] dp = new int[n+1][1<<5];\\n        for (int i = 0; i <= n; i++) Arrays.fill(dp[i], -(1<<30));\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int j = idx(s.charAt(i-1), vowels);\\n            if (j!=-1) dp[i][1<<j] = 1;\\n            else dp[i][0] = 1;\\n            for (int msk = 0; msk < 1<<5; msk++) {\\n                if (j!=-1) {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk^(1<<j)] + 1);\\n                }\\n                else {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk] + 1);\\n                }\\n            }\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int idx(char c, char[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            if (vowels[i] == c) return vowels.length-i-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255592,
                "title": "c",
                "content": "int findTheLongestSubstring(char * s){\\n    int window = 0;\\n    int posBitMap[26] = {0};\\n    posBitMap[\\'a\\'-\\'a\\'] = 1;\\n    posBitMap[\\'e\\' - \\'a\\'] = 2;\\n    posBitMap[\\'i\\' - \\'a\\'] = 4;\\n    posBitMap[\\'o\\' - \\'a\\'] = 8;\\n    posBitMap[\\'u\\' - \\'a\\'] = 16;\\n    \\n    int xorChar = 0;\\n    int count = 0;\\n    int states[32] = {0};\\n\\n    for(int clrSt = 0; clrSt < 32; clrSt++)\\n        states[clrSt] = -1;\\n    for(window = 0; s[window] != NULL; window++)\\n    {\\n        xorChar = xorChar ^ posBitMap[s[window] - \\'a\\'];\\n\\n        if(states[xorChar] == -1 && xorChar != 0)\\n        {\\n            states[xorChar] = window;\\n        }\\n\\n        count = count > (window - states[xorChar]) ? count : (window - states[xorChar]);    \\n    }\\n    return count;\\n}\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "int findTheLongestSubstring(char * s){\\n    int window = 0;\\n    int posBitMap[26] = {0};\\n    posBitMap[\\'a\\'-\\'a\\'] = 1;\\n    posBitMap[\\'e\\' - \\'a\\'] = 2;\\n    posBitMap[\\'i\\' - \\'a\\'] = 4;\\n    posBitMap[\\'o\\' - \\'a\\'] = 8;\\n    posBitMap[\\'u\\' - \\'a\\'] = 16;\\n    \\n    int xorChar = 0;\\n    int count = 0;\\n    int states[32] = {0};\\n\\n    for(int clrSt = 0; clrSt < 32; clrSt++)\\n        states[clrSt] = -1;\\n    for(window = 0; s[window] != NULL; window++)\\n    {\\n        xorChar = xorChar ^ posBitMap[s[window] - \\'a\\'];\\n\\n        if(states[xorChar] == -1 && xorChar != 0)\\n        {\\n            states[xorChar] = window;\\n        }\\n\\n        count = count > (window - states[xorChar]) ? count : (window - states[xorChar]);    \\n    }\\n    return count;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2214354,
                "title": "clean-c-solution-with-bitmasking",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n  int findTheLongestSubstring(string s)\\n    {\\n\\n        unordered_map<char, int> vowelpos;\\n        unordered_map<int, int> sametypeidx;\\n\\n        vowelpos[\\'a\\'] = 4;\\n        vowelpos[\\'e\\'] = 3;\\n        vowelpos[\\'i\\'] = 2;\\n        vowelpos[\\'o\\'] = 1;\\n        vowelpos[\\'u\\'] = 0;\\n\\n        int res = 0;\\n\\n        int mask=0;\\n\\n        sametypeidx[0]=-1;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n\\n            if(vowelpos.count(s[i]))\\n            mask=mask^(1<<vowelpos[s[i]]);\\n\\n            if (sametypeidx.count(mask))\\n                res = max(res, i - sametypeidx[mask]);\\n\\n            else\\n                sametypeidx[mask] = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n  int findTheLongestSubstring(string s)\\n    {\\n\\n        unordered_map<char, int> vowelpos;\\n        unordered_map<int, int> sametypeidx;\\n\\n        vowelpos[\\'a\\'] = 4;\\n        vowelpos[\\'e\\'] = 3;\\n        vowelpos[\\'i\\'] = 2;\\n        vowelpos[\\'o\\'] = 1;\\n        vowelpos[\\'u\\'] = 0;\\n\\n        int res = 0;\\n\\n        int mask=0;\\n\\n        sametypeidx[0]=-1;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n\\n            if(vowelpos.count(s[i]))\\n            mask=mask^(1<<vowelpos[s[i]]);\\n\\n            if (sametypeidx.count(mask))\\n                res = max(res, i - sametypeidx[mask]);\\n\\n            else\\n                sametypeidx[mask] = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210856,
                "title": "python-simple-logic",
                "content": "\\n    def findTheLongestSubstring(self, s):\\n        vowels = {\"a\":1, \"e\":2, \"i\":4, \"o\":8, \"u\":16}\\n        dict1, cur, max_len = {0:-1}, 0, 0\\n        \\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cur = cur^vowels[c]\\n            if cur not in dict1:\\n                dict1[cur] = i\\n            else:\\n                max_len = max(max_len, i - dict1[cur])\\n                \\n        return max_len",
                "solutionTags": [],
                "code": "\\n    def findTheLongestSubstring(self, s):\\n        vowels = {\"a\":1, \"e\":2, \"i\":4, \"o\":8, \"u\":16}\\n        dict1, cur, max_len = {0:-1}, 0, 0\\n        \\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cur = cur^vowels[c]\\n            if cur not in dict1:\\n                dict1[cur] = i\\n            else:\\n                max_len = max(max_len, i - dict1[cur])\\n                \\n        return max_len",
                "codeTag": "Python3"
            },
            {
                "id": 2209495,
                "title": "c-code-hashing-and-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int> mp;\\n        map<int,int> m;\\n        \\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=2;\\n        mp[\\'i\\']=4;\\n        mp[\\'o\\']=8;\\n        mp[\\'u\\']=16;\\n        \\n        m[0]=-1;\\n        int jor=0,i=0;\\n        int n=s.length();\\n        int ans=0;\\n        \\n        while (i<n){\\n            if (mp[s[i]]){\\n                jor^=mp[s[i]];\\n            }\\n            \\n            if (m.find(jor)!=m.end()){\\n                ans=max(ans,i-m[jor]);\\n            }\\n            \\n            if (m.find(jor)==m.end()){\\n                m[jor]=i;\\n            }\\n            i++;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int> mp;\\n        map<int,int> m;\\n        \\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=2;\\n        mp[\\'i\\']=4;\\n        mp[\\'o\\']=8;\\n        mp[\\'u\\']=16;\\n        \\n        m[0]=-1;\\n        int jor=0,i=0;\\n        int n=s.length();\\n        int ans=0;\\n        \\n        while (i<n){\\n            if (mp[s[i]]){\\n                jor^=mp[s[i]];\\n            }\\n            \\n            if (m.find(jor)!=m.end()){\\n                ans=max(ans,i-m[jor]);\\n            }\\n            \\n            if (m.find(jor)==m.end()){\\n                m[jor]=i;\\n            }\\n            i++;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196775,
                "title": "c-solution-by-sliding-window-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int n = s.size();\\n        unordered_map<char, int> mapping;\\n        /*\\n            {a: 0, e: 1, i: 2, o: 3, u: 4}, other letter: -1\\n        */\\n        mapping.insert({\\'a\\', 0});\\n        mapping.insert({\\'e\\', 1});\\n        mapping.insert({\\'i\\', 2});\\n        mapping.insert({\\'o\\', 3});\\n        mapping.insert({\\'u\\', 4});\\n        for (int letter = 0; letter < 26; letter++){\\n            char c = letter + \\'a\\';\\n            if (mapping.count(c) == 0){\\n                mapping.insert({c, -1});\\n            }\\n        }\\n        vector<vector<int>> prefix(5, vector<int>(n, 0));\\n        char c = s[0];\\n        if (mapping[c] != -1){\\n            prefix[mapping[c]][0] = 1;\\n        }\\n        for (int i = 1; i < n; i++){\\n            int current_letter = mapping[s[i]];\\n            for (int letter = 0; letter < 5; letter++){\\n                prefix[letter][i] = prefix[letter][i - 1];\\n                if (current_letter == letter){\\n                    prefix[letter][i]++;\\n                }\\n            }\\n        }\\n        for (int sliding = n; sliding > 0; sliding--){\\n            if (is_satisfied(prefix, n, mapping, sliding)){\\n                return sliding;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool is_satisfied(vector<vector<int>>& prefix, int n, unordered_map<char, int>& mapping, int sliding){\\n        // printf(\"sliding = %d\\\\n\", sliding);\\n        int vowels[5];\\n        for (int start = 0; start <= n - sliding; start++){\\n            int back = start + sliding - 1;\\n            // take look at [start, back]\\n            bool satisfied = true;\\n            if (start == 0){\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back] - prefix[letter][start - 1];\\n                }\\n            }\\n            for (int letter = 0; letter < 5; letter++){\\n                if (vowels[letter] % 2 != 0){\\n                    // printf(\"return false.\\\\n\");\\n                    satisfied = false;\\n                    break;\\n                }\\n            }\\n            if (satisfied){\\n                // printf(\"return true, satisfied region is[%d, %d]\\\\n\", start, back);\\n                // for (int letter = 0; letter < 5; letter++){\\n                //     printf(\"letter:%c, count:%d\\\\n\", letter + \\'a\\', vowels[letter]);\\n                // }\\n                return true;\\n            }\\n        }\\n        // printf(\"return false.\\\\n\");\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int n = s.size();\\n        unordered_map<char, int> mapping;\\n        /*\\n            {a: 0, e: 1, i: 2, o: 3, u: 4}, other letter: -1\\n        */\\n        mapping.insert({\\'a\\', 0});\\n        mapping.insert({\\'e\\', 1});\\n        mapping.insert({\\'i\\', 2});\\n        mapping.insert({\\'o\\', 3});\\n        mapping.insert({\\'u\\', 4});\\n        for (int letter = 0; letter < 26; letter++){\\n            char c = letter + \\'a\\';\\n            if (mapping.count(c) == 0){\\n                mapping.insert({c, -1});\\n            }\\n        }\\n        vector<vector<int>> prefix(5, vector<int>(n, 0));\\n        char c = s[0];\\n        if (mapping[c] != -1){\\n            prefix[mapping[c]][0] = 1;\\n        }\\n        for (int i = 1; i < n; i++){\\n            int current_letter = mapping[s[i]];\\n            for (int letter = 0; letter < 5; letter++){\\n                prefix[letter][i] = prefix[letter][i - 1];\\n                if (current_letter == letter){\\n                    prefix[letter][i]++;\\n                }\\n            }\\n        }\\n        for (int sliding = n; sliding > 0; sliding--){\\n            if (is_satisfied(prefix, n, mapping, sliding)){\\n                return sliding;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool is_satisfied(vector<vector<int>>& prefix, int n, unordered_map<char, int>& mapping, int sliding){\\n        // printf(\"sliding = %d\\\\n\", sliding);\\n        int vowels[5];\\n        for (int start = 0; start <= n - sliding; start++){\\n            int back = start + sliding - 1;\\n            // take look at [start, back]\\n            bool satisfied = true;\\n            if (start == 0){\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back] - prefix[letter][start - 1];\\n                }\\n            }\\n            for (int letter = 0; letter < 5; letter++){\\n                if (vowels[letter] % 2 != 0){\\n                    // printf(\"return false.\\\\n\");\\n                    satisfied = false;\\n                    break;\\n                }\\n            }\\n            if (satisfied){\\n                // printf(\"return true, satisfied region is[%d, %d]\\\\n\", start, back);\\n                // for (int letter = 0; letter < 5; letter++){\\n                //     printf(\"letter:%c, count:%d\\\\n\", letter + \\'a\\', vowels[letter]);\\n                // }\\n                return true;\\n            }\\n        }\\n        // printf(\"return false.\\\\n\");\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187909,
                "title": "easy-python-solution",
                "content": "```\\nv = {\\'a\\':0, \\'e\\':1, \\'i\\':2, \\'o\\':3, \\'u\\':4}\\ncurr = 0\\nleft = dict()\\nleft[0] = -1\\nans = 0\\nfor index, i in enumerate(s):\\n\\tif(i in v):\\n\\t\\tcurr ^= (1<<v[i])\\n\\tif(curr not in left):\\n\\t\\tleft[curr] = index\\n\\telse:\\n\\t\\tans = max(ans, index - left[curr])\\nreturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nv = {\\'a\\':0, \\'e\\':1, \\'i\\':2, \\'o\\':3, \\'u\\':4}\\ncurr = 0\\nleft = dict()\\nleft[0] = -1\\nans = 0\\nfor index, i in enumerate(s):\\n\\tif(i in v):\\n\\t\\tcurr ^= (1<<v[i])\\n\\tif(curr not in left):\\n\\t\\tleft[curr] = index\\n\\telse:\\n\\t\\tans = max(ans, index - left[curr])\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161265,
                "title": "javascript-bitmask-prefix-sum-173ms",
                "content": "```\\nconst findTheLongestSubstring = (s) => {\\n    let n = s.length, m = new Map([[0, -1]]), res = 0, cur = 0, mask = [1, 2, 4, 8, 16];\\n    for (let i = 0; i < n; i++) {\\n        let idx = \\'aeiou\\'.indexOf(s[i]);\\n        if (idx != -1) cur ^= mask[idx];\\n        if (!m.has(cur)) m.set(cur, i); // set min index for cur\\n        let len = i - m.get(cur);\\n        res = Math.max(res, len);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nconst findTheLongestSubstring = (s) => {\\n    let n = s.length, m = new Map([[0, -1]]), res = 0, cur = 0, mask = [1, 2, 4, 8, 16];\\n    for (let i = 0; i < n; i++) {\\n        let idx = \\'aeiou\\'.indexOf(s[i]);\\n        if (idx != -1) cur ^= mask[idx];\\n        if (!m.has(cur)) m.set(cur, i); // set min index for cur\\n        let len = i - m.get(cur);\\n        res = Math.max(res, len);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140451,
                "title": "python-bitmask-clean-code",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        first_occured_index = defaultdict(lambda:float(\\'inf\\'),{0:-1})\\n        cur = res = 0\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\":\\n                cur ^= (1<<(ord(c)-ord(\\'a\\')))\\n                first_occured_index[cur] = min(first_occured_index[cur], i)\\n            res = max(res, i-first_occured_index[cur])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        first_occured_index = defaultdict(lambda:float(\\'inf\\'),{0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 2135967,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string A ) {\\n        \\n        string vowel = \"aeiou\";\\n        \\n        for( auto &x : A )\\n        {\\n            if( count(vowel.begin() , vowel.end(),x) )\\n            {\\n                if( x == \\'a\\' ) x = \\'0\\';\\n                if( x == \\'e\\' ) x = \\'1\\';\\n                if( x == \\'i\\' ) x = \\'2\\';\\n                if( x == \\'o\\' ) x = \\'3\\';\\n                if( x == \\'u\\' ) x = \\'4\\';\\n                \\n            }\\n        }\\n        \\n        unordered_map< string , int > M ;\\n        string t = \"00000\";\\n        \\n        M[t] = -1 ;\\n        \\n        int mx = 0 ;\\n        \\n        for( int i = 0 ; i < A.size() ; i++ )\\n        {\\n            if( A[i] >= \\'0\\' && A[i] <= \\'4\\' )\\n                t[A[i]-\\'0\\']++;\\n            \\n            for( auto &x : t )\\n            {\\n                int v = x-\\'0\\';\\n                v %= 2 ;\\n                \\n                x = v + \\'0\\';\\n            }\\n            \\n            if( M.find(t) != M.end() )\\n                mx = max( mx , i - M[t] );\\n\\n            if( M.find(t) == M.end() )\\n                M[t] = i ; \\n        }\\n        return mx ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string A ) {\\n        \\n        string vowel = \"aeiou\";\\n        \\n        for( auto &x : A )\\n        {\\n            if( count(vowel.begin() , vowel.end(),x) )\\n            {\\n                if( x == \\'a\\' ) x = \\'0\\';\\n                if( x == \\'e\\' ) x = \\'1\\';\\n                if( x == \\'i\\' ) x = \\'2\\';\\n                if( x == \\'o\\' ) x = \\'3\\';\\n                if( x == \\'u\\' ) x = \\'4\\';\\n                \\n            }\\n        }\\n        \\n        unordered_map< string , int > M ;\\n        string t = \"00000\";\\n        \\n        M[t] = -1 ;\\n        \\n        int mx = 0 ;\\n        \\n        for( int i = 0 ; i < A.size() ; i++ )\\n        {\\n            if( A[i] >= \\'0\\' && A[i] <= \\'4\\' )\\n                t[A[i]-\\'0\\']++;\\n            \\n            for( auto &x : t )\\n            {\\n                int v = x-\\'0\\';\\n                v %= 2 ;\\n                \\n                x = v + \\'0\\';\\n            }\\n            \\n            if( M.find(t) != M.end() )\\n                mx = max( mx , i - M[t] );\\n\\n            if( M.find(t) == M.end() )\\n                M[t] = i ; \\n        }\\n        return mx ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130968,
                "title": "c-o-n-bitmask-for-vowels-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m;\\n        unordered_map<char, int> xx;\\n        xx[\\'a\\'] = 0;\\n        xx[\\'e\\'] = 1;\\n        xx[\\'i\\'] = 2;\\n        xx[\\'o\\'] = 3;\\n        xx[\\'u\\'] = 4;\\n        int num = 0, ans = 0;\\n        m[num] = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(xx.find(s[i]) != xx.end())\\n                num^=(1<<xx[s[i]]);\\n            if(m.find(num) != m.end())\\n                ans = max(ans, i - m[num]);\\n            else\\n                m[num] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m;\\n        unordered_map<char, int> xx;\\n        xx[\\'a\\'] = 0;\\n        xx[\\'e\\'] = 1;\\n        xx[\\'i\\'] = 2;\\n        xx[\\'o\\'] = 3;\\n        xx[\\'u\\'] = 4;\\n        int num = 0, ans = 0;\\n        m[num] = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(xx.find(s[i]) != xx.end())\\n                num^=(1<<xx[s[i]]);\\n            if(m.find(num) != m.end())\\n                ans = max(ans, i - m[num]);\\n            else\\n                m[num] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096710,
                "title": "python-bitmask-o-n-fastest-and-fugal",
                "content": "I have explanained step by step usign comments.\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define seen dict to store last seen position of mask\\n        seen = {0: -1}\\n        res = cur = 0\\n        \\n        # As vowels in fixed so manually define in dictionary\\n        vowel = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n        \\n        \\n        for i, c in enumerate(s):\\n            # if it\\'s not vowel then return 0\\n            cur ^= vowel.get(c,0)\\n            \\n            # save mask with it\\'s seen position if it dosen\\'t set yet\\n            seen.setdefault(cur, i)\\n            \\n            res = max(res, i - seen[cur])\\n        return res\\n```\\n\\n**upVote^** if you find this helpful. Comment below for any query.",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define seen dict to store last seen position of mask\\n        seen = {0: -1}\\n        res = cur = 0\\n        \\n        # As vowels in fixed so manually define in dictionary\\n        vowel = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n        \\n        \\n        for i, c in enumerate(s):\\n            # if it\\'s not vowel then return 0\\n            cur ^= vowel.get(c,0)\\n            \\n            # save mask with it\\'s seen position if it dosen\\'t set yet\\n            seen.setdefault(cur, i)\\n            \\n            res = max(res, i - seen[cur])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036375,
                "title": "go-o-n",
                "content": "```\\npackage q_1371\\n\\nvar (\\n\\tVowels2Idx = map[rune]int{\\n\\t\\t\\'a\\': 0,\\n\\t\\t\\'e\\': 1,\\n\\t\\t\\'i\\': 2,\\n\\t\\t\\'o\\': 3,\\n\\t\\t\\'u\\': 4,\\n\\t}\\n)\\n\\ntype VowelsCountManager struct {\\n\\tvowels2Idx          map[rune]int\\n\\tvowelsCnt2MaxStrIdx map[int]int\\n\\tvowelsCnt2MinStrIdx map[int]int\\n}\\n\\nfunc NewVowelsCountManager() (retHandler *VowelsCountManager) {\\n\\tretHandler = &VowelsCountManager{\\n\\t\\tvowels2Idx:          Vowels2Idx,\\n\\t\\tvowelsCnt2MaxStrIdx: map[int]int{},\\n\\t\\tvowelsCnt2MinStrIdx: map[int]int{\\n\\t\\t\\t0: -1,\\n\\t\\t},\\n\\t}\\n\\treturn retHandler\\n}\\n\\nfunc (h *VowelsCountManager) Count(s string) (retLen int) {\\n\\truneArr := []rune(s)\\n\\tbitMap := 0\\n\\tfor idx, char := range runeArr {\\n\\t\\tif vIdx, isVowel := h.vowels2Idx[char]; isVowel {\\n\\t\\t\\tbitMap ^= 1 << vIdx\\n\\t\\t\\t//fmt.Println(bitMap)\\n\\t\\t}\\n\\t\\tif max, exist := h.vowelsCnt2MaxStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t} else if max < idx {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t\\tif min, exist := h.vowelsCnt2MinStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t} else if min > idx {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t}\\n\\t//fmt.Println(h.vowelsCnt2MaxStrIdx)\\n\\t//fmt.Println(h.vowelsCnt2MinStrIdx)\\n\\tfor bitMap, max := range h.vowelsCnt2MaxStrIdx {\\n\\t\\tif min, minExist := h.vowelsCnt2MinStrIdx[bitMap]; minExist {\\n\\t\\t\\tlen := max - min\\n\\t\\t\\tif len > retLen {\\n\\t\\t\\t\\tretLen = len\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn retLen\\n}\\n\\nfunc findTheLongestSubstring(s string) (retLen int) {\\n\\th := NewVowelsCountManager()\\n\\tretLen = h.Count(s)\\n\\treturn\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npackage q_1371\\n\\nvar (\\n\\tVowels2Idx = map[rune]int{\\n\\t\\t\\'a\\': 0,\\n\\t\\t\\'e\\': 1,\\n\\t\\t\\'i\\': 2,\\n\\t\\t\\'o\\': 3,\\n\\t\\t\\'u\\': 4,\\n\\t}\\n)\\n\\ntype VowelsCountManager struct {\\n\\tvowels2Idx          map[rune]int\\n\\tvowelsCnt2MaxStrIdx map[int]int\\n\\tvowelsCnt2MinStrIdx map[int]int\\n}\\n\\nfunc NewVowelsCountManager() (retHandler *VowelsCountManager) {\\n\\tretHandler = &VowelsCountManager{\\n\\t\\tvowels2Idx:          Vowels2Idx,\\n\\t\\tvowelsCnt2MaxStrIdx: map[int]int{},\\n\\t\\tvowelsCnt2MinStrIdx: map[int]int{\\n\\t\\t\\t0: -1,\\n\\t\\t},\\n\\t}\\n\\treturn retHandler\\n}\\n\\nfunc (h *VowelsCountManager) Count(s string) (retLen int) {\\n\\truneArr := []rune(s)\\n\\tbitMap := 0\\n\\tfor idx, char := range runeArr {\\n\\t\\tif vIdx, isVowel := h.vowels2Idx[char]; isVowel {\\n\\t\\t\\tbitMap ^= 1 << vIdx\\n\\t\\t\\t//fmt.Println(bitMap)\\n\\t\\t}\\n\\t\\tif max, exist := h.vowelsCnt2MaxStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t} else if max < idx {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t\\tif min, exist := h.vowelsCnt2MinStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t} else if min > idx {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t}\\n\\t//fmt.Println(h.vowelsCnt2MaxStrIdx)\\n\\t//fmt.Println(h.vowelsCnt2MinStrIdx)\\n\\tfor bitMap, max := range h.vowelsCnt2MaxStrIdx {\\n\\t\\tif min, minExist := h.vowelsCnt2MinStrIdx[bitMap]; minExist {\\n\\t\\t\\tlen := max - min\\n\\t\\t\\tif len > retLen {\\n\\t\\t\\t\\tretLen = len\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn retLen\\n}\\n\\nfunc findTheLongestSubstring(s string) (retLen int) {\\n\\th := NewVowelsCountManager()\\n\\tretLen = h.Count(s)\\n\\treturn\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947093,
                "title": "python-o-n",
                "content": "\\'\\'\\'\\n\\n\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        self.mask = {0: -1}\\n        cur_mask = 0\\n        vowel    = \\'aeiou\\'\\n        \\n        answer = 0\\n        tmp = 0\\n        for idx in range(0, len(s)):\\n            char = s[idx]\\n            if char not in vowel:\\n                tmp += 1\\n                continue\\n            if answer < tmp:\\n                answer = tmp\\n            if char == \\'a\\':\\n                cur_mask = cur_mask ^ 2 ** 0\\n            elif char == \\'e\\':\\n                cur_mask = cur_mask ^ 2 ** 1\\n            elif char == \\'i\\':\\n                cur_mask = cur_mask ^ 2 ** 2\\n            elif char == \\'o\\':\\n                cur_mask = cur_mask ^ 2 ** 3\\n            elif char == \\'u\\':\\n                cur_mask = cur_mask ^ 2 ** 4\\n            \\n            if self.mask.get(cur_mask) is None:\\n                self.mask[cur_mask] = idx\\n                tmp = 0\\n            else:\\n                tmp = idx - self.mask.get(cur_mask)\\n        else:\\n            if answer < tmp:\\n                answer = tmp\\n        \\n        return answer\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        self.mask = {0: -1}\\n        cur_mask = 0\\n        vowel    = \\'aeiou\\'\\n        \\n        answer = 0\\n        tmp = 0\\n        for idx in range(0, len(s)):\\n            char = s[idx]\\n            if char not in vowel:\\n                tmp += 1\\n                continue\\n            if answer < tmp:\\n                answer = tmp\\n            if char == \\'a\\':\\n                cur_mask = cur_mask ^ 2 ** 0\\n            elif char == \\'e\\':\\n                cur_mask = cur_mask ^ 2 ** 1\\n            elif char == \\'i\\':\\n                cur_mask = cur_mask ^ 2 ** 2\\n            elif char == \\'o\\':\\n                cur_mask = cur_mask ^ 2 ** 3\\n            elif char == \\'u\\':\\n                cur_mask = cur_mask ^ 2 ** 4\\n            \\n            if self.mask.get(cur_mask) is None:\\n                self.mask[cur_mask] = idx\\n                tmp = 0\\n            else:\\n                tmp = idx - self.mask.get(cur_mask)\\n        else:\\n            if answer < tmp:\\n                answer = tmp\\n        \\n        return answer\\n\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1946987,
                "title": "easy-explanation-with-code",
                "content": "First build intuition:\\n1. To know if a given substring contains a vowel even number of times, we don\\'t need vowel\\'s count. We need a value either false (say non-zero) or true (say 0).\\n2. XOR properties\\n\\ta. 0 ^ any = any\\n\\tb. any ^ any = 0 (i.e. take any number even number of times xored with itself, it will give 0)\\n\\t\\nNow, the code is easy. Just have dry run over \"eleetminicoworoep\". It will be super intuitive.\\n\\n```\\n// TC : O(N)\\n// SC : O(1) since we have limited range (due to input constraint of \\'a\\'-\\'z\\' only)\\nprivate final static HashMap<Character, Integer> charToUniqueNumMap = new HashMap<>() {{\\n\\t\\tput(\\'a\\', 1);\\n\\t\\tput(\\'e\\', 2);\\n\\t\\tput(\\'i\\', 4);\\n\\t\\tput(\\'o\\', 8);\\n\\t\\tput(\\'u\\', 16);\\n\\t}};\\n\\nprivate boolean isVowel(char ch) {\\n\\treturn ch == \\'a\\' \\n\\t\\t\\t|| ch == \\'e\\'\\n\\t\\t\\t|| ch == \\'i\\'\\n\\t\\t\\t|| ch == \\'o\\'\\n\\t\\t\\t|| ch == \\'u\\';\\n}\\n\\npublic int findTheLongestSubstring(String s) {\\n\\tHashMap<Integer, Integer> mp = new HashMap<>();\\n\\tmp.put(0, -1);\\n\\n\\tint xor = 0;\\n\\tint maxLen = 0;\\n\\tint N = s.length();\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\txor = xor ^ (isVowel(ch) ? charToUniqueNumMap.get(ch) : 0);\\n\\t\\tif (mp.containsKey(xor)) {\\n\\t\\t\\tmaxLen = Math.max(maxLen, i-mp.get(xor));\\n\\t\\t}\\n\\t\\tmp.putIfAbsent(xor, i);\\n\\t}\\n\\n\\treturn maxLen;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// TC : O(N)\\n// SC : O(1) since we have limited range (due to input constraint of \\'a\\'-\\'z\\' only)\\nprivate final static HashMap<Character, Integer> charToUniqueNumMap = new HashMap<>() {{\\n\\t\\tput(\\'a\\', 1);\\n\\t\\tput(\\'e\\', 2);\\n\\t\\tput(\\'i\\', 4);\\n\\t\\tput(\\'o\\', 8);\\n\\t\\tput(\\'u\\', 16);\\n\\t}};\\n\\nprivate boolean isVowel(char ch) {\\n\\treturn ch == \\'a\\' \\n\\t\\t\\t|| ch == \\'e\\'\\n\\t\\t\\t|| ch == \\'i\\'\\n\\t\\t\\t|| ch == \\'o\\'\\n\\t\\t\\t|| ch == \\'u\\';\\n}\\n\\npublic int findTheLongestSubstring(String s) {\\n\\tHashMap<Integer, Integer> mp = new HashMap<>();\\n\\tmp.put(0, -1);\\n\\n\\tint xor = 0;\\n\\tint maxLen = 0;\\n\\tint N = s.length();\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\txor = xor ^ (isVowel(ch) ? charToUniqueNumMap.get(ch) : 0);\\n\\t\\tif (mp.containsKey(xor)) {\\n\\t\\t\\tmaxLen = Math.max(maxLen, i-mp.get(xor));\\n\\t\\t}\\n\\t\\tmp.putIfAbsent(xor, i);\\n\\t}\\n\\n\\treturn maxLen;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916343,
                "title": "simple-easy-o-n",
                "content": "Convert char  a  e  i  o  u    to its Ascii value and XOR them.\\n\\n\\n```\\n public int findTheLongestSubstring(String s) {\\n        \\n        int stream=0;\\n        Map<Integer,Integer> m= new HashMap<>();\\n        int max=0;\\n        m.putIfAbsent(stream,0);\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                int c=s.charAt(i);\\n                stream=stream ^ c;\\n            }\\n            m.putIfAbsent(stream,i+1);\\n           \\n            max=Math.max(max,i+1-m.get(stream));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int findTheLongestSubstring(String s) {\\n        \\n        int stream=0;\\n        Map<Integer,Integer> m= new HashMap<>();\\n        int max=0;\\n        m.putIfAbsent(stream,0);\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                int c=s.charAt(i);\\n                stream=stream ^ c;\\n            }\\n            m.putIfAbsent(stream,i+1);\\n           \\n            max=Math.max(max,i+1-m.get(stream));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904721,
                "title": "c-aeiou-one-integer-5-bits-32-variations-warmup-for-meta-onsite",
                "content": "April 1, 2022\\n**Introduction**\\nI could not come out working ideas to solve the algorithm. I tried to solve it using sliding window to beat brute force O(N^2) solution, but it does not work. I was so nervous since I could not find a solution, there are five vowel chars, and I need to determine left pointer with matching vowel char count even or odd. Left pointer can be moved forward and backward two directions. So I chose to read votrubac solution, since I chose to go through algorithms based on his up-voted algorithms. \\n\\n**Idea to count all vowel chars \"aeiou\" | even 0, odd 1| \"00001\" meaning: a is odd, four chars in \"eiou\" even | Easy to play**\\nGo through each char in given string once, and record the count in terms of 0 or 1 for five chars in \"aeiou\". If it is not found then set variable smallestIndex, apply substring comparison to any char not just vowel char. Do not skip non-vowel in comparison. Try yourself first, and then read my C# code, good luck!\\n\\n**Bit operation | C# | My bug written in my first practice**\\nIt is easy for me to write a C# bit operation algorithm. I checked all C# discuss post, none of them uses bit operation, so I decided to write one. But my code failed to return correct answer, given example, eleetminicoworoep, should return 13, but mine is 12. I could not figure out the reason, so I had to spend over 10 minutes to debug. \\n\\nI should apply caclulation of matching vowel chars \"vowel\" even substring to any char, not just vowel. In other words, \"leetminicowor\", my search stops \"leetminicowo\", but skip last char \\'r\\' since it is not vowel. \\n\\nI quickly fixed the bug to limit scope of if statement in the following:\\n```\\n// update bitVariation if it is vowel char\\nif (index >= 0)  // if it is vowel char\\n{\\n    var current = 1 << index;  // left shift\\n    bitVariation ^= current; // double check XOR ^\\n}\\n```\\nDo you think that it is worth time for me to practice writing and debugging? I have ideas to solve the problem using bit operation, and I can write C# code but I stumbled a few places since I did not practice and took breaks over six months in 2021. \\n\\n**Places I stumbled in C#:** \\n1. Declare C# bool[32] variable found, default value is false; but I was not sure until I debugged the code;\\n2. C# String.IndexOf(char) - syntax and usage, I have to depend on Visual Studio prompt to determine;\\n3. C# << left shift, only provide information once, vowels = \"aeiou\", I can quickly figure out how many bits to shift left;\\n4. C# XOR ^ - this is important XOR using module 2 as result, in other words 1^1 = 0, 1^0 = 1, 0^0 = 0;\\n\\n**The algorithm I chose to work on based on votrubac**\\nI cannot find time to work on more than 200 submission last 12 months, so I have to figure out ways to compensate on this lack-of-hardwork. After carefully reviewing my options, I choose to work on a most reputable player and his up-voted algorithms, compared to mock interview, paid udemy FANG interview algorithm courses. Here is the idea. Welcome comments  how to choose algorithms to work on to prepare Meta onsite. I have this idea after I reviewed 50 algorithms tag Facebook last six months. \\n\\n![image](https://assets.leetcode.com/users/images/40df5275-de43-449d-a887-943b7a4d34b8_1648850650.6111696.jpeg)\\n![image](https://assets.leetcode.com/users/images/a9e92e23-a01f-4e50-8225-fa77b4a50fa7_1648850672.7423983.jpeg)\\n\\nThe current algorithm is fourth algorithm below red circled algorthm in page 2. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1371_Find_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var longest = FindTheLongestSubstring(\"eleetminicoworoep\");\\n            Debug.Assert(longest == 13);\\n        }\\n\\n        /// <summary>\\n        /// code review on April 1, 2022\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int FindTheLongestSubstring(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n                return 0; \\n\\n            var vowels = \"aeiou\";\\n            var smallestIndex = new int[32];\\n            var found = new bool[32]; // default - false           \\n\\n            smallestIndex[0] = -1;\\n            found[0] = true;\\n\\n            var bitVariation = 0; // five bit, each bit matches one of vowel char \"aeiou\"\\n            var length = s.Length;\\n            var maxSubstringLength = 0; \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var c = s[i];\\n                var index = vowels.IndexOf(c);\\n\\n                // update bitVariation if it is vowel char\\n                if (index >= 0)  // if it is vowel char\\n                {\\n                    var current = 1 << index;  // left shift\\n                    bitVariation ^= current; // double check XOR ^\\n                }\\n\\n                // it applies to any char\\n                if (!found[bitVariation])\\n                {\\n                    smallestIndex[bitVariation] = i;\\n                    found[bitVariation] = true;\\n                }\\n                else\\n                {\\n                    maxSubstringLength = Math.Max(maxSubstringLength, i - smallestIndex[bitVariation]); \\n                }                \\n            }\\n\\n            return maxSubstringLength; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// update bitVariation if it is vowel char\\nif (index >= 0)  // if it is vowel char\\n{\\n    var current = 1 << index;  // left shift\\n    bitVariation ^= current; // double check XOR ^\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1371_Find_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var longest = FindTheLongestSubstring(\"eleetminicoworoep\");\\n            Debug.Assert(longest == 13);\\n        }\\n\\n        /// <summary>\\n        /// code review on April 1, 2022\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int FindTheLongestSubstring(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n                return 0; \\n\\n            var vowels = \"aeiou\";\\n            var smallestIndex = new int[32];\\n            var found = new bool[32]; // default - false           \\n\\n            smallestIndex[0] = -1;\\n            found[0] = true;\\n\\n            var bitVariation = 0; // five bit, each bit matches one of vowel char \"aeiou\"\\n            var length = s.Length;\\n            var maxSubstringLength = 0; \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var c = s[i];\\n                var index = vowels.IndexOf(c);\\n\\n                // update bitVariation if it is vowel char\\n                if (index >= 0)  // if it is vowel char\\n                {\\n                    var current = 1 << index;  // left shift\\n                    bitVariation ^= current; // double check XOR ^\\n                }\\n\\n                // it applies to any char\\n                if (!found[bitVariation])\\n                {\\n                    smallestIndex[bitVariation] = i;\\n                    found[bitVariation] = true;\\n                }\\n                else\\n                {\\n                    maxSubstringLength = Math.Max(maxSubstringLength, i - smallestIndex[bitVariation]); \\n                }                \\n            }\\n\\n            return maxSubstringLength; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867257,
                "title": "c-bit-mask",
                "content": "```\\nclass Solution {\\n    int getbitpos(char c)\\n    {\\n        if (c == \\'a\\')\\n            return 0;\\n        else if (c == \\'e\\')\\n            return 1;\\n        else if (c == \\'i\\')\\n            return 2;\\n        else if (c == \\'o\\')\\n            return 3;\\n        else if (c == \\'u\\')\\n            return 4;\\n        else \\n            return -1;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int indices[32], n = s.size(), code = 0, ans = 0;\\n        for(int i=0; i<32; i++)\\n            indices[i] = INT_MAX;\\n        indices[0] = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            int bitpos = getbitpos(s[i]);\\n            if (bitpos != -1)\\n                code ^= 1<<bitpos;\\n            if (indices[code] == INT_MAX)\\n                indices[code] = i;\\n            ans = max(ans, i-indices[code]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getbitpos(char c)\\n    {\\n        if (c == \\'a\\')\\n            return 0;\\n        else if (c == \\'e\\')\\n            return 1;\\n        else if (c == \\'i\\')\\n            return 2;\\n        else if (c == \\'o\\')\\n            return 3;\\n        else if (c == \\'u\\')\\n            return 4;\\n        else \\n            return -1;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int indices[32], n = s.size(), code = 0, ans = 0;\\n        for(int i=0; i<32; i++)\\n            indices[i] = INT_MAX;\\n        indices[0] = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            int bitpos = getbitpos(s[i]);\\n            if (bitpos != -1)\\n                code ^= 1<<bitpos;\\n            if (indices[code] == INT_MAX)\\n                indices[code] = i;\\n            ans = max(ans, i-indices[code]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769723,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        vector<int> dp(32, s.size());\\n        dp[0] = -1;\\n        int len = 0;\\n        string temp = \"aeiou\";\\n        for(int i = 0; i < s.size(); i++){\\n            int index = ((1<<(temp.find(s[i])+1))>>1);\\n            mask = (mask^index);\\n            len = max(len, i-dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        vector<int> dp(32, s.size());\\n        dp[0] = -1;\\n        int len = 0;\\n        string temp = \"aeiou\";\\n        for(int i = 0; i < s.size(); i++){\\n            int index = ((1<<(temp.find(s[i])+1))>>1);\\n            mask = (mask^index);\\n            len = max(len, i-dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756609,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findTheLongestSubstring(string s) {\\n\\t\\t\\tint c=0,ans=0;\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tmp[0]=-1;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n\\t\\t\\t\\t\\t c^=1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\tif(!mp.count(c)) mp[c]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans=max(ans,i-mp[c]); \\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findTheLongestSubstring(string s) {\\n\\t\\t\\tint c=0,ans=0;\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tmp[0]=-1;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n\\t\\t\\t\\t\\t c^=1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\tif(!mp.count(c)) mp[c]=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1745856,
                "title": "golang-bitmask-subarray-caching",
                "content": "```\\nfunc findTheLongestSubstring(s string) int {\\n    // bitmask and subarray caching\\n    vowelMap := map[byte]int {\\n        \\'a\\': 0,\\n        \\'e\\': 1,\\n        \\'i\\': 2,\\n        \\'o\\': 3,\\n        \\'u\\': 4,\\n    }\\n    \\n    mask := 0\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at index -1, the bitmask representation is 00000, 0 of all vowels\\n    res := 0\\n    for i := range s {\\n        if j, isVowel := vowelMap[s[i]]; isVowel {\\n            mask = mask ^ (1 << j)  // toggle the jth bit\\n        }\\n        if prevEnd, exist := cache[mask]; exist {\\n            res = max(res, i - prevEnd)    \\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheLongestSubstring(s string) int {\\n    // bitmask and subarray caching\\n    vowelMap := map[byte]int {\\n        \\'a\\': 0,\\n        \\'e\\': 1,\\n        \\'i\\': 2,\\n        \\'o\\': 3,\\n        \\'u\\': 4,\\n    }\\n    \\n    mask := 0\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at index -1, the bitmask representation is 00000, 0 of all vowels\\n    res := 0\\n    for i := range s {\\n        if j, isVowel := vowelMap[s[i]]; isVowel {\\n            mask = mask ^ (1 << j)  // toggle the jth bit\\n        }\\n        if prevEnd, exist := cache[mask]; exist {\\n            res = max(res, i - prevEnd)    \\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741401,
                "title": "something-new-c-um-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int a = 0, e = 0, i = 0, o = 0, u = 0;\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        \\n        string ss = \"_____\";\\n        um[ss] = -1;\\n        \\n        int ind = 0;\\n        \\n        for(char c: s)\\n        {\\n            if(c == \\'a\\')\\n                a = !a;\\n            if(c == \\'e\\')\\n                e = !e;\\n            if(c == \\'i\\')\\n                i = !i;\\n            if(c == \\'o\\')\\n                o = !o;\\n            if(c == \\'u\\')\\n                u = !u;\\n          \\n            if(a) ss[0] = \\'a\\'; else ss[0] = \\'_\\';\\n            if(e) ss[1] = \\'e\\'; else ss[1] = \\'_\\';\\n            if(i) ss[2] = \\'i\\'; else ss[2] = \\'_\\';\\n            if(o) ss[3] = \\'o\\'; else ss[3] = \\'_\\';\\n            if(u) ss[4] = \\'u\\'; else ss[4] = \\'_\\';\\n            \\n            if(um.find(ss) != um.end())\\n            {\\n                ans = max(ans, ind - um[ss]);\\n            }\\n            else\\n            {\\n                um[ss] = ind;\\n            }\\n            \\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int a = 0, e = 0, i = 0, o = 0, u = 0;\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        \\n        string ss = \"_____\";\\n        um[ss] = -1;\\n        \\n        int ind = 0;\\n        \\n        for(char c: s)\\n        {\\n            if(c == \\'a\\')\\n                a = !a;\\n            if(c == \\'e\\')\\n                e = !e;\\n            if(c == \\'i\\')\\n                i = !i;\\n            if(c == \\'o\\')\\n                o = !o;\\n            if(c == \\'u\\')\\n                u = !u;\\n          \\n            if(a) ss[0] = \\'a\\'; else ss[0] = \\'_\\';\\n            if(e) ss[1] = \\'e\\'; else ss[1] = \\'_\\';\\n            if(i) ss[2] = \\'i\\'; else ss[2] = \\'_\\';\\n            if(o) ss[3] = \\'o\\'; else ss[3] = \\'_\\';\\n            if(u) ss[4] = \\'u\\'; else ss[4] = \\'_\\';\\n            \\n            if(um.find(ss) != um.end())\\n            {\\n                ans = max(ans, ind - um[ss]);\\n            }\\n            else\\n            {\\n                um[ss] = ind;\\n            }\\n            \\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738624,
                "title": "c-easy-to-understand-100-runtime-solution",
                "content": "int findTheLongestSubstring(string s) {\\n        \\n            int n=s.size();\\n            unordered_map<int , int> mp;\\n           \\n            mp[0]=-1;\\n            int mask=0,ans=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    char c=s[i];\\n                    if(c==\\'a\\' || c==\\'e\\' || c==\\'o\\' || c==\\'i\\' || c==\\'u\\')\\n                    {\\n                            int k=s[i]-\\'a\\';\\n                            mask= mask ^ ( 1<<k); // left shift   1* pow(2,k);\\n                    }\\n                    else\\n                    {\\n                            mask = mask^ 0; // gives same value as mask \\n                    }\\n                    \\n                    if(mask!=0 && mp.find(mask)==mp.end())\\n                    {\\n                            mp[mask]=i;\\n                    }\\n                    ans=max(ans , i-mp[mask]);\\n                    \\n            }\\n            return ans;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "int findTheLongestSubstring(string s) {\\n        \\n            int n=s.size();\\n            unordered_map<int , int> mp;\\n           \\n            mp[0]=-1;\\n            int mask=0,ans=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    char c=s[i];\\n                    if(c==\\'a\\' || c==\\'e\\' || c==\\'o\\' || c==\\'i\\' || c==\\'u\\')\\n                    {\\n                            int k=s[i]-\\'a\\';\\n                            mask= mask ^ ( 1<<k); // left shift   1* pow(2,k);\\n                    }\\n                    else\\n                    {\\n                            mask = mask^ 0; // gives same value as mask \\n                    }\\n                    \\n                    if(mask!=0 && mp.find(mask)==mp.end())\\n                    {\\n                            mp[mask]=i;\\n                    }\\n                    ans=max(ans , i-mp[mask]);\\n                    \\n            }\\n            return ans;\\n            \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1726477,
                "title": "n-complexity-with-explanation",
                "content": "so basically what we will do here is that we will take prefix xor upto all the indices and then a subarray has xor 0 if it is in the range between the given prefixes. Now we will take in account the maximum length possible .\\n\\n\\n\\n\\n\\n int findTheLongestSubstring(string s) {\\n        \\n       int i,j=0;\\n        int n=s.size();\\n        int ans=0;\\n        int dp[n];\\n        int c=0;\\n        if(s[0]==\\'a\\'||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\'){\\n            c=s[0];\\n          \\n        }\\n        dp[0]=c;\\n        unordered_map<int,int> mp;\\n        mp[dp[0]]=0;\\n        for(i=1;i<n;i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                 c=dp[i-1]^s[i];\\n             }\\n            dp[i]=c; \\n            if(dp[i]==0){\\n                ans=max(ans,i+1);\\n            }\\n            if(mp.find(dp[i])!=mp.end()){\\n                ans=max(ans,i-mp[dp[i]]);\\n            }\\n            if(mp.find(dp[i])==mp.end()){\\n                mp[dp[i]]=i;\\n            }\\n        }\\n        \\n        \\n        \\n       \\n        \\n        return ans;    \\n    }",
                "solutionTags": [],
                "code": "so basically what we will do here is that we will take prefix xor upto all the indices and then a subarray has xor 0 if it is in the range between the given prefixes. Now we will take in account the maximum length possible .\\n\\n\\n\\n\\n\\n int findTheLongestSubstring(string s) {\\n        \\n       int i,j=0;\\n        int n=s.size();\\n        int ans=0;\\n        int dp[n];\\n        int c=0;\\n        if(s[0]==\\'a\\'||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\'){\\n            c=s[0];\\n          \\n        }\\n        dp[0]=c;\\n        unordered_map<int,int> mp;\\n        mp[dp[0]]=0;\\n        for(i=1;i<n;i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                 c=dp[i-1]^s[i];\\n             }\\n            dp[i]=c; \\n            if(dp[i]==0){\\n                ans=max(ans,i+1);\\n            }\\n            if(mp.find(dp[i])!=mp.end()){\\n                ans=max(ans,i-mp[dp[i]]);\\n            }\\n            if(mp.find(dp[i])==mp.end()){\\n                mp[dp[i]]=i;\\n            }\\n        }\\n        \\n        \\n        \\n       \\n        \\n        return ans;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1685038,
                "title": "golang-o-n-detail-explanation",
                "content": "There are 5 vowel, number of each vowel is odd/even, thus could be represented by 1/0 -> there are 2^5 = 32 state\\n\\nAt each step `i` (0 <= i < len(s)), we will try to compute the state. There are 2 cases:\\n\\n1. If state == 0 -> all even -> obviously: max = i + 1\\n2. maximum len of substring, end with `i` is: i - first_index_where_state_appear[state]\\n\\t2.1 edge case: if first index is -1 -> just record first index is `i` and do nothing\\n\\n\\n```go\\nfunc findTheLongestSubstring(s string) (max int) {\\n    var fi [32]int // first index that state appears\\n    for i := range fi {\\n        fi[i] = -1\\n    }\\n   \\n    var state byte\\n    for i := range s {\\n        c := isVowel(s[i])\\n        \\n        if c != 5 {\\n           state ^= 1 << c // toggle on/off the bit using xor, odd->even, even->odd, 0->1, 1->0\\n        }\\n        \\n        if state == 0 {\\n            max = i + 1\\n        } else if prevPos := fi[state]; prevPos == -1 { // previous position, same state\\n            fi[state] = i\\n        } else if d := i - prevPos; d > max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc isVowel(ch byte) byte {\\n    switch ch {\\n    case \\'a\\':\\n        return 0\\n    case \\'e\\':\\n        return 1\\n    case \\'i\\':\\n        return 2 \\n    case \\'o\\':\\n        return 3\\n    case \\'u\\':\\n        return 4\\n    default:\\n        return 5\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findTheLongestSubstring(s string) (max int) {\\n    var fi [32]int // first index that state appears\\n    for i := range fi {\\n        fi[i] = -1\\n    }\\n   \\n    var state byte\\n    for i := range s {\\n        c := isVowel(s[i])\\n        \\n        if c != 5 {\\n           state ^= 1 << c // toggle on/off the bit using xor, odd->even, even->odd, 0->1, 1->0\\n        }\\n        \\n        if state == 0 {\\n            max = i + 1\\n        } else if prevPos := fi[state]; prevPos == -1 { // previous position, same state\\n            fi[state] = i\\n        } else if d := i - prevPos; d > max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc isVowel(ch byte) byte {\\n    switch ch {\\n    case \\'a\\':\\n        return 0\\n    case \\'e\\':\\n        return 1\\n    case \\'i\\':\\n        return 2 \\n    case \\'o\\':\\n        return 3\\n    case \\'u\\':\\n        return 4\\n    default:\\n        return 5\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640820,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int cur=0;\\n        unordered_map<char,int>mp,m;\\n        mp[\\'a\\']=0;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=2;\\n        mp[\\'o\\']=3;\\n        mp[\\'u\\']=4;\\n        m[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\'||(s[i]==\\'e\\'||(s[i]==\\'i\\'||(s[i]==\\'o\\'||s[i]==\\'u\\'))))\\n            {\\n                cur=cur^(1<<mp[s[i]]);\\n                \\n            }\\n            int x=cur;\\n           \\n            if(m.find(cur)!=m.end())\\n                {\\n                    ans=max(ans,i-(m[cur])+1);\\n                }\\n            else\\n                m[cur]=i+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int cur=0;\\n        unordered_map<char,int>mp,m;\\n        mp[\\'a\\']=0;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=2;\\n        mp[\\'o\\']=3;\\n        mp[\\'u\\']=4;\\n        m[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\'||(s[i]==\\'e\\'||(s[i]==\\'i\\'||(s[i]==\\'o\\'||s[i]==\\'u\\'))))\\n            {\\n                cur=cur^(1<<mp[s[i]]);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609945,
                "title": "dp-without-bit-manipulation",
                "content": "Easier to understand at first without the bit manipulation. This is the same technique with the same time complexity. The bit manipulation is just a trick to go faster. \\n\\nTime: O(len(s)). Space: O(1).\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\':0, \\'e\\':0, \\'i\\':0, \\'o\\':0, \\'u\\':0 }\\n        earliestSeen = { self.getKey(vowels):-1 }\\n        result = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                vowels[c] = (vowels[c] + 1) % 2\\n            seenKey = self.getKey(vowels)\\n            if seenKey in earliestSeen:\\n                result = max(result, i - earliestSeen[seenKey])\\n            else:\\n                earliestSeen[seenKey] = i\\n        return result\\n    \\n    def getKey(self, vowelsDict):\\n        return tuple([(key, val) for key, val in vowelsDict.items()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\':0, \\'e\\':0, \\'i\\':0, \\'o\\':0, \\'u\\':0 }\\n        earliestSeen = { self.getKey(vowels):-1 }\\n        result = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                vowels[c] = (vowels[c] + 1) % 2\\n            seenKey = self.getKey(vowels)\\n            if seenKey in earliestSeen:\\n                result = max(result, i - earliestSeen[seenKey])\\n            else:\\n                earliestSeen[seenKey] = i\\n        return result\\n    \\n    def getKey(self, vowelsDict):\\n        return tuple([(key, val) for key, val in vowelsDict.items()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603058,
                "title": "c-100ms-63-simple-easy-small-bit-hash",
                "content": "Runtime: 100 ms, faster than 62.87% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16.4 MB, less than 9.76% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    int mask_a = 1, mask_e = 2, mask_i = 4, mask_o = 8, mask_u = 16, mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      switch(s[i]){\\n        case \\'a\\': mask ^= mask_a; break;\\n        case \\'e\\': mask ^= mask_e; break;\\n        case \\'i\\': mask ^= mask_i; break;\\n        case \\'o\\': mask ^= mask_o; break;\\n        case \\'u\\': mask ^= mask_u; break;\\n      }\\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```\\n\\n**or such:**\\n\\nRuntime: 120 ms, faster than 45.80% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16.4 MB, less than 9.76% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    unordered_map<char,int>masks = {{\\'a\\',1}, {\\'e\\',2}, {\\'i\\',4}, {\\'o\\',8}, {\\'u\\',16}};\\n    int mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      if(masks.count(s[i])) mask ^= masks[s[i]]; \\n      \\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    int mask_a = 1, mask_e = 2, mask_i = 4, mask_o = 8, mask_u = 16, mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      switch(s[i]){\\n        case \\'a\\': mask ^= mask_a; break;\\n        case \\'e\\': mask ^= mask_e; break;\\n        case \\'i\\': mask ^= mask_i; break;\\n        case \\'o\\': mask ^= mask_o; break;\\n        case \\'u\\': mask ^= mask_u; break;\\n      }\\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    unordered_map<char,int>masks = {{\\'a\\',1}, {\\'e\\',2}, {\\'i\\',4}, {\\'o\\',8}, {\\'u\\',16}};\\n    int mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      if(masks.count(s[i])) mask ^= masks[s[i]]; \\n      \\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564670,
                "content": [
                    {
                        "username": "Switch2on",
                        "content": "According to the time top contesters spent on this problem and number of people who solved this question, I think the problem should be marked as hard. What do you think?"
                    },
                    {
                        "username": "yang_tomato",
                        "content": "I can\\'t agree more\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Limit of Balls in a Bag",
        "question_content": "<p>You are given an integer array <code>nums</code> where the <code>i<sup>th</sup></code> bag contains <code>nums[i]</code> balls. You are also given an integer <code>maxOperations</code>.</p>\n\n<p>You can perform the following operation at most <code>maxOperations</code> times:</p>\n\n<ul>\n\t<li>Take any bag of balls and divide it into two new bags with a <strong>positive </strong>number of balls.\n\n\t<ul>\n\t\t<li>For example, a bag of <code>5</code> balls can become two new bags of <code>1</code> and <code>4</code> balls, or two new bags of <code>2</code> and <code>3</code> balls.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Your penalty is the <strong>maximum</strong> number of balls in a bag. You want to <strong>minimize</strong> your penalty after the operations.</p>\n\n<p>Return <em>the minimum possible penalty after performing the operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9], maxOperations = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \n- Divide the bag with 9 balls into two bags of sizes 6 and 3. [<strong><u>9</u></strong>] -&gt; [6,3].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. [<strong><u>6</u></strong>,3] -&gt; [3,3,3].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,8,2], maxOperations = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,<strong><u>8</u></strong>,2] -&gt; [2,4,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,<strong><u>4</u></strong>,4,4,2] -&gt; [2,2,2,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,<strong><u>4</u></strong>,4,2] -&gt; [2,2,2,2,2,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,<strong><u>4</u></strong>,2] -&gt; [2,2,2,2,2,2,2,2].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= maxOperations, nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1064548,
                "title": "java-c-python-binary-search",
                "content": "# **Explanation**\\nBinary search the size of bag,\\nwhich is called penalty in this problem.\\n\\nFor each penalty value, we split the balls into bags with this value.\\nFor example, the `mid = 3`,\\n`A[i] = 2`, we split it into `[2]`, and operations = 0\\n`A[i] = 3`, we split it into `[3]`, and operations = 0\\n`A[i] = 4`, we split it into `[3,1]`, and operations = 1\\n`A[i] = 5`, we split it into `[3,2]`, and operations = 1\\n`A[i] = 6`, we split it into `[3,3]`, and operations = 1\\n`A[i] = 7`, we split it into `[3,3,1]`, and operations = 2\\n\\nThe number of operation we need is `(a - 1) / mid`\\n\\nIf the total operation > max operations,\\nthe size of bag is too small,\\nwe set `left = mid + 1`\\n\\nOtherwise,\\nthis size of bag is big enough,\\nwe set `right = mid`\\n\\nWe return the final result,\\nwhere result = left = right.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog10^9)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumSize(int[] A, int k) {\\n        int left = 1, right = 1_000_000_000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, count = 0;\\n            for (int a : A)\\n                count += (a - 1) / mid;\\n            if (count > k)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n**C++**\\n```cpp\\n    int minimumSize(vector<int>& A, int k) {\\n        int left = 1, right = 1e9;\\n        while (left < right) {\\n            int mid = (left + right) / 2, count = 0;\\n            for (int a : A)\\n                count += (a - 1) / mid;\\n            if (count > k)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\\n**Python**\\n```py\\n    def minimumSize(self, A, k):\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            if sum((a - 1) / mid for a in A) > k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minimumSize(int[] A, int k) {\\n        int left = 1, right = 1_000_000_000;\\n        while (left < right) {\\n            int mid = (left + right) / 2, count = 0;\\n            for (int a : A)\\n                count += (a - 1) / mid;\\n            if (count > k)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int minimumSize(vector<int>& A, int k) {\\n        int left = 1, right = 1e9;\\n        while (left < right) {\\n            int mid = (left + right) / 2, count = 0;\\n            for (int a : A)\\n                count += (a - 1) / mid;\\n            if (count > k)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def minimumSize(self, A, k):\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            if sum((a - 1) / mid for a in A) > k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1064793,
                "title": "binary-search-with-intuition-and-explanation",
                "content": "concept is similar to: 1011. capacity-to-ship-packages-within-d-days\\n\\n##### Intuition\\n* Minimum possible penalty can be 1, and max possible penalty can be eq to max element. This is the possible range of our answer.\\n* If we have a helper function which tells if it is possible to get a certain penalty considering the max number of operations allowed, we can perform binary search on above range to minimize the possible penalty.\\n\\n##### helper functon\\n* It calculates the total number of operations required to make every number less than or eq to the current assumed penalty.\\n* If the total ops required is less than or equal to the given limit of maxOperations, it is possible.\\n\\nBelow is the code for C++. Upvote if you found it useful.\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\tint start = 1, end = *max_element(nums.begin(), nums.end());\\n\\t\\tint minPenalty = end;\\n\\t\\t// binary search on possible range\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint penalty = start + (end-start)/2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, penalty))\\n\\t\\t\\t\\tminPenalty = penalty, end = penalty-1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = penalty+1;\\n\\t\\t}\\n\\n\\t\\treturn minPenalty;\\n\\t}\\n\\n\\tbool isPossible(vector<int>& nums, int maxOperations, int penalty) {\\n\\t\\tint requiredOps = 0;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\t// no. of operations required to bring n less than or eq to curr assumed penalty\\n\\t\\t\\tint x = n / penalty;\\n\\t\\t\\t// if n is divisible by penalty, need to subtract 1\\n\\t\\t\\tif (n % penalty == 0) x--;\\n\\t\\t\\trequiredOps += x;\\n\\t\\t}\\n\\t\\t// getting current penalty is possible only if required ops is <= maxOps\\n\\t\\treturn requiredOps <= maxOperations;\\n\\t}\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\tint start = 1, end = *max_element(nums.begin(), nums.end());\\n\\t\\tint minPenalty = end;\\n\\t\\t// binary search on possible range\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint penalty = start + (end-start)/2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, penalty))\\n\\t\\t\\t\\tminPenalty = penalty, end = penalty-1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = penalty+1;\\n\\t\\t}\\n\\n\\t\\treturn minPenalty;\\n\\t}\\n\\n\\tbool isPossible(vector<int>& nums, int maxOperations, int penalty) {\\n\\t\\tint requiredOps = 0;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\t// no. of operations required to bring n less than or eq to curr assumed penalty\\n\\t\\t\\tint x = n / penalty;\\n\\t\\t\\t// if n is divisible by penalty, need to subtract 1\\n\\t\\t\\tif (n % penalty == 0) x--;\\n\\t\\t\\trequiredOps += x;\\n\\t\\t}\\n\\t\\t// getting current penalty is possible only if required ops is <= maxOps\\n\\t\\treturn requiredOps <= maxOperations;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064497,
                "title": "unravel-it-layer-by-layer",
                "content": "We can apply  **Binary Search** on the **Answer Space**. The minimum lower bound after all operations have been performed is `1` while the maximum is `10^9`. Suppose that the all the elements are less than or equal to `max_allowed`. Let\\'s find out the minimum number of operations required to satisfy this constraint.\\n\\nLet\\'s solve for each array element individually. Say, we are solving for `ele`. By **Euclid\\'s Division Lemma**, we have\\n\\n```\\nele = quotient*max_allowed + remainder\\n```\\n\\nSuppose `remainder` is zero, implying `ele = quotient*max_allowed`. In other words, the element is made up of `quotient` blocks, where each block is of size `max_allowed`. Hence, at each step, we can unravel one layer of the box, resulting in a total of `(quotient - 1)` steps to completion.\\n\\nNow, assume `remainder` is non-zero. Hence, in the first step of unraveling, we can split remainder in one half and `quotient*remainder` in other and then follow the steps in the previous paragraph for the second part.\\n\\nTo conclude, if `rem == 0`, the minimum operations required is `quotient - 1`, else, the minimum operations required is `(quotient)`.\\n\\nOnce we are certain that a series of steps exist which can lead to every element being less than or equal to `mid`, we can simply discard the right half of the search space. If not, we can discard the left half.\\n\\nThe time complexity is `O(N log(N))`.\\n\\n**Extended Discussion** : Why are we not splitting in half at each stage?\\n\\nA simple counter example is an element with value `8`, where the maximum allowed value is `3`. If we split it into half, we get `4` and `4`. Hence, we need 3 steps. However, if we split it into `6 + 2`, we can be done in 2 steps. \\n\\nBut that was a counter example, what\\'s the intuition? We have to realize that even if we split into 2 at each stage, we have to eventually make a cut which partitions it into sizes less than `max_allowed`. Hence, we\\'d have just wasted the `split by 2` cuts. Hence, it\\'s optimal to peel one layer as soon as possible.\\n\\nAnother way to look at it is, if you divide it into 2 equal halves at each stage, the tree would be a binary tree, hence, cost is counted for each node in the tree, which can be huge. However, if you follow the above algorithm, the tree would be  linear (so, in other words, you only have to travel (roughly) one height, rather than all nodes of the old tree).\\n\\n**A yet another perspective** : Visualize each box as a set of people. Suppose we want to ensure sizes of atmost `max_allowed`. We can interpret this situation as : You need to seat `n` people in benches, such that each bench has capacity atmost `max_allowed`. What is the minimum number of benches required? Now, it seems rather intuitive that you\\'d fill each bench to its full capacity, except possibly the last one. In other words\\n\\n```\\nn = benches*max_allowed + last_bench\\n```\\n\\n```cpp\\nint get_cost(int val, int max_allow) {\\n    int quotient = val/max_allow;\\n    int rem = val % max_allow;\\n    return quotient + (rem == 0 ? -1 : 0);\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& a, int max_op) {\\n        int low = 1, high = 1e9,res = -1;\\n        \\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            long long need = 0;\\n            for(auto &ele : a)\\n                need += get_cost(ele, mid);\\n            \\n            if(need <= max_op) {\\n                res = mid;\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nele = quotient*max_allowed + remainder\\n```\n```\\nn = benches*max_allowed + last_bench\\n```\n```cpp\\nint get_cost(int val, int max_allow) {\\n    int quotient = val/max_allow;\\n    int rem = val % max_allow;\\n    return quotient + (rem == 0 ? -1 : 0);\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& a, int max_op) {\\n        int low = 1, high = 1e9,res = -1;\\n        \\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            long long need = 0;\\n            for(auto &ele : a)\\n                need += get_cost(ele, mid);\\n            \\n            if(need <= max_op) {\\n                res = mid;\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064539,
                "title": "c-binary-search",
                "content": "I did not think of binary search at all; I tried to use max heap and \"cleverly\" split the largest number.\\n\\nBut it got complicated very quickly, and I got wrong answer. However, it gave me the intuition to use a binary search.\\n\\nThe search range is [1, 1000000000], per the problem constraints, so we set `l` and `r` accordintly. The target is `m = (l + r) / 2`.\\n\\nWe then check if we can achieve the target with the number of operations we have. This is easy - we need to use `(n - 1) / m` operations to split each bag, and we check if it\\'s not greater than max operations. \\n\\nExamples:\\n1. n = 20, target = 4: 4 + (4 + (4 + (4 + 4))) = 4 operations\\n2. n = 21, target = 4: 4 + (4 + (4 + (4 + (4 + 1)))) = 5 operations\\n3. n = 19, target = 4: 4 + (4 + (4 + (4 + 3))) = 4 operations\\n\\n```cpp\\nint minimumSize(vector<int>& ns, int maxOperations) {\\n    int l = 1, r = 1000000000;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (accumulate(begin(ns), end(ns), 0, [&](int s, int n){ return s + (n - 1) / m; }) <= maxOperations)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumSize(vector<int>& ns, int maxOperations) {\\n    int l = 1, r = 1000000000;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (accumulate(begin(ns), end(ns), 0, [&](int s, int n){ return s + (n - 1) / m; }) <= maxOperations)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031309,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-binary-search",
                "content": "Ayo, binary search binary search binary search. Another one.\\nSo the question is a bit tricky but don\\'t worry, we\\'ll solve it all the way through.\\n\\nSo we\\'re given some bags that contain balls. What we have to do is divide each bag into as many parts as possible but the twist is to divide the bags so that EVERY BAG has the minimum size possible.\\n\\n> **REMEMBER:** Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.\\n\\nSo if maximum balls in a bag is penalty, that means we have to store the minimum amount of balls in every bag. So we\\'re going to minimize bag size.\\n\\nSo since this is binary search, our low limit is the number of balls we can keep in each bag. That could be 0 of course, we don\\'t keep any balls in a bag but instead we\\'ll take our low limit as 1. I\\'ll tell you why later: **READ COMEBACK POINT**.\\n\\nThe maximum amount of balls we can keep in a bag, is the maximum out of all the bags we\\'re given. So you either can find the maximum bag out of all bags and use that as a high limit or just 10^9 or 1e9 (which is given in the constraints as the maximum balls in a bag).\\n\\nApply regular binary search here. While low is less/equal to high, we calculate mid as usual.\\n`mid` is our bag limit, the maximum number of balls we can store in every bag.\\nNow here\\'s the fun part. We need to do extra stuff to binary search to decide the best answer.\\n\\nSo, we\\'re gonna go through every bag we have and count the number of times we can split the bag so that each split bag contains a maximum of `mid` balls. It\\'s kinda tricky but also simple to calculate.\\nSo say we have a bag of 8 balls and our mid is 2. What this means is that we have to split the bag so that each bag split from 8 contains maximum of 2 balls. So that can be 4 bags that contain 2 balls yeah? Good so we get 4 bags in total but weight, how many times did we split our bag? That\\'ll be 3 times, not 4 because 8 split once is 6 and 2. 6 split once is 4 and 2. 4 split once is 2 and 2. So in total, we get 4 bags of 2 balls by splitting 3 times.\\nSo number of splits is less than the number of total bags yeah? Easy to calculate. Just take the bag size subtract 1 from it and divide it by mid. So, (8-1)/2 which gives us 3. If we had done only 8/2, we would have gotten 4 bags but we need to find the number of splits, not number of bags after splitting.\\n\\nNow you\\'ll ask, why did we subtract 1 from 8 and not 8/2. The answer is simple, subtracting 1 from the bag directly handles the case for even and odd numbers. If the number is even, we actually can do 8/2 and subtract 1 later, that\\'s totally fine but if the bag size was 7 (an odd number), we would do 7/2 only and that would give us 3 number of splits. So, while looping through each bag, you can either check for even/odd condition: when even, subtract 1 later, when odd, just divide or you can just subtract 1 from the bag size and divide by mid to handle both cases at the same time.\\n\\n**COME BACK:** We didn\\'t start with 0, because if our mid ever got to 0, then we would be dividing bag_size by mid but we can\\'t do that. The compiler would throw error on dividing anything by 0 so we start our lower limit with 1 instead ;)\\n\\nGood, so we\\'ve got the number of splits we\\'ve made so that all bags are divided into maximum bag size of `mid`.\\n\\nBUT HOLD ON, we were given a limit of how many split operations we can do.\\nThis will be our deciding factor in the binary search.\\n\\nIf our split count is less than the limit of split operations allowed, then we possibly have our answer. So store the mid as our ans but it\\'s not enough, maybe we can do better? So, set high limit ot mid-1, to make sure the bag size is even smaller because remember, our penalty is maximizing the size of the bag so we have to keep it as minimum as possible.\\n\\nIf our split count is greater than the limit, then we know our bag size is wrong and we can probably add more balls in our bags so that the total split operations are less. So our low limit is mid+1.\\n\\nThat\\'s it! Here\\'s the code:\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low = 1;\\n        int high = 1e9;\\n        \\n        while(low < high){\\n            // mid is our bag limit. If it\\'s 2, we can only split the bags into \\n            // max balls of 2. So if we have a bag of 8 balls. We can split it into\\n            // 4 bags of 2 balls.\\n            int mid = low + (high - low) / 2;\\n            \\n            int splitOperations = 0;\\n            // if our bag limit is 3 and bag is 9.\\n            // we can divide it: (9-1)/3 times = 2.\\n            // if bag is less than limit, then it\\'ll not increase count of bags\\n            // because we can\\'t split that bag.\\n            // So, if bag limit is 2 and bag is 8. We can split 8 into bags of 2\\n            // 8-1/2=3 times.\\n            // if bag limit is 2, bag is 4. We can split 4-1/2=1 times.\\n            // 4-> 2,2\\n            // 8-> 2,6 then 6->2,4 then 4->2,2\\n            // So the number of times we split, is the number of operations we\\'re making\\n            // we\\'re only allowed maxOperations. So according to the bag limit,\\n            // find out how many operations we can do to split the bag into\\n            // bags of bag limit.\\n            for(auto bag: nums){\\n                splitOperations += (bag - 1)/mid;\\n            }\\n            // if our split operations require more splits than allowed,\\n            // we can try reducing the number of splits by increasing\\n            // bag limit\\n            if(splitOperations > maxOperations){\\n                low = mid + 1;\\n            } else {\\n                // if we\\'re able to split bags into bag limit\\n                // and still not exceed the total allowed operations\\n                // we try to split even more bags by decreasing the bag limit\\n                // and see if we\\'re able to split without exceeding the maximum\\n                // allowed split operations\\n                high = mid;\\n            }\\n            \\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low = 1;\\n        int high = 1e9;\\n        \\n        while(low < high){\\n            // mid is our bag limit. If it\\'s 2, we can only split the bags into \\n            // max balls of 2. So if we have a bag of 8 balls. We can split it into\\n            // 4 bags of 2 balls.\\n            int mid = low + (high - low) / 2;\\n            \\n            int splitOperations = 0;\\n            // if our bag limit is 3 and bag is 9.\\n            // we can divide it: (9-1)/3 times = 2.\\n            // if bag is less than limit, then it\\'ll not increase count of bags\\n            // because we can\\'t split that bag.\\n            // So, if bag limit is 2 and bag is 8. We can split 8 into bags of 2\\n            // 8-1/2=3 times.\\n            // if bag limit is 2, bag is 4. We can split 4-1/2=1 times.\\n            // 4-> 2,2\\n            // 8-> 2,6 then 6->2,4 then 4->2,2\\n            // So the number of times we split, is the number of operations we\\'re making\\n            // we\\'re only allowed maxOperations. So according to the bag limit,\\n            // find out how many operations we can do to split the bag into\\n            // bags of bag limit.\\n            for(auto bag: nums){\\n                splitOperations += (bag - 1)/mid;\\n            }\\n            // if our split operations require more splits than allowed,\\n            // we can try reducing the number of splits by increasing\\n            // bag limit\\n            if(splitOperations > maxOperations){\\n                low = mid + 1;\\n            } else {\\n                // if we\\'re able to split bags into bag limit\\n                // and still not exceed the total allowed operations\\n                // we try to split even more bags by decreasing the bag limit\\n                // and see if we\\'re able to split without exceeding the maximum\\n                // allowed split operations\\n                high = mid;\\n            }\\n            \\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064519,
                "title": "java-python-3-binary-search-w-brief-explanation-analysis-and-11-similar-problems",
                "content": "Similar to:\\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446313/JavaPython-3-Binary-search-9-and-8-liners-w-brief-explanation-and-analysis.)\\n[1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/discuss/451290/JavaPython-3-O(n)-and-O(logn)-codes-w-brief-explanation-and-analysis.)\\n\\n----\\n\\nUse Binary search to locate the minimum size that we can divide to, given the maxOperations.\\n1. At least there is `1` and at most there are `10 ^ 9` balls in a bag, considering the given range; therefore, we choose `1` and `10 ^ 9 + 1` as low and high bounds, inclusively and exclusively, respectively;\\n2. The min value of the max size must be between low and high bounds: `lo` and `hi`, we check if the mid value `size` between `lo` and `hi` is no less than  or less than the required solution; this process is completed by private method `canDivide()`;\\n3. Adjust the `lo` or `hi` bounds according to the value of `canDivide()`, then repeat 2 till `lo == hi`, which is the solution.\\n\\nNote: - credit to **@Zoey_Yue**\\nwhat does the following statement mean?\\n```\\ncnt += balls / size - (balls % size == 0 ? 1 : 0);\\n```\\nIf it\\'s 6, 6/3=2 but we only need 1 operation here\\nIf it\\'s 7, 7/3=2, we need 2 operations because 3+3+1=7\\n\\n----\\n\\n\\n```java\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int lo = 1, hi = 1_000_000_001;\\n        while (lo < hi) {\\n            int size = lo + hi >> 1;\\n            if (canDivide(nums, size, maxOperations)) {\\n                hi = size;\\n            }else {\\n                lo = size + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    private boolean canDivide(int[] nums, int size, int maxOperations) {\\n        int cnt = 0;\\n        for (int balls : nums) {\\n         // cnt += balls / size - (balls % size == 0 ? 1 : 0);\\n            cnt += (balls - 1) / size;\\t\\t \\n            if (cnt > maxOperations) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n----\\n\\n\\n```python\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        def canDivide(size: int) -> bool:\\n          # return sum(balls // size - (1 if balls % size == 0 else 0) for balls in nums) <= maxOperations\\n            return sum((balls - 1) // size for balls in nums) <= maxOperations\\n        \\n        lo, hi = 1, 10 ** 9 + 1\\n        while lo < hi:\\n            size = lo + hi >> 1\\n            if canDivide(size):\\n                hi = size\\n            else:\\n                lo = size + 1\\n        return lo\\n```\\n\\n----\\n\\n\\n**Analysis:**\\nThere are `O(log(range))` iterations in while loop, and there are `O(n)` iterations in `canDivide()` method. Therefore,\\n\\nTime: `O(nlog(range))`, space: `O(1)`, where `n = nums.length`, `range = max(nums) - min(nums)`.\\n\\n----\\n\\nHere are more similar binary search problem list:\\n\\n[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011. Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[1150. Check If a Number Is Majority Element in a Sorted Array: Premium](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array)\\n[1231. Divide Chocolate: Premium](https://leetcode.com/problems/divide-chocolate/)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets)\\n[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)",
                "solutionTags": [],
                "code": "```\\ncnt += balls / size - (balls % size == 0 ? 1 : 0);\\n```\n```java\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int lo = 1, hi = 1_000_000_001;\\n        while (lo < hi) {\\n            int size = lo + hi >> 1;\\n            if (canDivide(nums, size, maxOperations)) {\\n                hi = size;\\n            }else {\\n                lo = size + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    private boolean canDivide(int[] nums, int size, int maxOperations) {\\n        int cnt = 0;\\n        for (int balls : nums) {\\n         // cnt += balls / size - (balls % size == 0 ? 1 : 0);\\n            cnt += (balls - 1) / size;\\t\\t \\n            if (cnt > maxOperations) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        def canDivide(size: int) -> bool:\\n          # return sum(balls // size - (1 if balls % size == 0 else 0) for balls in nums) <= maxOperations\\n            return sum((balls - 1) // size for balls in nums) <= maxOperations\\n        \\n        lo, hi = 1, 10 ** 9 + 1\\n        while lo < hi:\\n            size = lo + hi >> 1\\n            if canDivide(size):\\n                hi = size\\n            else:\\n                lo = size + 1\\n        return lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1243038,
                "title": "detailed-explanation-with-solution-binary-search-c",
                "content": "#  Approach : \\nAt first it seems like we can use use heap and at every steps we can break largest bag , but how we divide balls in two bags not clear ,  we may try all possible combinations of divison of balls like (1,n-1)  , (2,n-2) , and so on . but this is not a good solution we may get TLE ( i have not tried this implementation)\\n \\nFrom problem statement we can see we have to minimize , so there may be possiblity of dynamic programming or Binary search , and there seems no way to apply dynamic programmig but we can apply binary search \\n \\nBasic idea behind binary search is that we know minimum val that we can get as answer is 1 and lets set maximum val to  10e9  i.e. maximum no of operations .\\nAt every step in binary search we find mid and check that if we can achieve this mid in given no of operation\\n        if yes then end = mid \\n        otherwise s= mid+1\\n\\t    Ans in last we return s ;   \\n\\t\\n\\nNow how do we find no of operations needed for a particular mid \\n    we iterate over all elements \\n    for each element we need to find operations needed for reduction \\n        let say A[i] = X  \\n        we divide X in such a way that every element less than equal to X ( in minimum no of operations)\\n        this can be done in (X-1)/mid no of operations \\n        \\n    for example :-  A[i] = 15 and mid = 4\\n                operations needed is (15-1)/4 =  3;\\n                i.e. we can divide 15 as 4,4,4,3 \\n              \\n\\t\\t\\t  \\n                         15\\n                         /\\\\\\n                        /  \\\\\\n                        8   7      ----> 1 operation \\n                       /\\\\   /\\\\\\n                      /  \\\\ /  \\\\\\n                     4   4 4   3   ----> 2 operation\\n                      \\n                                   Total 3 oeprations\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# Implementation \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    Solution() { ios_base::sync_with_stdio(0); cin.tie(NULL); }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n   \\n    int s= 1, e= 1e9;   // setting s = 1 i.e minimum possible solution , and e=1e9 maximum possible solution \\n    while (s < e)       \\n    {\\n        int mid = (s + e) / 2 ;\\n        int cnt = 0;\\n        for (auto &x: nums)\\n            cnt += (x - 1) / mid;  // adding no of operations needed to break current numbers such that both parts have value leass than equal to mid \\n        if (cnt > maxOperations) s = mid + 1;  \\n        else e = mid;\\n    }\\n    return s;\\n    }\\n};\\n```\\n\\n# Upvote if this solution is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Solution() { ios_base::sync_with_stdio(0); cin.tie(NULL); }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n   \\n    int s= 1, e= 1e9;   // setting s = 1 i.e minimum possible solution , and e=1e9 maximum possible solution \\n    while (s < e)       \\n    {\\n        int mid = (s + e) / 2 ;\\n        int cnt = 0;\\n        for (auto &x: nums)\\n            cnt += (x - 1) / mid;  // adding no of operations needed to break current numbers such that both parts have value leass than equal to mid \\n        if (cnt > maxOperations) s = mid + 1;  \\n        else e = mid;\\n    }\\n    return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064495,
                "title": "python-binary-search-o-nlog-m",
                "content": "\\n\\n```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> m = max(nums) n = nums.length &becaus; binary search requires log(m) iterations \\n<b>Space Complexity: O(1)</b> &becaus; only 5 integers are stored in memory\\n```\\n\\n**Approach:**\\n\\nGuess the maximum number that we can achieve after maxOperations.\\n\\nThen check if it is possible where each number requires\\nmath.ceil(num / guess) - 1 operations to have it\\'s largest bag\\nbe less than or equal to  guess.\\n\\nTry this for all of the numbers, if it requires more than maxOperations\\nthen return false and try guessing a higher number.\\nOtherwise return True and guess a lower number.  \\nRepeat until high == low.  \\n\\n<hr>\\n\\n```python\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        def valid(guess):\\n            \"\"\"Returns True if we can achieve guess as the \\n            largest number after performing maxOperations\"\"\"\\n            count = 0\\n            for num in nums:\\n                if num > guess:\\n                    count += math.ceil(num / guess) - 1\\n                    if count > maxOperations:\\n                        return False\\n            return True\\n        \\n        high = max(nums)\\n        best = high\\n        low = 1\\n        while low <= high:\\n            g = (low + high) // 2\\n            if valid(g):\\n                best = min(best, g)\\n                high = g - 1\\n            else:\\n                low = g + 1\\n                \\n        return best\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> m = max(nums) n = nums.length &becaus; binary search requires log(m) iterations \\n<b>Space Complexity: O(1)</b> &becaus; only 5 integers are stored in memory\\n```\n```python\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        def valid(guess):\\n            \"\"\"Returns True if we can achieve guess as the \\n            largest number after performing maxOperations\"\"\"\\n            count = 0\\n            for num in nums:\\n                if num > guess:\\n                    count += math.ceil(num / guess) - 1\\n                    if count > maxOperations:\\n                        return False\\n            return True\\n        \\n        high = max(nums)\\n        best = high\\n        low = 1\\n        while low <= high:\\n            g = (low + high) // 2\\n            if valid(g):\\n                best = min(best, g)\\n                high = g - 1\\n            else:\\n                low = g + 1\\n                \\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064491,
                "title": "c-binary-search-solution-o-32-n",
                "content": "\\nBinary Search. split each element to numbers which are equal or less than `mid` and accumluate the total opertions, if total > maxOperations => mid = l + 1, otherwise mid = r.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long l = 1, r = 1e9;\\n        while(l < r) {\\n            long long mid = (l + r) / 2;\\n            long long steps = 0;\\n            for(long long x : nums) {\\n                if(x <= mid) continue;\\n                steps += x / mid - (x % mid == 0);\\n            }\\n            if(steps > maxOperations) {\\n                l = mid + 1;\\n            }else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long l = 1, r = 1e9;\\n        while(l < r) {\\n            long long mid = (l + r) / 2;\\n            long long steps = 0;\\n            for(long long x : nums) {\\n                if(x <= mid) continue;\\n                steps += x / mid - (x % mid == 0);\\n            }\\n            if(steps > maxOperations) {\\n                l = mid + 1;\\n            }else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916059,
                "title": "c-binary-search-o-nlog-max-element-with-explanation",
                "content": "/***Approach:-This is the question Based on Binary Search on Answer**.\\n-->What is the lowest Panelty we will give ? Answer is 1\\n-->And the Maximum Penelty We will give is Maximum Element of Array.\\n\\n-->Now We will find a mid_penalty.\\nAnd for that mid_penalty we check how many Operation We will Need to divide each element of array not more that mid_penalty\\n\\n-->Our isPossible function will check this.\\n*/\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid_penalty,int maxOperations)\\n    {\\n        int operations=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            operations+=(nums[i]/mid_penalty); //Operations Nedded to divide that element.\\n            if(nums[i]%mid_penalty==0) //if it is completely divisible means less 1 less is needed for that nums.\\n                operations--;\\n        }\\n        \\n        return operations<=maxOperations?1:0; //If operations are less than maxOperations it is one of our ans.\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low_penalty=1,high_penalty=*max_element(nums.begin(),nums.end());\\n        int ans=high_penalty;\\n        while(low_penalty<=high_penalty)\\n        {\\n            int mid_penalty=low_penalty+(high_penalty-low_penalty)/2;\\n            if(mid_penalty==0) //To avoid divison by zero.\\n                break;\\n            if(isPossible(nums,mid_penalty,maxOperations))\\n            {\\n                ans=mid_penalty;\\n                high_penalty=mid_penalty-1;\\n            }\\n            else\\n                low_penalty=mid_penalty+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*If you find it helpful. Please UPvote.*\\n\\n**Related Problem for Practice:-**\\n1. LeetCode 410 Split Array Largest Sum.\\n2. Leetcode 774 Max Distance to Gas Station.\\n3. Leetcode 875 Koko Eating Banana.\\n4. Leetcode 1011 Capacity to Ship Package in N Days.\\n5. Leetcode 1231 Divide Chocolate.\\n6. Leetcode 1283 Find the Smallest Divisior Given a Threshold.\\n7. Leetcode 1482 Minimum Number of Days to make m Bouquets.\\n8. Geeks for Geek :- Book Allocation Problem.\\n9. Geeks for Geeks:- Painter Partition Problem.\\n10. SPOJ:- Aggressive Cows\\n11. SPOJ:- Parata and Roti.\\n12. SPOJ:-EKO.\\n13. Google Kickstart Round A Q-3 2020.  \\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid_penalty,int maxOperations)\\n    {\\n        int operations=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            operations+=(nums[i]/mid_penalty); //Operations Nedded to divide that element.\\n            if(nums[i]%mid_penalty==0) //if it is completely divisible means less 1 less is needed for that nums.\\n                operations--;\\n        }\\n        \\n        return operations<=maxOperations?1:0; //If operations are less than maxOperations it is one of our ans.\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low_penalty=1,high_penalty=*max_element(nums.begin(),nums.end());\\n        int ans=high_penalty;\\n        while(low_penalty<=high_penalty)\\n        {\\n            int mid_penalty=low_penalty+(high_penalty-low_penalty)/2;\\n            if(mid_penalty==0) //To avoid divison by zero.\\n                break;\\n            if(isPossible(nums,mid_penalty,maxOperations))\\n            {\\n                ans=mid_penalty;\\n                high_penalty=mid_penalty-1;\\n            }\\n            else\\n                low_penalty=mid_penalty+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147066,
                "title": "c-binary-search-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Looking the question it is a mini-max problem. So we can do Binary search\\n- We can do binary search on size of bag beacuse we have to minimixe the maximum size of a bag .\\n- So if our `mid` is max size of bag then we have to check if that max  size we choose is satisfying the maxOperations because we have limited operations to do . So for each mid if our `ops<maxOps` then we can further decrease the size of bag  so` high=mid-1` else `low=mid+1.`\\n- The opeartions can be calcutated by looping the array and store  (arr[i]-1)/mid  since mid is size of bag so dividing arr[i] by mid gives us no. of splits\\n- e.g if we have to divide 9 into max size of 4 we will require 2 ops beacuse 9--> 4 & 5 then  5-->3 & 2 so formula is ops= (9-1)/4.\\n- arr[i]-1 is becuase arr[i] has to divided into some postive two bags not 0 & arr[i] (max we can do arr[i]-1 & 1)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& arr, int maxOp) {\\n       int low=1,high=*max_element(arr.begin(),arr.end());\\n       \\n       while(low<=high){\\n           int op=0;\\n           int mid=low+(high-low)/2;\\n           for(auto a:arr)op+=(a-1)/mid;\\n          if(op>maxOp)low=mid+1;\\n          else high=mid-1;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& arr, int maxOp) {\\n       int low=1,high=*max_element(arr.begin(),arr.end());\\n       \\n       while(low<=high){\\n           int op=0;\\n           int mid=low+(high-low)/2;\\n           for(auto a:arr)op+=(a-1)/mid;\\n          if(op>maxOp)low=mid+1;\\n          else high=mid-1;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070254,
                "title": "java-easy-binary-search-with-explanation",
                "content": "My first thoughts after reading the problem:\\n\\nThis must be a dynamic programming problem!! which I never figure out!!!\\n\\nBUT, this problem can be easily done by Binary Search. For similar questions, you can try binary Search if the answers are yes to all the following questions:\\n* Is it asking for a **min/max** value?\\n* Is there a higher boundary and lower **boundary** for possible answers?\\n* Does it look like a **dynamic programming** problem at the first glance?\\n* Is it easier to **verify** if the answer is correct than try to find the correct answer it self?\\n\\nIn this problem, our answer to the four questions above are YES. The answer is to find the minimized maximum balls in a bag, which is called panelty.\\n\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\t//initiate the boundary for possible answers, here if you let min=1 it will still work for most cases except for some corner cases. We make max=100000000 because nums[i] <= 10^9. You can choose to sort the array and make the max= arr.max, at the price of time consumption.\\n\\t//The answer should be the minimized max value.\\n        int min = 0;\\n        int max = 1000000000;\\n\\t\\t//Compared with min<max or min <= max, min + 1 < max will avoid infinite loops e.g. when min = 2, max = 3\\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n\\t\\t\\t//count indicates the operation times with atmost mid balls in bag.\\n            int count = 0;\\n            for (int a: nums) {\\n\\t\\t\\t//this is the same as Math. ceil(a/mid) - 1=> math.ceil(a/mid) gives the number of divided bags, we subtract the number by 1 to get the subdivision operation times.\\n                count+=(a-1)/mid;\\n            }\\n\\t\\t\\t//if count < maxOperations, max WOULD be further minimized and set to mid; \\n\\t\\t\\t//if count = maxOperations, max still COULD be further minimized and set to mid. \\n\\t\\t\\t//so we combine < and = cases together in one if condition\\n            if (count <= maxOperations) {\\n\\t\\t\\t//max = mid - 1 will not work in this case becasue mid could be the correct answer. \\n\\t\\t\\t//To not miss the correct answer we set a relatively \"loose\" boundary for max and min.\\n                max = mid;\\n            } else{\\n                min = mid;\\n            }\\n        }\\n\\t\\t//Now we find the minimized max value\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\t//initiate the boundary for possible answers, here if you let min=1 it will still work for most cases except for some corner cases. We make max=100000000 because nums[i] <= 10^9. You can choose to sort the array and make the max= arr.max, at the price of time consumption.\\n\\t//The answer should be the minimized max value.\\n        int min = 0;\\n        int max = 1000000000;\\n\\t\\t//Compared with min<max or min <= max, min + 1 < max will avoid infinite loops e.g. when min = 2, max = 3\\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n\\t\\t\\t//count indicates the operation times with atmost mid balls in bag.\\n            int count = 0;\\n            for (int a: nums) {\\n\\t\\t\\t//this is the same as Math. ceil(a/mid) - 1=> math.ceil(a/mid) gives the number of divided bags, we subtract the number by 1 to get the subdivision operation times.\\n                count+=(a-1)/mid;\\n            }\\n\\t\\t\\t//if count < maxOperations, max WOULD be further minimized and set to mid; \\n\\t\\t\\t//if count = maxOperations, max still COULD be further minimized and set to mid. \\n\\t\\t\\t//so we combine < and = cases together in one if condition\\n            if (count <= maxOperations) {\\n\\t\\t\\t//max = mid - 1 will not work in this case becasue mid could be the correct answer. \\n\\t\\t\\t//To not miss the correct answer we set a relatively \"loose\" boundary for max and min.\\n                max = mid;\\n            } else{\\n                min = mid;\\n            }\\n        }\\n\\t\\t//Now we find the minimized max value\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065898,
                "title": "python-simple-binary-search-with-explanation",
                "content": "Given a threshold `t` (max number of balls per final bag), we need at least `ceil(n / t)` of bags to split `n` balls. The required operations is then `ceil(n / t) - 1`. For example a bag of `n = 10` balls and threshold `t = 4`, we need to split them into `(4, 4, 2)` 3 bags, which requires 2 split operations.\\nBinary search on the threshold which takes O(logM) time, where M is the maximum number of balls in each bags. Checking if a certain threshold is feasible take O(N) for N bags. Together, the time complexity is O(N log M).\\n\\n```\\nfrom math import ceil\\ndef minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n\\tdef required(n, t):\\n\\t    \"\"\" Required N of operations to split a bag with n balls into bags \\n\\t\\t\\teach with fewer than or equals to t balls\\n\\t\\t\"\"\"\\n\\t\\treturn int(ceil(n / t)) - 1\\n\\tdef possible(t):\\n\\t    \"\"\" Is it possible to have less than t balls per bag with maxOperations? \"\"\"\\n\\t\\tif t <= 0:\\n\\t\\t\\treturn False\\n\\t\\tsum_req = 0\\n\\t\\tfor x in nums:\\n\\t\\t\\tsum_req += required(x, t)\\n\\t\\t\\tif sum_req > maxOperations:\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tnums = sorted(nums, reverse=True)\\n\\tr = nums[0]  # known minimum possible threshold\\n\\tl = 0        # known maximum impossible threshold\\n\\twhile r - l > 1:\\n\\t\\tmid = (r + l) // 2\\n\\t\\tif possible(mid):\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\t\\t\\tl = mid\\n\\treturn r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import ceil\\ndef minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n\\tdef required(n, t):\\n\\t    \"\"\" Required N of operations to split a bag with n balls into bags \\n\\t\\t\\teach with fewer than or equals to t balls\\n\\t\\t\"\"\"\\n\\t\\treturn int(ceil(n / t)) - 1\\n\\tdef possible(t):\\n\\t    \"\"\" Is it possible to have less than t balls per bag with maxOperations? \"\"\"\\n\\t\\tif t <= 0:\\n\\t\\t\\treturn False\\n\\t\\tsum_req = 0\\n\\t\\tfor x in nums:\\n\\t\\t\\tsum_req += required(x, t)\\n\\t\\t\\tif sum_req > maxOperations:\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tnums = sorted(nums, reverse=True)\\n\\tr = nums[0]  # known minimum possible threshold\\n\\tl = 0        # known maximum impossible threshold\\n\\twhile r - l > 1:\\n\\t\\tmid = (r + l) // 2\\n\\t\\tif possible(mid):\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\t\\t\\tl = mid\\n\\treturn r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1066043,
                "title": "java-binary-search-solution-with-explanation",
                "content": "At the beginning, I was trying to use dp to solve this problem, but soon I found that this can be solved by the **binary search technique**. **Here is why**: basic we can try every num between 1 - max balls in bags, that is called a brutal force solution, and return the minimum valid one as the answer, to expedite this search process, we can use binary search here.\\n\\nHere is how:\\n\\n```\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1, high = 1000000001;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getOperations(nums, mid, maxOperations)) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (getOperations(nums, low, maxOperations)) return low;\\n        \\n        return high;\\n    }\\n    \\n\\t// targetNum: the maximum number of balls in a bag\\n    public boolean getOperations(int[] balls, int targetNum, int maxOperations) {\\n        int res = 0;\\n        for (int i : balls) {\\n            res += i / targetNum;\\n            if (i % targetNum == 0) {\\n                res -= 1;\\n            }\\n            if (res > maxOperations)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n**Please upvote if this help you to understand!**",
                "solutionTags": [],
                "code": "```\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1, high = 1000000001;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getOperations(nums, mid, maxOperations)) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (getOperations(nums, low, maxOperations)) return low;\\n        \\n        return high;\\n    }\\n    \\n\\t// targetNum: the maximum number of balls in a bag\\n    public boolean getOperations(int[] balls, int targetNum, int maxOperations) {\\n        int res = 0;\\n        for (int i : balls) {\\n            res += i / targetNum;\\n            if (i % targetNum == 0) {\\n                res -= 1;\\n            }\\n            if (res > maxOperations)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065754,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {    \\n    public boolean isMin(int[] nums, int min, int maxOperations){\\n        int operations = 0;\\n        for(int val : nums){\\n            if(val > min){\\n                operations += val/min;\\n                if(val%min == 0){\\n                    operations--;\\n                }\\n            }\\n        }\\n        return operations <= maxOperations;\\n    }\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            max = Math.max(nums[i], max);\\n        }\\n        int low = 1, high = max, ans = -1;\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(isMin(nums, mid, maxOperations)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {    \\n    public boolean isMin(int[] nums, int min, int maxOperations){\\n        int operations = 0;\\n        for(int val : nums){\\n            if(val > min){\\n                operations += val/min;\\n                if(val%min == 0){\\n                    operations--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2413691,
                "title": "simple-c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int h = *max_element(nums.begin(),nums.end()); // max bag size\\n        int l = 1;\\n        while(l<h)\\n        {\\n            int c = 0;\\n            int mid = (l+h)/2;                          // mid of size\\n            for(int x : nums)                   \\n                c += (x - 1)/mid;                       // cout no of operatin \\n            if(c > maxOperations)                       // if size is small large no of operations \\n                l = mid +1;                             // neglect range of small size \\n            else\\n                h = mid;                                // set higher bound to mid obtain optimal sol\\n        }\\n        return l;\\n    }\\n};\\n```\\n**Time complexity nlong(n)** : n * log(max_element)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int h = *max_element(nums.begin(),nums.end()); // max bag size\\n        int l = 1;\\n        while(l<h)\\n        {\\n            int c = 0;\\n            int mid = (l+h)/2;                          // mid of size\\n            for(int x : nums)                   \\n                c += (x - 1)/mid;                       // cout no of operatin \\n            if(c > maxOperations)                       // if size is small large no of operations \\n                l = mid +1;                             // neglect range of small size \\n            else\\n                h = mid;                                // set higher bound to mid obtain optimal sol\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1999083,
                "title": "c-binary-search-with-explanation",
                "content": "# Approach\\n* Let\\'s suppose after doing given operation maxOps times, the maximum balls present in any bag is X.\\n* Then number of balls in all bag i.e all elements in nums after maxOps should be <= X.\\n* Lets now find out how many operations it would take to make the max value in nums <= X.\\n\\t* For an element Z, to represent it as sum of elements <= X it would take,\\n\\t\\t* (Z/X - 1) steps when Z is divisible by X.\\n\\t\\t* (Z/X) steps otherwise.\\n\\t\\t* ![image](https://assets.leetcode.com/users/images/19d349dd-a2c2-4524-a620-79f44cd116be_1651431323.578351.png) ![image](https://assets.leetcode.com/users/images/fe74ce97-5c81-41f5-9ea4-efb1b3936c80_1651431323.599525.png)\\n\\n\\t* Sum these steps for all elements in num.\\n\\t* If sum <= maxOps then X is a possible answer.\\n* Binary Search X.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helperFunc(vector<int> nums, int x, int maxOp)\\n    {\\n        int i, n = nums.size(), count = 0;\\n        for(i=0;i<n;i++)\\n        {\\n            count += nums[i]/x;\\n            if(nums[i] % x == 0)     count -= 1;\\n        }\\n        return count <= maxOp;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOp) {\\n        \\n        bool poss;\\n        int n = nums.size(), i, low, high, mid, maxx = INT_MIN, ans;\\n        \\n        for(auto e : nums)\\n            maxx = max(maxx, e);\\n        \\n        low = 1;\\n        high = maxx;\\n        \\n        while(low <= high)\\n        {\\n            mid = low + (high - low)/2;\\n            poss = helperFunc(nums, mid, maxOp);\\n            if(poss)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helperFunc(vector<int> nums, int x, int maxOp)\\n    {\\n        int i, n = nums.size(), count = 0;\\n        for(i=0;i<n;i++)\\n        {\\n            count += nums[i]/x;\\n            if(nums[i] % x == 0)     count -= 1;\\n        }\\n        return count <= maxOp;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOp) {\\n        \\n        bool poss;\\n        int n = nums.size(), i, low, high, mid, maxx = INT_MIN, ans;\\n        \\n        for(auto e : nums)\\n            maxx = max(maxx, e);\\n        \\n        low = 1;\\n        high = maxx;\\n        \\n        while(low <= high)\\n        {\\n            mid = low + (high - low)/2;\\n            poss = helperFunc(nums, mid, maxOp);\\n            if(poss)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064790,
                "title": "optimization-of-binary-search",
                "content": "**Solution**\\nThe idea is quit simple, try all of possible `penalty` number and find the minized one, so using the binary search to search the minimized `penaliry` is the common sense.\\n\\nHowever, the search range could be optimzied. \\n- **High Bound**  -  the bag who has the most ball.\\n- **Low Bound** - the average of the ball after we procedd the `maxOperations` times sepration. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        //find the theoretical min/max of penalty\\n        int max_penalty = 0;\\n        long long sum = 0;\\n        for (auto& n: nums){\\n            max_penalty = max(max_penalty, n);\\n            sum += n;\\n        }\\n        //the max of bags is nums.size() + maxOperations\\n        //the average of the ball is the theoretical min penalty\\n        int min_penalty = sum / (nums.size() + maxOperations);\\n        min_penalty = max(1, min_penalty); // in case of min_penalty is zero\\n        \\n        //binary search the real min penalty\\n        while (min_penalty < max_penalty) {\\n            int mid = min_penalty + (max_penalty - min_penalty) / 2;\\n            \\n            //if the penalty is `mid`, then how many operation we need\\n            int ops = 0;\\n            for (auto& n : nums){\\n                if (n <= mid) continue; //no need seperation\\n                ops += (n-1) / mid; \\n            }\\n            \\n            //if the operation we need is beyoned the limitation, \\n            //then we find in the large part, else find in the small part.\\n            if (ops > maxOperations) {\\n                min_penalty = mid + 1;\\n            }else{\\n                max_penalty = mid;\\n            }\\n        }\\n        return min_penalty;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        //find the theoretical min/max of penalty\\n        int max_penalty = 0;\\n        long long sum = 0;\\n        for (auto& n: nums){\\n            max_penalty = max(max_penalty, n);\\n            sum += n;\\n        }\\n        //the max of bags is nums.size() + maxOperations\\n        //the average of the ball is the theoretical min penalty\\n        int min_penalty = sum / (nums.size() + maxOperations);\\n        min_penalty = max(1, min_penalty); // in case of min_penalty is zero\\n        \\n        //binary search the real min penalty\\n        while (min_penalty < max_penalty) {\\n            int mid = min_penalty + (max_penalty - min_penalty) / 2;\\n            \\n            //if the penalty is `mid`, then how many operation we need\\n            int ops = 0;\\n            for (auto& n : nums){\\n                if (n <= mid) continue; //no need seperation\\n                ops += (n-1) / mid; \\n            }\\n            \\n            //if the operation we need is beyoned the limitation, \\n            //then we find in the large part, else find in the small part.\\n            if (ops > maxOperations) {\\n                min_penalty = mid + 1;\\n            }else{\\n                max_penalty = mid;\\n            }\\n        }\\n        return min_penalty;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188371,
                "title": "c-beginner-friendly-code",
                "content": "# Complexity\\n- Time complexity: **O(nlogx)** ,here x is largest number\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n      int l = 1, r = 1000000000;\\n      int ans = r;\\n      while(l<=r){\\n          int m = l + r;\\n          m/=2;\\n          int h = 0 ;\\n          for(auto k : nums){\\n              if(k>m){\\n                  h += k/m;\\n                  if(k%m==0)h--;\\n              }\\n          }\\n          if(h<=maxOperations){\\n             ans=m;\\n             r=m-1;\\n          } \\n          else{\\n            l=m+1;\\n          }\\n      }  \\n      return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/39fcda68-4496-4628-932a-3c3b45accd0a_1676450431.2490256.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n      int l = 1, r = 1000000000;\\n      int ans = r;\\n      while(l<=r){\\n          int m = l + r;\\n          m/=2;\\n          int h = 0 ;\\n          for(auto k : nums){\\n              if(k>m){\\n                  h += k/m;\\n                  if(k%m==0)h--;\\n              }\\n          }\\n          if(h<=maxOperations){\\n             ans=m;\\n             r=m-1;\\n          } \\n          else{\\n            l=m+1;\\n          }\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974769,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\t//initiate the boundary for possible answers, here if you let min=1 it will still work for most cases except for some corner cases. We make max=100000000 because nums[i] <= 10^9. You can choose to sort the array and make the max= arr.max, at the price of time consumption.\\n\\t//The answer should be the minimized max value.\\n        int min = 0;\\n        int max = 1000000000;\\n\\t\\t//Compared with min<max or min <= max, min + 1 < max will avoid infinite loops e.g. when min = 2, max = 3\\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n\\t\\t\\t//count indicates the operation times with atmost mid balls in bag.\\n            int count = 0;\\n            for (int a: nums) {\\n\\t\\t\\t//this is the same as Math. ceil(a/mid) - 1=> math.ceil(a/mid) gives the number of divided bags, we subtract the number by 1 to get the subdivision operation times.\\n                count+=(a-1)/mid;\\n            }\\n\\t\\t\\t//if count < maxOperations, max WOULD be further minimized and set to mid; \\n\\t\\t\\t//if count = maxOperations, max still COULD be further minimized and set to mid. \\n\\t\\t\\t//so we combine < and = cases together in one if condition\\n            if (count <= maxOperations) {\\n\\t\\t\\t//max = mid - 1 will not work in this case becasue mid could be the correct answer. \\n\\t\\t\\t//To not miss the correct answer we set a relatively \"loose\" boundary for max and min.\\n                max = mid;\\n            } else{\\n                min = mid;\\n            }\\n        }\\n\\t\\t//Now we find the minimized max value\\n        return max;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\t//initiate the boundary for possible answers, here if you let min=1 it will still work for most cases except for some corner cases. We make max=100000000 because nums[i] <= 10^9. You can choose to sort the array and make the max= arr.max, at the price of time consumption.\\n\\t//The answer should be the minimized max value.\\n        int min = 0;\\n        int max = 1000000000;\\n\\t\\t//Compared with min<max or min <= max, min + 1 < max will avoid infinite loops e.g. when min = 2, max = 3\\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n\\t\\t\\t//count indicates the operation times with atmost mid balls in bag.\\n            int count = 0;\\n            for (int a: nums) {\\n\\t\\t\\t//this is the same as Math. ceil(a/mid) - 1=> math.ceil(a/mid) gives the number of divided bags, we subtract the number by 1 to get the subdivision operation times.\\n                count+=(a-1)/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1780994,
                "title": "c-minimum-limit-of-balls-in-a-bag",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int maxOperations, int penalty)\\n    {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i]/penalty;\\n            if(nums[i]%penalty==0)\\n                x--;\\n            res+=x;\\n        }\\n        return res<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n       \\n        int minOp=high;\\n        while(low<=high)\\n        {\\n            int penalty=low+(high-low)/2;\\n           \\n            if(isPossible(nums, maxOperations, penalty)==true)\\n            {\\n                minOp=min(minOp, penalty);\\n                high=penalty-1;\\n            }\\n            else\\n            {\\n                low=penalty+1;\\n            }\\n        }\\n        return minOp;\\n    }\\n};\\n```\\n\\nWhy Binary Search ?\\n* As the problem is asking to maximize/minimize something, you may think of using binary search \\n* If for the problem you know the highest and lowest possible answers (lo & hi) irrespective of constraints (like maxOperations) \\n\\nIn this question, As Lowest possible value can be 1 and Highest can be max of all nums element \\n\\n*SIMILAR Questions*\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/\\nhttps://leetcode.com/problems/split-array-largest-sum/\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int maxOperations, int penalty)\\n    {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i]/penalty;\\n            if(nums[i]%penalty==0)\\n                x--;\\n            res+=x;\\n        }\\n        return res<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n       \\n        int minOp=high;\\n        while(low<=high)\\n        {\\n            int penalty=low+(high-low)/2;\\n           \\n            if(isPossible(nums, maxOperations, penalty)==true)\\n            {\\n                minOp=min(minOp, penalty);\\n                high=penalty-1;\\n            }\\n            else\\n            {\\n                low=penalty+1;\\n            }\\n        }\\n        return minOp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743658,
                "title": "binary-search-approach-with-explanation-o-nlogn-time-complexity-beats-90",
                "content": "# Approach\\n- The minimum penalty can be 1 and the maximum penalty can be the maximum element in nums array. Since we have determined a search space, we can proceed with binary search. \\n- We calculate the mid and then check if we have mid as penalty then can we perform the operationn in less than or equal to maxOperations. \\n- If yes, then mid is a possible answer so we store it and then put end = mid-1 to find a better(minimum) solution. If mid is not a possible solution then every number less than mid is also not a valid solution and hence we put start = mid+1.\\n- We continue this process until we reach a point where we cannot get a better solution and hence finally, we return the mid value stored before as the final answer. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\tint start = 1, end = *max_element(nums.begin(), nums.end());\\n\\t\\tint minPenalty = end;\\n\\t\\t// binary search on possible range\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint penalty = start + (end-start)/2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, penalty))\\n\\t\\t\\t\\tminPenalty = penalty, end = penalty-1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = penalty+1;\\n\\t\\t}\\n\\n\\t\\treturn minPenalty;\\n\\t}\\n\\n\\tbool isPossible(vector<int>& nums, int maxOperations, int penalty) {\\n\\t\\tint requiredOps = 0;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\t// no. of operations required to bring n less than or eq to curr assumed penalty\\n\\t\\t\\tint x = n / penalty;\\n\\t\\t\\t// if n is divisible by penalty, need to subtract 1\\n\\t\\t\\tif (n % penalty == 0) x--;\\n\\t\\t\\trequiredOps += x;\\n\\t\\t}\\n\\t\\t// getting current penalty is possible only if required ops is <= maxOps\\n\\t\\treturn requiredOps <= maxOperations;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\tint start = 1, end = *max_element(nums.begin(), nums.end());\\n\\t\\tint minPenalty = end;\\n\\t\\t// binary search on possible range\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint penalty = start + (end-start)/2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, penalty))\\n\\t\\t\\t\\tminPenalty = penalty, end = penalty-1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = penalty+1;\\n\\t\\t}\\n\\n\\t\\treturn minPenalty;\\n\\t}\\n\\n\\tbool isPossible(vector<int>& nums, int maxOperations, int penalty) {\\n\\t\\tint requiredOps = 0;\\n\\t\\tfor (int n : nums) {\\n\\t\\t\\t// no. of operations required to bring n less than or eq to curr assumed penalty\\n\\t\\t\\tint x = n / penalty;\\n\\t\\t\\t// if n is divisible by penalty, need to subtract 1\\n\\t\\t\\tif (n % penalty == 0) x--;\\n\\t\\t\\trequiredOps += x;\\n\\t\\t}\\n\\t\\t// getting current penalty is possible only if required ops is <= maxOps\\n\\t\\treturn requiredOps <= maxOperations;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275499,
                "title": "c-binary-search-on-answers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int> &nums,int mid,int maxOperations){\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n                continue;\\n            if(nums[i]%mid==0)\\n                cnt+=((nums[i]/mid)-1);\\n            else\\n                cnt+=(nums[i]/mid);\\n        }\\n        return cnt<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l=1,h=*max_element(nums.begin(),nums.end());\\n        int ans;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(f(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int> &nums,int mid,int maxOperations){\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n                continue;\\n            if(nums[i]%mid==0)\\n                cnt+=((nums[i]/mid)-1);\\n            else\\n                cnt+=(nums[i]/mid);\\n        }\\n        return cnt<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l=1,h=*max_element(nums.begin(),nums.end());\\n        int ans;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(f(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168977,
                "title": "85-faster-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) {\\n        int mx = 0;\\n        for(auto &i: nums){\\n            mx = max(mx,i);\\n        }\\n        int mn = 1,mid,x,ans;\\n        while(mn<=mx){\\n            x = 0;\\n            mid = (mx-mn)/2+mn;\\n            for(auto &i: nums){\\n                if(i%mid){\\n                    x += i/mid;\\n                }else{\\n                    x += i/mid-1;\\n                }\\n            }\\n            if(x>k){\\n                mn = mid+1;\\n            }else{\\n                ans= mid;\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) {\\n        int mx = 0;\\n        for(auto &i: nums){\\n            mx = max(mx,i);\\n        }\\n        int mn = 1,mid,x,ans;\\n        while(mn<=mx){\\n            x = 0;\\n            mid = (mx-mn)/2+mn;\\n            for(auto &i: nums){\\n                if(i%mid){\\n                    x += i/mid;\\n                }else{\\n                    x += i/mid-1;\\n                }\\n            }\\n            if(x>k){\\n                mn = mid+1;\\n            }else{\\n                ans= mid;\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126158,
                "title": "solution-in-c",
                "content": "``` class Solution {\\npublic:\\n    bool help(vector<int>& nums,int mid, int maxOperations)\\n    {\\n        int sum=0;\\n        for(int j:nums)\\n    {        int g=j/mid;\\n        if(j%mid==0)\\n        g--;\\n        sum+=g;\\n    }\\n        return(sum<=maxOperations);\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int ans=0;\\n        int high=*max_element(nums.begin(),nums.end());\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(help(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool help(vector<int>& nums,int mid, int maxOperations)\\n    {\\n        int sum=0;\\n        for(int j:nums)\\n    {        int g=j/mid;\\n        if(j%mid==0)\\n        g--;\\n        sum+=g;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2823796,
                "title": "easy-c-solution-binary-search",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int opreq(vector<int>& nums, int n){\\n        if (n==0)return 0;\\n        int dem=0;\\n        for (int i=0; i<nums.size(); i++){\\n            // n mein divide karna\\n            //9 ko 2 mein kare toh\\n            dem+= ((nums[i]/n)-(nums[i]%n==0));\\n                // 5 = 2 + 2 + 1\\n                // 6 = 2 + 2 + 2\\n        }\\n        return dem;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int i=0; int j=0;\\n        for (int x=0; x<nums.size(); x++)j= max(j,nums[x]);\\n        int ans=0;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (opreq(nums,mid)<=maxOperations){\\n                ans= mid;\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        if (ans==0)return *max_element(nums.begin(),nums.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int opreq(vector<int>& nums, int n){\\n        if (n==0)return 0;\\n        int dem=0;\\n        for (int i=0; i<nums.size(); i++){\\n            // n mein divide karna\\n            //9 ko 2 mein kare toh\\n            dem+= ((nums[i]/n)-(nums[i]%n==0));\\n                // 5 = 2 + 2 + 1\\n                // 6 = 2 + 2 + 2\\n        }\\n        return dem;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int i=0; int j=0;\\n        for (int x=0; x<nums.size(); x++)j= max(j,nums[x]);\\n        int ans=0;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (opreq(nums,mid)<=maxOperations){\\n                ans= mid;\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        if (ans==0)return *max_element(nums.begin(),nums.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686913,
                "title": "minimum-limit-of-balls-in-a-bag-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed simple binary search technique to find the Optimal answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The minimum no of balls can be 1 and the maximum no of balls can be the maximum number from an array as if maxOperations as 0 then that can be the ans.\\n2. Now create a Helper Method to find if we can have a particular penalty\\n3. Now we calculate how many opeartions are needed to convert this number into two numbers \\nSuch that the maxmimum of two numbers = penalty\\n4. If number is divisible by penalty, we need one less operation\\n5. If our penality is more than maxOperations, this is not a valid penalty value we will return false and update the low and search on right side of mid.\\n6. Otherwise if true, then this is one possible solution but since we want to minimize the penalty, that means keep searching on left side of mid.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int max = 0;\\n        for(int i:nums){\\n          max = Math.max(i,max);\\n        }\\n        int low = 1, high = max;\\n        while(low<high){\\n          int mid = (high-low)/2+low;\\n          if(helper(nums,mid,maxOperations)){\\n            high = mid;\\n          }else\\n            low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean helper(int arr[],int mid,int k){\\n\\n      int counter = 0;\\n      for(int i=0;i<arr.length;i++){\\n        counter+= (arr[i]-1)/mid;\\n        if(counter>k){\\n            return false; \\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int max = 0;\\n        for(int i:nums){\\n          max = Math.max(i,max);\\n        }\\n        int low = 1, high = max;\\n        while(low<high){\\n          int mid = (high-low)/2+low;\\n          if(helper(nums,mid,maxOperations)){\\n            high = mid;\\n          }else\\n            low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean helper(int arr[],int mid,int k){\\n\\n      int counter = 0;\\n      for(int i=0;i<arr.length;i++){\\n        counter+= (arr[i]-1)/mid;\\n        if(counter>k){\\n            return false; \\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566685,
                "title": "java-binary-search",
                "content": "class Solution {\\n \\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        int left = 0;\\n        int right = 0;\\n\\n        for (int num : nums) {\\n            right = Math.max(right, num);\\n        }\\n\\n        int res = -1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canBeMin(nums, mid, maxOperations)) {\\n                res = mid;\\n                right = mid-1;\\n            }else {\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean canBeMin(int[] nums, int mid, int maxOperations) {\\n        if (mid == 0) return false;\\n        int operations = 0;\\n        for (int num : nums) {\\n            if (num > mid) {\\n                operations+= (num-1) / mid;\\n            }\\n        }\\n        return operations<=maxOperations;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n \\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        int left = 0;\\n        int right = 0;\\n\\n        for (int num : nums) {\\n            right = Math.max(right, num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2303490,
                "title": "binary-search-easy-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mx) {\\n        \\n        int n = nums.size();\\n        int i;\\n        sort(nums.begin(),nums.end());\\n        int l =1;\\n        int r = nums[n-1];\\n        int res =r;\\n        while(l<r)\\n        {\\n            int penalty = (l+r)/2;\\n            int ops =0;\\n            for(i=0;i<n;i++)\\n            {\\n                if(nums[i]>penalty)\\n                {\\n                    if(nums[i]%penalty==0)\\n                    {\\n                        ops+=nums[i]/penalty - 1;\\n                    }\\n                    else{\\n                        ops+=nums[i]/penalty;\\n                    }\\n                }\\n            }\\n            if(ops<=mx)\\n            {\\n                r = penalty;\\n                res = penalty;\\n            }\\n            else{\\n                l = penalty+1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mx) {\\n        \\n        int n = nums.size();\\n        int i;\\n        sort(nums.begin(),nums.end());\\n        int l =1;\\n        int r = nums[n-1];\\n        int res =r;\\n        while(l<r)\\n        {\\n            int penalty = (l+r)/2;\\n            int ops =0;\\n            for(i=0;i<n;i++)\\n            {\\n                if(nums[i]>penalty)\\n                {\\n                    if(nums[i]%penalty==0)\\n                    {\\n                        ops+=nums[i]/penalty - 1;\\n                    }\\n                    else{\\n                        ops+=nums[i]/penalty;\\n                    }\\n                }\\n            }\\n            if(ops<=mx)\\n            {\\n                r = penalty;\\n                res = penalty;\\n            }\\n            else{\\n                l = penalty+1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278423,
                "title": "c-binary-search-with-comments-and-explanation",
                "content": "We will perform binary search on the ***\"maximum minimum element\"*** of the array.\\n1. Suppose we have a mid value of 4 and the array is [8,2,2] then the number of operations required to make this array with the maximum value 4 is 1.\\n1. After applying the operations the imaginary array would be [4,4,2,2]. Suppose that we are given 3 ***maxOperations*** then since we have obtained a lower value than current max which is 4 in less operations than 3. \\n1. So if we decrease the mid value i.e., 4 then the operations would increase, therefore we will decrease the mid value and we will check for a lower mid value maybe 2 aur 1 in this case.\\n1. We will check if we can get an imaginary array having max value as mid if we can then we will further decrease the mid value or else we will increase the mid value.\\n1. By this way we will perfrom binary search.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& a, int mx) {\\n\\t\\n        // intializing l and r with the range values\\n        int l=1,r=1000000001,ans=INT_MAX;\\n        \\n        while(l<=r){\\n\\t\\t\\n            int mid=(l+r)/2;\\n\\t\\t\\t\\n            // to store the operations required for transition of array with the mid value\\n            int ops=0;\\n\\t\\t\\t\\n            for(auto x:a){\\n\\t\\t\\t\\n                // the value of mid is less than x (9>3) then the required operations would be (x/mid)\\n\\t\\t\\t  if(x>mid){ \\n\\t\\t\\t  \\n                    // (9/3) \\n                    ops+=x/mid;\\n                    \\n                    // this is the edge case which is present in sample case 1 if x \\n                    // is divisible by mid then we will decrease ops because in reality \\n                    // we did only 2 extra transformations but since it is divisible it adding \\n                    // one more so we will remove that\\n                    if(x%mid==0) ops--;\\n                }\\n            }\\n\\t\\t\\t\\n            // if ops is less than the maxOperations then we will decrease the range\\n            if(ops<=mx){\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n\\t\\t\\t\\n            // else we will increase the range\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n Do consider ***upvoting*** if it helps, and if there is any doubt then you can ask in the comment section.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& a, int mx) {\\n\\t\\n        // intializing l and r with the range values\\n        int l=1,r=1000000001,ans=INT_MAX;\\n        \\n        while(l<=r){\\n\\t\\t\\n            int mid=(l+r)/2;\\n\\t\\t\\t\\n            // to store the operations required for transition of array with the mid value\\n            int ops=0;\\n\\t\\t\\t\\n            for(auto x:a){\\n\\t\\t\\t\\n                // the value of mid is less than x (9>3) then the required operations would be (x/mid)\\n\\t\\t\\t  if(x>mid){ \\n\\t\\t\\t  \\n                    // (9/3) \\n                    ops+=x/mid;\\n                    \\n                    // this is the edge case which is present in sample case 1 if x \\n                    // is divisible by mid then we will decrease ops because in reality \\n                    // we did only 2 extra transformations but since it is divisible it adding \\n                    // one more so we will remove that\\n                    if(x%mid==0) ops--;\\n                }\\n            }\\n\\t\\t\\t\\n            // if ops is less than the maxOperations then we will decrease the range\\n            if(ops<=mx){\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n\\t\\t\\t\\n            // else we will increase the range\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158475,
                "title": "binary-search-approach-with-detailed-comments",
                "content": "## Please Upvote if you like this\\n\\n#### Time Complexity: O(N * Log(max Value))\\n#### Space Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n//         Approach using Binary Search: T.C -> O(N(Log(mx)))\\n        \\n        //taking max value from nums to set the upper limit of penalty can reach\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        // set start = 1 because lowest penalty can possible is 1\\n        // set end = mx highest penalty can possible is mx\\n        int start = 1, end = mx;\\n        \\n        // initialize the ans as 0\\n        int ans = 0;\\n        \\n        while(start <= end){\\n            \\n            // calculate the mid\\n            int mid = start + (end - start)/2;\\n            \\n            int totOper = 0;\\n            \\n            // count the possible bags that can be divided into small bags by mid\\n            \\n            for(int &i: nums){\\n            \\n                // check if remainder is 0 then possible operations will be (i/mid - 1) because:\\n                    // if we divide 12 in 4 parts of 3 each then we will cut the 12 three times 3 - 3 - 3 and \\n                    // last part will be 3. so total operations will be 3...\\n                \\n                if(i % mid == 0){\\n                    totOper += (i/mid - 1);\\n                }\\n                \\n                // if the value is not the multiple of mid then remainder will be extra and kept in a new bag\\n                // thats why we will not delete 1.\\n                else{\\n                    totOper += i/mid;\\n                }\\n            }\\n            \\n            // check if the Total Operations <=  maxOperations then we will update the ans\\n            // and start the search for smaller values;\\n            \\n            if(totOper <= maxOperations){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            //if it is doesn\\'t fullfill the condition then search for bigger values in possible limits 1 to mx\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n//         Approach using Binary Search: T.C -> O(N(Log(mx)))\\n        \\n        //taking max value from nums to set the upper limit of penalty can reach\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        // set start = 1 because lowest penalty can possible is 1\\n        // set end = mx highest penalty can possible is mx\\n        int start = 1, end = mx;\\n        \\n        // initialize the ans as 0\\n        int ans = 0;\\n        \\n        while(start <= end){\\n            \\n            // calculate the mid\\n            int mid = start + (end - start)/2;\\n            \\n            int totOper = 0;\\n            \\n            // count the possible bags that can be divided into small bags by mid\\n            \\n            for(int &i: nums){\\n            \\n                // check if remainder is 0 then possible operations will be (i/mid - 1) because:\\n                    // if we divide 12 in 4 parts of 3 each then we will cut the 12 three times 3 - 3 - 3 and \\n                    // last part will be 3. so total operations will be 3...\\n                \\n                if(i % mid == 0){\\n                    totOper += (i/mid - 1);\\n                }\\n                \\n                // if the value is not the multiple of mid then remainder will be extra and kept in a new bag\\n                // thats why we will not delete 1.\\n                else{\\n                    totOper += i/mid;\\n                }\\n            }\\n            \\n            // check if the Total Operations <=  maxOperations then we will update the ans\\n            // and start the search for smaller values;\\n            \\n            if(totOper <= maxOperations){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            //if it is doesn\\'t fullfill the condition then search for bigger values in possible limits 1 to mx\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107953,
                "title": "10-lines-python-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if sum([(n - 1) // mid for n in nums]) > maxOperations: \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if sum([(n - 1) // mid for n in nums]) > maxOperations: \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072094,
                "title": "yet-another-binary-search-solution-with-explanation-based-on-my-understanding",
                "content": "Before moving on to the solution, let\\'s think what\\'s the best and worst possible answer we can get.\\n\\nArray : `[2,4,8,2]` \\n\\nLet\\'s say we had infinite operations available, then we\\'d just keep splitting the bag into two new bags until we only had a series of ones `[1,1,1,1,1.....]`. Our answer would be **1** . This is the best case.\\n\\nIf we had 0 operations, then our answer would be simply **max(nums)** which is **8**. This is the worst case.\\n\\nSo we now know that our answer lies in **[1, max(nums)]**. \\n\\nNow we just need to find the answer within this range using binary search. For each **d** here we\\'d like to answer this question : can we make every element in this array less than equal to d in **maxOperations**? We return the answer to this question. \\n\\nIf it returns True, we try to further minimize our answer by reducing the range to **[lo, mid-1]**. Else, it means that our answer is bigger than **d** so we search for our answer in **[mid+1, hi]**.\\n\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        n = len(nums)\\n        lo, hi = 1, max(nums)\\n        \\n        res = None\\n        \\n        def count(d):\\n            maxo = maxOperations           \\n            for i in range(n):\\n                ops = (nums[i]-1)//d\\n                if ops <= maxo:\\n                    maxo -= ops\\n                else:\\n                    return False                                       \\n            return True\\n        \\n        while lo <= hi:\\n            mid = lo + (hi - lo)//2\\n            \\n            if count(mid):\\n                res = mid\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        n = len(nums)\\n        lo, hi = 1, max(nums)\\n        \\n        res = None\\n        \\n        def count(d):\\n            maxo = maxOperations           \\n            for i in range(n):\\n                ops = (nums[i]-1)//d\\n                if ops <= maxo:\\n                    maxo -= ops\\n                else:\\n                    return False                                       \\n            return True\\n        \\n        while lo <= hi:\\n            mid = lo + (hi - lo)//2\\n            \\n            if count(mid):\\n                res = mid\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008700,
                "title": "python-binary-search",
                "content": "\\n    def dfs(self, nums, maxOperations, mid):\\n        count = 0\\n        \\n        for num in nums:\\n            count += (num-1)//mid\\n            \\n        return count <= maxOperations\\n    \\n    def minimumSize(self, nums, maxOperations):\\n        low, high = 1, max(nums)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if self.dfs(nums, maxOperations, mid):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "solutionTags": [],
                "code": "\\n    def dfs(self, nums, maxOperations, mid):\\n        count = 0\\n        \\n        for num in nums:\\n            count += (num-1)//mid\\n            \\n        return count <= maxOperations\\n    \\n    def minimumSize(self, nums, maxOperations):\\n        low, high = 1, max(nums)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if self.dfs(nums, maxOperations, mid):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "codeTag": "Python3"
            },
            {
                "id": 1980771,
                "title": "java-c-classic-binary-search",
                "content": "### Java\\n```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int left = 1;\\n        int right = 1_000_000_000;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (operations(nums, mid) > maxOperations)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n\\n    private int operations(int[] nums, int mid) {\\n        int operations = 0;\\n        for (int num : nums) {\\n            operations += (num - 1) / mid;\\n        }\\n\\n        return operations;\\n    }\\n```\\n\\n### C++\\n\\n```\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left = 1;\\n        int right = 1000000000;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (operations(nums, mid) > maxOperations)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left; \\n    }\\n\\nprivate:\\n    int operations(vector<int>& nums, int mid) {\\n        int operations = 0;\\n        for (int num : nums) {\\n            operations += (num - 1) / mid;\\n        }\\n        return operations;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int left = 1;\\n        int right = 1_000_000_000;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (operations(nums, mid) > maxOperations)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n\\n    private int operations(int[] nums, int mid) {\\n        int operations = 0;\\n        for (int num : nums) {\\n            operations += (num - 1) / mid;\\n        }\\n\\n        return operations;\\n    }\\n```\n```\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left = 1;\\n        int right = 1000000000;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (operations(nums, mid) > maxOperations)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left; \\n    }\\n\\nprivate:\\n    int operations(vector<int>& nums, int mid) {\\n        int operations = 0;\\n        for (int num : nums) {\\n            operations += (num - 1) / mid;\\n        }\\n        return operations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976189,
                "title": "python-easy-to-understand-binary-search-approach",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    \"\"\"\\n    approach:\\n    we can tackle this problem by applying binary search to find the optimal \\n    value of penalty\\n    min_penalty = 1 (when bag has maximum of 1 ball)\\n    max_penalty = max(nums)\\n    \"\"\"\\n    def check_fulfilment(self, nums, penalty, maxOperations):\\n        ops = 0\\n        for num in nums:\\n            if num <= penalty:\\n                continue\\n            else:\\n                ops+=math.ceil(num/penalty)-1\\n            \\n        return ops <= maxOperations\\n    \\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        min_penalty = 1\\n        max_penalty = max(nums)\\n        while min_penalty <= max_penalty:\\n            mid = (min_penalty + max_penalty) // 2\\n            status = self.check_fulfilment(nums, mid, maxOperations)\\n            if status:\\n                max_penalty = mid - 1\\n            else:\\n                # need to increase penalty to reduce operations\\n                min_penalty = mid + 1\\n        return min_penalty\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    \"\"\"\\n    approach:\\n    we can tackle this problem by applying binary search to find the optimal \\n    value of penalty\\n    min_penalty = 1 (when bag has maximum of 1 ball)\\n    max_penalty = max(nums)\\n    \"\"\"\\n    def check_fulfilment(self, nums, penalty, maxOperations):\\n        ops = 0\\n        for num in nums:\\n            if num <= penalty:\\n                continue\\n            else:\\n                ops+=math.ceil(num/penalty)-1\\n            \\n        return ops <= maxOperations\\n    \\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        min_penalty = 1\\n        max_penalty = max(nums)\\n        while min_penalty <= max_penalty:\\n            mid = (min_penalty + max_penalty) // 2\\n            status = self.check_fulfilment(nums, mid, maxOperations)\\n            if status:\\n                max_penalty = mid - 1\\n            else:\\n                # need to increase penalty to reduce operations\\n                min_penalty = mid + 1\\n        return min_penalty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960372,
                "title": "simple-and-easy-commented-for-explanation-java",
                "content": "```\\nclass Solution {\\n    public int func(int[] nums, int a) {\\n        int cnt=0;\\n        for (Integer it : nums) {\\n            if (it % a == 0)\\n                cnt += (it / a) - 1;\\n            else\\n                cnt += it / a;\\n        }\\n        return cnt;\\n    }\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int mx = -1;\\n        for (Integer it : nums)\\n            if (it > mx)\\n                mx = it;\\n        int left = 1, right = mx, mid, operations, ans = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2; // this is value, that each ball will have or be near to it, after n-th operations\\n            // We now only have to check whether the value of n is <= maxOperations after each partition of size <= mid.\\n            // if mid = 2 and ball = 4, then n=4/2-1=1 (1 operation needed, balls=operation1[2,2])\\n            // if mid = 2 and ball = 5. then n= 5/2 (2 operations needed, balls = op1[2,3]->op2[2,2,1]).\\n            operations = func(nums, mid);\\n            if (operations <= maxOperations) {\\n                if (mid < ans)\\n                    ans = mid;\\n                right = mid - 1;\\n            } else\\n                left = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int func(int[] nums, int a) {\\n        int cnt=0;\\n        for (Integer it : nums) {\\n            if (it % a == 0)\\n                cnt += (it / a) - 1;\\n            else\\n                cnt += it / a;\\n        }\\n        return cnt;\\n    }\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int mx = -1;\\n        for (Integer it : nums)\\n            if (it > mx)\\n                mx = it;\\n        int left = 1, right = mx, mid, operations, ans = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2; // this is value, that each ball will have or be near to it, after n-th operations\\n            // We now only have to check whether the value of n is <= maxOperations after each partition of size <= mid.\\n            // if mid = 2 and ball = 4, then n=4/2-1=1 (1 operation needed, balls=operation1[2,2])\\n            // if mid = 2 and ball = 5. then n= 5/2 (2 operations needed, balls = op1[2,3]->op2[2,2,1]).\\n            operations = func(nums, mid);\\n            if (operations <= maxOperations) {\\n                if (mid < ans)\\n                    ans = mid;\\n                right = mid - 1;\\n            } else\\n                left = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944546,
                "title": "java-binary-search-with-logic-explain",
                "content": "```\\n\\tprivate boolean check(int max, int[] nums, int operations){\\n        for(int n: nums){\\n            operations -= n/max;// We need these many minimum operations\\n            if(n%max == 0) {// If no remainder we need 1 less operations from above step\\n                operations += 1;    \\n            }\\n            if(operations < 0) return false;\\n        }\\n        return operations >= 0;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int l = 1;\\n        int r = Integer.MAX_VALUE;\\n        int resultSoFar=r;\\n        \\n        while(l <= r){\\n            int m = l + (r-l)/2; // 1 -> 1\\n            boolean isPossible = check(m,nums,maxOperations);\\n            \\n            if(isPossible){//Possible to achieve m as max after dividing. Try to get better/min\\n                resultSoFar = m;//In case of isPossible, we will shrink/reduce r = m-1.So should collect best result so far to return\\n                r = m-1;\\n            }\\n            else {\\n                l = m+1;\\n            }\\n        }\\n        return resultSoFar;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tprivate boolean check(int max, int[] nums, int operations){\\n        for(int n: nums){\\n            operations -= n/max;// We need these many minimum operations\\n            if(n%max == 0) {// If no remainder we need 1 less operations from above step\\n                operations += 1;    \\n            }\\n            if(operations < 0) return false;\\n        }\\n        return operations >= 0;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int l = 1;\\n        int r = Integer.MAX_VALUE;\\n        int resultSoFar=r;\\n        \\n        while(l <= r){\\n            int m = l + (r-l)/2; // 1 -> 1\\n            boolean isPossible = check(m,nums,maxOperations);\\n            \\n            if(isPossible){//Possible to achieve m as max after dividing. Try to get better/min\\n                resultSoFar = m;//In case of isPossible, we will shrink/reduce r = m-1.So should collect best result so far to return\\n                r = m-1;\\n            }\\n            else {\\n                l = m+1;\\n            }\\n        }\\n        return resultSoFar;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926601,
                "title": "python-binary-search-simple-solution-with-explanation",
                "content": "## Logic: \\n\\t1. This question is very similar to https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/1926040/python-binary-search-simple-solution-with-explanation\\n    2. Here, instead of capacity of the conveyor, we can apply the binary search on the size of bags as,\\n        - minimum size of a bag could be 1\\n        - maximum size of a bag could be max(nums)\\n    3. We now need to have an optimal size of bag which could accommodate the maxOperations on given nums.\\n    4. Now to check whether a size is valid to accommodate the maxOperations-\\n    5. This is calculated in isValid() function.\\n    6. The number of operations required for each bag to accommodate maxSize is calculated as num / maxsize.\\n\\t\\t- [NOTE] if a bag size is a multiple of num then we have to subtract 1 from operations because in this case remainder will be 0.\\n    7. Then if the sum of all operations is less than or equal to maxOperations then it is a valid bag size.\\n\\n```\\nclass Solution:\\n    def isValid(self, nums, maxSize, maxOperations):\\n        requiredOperations = 0\\n        for num in nums:\\n            operation = num // maxSize\\n            if num % maxSize == 0:\\n                operation -= 1\\n            requiredOperations += operation\\n        return requiredOperations <= maxOperations\\n\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        minPenalty, maxPenalty = 1, max(nums)\\n        while minPenalty < maxPenalty:\\n            mid = minPenalty + ((maxPenalty-minPenalty)//2)\\n            if self.isValid(nums, mid, maxOperations):\\n                maxPenalty = mid\\n            else:\\n                minPenalty = mid+1\\n        return maxPenalty\\n\\n\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, nums, maxSize, maxOperations):\\n        requiredOperations = 0\\n        for num in nums:\\n            operation = num // maxSize\\n            if num % maxSize == 0:\\n                operation -= 1\\n            requiredOperations += operation\\n        return requiredOperations <= maxOperations\\n\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        minPenalty, maxPenalty = 1, max(nums)\\n        while minPenalty < maxPenalty:\\n            mid = minPenalty + ((maxPenalty-minPenalty)//2)\\n            if self.isValid(nums, mid, maxOperations):\\n                maxPenalty = mid\\n            else:\\n                minPenalty = mid+1\\n        return maxPenalty\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922179,
                "title": "c-binary-explanation-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool check(int x, int k, vector<int>& nums){\\n        int total = 0;\\n        for(auto i:nums){\\n            // adding the minimum number of moves required to divide the current\\n            // element into parts whose value is equal to or less than x\\n            \\n            // for minimum moves we are dividing the current element into parts equal\\n            // to x and if some part is left which cannot be equal to x we leave it as it is\\n            \\n            // example\\n            // i = 16, x = 3\\n            // 16 -> 3, 13 -> 3, 3, 10 -> 3, 3, 3, 7 -> 3, 3, 3, 3, 4 -> 3, 3, 3, 3, 3, 1\\n            // 16/3 - (0) = 5\\n            \\n            // i = 18, x = 3\\n            // 18 -> 3, 15 -> 3, 3, 12 -> 3, 3, 3, 9 -> 3, 3, 3, 3, 6 -> 3, 3, 3, 3, 3, 3\\n            // 18/3 - (1) = 6 - 1 = 5\\n            total += i/x - (i%x == 0);\\n        }\\n        \\n        return (total <= k);\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        // defining low value and high value for binary search\\n        int low = 1, ans = 1, high = *max_element(nums.begin(), nums.end());\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // if this is possible then we are trying for lower value\\n            // otherwise we increase the mid value\\n            if(check(mid, maxOperations, nums)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nPlease upvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool check(int x, int k, vector<int>& nums){\\n        int total = 0;\\n        for(auto i:nums){\\n            // adding the minimum number of moves required to divide the current\\n            // element into parts whose value is equal to or less than x\\n            \\n            // for minimum moves we are dividing the current element into parts equal\\n            // to x and if some part is left which cannot be equal to x we leave it as it is\\n            \\n            // example\\n            // i = 16, x = 3\\n            // 16 -> 3, 13 -> 3, 3, 10 -> 3, 3, 3, 7 -> 3, 3, 3, 3, 4 -> 3, 3, 3, 3, 3, 1\\n            // 16/3 - (0) = 5\\n            \\n            // i = 18, x = 3\\n            // 18 -> 3, 15 -> 3, 3, 12 -> 3, 3, 3, 9 -> 3, 3, 3, 3, 6 -> 3, 3, 3, 3, 3, 3\\n            // 18/3 - (1) = 6 - 1 = 5\\n            total += i/x - (i%x == 0);\\n        }\\n        \\n        return (total <= k);\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        // defining low value and high value for binary search\\n        int low = 1, ans = 1, high = *max_element(nums.begin(), nums.end());\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // if this is possible then we are trying for lower value\\n            // otherwise we increase the mid value\\n            if(check(mid, maxOperations, nums)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622928,
                "title": "java-binary-search",
                "content": "```\\n    public int opR(int[] nums , int mid ){\\n        \\n        int count = 0;\\n        for(int i : nums) count+= (i-1)/mid; //  if we divide the complete no it might be possible that one bag will get 0 balls but we want it to be a positive number\\n        return count;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        \\n        int si = 1;\\n        int max = -(int)1e9;\\n        for(int i : nums) max =  Math.max(max,i);\\n        int ei = max;\\n        \\n        while(si<ei){\\n            \\n            int mid = (si+ei)/2;\\n            \\n            if(opR(nums,mid) > maxOperations ){\\n                si = mid +1;\\n            }else{\\n                ei = mid;\\n            }\\n        }\\n        \\n        return si;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    public int opR(int[] nums , int mid ){\\n        \\n        int count = 0;\\n        for(int i : nums) count+= (i-1)/mid; //  if we divide the complete no it might be possible that one bag will get 0 balls but we want it to be a positive number\\n        return count;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        \\n        int si = 1;\\n        int max = -(int)1e9;\\n        for(int i : nums) max =  Math.max(max,i);\\n        int ei = max;\\n        \\n        while(si<ei){\\n            \\n            int mid = (si+ei)/2;\\n            \\n            if(opR(nums,mid) > maxOperations ){\\n                si = mid +1;\\n            }else{\\n                ei = mid;\\n            }\\n        }\\n        \\n        return si;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541983,
                "title": "concise-binary-search-for-humans-c",
                "content": "```\\n    int moves(vector<int>& nums, int k) {\\n        \\n        int m = 0;\\n        for(auto n : nums) m += n / k - 1 + (n % k == 0? 0 : 1);\\n        return m;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int ops) {\\n        \\n        int res; int lo = 1; int hi = *max_element(nums.begin(), nums.end());\\n        \\n        while(lo <= hi) {\\n            \\n            int m = lo + (hi - lo) / 2;\\n            if(moves(nums, m) > ops) lo = m + 1;\\n            else res = m, hi = m - 1;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int moves(vector<int>& nums, int k) {\\n        \\n        int m = 0;\\n        for(auto n : nums) m += n / k - 1 + (n % k == 0? 0 : 1);\\n        return m;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int ops) {\\n        \\n        int res; int lo = 1; int hi = *max_element(nums.begin(), nums.end());\\n        \\n        while(lo <= hi) {\\n            \\n            int m = lo + (hi - lo) / 2;\\n            if(moves(nums, m) > ops) lo = m + 1;\\n            else res = m, hi = m - 1;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1223470,
                "title": "easy-c-soln-binary-search-explanation-inside",
                "content": "```\\nclass Solution {\\npublic:\\n    //juts like heater problem\\n    bool check(vector<int>& nums, int tar,int m){\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            count+=ceil((double)nums[i]/tar)-1; //number of operation to make penalty of nums[i] equal to tar i.e. //\\n\\t\\t\\thow many time we need to split it (ceil(nums[i]/tar)), and in one operation we divide it into two parts, \\n\\t\\t\\t//so number of operations for (ceil(nums[i]/tar)) parts will be (ceil(nums[i]/tar))-1 \\n        }\\n        return count<=m;\\n    }\\n    int minimumSize(vector<int>& nums, int m) {\\n        int i=1,j=INT_MAX-1;\\n        int res=j;\\n        while(i<=j){\\n            int mid=(i+j)>>1;\\n            if(check(nums,mid,m)){\\n                res=min(mid,res);\\n                j=mid-1;\\n            }\\n            else i=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //juts like heater problem\\n    bool check(vector<int>& nums, int tar,int m){\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            count+=ceil((double)nums[i]/tar)-1; //number of operation to make penalty of nums[i] equal to tar i.e. //\\n\\t\\t\\thow many time we need to split it (ceil(nums[i]/tar)), and in one operation we divide it into two parts, \\n\\t\\t\\t//so number of operations for (ceil(nums[i]/tar)) parts will be (ceil(nums[i]/tar))-1 \\n        }\\n        return count<=m;\\n    }\\n    int minimumSize(vector<int>& nums, int m) {\\n        int i=1,j=INT_MAX-1;\\n        int res=j;\\n        while(i<=j){\\n            int mid=(i+j)>>1;\\n            if(check(nums,mid,m)){\\n                res=min(mid,res);\\n                j=mid-1;\\n            }\\n            else i=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207987,
                "title": "simple-c-binary-search-with-intuition-explained",
                "content": "```\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) { \\n\\n\\tint lo = 1, hi = *max_element(nums.begin(),nums.end());\\n\\tint ans = 0;\\n\\n\\twhile(lo <= hi)\\n\\t{\\n\\t\\tint mid = (lo + hi)/2;\\n\\t\\tint n = nums.size();\\n\\t\\tint ops = 0;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\tops += (nums[i] + mid - 1)/mid - 1; //ceil(nums[i]/mid) - 1\\n\\n\\t\\t/*Intuition for ceil(nums[i]/mid) - 1: \\n\\t\\tfor example nums[i] = 9 and mid = 2 : \\n\\t\\twe need to find maxOperations to split 9 to numbers where each number is at max 2\\n\\n\\t\\tideal split is 9 --> 2 2 2 2 1 (ceil(9/2))\\n\\t\\tnow if we have split 1 number (in this case 9) to n parts (here 5),\\n\\t\\tthe number of splits is n-1, hence maxOperations = ceil(9/2) - 1 */\\n\\n\\t\\tif(ops > maxOperations)\\n\\t\\t\\tlo = mid + 1;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = mid;\\n\\t\\t\\thi = mid - 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n\\n",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) { \\n\\n\\tint lo = 1, hi = *max_element(nums.begin(),nums.end());\\n\\tint ans = 0;\\n\\n\\twhile(lo <= hi)\\n\\t{\\n\\t\\tint mid = (lo + hi)/2;\\n\\t\\tint n = nums.size();\\n\\t\\tint ops = 0;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\tops += (nums[i] + mid - 1)/mid - 1; //ceil(nums[i]/mid) - 1\\n\\n\\t\\t/*Intuition for ceil(nums[i]/mid) - 1: \\n\\t\\tfor example nums[i] = 9 and mid = 2 : \\n\\t\\twe need to find maxOperations to split 9 to numbers where each number is at max 2\\n\\n\\t\\tideal split is 9 --> 2 2 2 2 1 (ceil(9/2))\\n\\t\\tnow if we have split 1 number (in this case 9) to n parts (here 5),\\n\\t\\tthe number of splits is n-1, hence maxOperations = ceil(9/2) - 1 */\\n\\n\\t\\tif(ops > maxOperations)\\n\\t\\t\\tlo = mid + 1;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = mid;\\n\\t\\t\\thi = mid - 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1184716,
                "title": "java-clean-concise-code-binary-search-technique-o-n-log-10-9-time-100-optimal-code",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isPossible (int[] nums, int maxOperations, int balls) {\\n        \\n        for (int num : nums) {\\n            maxOperations -= (--num / balls);\\n        }\\n        \\n        return maxOperations >= 0;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int start = 1, end = 1000_000_000;\\n        \\n        while (start < end) {\\n            int balls = start + (end - start) / 2;\\n            if (isPossible (nums, maxOperations, balls)) {\\n                end = balls;\\n            }\\n            else {\\n                start = balls + 1;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isPossible (int[] nums, int maxOperations, int balls) {\\n        \\n        for (int num : nums) {\\n            maxOperations -= (--num / balls);\\n        }\\n        \\n        return maxOperations >= 0;\\n    }\\n    \\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int start = 1, end = 1000_000_000;\\n        \\n        while (start < end) {\\n            int balls = start + (end - start) / 2;\\n            if (isPossible (nums, maxOperations, balls)) {\\n                end = balls;\\n            }\\n            else {\\n                start = balls + 1;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113616,
                "title": "scala-solution",
                "content": "```\\ndef check(left:Int, right:Int, nums: Array[Int], maxOperations: Int):Int = {\\n    if(left >= right) return left\\n    val mid = (left + right) / 2\\n    if( (0 until nums.length).foldLeft(0)((b, a)=> b + (nums(a)-1)/mid) > maxOperations) check(mid +1,right,nums,maxOperations)\\n    else check(left,mid,nums,maxOperations)\\n  }\\n\\n  def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\\n    check(1,nums.max,nums,maxOperations)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\ndef check(left:Int, right:Int, nums: Array[Int], maxOperations: Int):Int = {\\n    if(left >= right) return left\\n    val mid = (left + right) / 2\\n    if( (0 until nums.length).foldLeft(0)((b, a)=> b + (nums(a)-1)/mid) > maxOperations) check(mid +1,right,nums,maxOperations)\\n    else check(left,mid,nums,maxOperations)\\n  }\\n\\n  def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\\n    check(1,nums.max,nums,maxOperations)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1066403,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int lo = 1;\\n        int hi = 1_000_000_000;\\n        \\n        while(lo < hi){\\n            \\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(canDivide(mid, maxOperations, nums)){\\n                hi = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canDivide(int size, int maxCount, int[] balls){\\n        \\n        int count = 0;\\n        \\n        for(int ball : balls){\\n            \\n            count += (ball - 1) / size;\\n            \\n            if(count > maxCount){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        \\n        int lo = 1;\\n        int hi = 1_000_000_000;\\n        \\n        while(lo < hi){\\n            \\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(canDivide(mid, maxOperations, nums)){\\n                hi = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canDivide(int size, int maxCount, int[] balls){\\n        \\n        int count = 0;\\n        \\n        for(int ball : balls){\\n            \\n            count += (ball - 1) / size;\\n            \\n            if(count > maxCount){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064678,
                "title": "easy-logic-find-partitions-and-compare",
                "content": "```\\n    fun minimumSize(nums: IntArray, maxOperations: Int): Int {\\n        var min = 1\\n        var max = Math.pow(10.0, 9.0).toInt() + 1\\n        while(min < max) {\\n            val maxBallsPerBag = min + (max - min)/2\\n            var totalBagsNeeded = 0\\n            for(bag in nums) {\\n                totalBagsNeeded += bag/maxBallsPerBag + (if(bag%maxBallsPerBag == 0) 0 else 1)\\n            }\\n            if(totalBagsNeeded > nums.size + maxOperations) { // nums.size is bags we have intially +  number of bags we get after doing maxOperations\\n                min = maxBallsPerBag + 1\\n            } else {\\n                max = maxBallsPerBag\\n            }\\n        }\\n        return min\\n    }",
                "solutionTags": [],
                "code": "```\\n    fun minimumSize(nums: IntArray, maxOperations: Int): Int {\\n        var min = 1\\n        var max = Math.pow(10.0, 9.0).toInt() + 1\\n        while(min < max) {\\n            val maxBallsPerBag = min + (max - min)/2\\n            var totalBagsNeeded = 0\\n            for(bag in nums) {\\n                totalBagsNeeded += bag/maxBallsPerBag + (if(bag%maxBallsPerBag == 0) 0 else 1)\\n            }\\n            if(totalBagsNeeded > nums.size + maxOperations) { // nums.size is bags we have intially +  number of bags we get after doing maxOperations\\n                min = maxBallsPerBag + 1\\n            } else {\\n                max = maxBallsPerBag\\n            }\\n        }\\n        return min\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1064572,
                "title": "python3-binary-search",
                "content": "Algo\\nBinary search the space of balls to find the number for which `maxOperations` is enough to arrive at this number. \\n\\nImplementation\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        lo, hi = 1, 1_000_000_000\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```\\n\\nAnalysis\\nTime complexity `O(MlogN)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        lo, hi = 1, 1_000_000_000\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386034,
                "title": "eays-binary-search-solution-binary-search-on-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int m,vector<int>& nums,int ma)\\n    {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n              sum+= nums[i]/m;\\n            if(nums[i]%m==0)\\n            {\\n                sum--;\\n            }\\n          \\n        }\\n        return sum<=ma;\\n    }\\n    int minimumSize(vector<int>& nums, int ma) {\\n      int l  = 1,h= 1e9;\\n        while(l<=h)\\n        {\\n            int m = (l+h)/2;\\n           if(f(m,nums,ma))h = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int m,vector<int>& nums,int ma)\\n    {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n              sum+= nums[i]/m;\\n            if(nums[i]%m==0)\\n            {\\n                sum--;\\n            }\\n          \\n        }\\n        return sum<=ma;\\n    }\\n    int minimumSize(vector<int>& nums, int ma) {\\n      int l  = 1,h= 1e9;\\n        while(l<=h)\\n        {\\n            int m = (l+h)/2;\\n           if(f(m,nums,ma))h = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340780,
                "title": "binary-search-for-minimum-penalty-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using binary search on the answer. Let\\'s define the range of possible answers. Since we want to minimize the maximum number of balls in a bag, the minimum possible value for the answer is 1 (we can\\'t have a bag with 0 balls). The maximum possible value for the answer is the maximum value in the input array, since we can\\'t divide a bag into bags with more balls than the original bag.\\n\\nFor each guess of the answer, we can count how many operations we need to perform to get to that answer. We do this by iterating over the input array, and for each bag, we count how many times we need to divide it until the maximum number of balls in a bag is less than or equal to our guess. We can use integer division to do this.\\n\\nIf the total number of operations we need to perform is less than or equal to maxOperations, then the guess is a valid answer. We update the range of possible answers accordingly. Otherwise, we discard the guess and update the range of possible answers accordingly.\\n\\nWe continue this process until the range of possible answers has only one value, which is the minimum possible penalty.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is another C++ implementation of the binary search algorithm to solve the problem. It\\'s a similar approach to the first C++ implementation we provided, but with a different implementation of the binary search.\\n\\nThe check function takes three parameters: m, nums, and o. m is the current guess for the minimum possible penalty, nums is the input array of bag sizes, and o is the remaining number of operations we can perform. The function returns true if we can divide all the bags of balls such that the maximum number of balls in a bag is less than or equal to m, given that we have o operations left.\\n\\nThe minimumSize function takes two parameters: nums and maxOperations. It initializes the binary search range as [1, INT_MAX] and the initial guess for the minimum possible penalty as 0. It then runs the binary search loop until the search range is exhausted.\\n\\nIn each iteration of the loop, it computes the mid-point mid of the search range, and checks whether we can divide all the bags of balls such that the maximum number of balls in a bag is less than or equal to mid, given that we have maxOperations operations left, by calling the check function. If we can, then we update the answer ans to be mid, and search the left half of the range by setting e = mid - 1. Otherwise, we search the right half of the range by setting s = mid + 1.\\n\\nFinally, the function returns the answer ans.\\n\\nThis approach has a time complexity of O(n log m), where n is the length of the input array and m is the maximum possible value for the penalty. The space complexity is O(1).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n log m), where n is the length of the input array and m is the maximum value in the input array. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int m,vector<int>nums,int o){\\n        for(int i=0;i<nums.size();i++){\\n            o-=(nums[i]/m);\\n            if(nums[i]%m==0)o++;\\n        }\\n        return o>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int s=1,e=INT_MAX,ans=0;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(check(mid,nums,maxOperations)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int m,vector<int>nums,int o){\\n        for(int i=0;i<nums.size();i++){\\n            o-=(nums[i]/m);\\n            if(nums[i]%m==0)o++;\\n        }\\n        return o>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int s=1,e=INT_MAX,ans=0;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(check(mid,nums,maxOperations)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268872,
                "title": "range-bs-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) \\n    {\\n        //we can perform the operations at most k times\\n       \\n        //the final min penalty ans\\n        long long int ans = LONG_MAX;\\n\\n        //your penalty is the max number of balls in a bag\\n        //so according to the given data the min penalty that we can have is min element from the array\\n        //so according to the given data the max penalty that we can have is max element from the array\\n\\n        //finding out the min element from the array\\n        long long int start = 1;\\n        //finding out the max element from the array\\n        long long int end = *max_element(nums.begin(),nums.end());\\n     \\n        //taking the approach of range binary search\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n\\n            //now checkin if the mid can be the min penalty\\n\\n            if(fun(nums,mid,k) == true)\\n            {\\n                cout<<\"mid = \"<<mid<<endl;\\n                //this is the potential ans\\n                ans = min(ans,mid);\\n                //now we will try to minimize the penalty\\n                end = mid-1;\\n            }\\n            else \\n            {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,long long int &mid,int k)\\n    {\\n         long long int count = 0;\\n         int idx = 0;\\n         while(idx < nums.size() and k>0)\\n         {\\n             if(nums[idx] == mid) \\n             {\\n                 idx++;\\n             }\\n             else if(nums[idx] < mid)\\n             {\\n                 idx++;\\n             }\\n             else if(nums[idx] > mid)\\n             {\\n                 if((nums[idx]%mid) == 0)\\n                 {\\n                    long long int temp = (nums[idx]/mid);\\n                    count = (count + (temp-1));\\n                 }\\n                 else if((nums[idx]%mid)!=0)\\n                 {\\n                     long long int temp = (nums[idx]/mid);\\n                    count = (count + (temp));\\n                 }\\n                 idx++;\\n             }\\n             if(count > k) return false;\\n         }\\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) \\n    {\\n        //we can perform the operations at most k times\\n       \\n        //the final min penalty ans\\n        long long int ans = LONG_MAX;\\n\\n        //your penalty is the max number of balls in a bag\\n        //so according to the given data the min penalty that we can have is min element from the array\\n        //so according to the given data the max penalty that we can have is max element from the array\\n\\n        //finding out the min element from the array\\n        long long int start = 1;\\n        //finding out the max element from the array\\n        long long int end = *max_element(nums.begin(),nums.end());\\n     \\n        //taking the approach of range binary search\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n\\n            //now checkin if the mid can be the min penalty\\n\\n            if(fun(nums,mid,k) == true)\\n            {\\n                cout<<\"mid = \"<<mid<<endl;\\n                //this is the potential ans\\n                ans = min(ans,mid);\\n                //now we will try to minimize the penalty\\n                end = mid-1;\\n            }\\n            else \\n            {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,long long int &mid,int k)\\n    {\\n         long long int count = 0;\\n         int idx = 0;\\n         while(idx < nums.size() and k>0)\\n         {\\n             if(nums[idx] == mid) \\n             {\\n                 idx++;\\n             }\\n             else if(nums[idx] < mid)\\n             {\\n                 idx++;\\n             }\\n             else if(nums[idx] > mid)\\n             {\\n                 if((nums[idx]%mid) == 0)\\n                 {\\n                    long long int temp = (nums[idx]/mid);\\n                    count = (count + (temp-1));\\n                 }\\n                 else if((nums[idx]%mid)!=0)\\n                 {\\n                     long long int temp = (nums[idx]/mid);\\n                    count = (count + (temp));\\n                 }\\n                 idx++;\\n             }\\n             if(count > k) return false;\\n         }\\n         return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3268369,
                "title": "easy-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mo) {\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(nums,mid,mo)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,int &mid,int &mo)\\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mid<=nums[i])\\n            {\\n                if(nums[i]%mid==0)\\n                {\\n                    c=c+((nums[i]/mid)-1);\\n                }\\n                else\\n                {\\n                    c=c+((nums[i]/mid));\\n                }\\n            }\\n        }\\n        if(c<=mo)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mo) {\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(nums,mid,mo)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,int &mid,int &mo)\\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mid<=nums[i])\\n            {\\n                if(nums[i]%mid==0)\\n                {\\n                    c=c+((nums[i]/mid)-1);\\n                }\\n                else\\n                {\\n                    c=c+((nums[i]/mid));\\n                }\\n            }\\n        }\\n        if(c<=mo)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199096,
                "title": "like-koko-eating-bananas",
                "content": "# Complexity\\n- Time complexity: $$nlog(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_size(nums: Vec<i32>, max_operations: i32) -> i32 {\\n        let (mut min, mut max) = (1, *nums.iter().max().unwrap());\\n\\n        let mut pen;\\n\\n        while min < max {\\n            pen = (min + max) / 2;\\n            if Self::can_fit_operations(pen, &nums, max_operations) {\\n                max = pen;\\n            } else {\\n                min = pen + 1;\\n            }\\n        }\\n\\n        min\\n    }\\n\\n    fn can_fit_operations(pen: i32, nums: &Vec<i32>, max: i32) -> bool {\\n        let mut ans = 0;\\n        for num in nums {\\n            ans += (num - 1) / pen;\\n            if ans > max { return  false }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_size(nums: Vec<i32>, max_operations: i32) -> i32 {\\n        let (mut min, mut max) = (1, *nums.iter().max().unwrap());\\n\\n        let mut pen;\\n\\n        while min < max {\\n            pen = (min + max) / 2;\\n            if Self::can_fit_operations(pen, &nums, max_operations) {\\n                max = pen;\\n            } else {\\n                min = pen + 1;\\n            }\\n        }\\n\\n        min\\n    }\\n\\n    fn can_fit_operations(pen: i32, nums: &Vec<i32>, max: i32) -> bool {\\n        let mut ans = 0;\\n        for num in nums {\\n            ans += (num - 1) / pen;\\n            if ans > max { return  false }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104722,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int min = 0;\\n        int max = 1000000000;\\n        \\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n            int count = 0;\\n            \\n            for (int a: nums) {\\n                count+=(a-1)/mid;\\n            }\\n            \\n            if (count <= maxOperations) {\\n                max = mid;\\n            } else {\\n                min = mid;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int min = 0;\\n        int max = 1000000000;\\n        \\n        while (min +1< max) {\\n            int mid = (max - min)/2 + min;\\n            int count = 0;\\n            \\n            for (int a: nums) {\\n                count+=(a-1)/mid;\\n            }\\n            \\n            if (count <= maxOperations) {\\n                max = mid;\\n            } else {\\n                min = mid;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904535,
                "title": "c-solution-binary-search",
                "content": "# CPP CODE:\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int o) {\\n        int r = *max_element(nums.begin(), nums.end());\\n        int l = 1;\\n        int res = r;\\n        while(l < r) {\\n            int penalty = (l + r) / 2;\\n            int ops = 0;\\n            for(int i = 0; i < nums.size(); i++) {\\n                if(nums[i] > penalty) {\\n                    if(nums[i] % penalty == 0) {\\n                        ops += nums[i] / penalty - 1;\\n                    } else {\\n                    ops += nums[i] / penalty;\\n                    }\\n                }\\n            }\\n            if(ops <= o) {\\n                res = penalty;\\n                r = penalty;\\n            } else {\\n                l = penalty + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int o) {\\n        int r = *max_element(nums.begin(), nums.end());\\n        int l = 1;\\n        int res = r;\\n        while(l < r) {\\n            int penalty = (l + r) / 2;\\n            int ops = 0;\\n            for(int i = 0; i < nums.size(); i++) {\\n                if(nums[i] > penalty) {\\n                    if(nums[i] % penalty == 0) {\\n                        ops += nums[i] / penalty - 1;\\n                    } else {\\n                    ops += nums[i] / penalty;\\n                    }\\n                }\\n            }\\n            if(ops <= o) {\\n                res = penalty;\\n                r = penalty;\\n            } else {\\n                l = penalty + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882390,
                "title": "95-faste-binary-search-easy-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) {\\n        int right = INT_MAX;\\n        int cnt = 0,ans = 0, left = 1,mid;\\n        while(left < right){\\n            mid = ((right-left)>>1)+left;\\n            cnt = 0;\\n            for(auto &i: nums){\\n                cnt += ((i-1)/mid);\\n            }\\n            if(cnt>k){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int k) {\\n        int right = INT_MAX;\\n        int cnt = 0,ans = 0, left = 1,mid;\\n        while(left < right){\\n            mid = ((right-left)>>1)+left;\\n            cnt = 0;\\n            for(auto &i: nums){\\n                cnt += ((i-1)/mid);\\n            }\\n            if(cnt>k){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823867,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\t\\tint i=1, j=*max_element(nums.begin(), nums.end()), ans=j;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int k=0; k<nums.size(); k++){\\n\\t\\t\\t\\t\\tcnt+=(nums[k]/mid);\\n\\t\\t\\t\\t\\t// if(nums[k]>mid){\\n\\t\\t\\t\\t\\t//     cnt+=(nums[k]/mid);\\n\\t\\t\\t\\t\\t\\tif(nums[k]%mid==0){cnt--;}\\n\\t\\t\\t\\t\\t// }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//cout<<cnt<<\" \"<<mid<<endl;\\n\\t\\t\\t\\t//if(cnt==maxOperations){ans=mid;}\\n\\t\\t\\t\\tif(cnt<=maxOperations){\\n\\t\\t\\t\\t\\t//cout<<ans<<endl;\\n\\t\\t\\t\\t\\tans=mid;\\n\\t\\t\\t\\t\\tj=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t//cout<<ans<<endl;\\n\\t\\t\\t\\t\\t//ans=mid;\\n\\t\\t\\t\\t\\ti=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint minimumSize(vector<int>& nums, int maxOperations) {\\n\\t\\t\\tint i=1, j=*max_element(nums.begin(), nums.end()), ans=j;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int k=0; k<nums.size(); k++){\\n\\t\\t\\t\\t\\tcnt+=(nums[k]/mid);\\n\\t\\t\\t\\t\\t// if(nums[k]>mid){\\n\\t\\t\\t\\t\\t//     cnt+=(nums[k]/mid);\\n\\t\\t\\t\\t\\t\\tif(nums[k]%mid==0){cnt--;}",
                "codeTag": "Java"
            },
            {
                "id": 2577374,
                "title": "with-explanation-comments-time-367-ms-42-60-space-55-9-mb-95-60",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    //helper function to check if the middle pointer value of the range is a valid value to be divided or not\\n    bool valid(int mid, vector<int> &nums, int maxOperations){\\n        \\n        //initialize a counter\\n        int counter=0;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n          //check if the current element is greater than the mid\\n            if(num>mid){\\n                //initialize a temp variable\\n                int temp=num;\\n                //check again if the current element is divisible by the mid\\n                if(temp%mid==0)\\n                    //if yes-> add the following value to the counter\\n                    //ex: 8 ->(4),(4)-> (2,2),(2,2)-> 3 operations\\n                    counter+=(temp/mid)-1;\\n                else\\n                    //if no...\\n                    counter+=(temp/mid);\\n            }\\n        }\\n        \\n        //check if the counted balls is valid or not compared to the allowed ones\\n        return counter<=maxOperations;\\n    }\\n    \\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        //handle invalid cases\\n        if(maxOperations<1)\\n            return 0;\\n        \\n        //initialize mainly two pointers-> one on the minimum possible value in the array & one on the maximum one\\n        int left=1, right=*max_element(nums.begin(), nums.end());\\n        \\n        //loop while the left pointer is before the right one\\n        while(left<right){\\n            \\n            //the third pointer mid-> is exactly the middle element between the main two ones\\n            int mid=left+(right-left)/2;\\n            \\n            //call the helper function\\n            if(valid(mid, nums, maxOperations))\\n                //case 1: if yes, valid-> move the right pointer to the mid position\\n                right=mid;\\n            else\\n                //case 2: if not-> move the left pointer to the position after the mid one\\n                left=mid+1;\\n        }\\n        \\n        //return the right position \\n        return right;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //helper function to check if the middle pointer value of the range is a valid value to be divided or not\\n    bool valid(int mid, vector<int> &nums, int maxOperations){\\n        \\n        //initialize a counter\\n        int counter=0;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n          //check if the current element is greater than the mid\\n            if(num>mid){\\n                //initialize a temp variable\\n                int temp=num;\\n                //check again if the current element is divisible by the mid\\n                if(temp%mid==0)\\n                    //if yes-> add the following value to the counter\\n                    //ex: 8 ->(4),(4)-> (2,2),(2,2)-> 3 operations\\n                    counter+=(temp/mid)-1;\\n                else\\n                    //if no...\\n                    counter+=(temp/mid);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2427679,
                "title": "c-code-full-explanation-complexity-analysis",
                "content": "***Explanation :*** \\uD83D\\uDCCA\\nLet\\'s understand this with this eg  : ***[2,4,8,2]***\\n***Steps towards the solution :*** \\u2714\\uFE0F\\nFirst of all ,in order to get a ***minimum*** answer , we should know that we need to split the ***bag with maximum size*** first and formost . \\nThis is what we are gonna do in each step , get the bag with max size and try to split it in max ***maxOperations***\\n\\n***Splitting the bag?*** \\uD83D\\uDC5C\\nWe use ***Binary Search*** for splitting the bag . ***(How?)***\\nhere, maximum element is ***8*** (int above eg).\\nlow=1,high=2 , mid=1 i.e. 4\\nWe will iterate through the array for elements ***greater than 4*** and we will try to split them in parts of **size<=4*** withing ***maxOperations***.\\n***Because*** , we try to find if it is possible to get ***4*** as ***answer*** , \\nIf we are able to divide them , then we move\\n***high=mid-1***, and try to reduce ***4*** to ***2*** withing ***maxOperations*** so that we can get ***2*** as answer if it is possible.\\nWe continue doing it until the while loop condition ***low<=high*** is valid\\n\\n***How to split into parts ?*** \\uD83C\\uDF55\\uD83C\\uDF55\\nMinimum parts of ***8*** in ***maxOperations*** : 8->4,4->2,2,2,2  ***[3 opeartions]***\\n=>8%2==0 ***(even)***  parts = 8/2-1 = 4-1 =3. ***(well this is just mathematics)***\\nFor, x%y!=0 ***(odd)*** parts =x/y .\\n\\n***Complexity Analysis :\\nTC : O(nlog n)\\nSC : O(1)***\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid,int maxOperations){\\n        int m=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>mid){\\n                int temp=nums[i];\\n                if(temp%mid==0){\\n                    m+=(temp/mid)-1;\\n                }\\n                else m+=(temp/mid);\\n            }\\n        }\\n        return  m<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(nums,mid,maxOperations)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else  low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid,int maxOperations){\\n        int m=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>mid){\\n                int temp=nums[i];\\n                if(temp%mid==0){\\n                    m+=(temp/mid)-1;\\n                }\\n                else m+=(temp/mid);\\n            }\\n        }\\n        return  m<=maxOperations;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(nums,mid,maxOperations)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else  low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330151,
                "title": "c-binary-search-minimum-limit-of-balls-in-a-bag",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>&a, int op){\\n        long long cnt = 0;\\n        for(auto x: a){\\n            cnt += (x/mid);\\n            if(x%mid==0) cnt--;\\n        }\\n        if(cnt<=op) return true;\\n        else return false;\\n    }\\n    int minimumSize(vector<int>& a, int op) {\\n        long long lo=1, hi=0;\\n        hi = *max_element(a.begin(),a.end());\\n        int ans = 0;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid,a,op)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>&a, int op){\\n        long long cnt = 0;\\n        for(auto x: a){\\n            cnt += (x/mid);\\n            if(x%mid==0) cnt--;\\n        }\\n        if(cnt<=op) return true;\\n        else return false;\\n    }\\n    int minimumSize(vector<int>& a, int op) {\\n        long long lo=1, hi=0;\\n        hi = *max_element(a.begin(),a.end());\\n        int ans = 0;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(check(mid,a,op)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293649,
                "title": "c-simple-binary-search-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>&nums,int n)\\n    {\\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=(nums[i]-1)/mid;\\n            \\n            if(sum>n)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n         \\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int res=-1;\\n        while(low<=high)\\n        {\\n            int mid=low + (high-low)/2;\\n            if(valid(mid,nums,maxOperations))\\n            {\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n            \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>&nums,int n)\\n    {\\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=(nums[i]-1)/mid;\\n            \\n            if(sum>n)\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n         \\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int res=-1;\\n        while(low<=high)\\n        {\\n            int mid=low + (high-low)/2;\\n            if(valid(mid,nums,maxOperations))\\n            {\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n            \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274641,
                "title": "easy-c-o-n-log-max-solution-explained-with-approach",
                "content": "**APPROACH:**\\nmin penalty val possible=1\\nmax penalty value possible=maximum element in array.\\nwe calculate mid and check number of operations required to make all elements lees than equal to mid. if number of operations required is less than maxOperations we decrement end=mid-1 else start=mid+1.\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums,ll target,int maxOperations)\\n    {\\n        int n=nums.size();\\n        int count=0; //operations\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=ceil(nums[i]/(double)target)-1; //for operations calculations logic.\\n        }\\n        if(count<=maxOperations) // if less than maxOperations return true\\n            return true;\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int mx=INT_MAX;\\n        for(int num:nums)\\n            mx=max(mx,num);\\n        ll start=1,end=mx,ans=mx;  // min and max possible value as start and end respectively\\n        while(start<=end)\\n        {\\n            ll mid=start+(end-start)/2;\\n            if(possible(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums,ll target,int maxOperations)\\n    {\\n        int n=nums.size();\\n        int count=0; //operations\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=ceil(nums[i]/(double)target)-1; //for operations calculations logic.\\n        }\\n        if(count<=maxOperations) // if less than maxOperations return true\\n            return true;\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int mx=INT_MAX;\\n        for(int num:nums)\\n            mx=max(mx,num);\\n        ll start=1,end=mx,ans=mx;  // min and max possible value as start and end respectively\\n        while(start<=end)\\n        {\\n            ll mid=start+(end-start)/2;\\n            if(possible(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274313,
                "title": "java-binary-search-template-pattern-beats-90-percent",
                "content": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOp) {\\n        int high = 0;\\n        for(int i: nums){\\n            if(high < i) high = i;\\n        }\\n        int low =1,  ans = -1;\\n        while(low<= high){\\n            int mid= (low+high)/2, sum = 0;\\n            for(int i: nums){\\n                sum+= (i-1)/mid;\\n            }\\n            if(sum<= maxOp){\\n                high = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOp) {\\n        int high = 0;\\n        for(int i: nums){\\n            if(high < i) high = i;\\n        }\\n        int low =1,  ans = -1;\\n        while(low<= high){\\n            int mid= (low+high)/2, sum = 0;\\n            for(int i: nums){\\n                sum+= (i-1)/mid;\\n            }\\n            if(sum<= maxOp){\\n                high = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230090,
                "title": "priority-queue-python",
                "content": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        u = sum(nums)\\n        b = maxOperations\\n        splits = [max(n*b//u, 1) for n in nums]\\n        heap = [(-1 * ((n+split-1)//split), n, split) for n, split in zip(nums, splits)]\\n        heapq.heapify(heap)\\n        for _ in range(maxOperations + len(nums) - sum(splits)):\\n            item = heapq.heappop(heap)\\n            _, n, split = item\\n            num = (n+split)//(split+1)\\n            heapq.heappush(heap, (-num, n, split+1))\\n        return - heap[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        u = sum(nums)\\n        b = maxOperations\\n        splits = [max(n*b//u, 1) for n in nums]\\n        heap = [(-1 * ((n+split-1)//split), n, split) for n, split in zip(nums, splits)]\\n        heapq.heapify(heap)\\n        for _ in range(maxOperations + len(nums) - sum(splits)):\\n            item = heapq.heappop(heap)\\n            _, n, split = item\\n            num = (n+split)//(split+1)\\n            heapq.heappush(heap, (-num, n, split+1))\\n        return - heap[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228691,
                "title": "c-intution-binary-search",
                "content": "Language Used: **C++**\\n\\n*If you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!***\\n\\nTime Complexity = O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int r = *max_element(nums.begin(), nums.end());\\n        int l = 1;\\n        \\n        while(l<r){\\n            int m = (l+r)/2;\\n            if(numOp(nums, m) <= maxOperations) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\nprivate:\\n    int numOp(vector<int>& nums, int m){\\n        int ans =0;\\n        for(int i{}; i<nums.size(); i++){\\n            if(nums[i] >= m){\\n                int s = (nums[i]%m == 0)?(nums[i]/m):(nums[i]/m + 1);\\n                ans += s-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int r = *max_element(nums.begin(), nums.end());\\n        int l = 1;\\n        \\n        while(l<r){\\n            int m = (l+r)/2;\\n            if(numOp(nums, m) <= maxOperations) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\nprivate:\\n    int numOp(vector<int>& nums, int m){\\n        int ans =0;\\n        for(int i{}; i<nums.size(); i++){\\n            if(nums[i] >= m){\\n                int s = (nums[i]%m == 0)?(nums[i]/m):(nums[i]/m + 1);\\n                ans += s-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208017,
                "title": "java-simple-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int left = 1, right = 1000000000;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(numOfOperations(mid, nums) > maxOperations){\\n                left = mid + 1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    public int numOfOperations(int penalty, int[] balls){\\n        int operations = 0;\\n        for(int ball: balls){\\n            operations += (ball - 1) / penalty;\\n        }\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int left = 1, right = 1000000000;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(numOfOperations(mid, nums) > maxOperations){\\n                left = mid + 1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    public int numOfOperations(int penalty, int[] balls){\\n        int operations = 0;\\n        for(int ball: balls){\\n            operations += (ball - 1) / penalty;\\n        }\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193967,
                "title": "c-fastest-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&arr,int oper,int mid){\\n        \\n       long long cnt=0;\\n        for(int i=0;i<arr.size();i++){\\n         if(arr[i]>=mid)cnt+=ceil((double)arr[i]/mid)-1;\\n            \\n        }\\n        return cnt<=oper;\\n        \\n        \\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        sort(nums.begin(),nums.end());\\n        int s=1;\\n        int e=1e9;\\n        int ans=1e9;\\n        while(s<=e){\\n            int mid=(s+e)>>1;\\n            if(ispossible(nums,maxOperations,mid)){\\n                ans=min(ans,mid);\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&arr,int oper,int mid){\\n        \\n       long long cnt=0;\\n        for(int i=0;i<arr.size();i++){\\n         if(arr[i]>=mid)cnt+=ceil((double)arr[i]/mid)-1;\\n            \\n        }\\n        return cnt<=oper;\\n        \\n        \\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        sort(nums.begin(),nums.end());\\n        int s=1;\\n        int e=1e9;\\n        int ans=1e9;\\n        while(s<=e){\\n            int mid=(s+e)>>1;\\n            if(ispossible(nums,maxOperations,mid)){\\n                ans=min(ans,mid);\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157094,
                "title": "c-binary-search-approach",
                "content": "```\\nbool isPossible(vector<int>&nums, int mid_penalty, int maxOperations)\\n{\\n\\tint operations=0;\\n\\tfor(int i=0; i<nums.size(); i++)\\n\\t{\\n\\t\\toperations += (nums[i] / mid_penalty); \\n\\t\\tif(nums[i] % mid_penalty == 0) \\n\\t\\t\\toperations--;\\n\\t}\\n\\n\\treturn operations <= maxOperations ? 1 : 0; \\n}\\n\\nint minimumSize(vector<int>& nums, int maxOperations) \\n{\\n\\tint low_penalty = 1,high_penalty = *max_element(nums.begin(), nums.end());\\n\\tint ans = high_penalty;\\n\\twhile(low_penalty <= high_penalty)\\n\\t{\\n\\t\\tint mid_penalty = low_penalty + (high_penalty - low_penalty)/2;\\n\\t\\tif(mid_penalty == 0)\\n\\t\\t\\tbreak;\\n\\n\\t\\tif(isPossible(nums, mid_penalty, maxOperations))\\n\\t\\t{\\n\\t\\t\\tans = mid_penalty;\\n\\t\\t\\thigh_penalty = mid_penalty - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tlow_penalty = mid_penalty + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool isPossible(vector<int>&nums, int mid_penalty, int maxOperations)\\n{\\n\\tint operations=0;\\n\\tfor(int i=0; i<nums.size(); i++)\\n\\t{\\n\\t\\toperations += (nums[i] / mid_penalty); \\n\\t\\tif(nums[i] % mid_penalty == 0) \\n\\t\\t\\toperations--;\\n\\t}\\n\\n\\treturn operations <= maxOperations ? 1 : 0; \\n}\\n\\nint minimumSize(vector<int>& nums, int maxOperations) \\n{\\n\\tint low_penalty = 1,high_penalty = *max_element(nums.begin(), nums.end());\\n\\tint ans = high_penalty;\\n\\twhile(low_penalty <= high_penalty)\\n\\t{\\n\\t\\tint mid_penalty = low_penalty + (high_penalty - low_penalty)/2;\\n\\t\\tif(mid_penalty == 0)\\n\\t\\t\\tbreak;\\n\\n\\t\\tif(isPossible(nums, mid_penalty, maxOperations))\\n\\t\\t{\\n\\t\\t\\tans = mid_penalty;\\n\\t\\t\\thigh_penalty = mid_penalty - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tlow_penalty = mid_penalty + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117027,
                "title": "c-short-and-clean-code-tc-o-nlog-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>&vec,long long val,long long k)\\n    {\\n        for(int i=0;i<(int)vec.size();i++)\\n        {\\n            if(vec[i]<=val)\\n                continue;\\n            else\\n            {\\n                if((vec[i]%val)==0)\\n                    k-=(vec[i]/val)-1;\\n                else\\n                k-=(vec[i]/val);\\n            }\\n        }\\n        return k>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long st=1,en=1e10,mid;\\n        int ans=0;\\n        while(st<=en)\\n        {\\n            mid=st+(en-st)/2;\\n            if(check(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>&vec,long long val,long long k)\\n    {\\n        for(int i=0;i<(int)vec.size();i++)\\n        {\\n            if(vec[i]<=val)\\n                continue;\\n            else\\n            {\\n                if((vec[i]%val)==0)\\n                    k-=(vec[i]/val)-1;\\n                else\\n                k-=(vec[i]/val);\\n            }\\n        }\\n        return k>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long st=1,en=1e10,mid;\\n        int ans=0;\\n        while(st<=en)\\n        {\\n            mid=st+(en-st)/2;\\n            if(check(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110490,
                "title": "c-step-by-step-binary-search-o-n-log10-9",
                "content": "```\\n  int minimumSize(vector<int>& nums, int maxOperations) {\\n        /*\\n        Time: O(N*Log10^9) where N is the number of values in the input array\\n        Space: O(1)\\n        \\n        Intuition: We want to reduce the number of balls in the bag so that the maximum\\n        is a particular number. The brute force method would be to check each number\\n        one by one (i.e using n number of operations, can we reduce it to 1? 2? 3?, etc)\\n        \\n        To optimize this search we use binary search\\n        \\n        STEP 1: Use binary search to select a number, let us call it bNum, \\n        between 1 and 10^5 (our lower and upper bounds)\\n        \\n        STEP 2: For each number in the bag, num, check how many operations it takes to divide\\n        num into bNum. We compute this by recognizing that if num is equal to bNum we should stop. \\n        But if we simply divide num by bNum that equals 1, we want it to equal 0 since no operations \\n        are required if they are equal.\\n        \\n        We offset this by subtracting num by 1. Now if we divide num by bNum, it gives us how many\\n        times we must split num up to get bNum. Note, in C++ when we perform integer division if 7 is\\n        divided by 8 we get 0 (representing 0 operations required to split 7 into 8).\\n        \\n        Compute and sum up this for every number in the bag. This value represents the number of operations \\n        we must perform to minimize all numbers in the bag to bNum.\\n        \\n        STEP 3: If the number of operations we performed is greater than maxOperations, that means we\\n        chose a number that is too small and divided up the bag too many times. Pick a larger value with\\n        binary search by shifting the left pointer, else attempt to minimize our choice further by shifting\\n        the right pointer and checking if a smaller number is valid\\n        \\n        STEP 4: After binary search, return left pointer which represents the lowest number found in binary search\\n        that minimizes all numbers in the bag while not exceeding maxOperations\\n        */\\n        int l=1, r=1e9, bNum;           // pointers for binary search, left starts at 1 and right at 10^9 (within bounds)\\n        int numberOfOperations=0;       // number of operations it takes to reduce all numbers in bag to bNum \\n        while( l<=r)\\n        {\\n            numberOfOperations=0;   // reset value for every search\\n            // number chosen from binary search\\n            bNum = (l+r)/2;       \\n            // for every number in bag\\n            for(int& num : nums) {\\n                numberOfOperations += (num-1)/bNum;\\n            }\\n            // if too many operations\\n            if( numberOfOperations > maxOperations) {\\n                l=bNum+1;\\n            }\\n            // else try to minimize bNum\\n            else {\\n                r=bNum-1;\\n            }\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n  int minimumSize(vector<int>& nums, int maxOperations) {\\n        /*\\n        Time: O(N*Log10^9) where N is the number of values in the input array\\n        Space: O(1)\\n        \\n        Intuition: We want to reduce the number of balls in the bag so that the maximum\\n        is a particular number. The brute force method would be to check each number\\n        one by one (i.e using n number of operations, can we reduce it to 1? 2? 3?, etc)\\n        \\n        To optimize this search we use binary search\\n        \\n        STEP 1: Use binary search to select a number, let us call it bNum, \\n        between 1 and 10^5 (our lower and upper bounds)\\n        \\n        STEP 2: For each number in the bag, num, check how many operations it takes to divide\\n        num into bNum. We compute this by recognizing that if num is equal to bNum we should stop. \\n        But if we simply divide num by bNum that equals 1, we want it to equal 0 since no operations \\n        are required if they are equal.\\n        \\n        We offset this by subtracting num by 1. Now if we divide num by bNum, it gives us how many\\n        times we must split num up to get bNum. Note, in C++ when we perform integer division if 7 is\\n        divided by 8 we get 0 (representing 0 operations required to split 7 into 8).\\n        \\n        Compute and sum up this for every number in the bag. This value represents the number of operations \\n        we must perform to minimize all numbers in the bag to bNum.\\n        \\n        STEP 3: If the number of operations we performed is greater than maxOperations, that means we\\n        chose a number that is too small and divided up the bag too many times. Pick a larger value with\\n        binary search by shifting the left pointer, else attempt to minimize our choice further by shifting\\n        the right pointer and checking if a smaller number is valid\\n        \\n        STEP 4: After binary search, return left pointer which represents the lowest number found in binary search\\n        that minimizes all numbers in the bag while not exceeding maxOperations\\n        */\\n        int l=1, r=1e9, bNum;           // pointers for binary search, left starts at 1 and right at 10^9 (within bounds)\\n        int numberOfOperations=0;       // number of operations it takes to reduce all numbers in bag to bNum \\n        while( l<=r)\\n        {\\n            numberOfOperations=0;   // reset value for every search\\n            // number chosen from binary search\\n            bNum = (l+r)/2;       \\n            // for every number in bag\\n            for(int& num : nums) {\\n                numberOfOperations += (num-1)/bNum;\\n            }\\n            // if too many operations\\n            if( numberOfOperations > maxOperations) {\\n                l=bNum+1;\\n            }\\n            // else try to minimize bNum\\n            else {\\n                r=bNum-1;\\n            }\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936430,
                "title": "c-binary-search-clean-code",
                "content": "```\\n\\n bool ispossible(int mid , vector<int> &nums , int ops)\\n    {\\n        int count=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n           if(nums[i]%mid==0)\\n           {\\n               count+=(nums[i]/mid  - 1);\\n           }\\n            else\\n           {\\n               count+=(nums[i]/mid);\\n            }\\n        }\\n        \\n        return count<=ops;\\n    }\\n    int minimumSize(vector<int>& nums, int ops) {\\n        \\n        int n=nums.size();\\n        \\n        int l=1 , r=*max_element(nums.begin(),nums.end());\\n              \\n        int ans;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+(r-l)/2);\\n            \\n            if(ispossible(mid , nums , ops)==true)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return l;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n bool ispossible(int mid , vector<int> &nums , int ops)\\n    {\\n        int count=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n           if(nums[i]%mid==0)\\n           {\\n               count+=(nums[i]/mid  - 1);\\n           }\\n            else\\n           {\\n               count+=(nums[i]/mid);\\n            }\\n        }\\n        \\n        return count<=ops;\\n    }\\n    int minimumSize(vector<int>& nums, int ops) {\\n        \\n        int n=nums.size();\\n        \\n        int l=1 , r=*max_element(nums.begin(),nums.end());\\n              \\n        int ans;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+(r-l)/2);\\n            \\n            if(ispossible(mid , nums , ops)==true)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return l;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1910722,
                "title": "python-binary-search-comments",
                "content": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        # the maximum size increases the minimum number of bags decreases so we can binary search the maximum size\\n        def helper(penalty):\\n            \\n            split = 0\\n            \\n            for i in nums:\\n                split+=(i-1)//penalty\\n            \\n            if split<=maxOperations:\\n                return True\\n            else:\\n                return False\\n            \\n        # if we know the maximum size of a bag what is the minimum number of bags you can make\\n        low = 1\\n        heigh = max(nums)\\n        \\n        while low<heigh:\\n            mid = (low+heigh)//2\\n            \\n            if helper(mid):\\n                heigh = mid\\n            \\n            else:\\n                low = mid+1\\n                \\n        return low",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        # the maximum size increases the minimum number of bags decreases so we can binary search the maximum size\\n        def helper(penalty):\\n            \\n            split = 0\\n            \\n            for i in nums:\\n                split+=(i-1)//penalty\\n            \\n            if split<=maxOperations:\\n                return True\\n            else:\\n                return False\\n            \\n        # if we know the maximum size of a bag what is the minimum number of bags you can make\\n        low = 1\\n        heigh = max(nums)\\n        \\n        while low<heigh:\\n            mid = (low+heigh)//2\\n            \\n            if helper(mid):\\n                heigh = mid\\n            \\n            else:\\n                low = mid+1\\n                \\n        return low",
                "codeTag": "Java"
            },
            {
                "id": 1892388,
                "title": "c-binary-search-beginner-friendly-fast-t-c-o-log-maximum-element",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector <int>&nums, long long int m,long long int mid){\\n        long long int count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int x=nums[i]/mid;\\n            if(nums[i]%mid==0)\\n                x--;\\n            count+=x; \\n        }\\n        if(count<=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int m) {\\n        long long int low=1;\\n        long long int ans=-1;\\n        long long int high=*max_element(nums.begin(),nums.end());\\n        while(low<=high){\\n            long long int mid=low+(high-low)/2;\\n            if(check(nums,m,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector <int>&nums, long long int m,long long int mid){\\n        long long int count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            int x=nums[i]/mid;\\n            if(nums[i]%mid==0)\\n                x--;\\n            count+=x; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1873257,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &nums, int val, int maxOperations){\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            if(nums[i] > val){\\n                int curr = nums[i] / val;\\n                \\n                if(nums[i] % val != 0)\\n                    curr++;\\n                \\n                maxOperations -= curr - 1;\\n            }\\n            \\n            if(maxOperations < 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int l = 1;\\n        int r = *max_element(begin(nums), end(nums));\\n        \\n        while(l < r){\\n            \\n            int mid = l + ((r - l) >> 1);\\n            \\n            if(check(nums, mid, maxOperations)){\\n                r = mid;\\n            }\\n            \\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &nums, int val, int maxOperations){\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            if(nums[i] > val){\\n                int curr = nums[i] / val;\\n                \\n                if(nums[i] % val != 0)\\n                    curr++;\\n                \\n                maxOperations -= curr - 1;\\n            }\\n            \\n            if(maxOperations < 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int l = 1;\\n        int r = *max_element(begin(nums), end(nums));\\n        \\n        while(l < r){\\n            \\n            int mid = l + ((r - l) >> 1);\\n            \\n            if(check(nums, mid, maxOperations)){\\n                r = mid;\\n            }\\n            \\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846212,
                "title": "easy-c-binary-search",
                "content": "```\\nclass Solution {\\n    int get_operations(vector<int>&nums,int &penality){\\n        int operations = 0;\\n        for(auto i:nums){\\n            operations += (i/penality);\\n            if(i%penality==0) --operations;\\n        }\\n        return operations;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int min_penality = 1, max_penality, penality;\\n        max_penality = *max_element(nums.begin(),nums.end());\\n        int op,res=max_penality;\\n        while(min_penality<=max_penality){\\n            penality = min_penality + (max_penality-min_penality)/2;\\n            op = get_operations(nums,penality);\\n            if(op>maxOperations) min_penality=penality+1;\\n            else{\\n                res=min(res,penality);\\n                max_penality = penality-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int get_operations(vector<int>&nums,int &penality){\\n        int operations = 0;\\n        for(auto i:nums){\\n            operations += (i/penality);\\n            if(i%penality==0) --operations;\\n        }\\n        return operations;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int min_penality = 1, max_penality, penality;\\n        max_penality = *max_element(nums.begin(),nums.end());\\n        int op,res=max_penality;\\n        while(min_penality<=max_penality){\\n            penality = min_penality + (max_penality-min_penality)/2;\\n            op = get_operations(nums,penality);\\n            if(op>maxOperations) min_penality=penality+1;\\n            else{\\n                res=min(res,penality);\\n                max_penality = penality-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780376,
                "title": "o-1-100-faster-c-java-python-c-javascript-php-html-ml",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isitposs(vector<int>& nums, long long cur , int maxOpr)\\n    {\\n        if(cur==0)return false;\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans+=(nums[i]-1)/cur;\\n        }\\n        return ans<=maxOpr;\\n    }\\n    int minimumSize(vector<int>& nums, int maxopr) {\\n        int s=0,e=*max_element(nums.begin(),nums.end());\\n        int mid=0;\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            mid=s+(e-s)/2;\\n            if(isitposs(nums,mid,maxopr))\\n            {\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isitposs(vector<int>& nums, long long cur , int maxOpr)\\n    {\\n        if(cur==0)return false;\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans+=(nums[i]-1)/cur;\\n        }\\n        return ans<=maxOpr;\\n    }\\n    int minimumSize(vector<int>& nums, int maxopr) {\\n        int s=0,e=*max_element(nums.begin(),nums.end());\\n        int mid=0;\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            mid=s+(e-s)/2;\\n            if(isitposs(nums,mid,maxopr))\\n            {\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763331,
                "title": "binary-search-on-answer-simple-concept",
                "content": "bool can_be_answer(vector<int> arr,int n,int max_op,int maxo_in_arr)\\n{\\n    int curr_op=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]>=maxo_in_arr)      \\n        curr_op+=arr[i]/maxo_in_arr;\\n        \\n         //if number is 5 and maxo_in_arr=5 or multiple of 5\\n        if(arr[i]%maxo_in_arr==0)  \\n            curr_op--;\\n    }\\n\\n    return curr_op<=max_op;\\n }\\nint minimumSize(vector<int>& arr, int max_op)\\n{\\n    int s=1,e=0,ans=0;\\n    int n=arr.size();\\n\\n    for(int i=0;i<n;i++)\\n    e=max(e,arr[i]);\\n\\n    while(s<=e)\\n    {\\n        int mid=s+(e-s)/2;\\n\\n        if(can_be_answer(arr,n,max_op,mid))\\n        {\\n            ans=mid;\\n            e=mid-1;\\n        }\\n        else\\n        s=mid+1;\\n    }\\n\\n    return ans;\\n}",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "bool can_be_answer(vector<int> arr,int n,int max_op,int maxo_in_arr)\\n{\\n    int curr_op=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]>=maxo_in_arr)      \\n        curr_op+=arr[i]/maxo_in_arr;\\n        \\n         //if number is 5 and maxo_in_arr=5 or multiple of 5\\n        if(arr[i]%maxo_in_arr==0)  \\n            curr_op--;\\n    }\\n\\n    return curr_op<=max_op;\\n }\\nint minimumSize(vector<int>& arr, int max_op)\\n{\\n    int s=1,e=0,ans=0;\\n    int n=arr.size();\\n\\n    for(int i=0;i<n;i++)\\n    e=max(e,arr[i]);\\n\\n    while(s<=e)\\n    {\\n        int mid=s+(e-s)/2;\\n\\n        if(can_be_answer(arr,n,max_op,mid))\\n        {\\n            ans=mid;\\n            e=mid-1;\\n        }\\n        else\\n        s=mid+1;\\n    }\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1706907,
                "title": "c-binary-search-on-answer-o-nlog-max-in-array",
                "content": "**Binary Search on answer. Our answer will lie in the range 1 to maximum in array in case we do not use any operations. So we got our search space. Now as in binary search we will make left=1 and right=maximum in array, and then finding mid and checking is mid a possible answer if yes than we will reduce our search space and set r=mid because we have to minimize the answer and if mid is not the possible answer so we have to set l=mid+1 as our answer will lie to the right.**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums, int num, int k, int n){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>num){\\n                int val=ceil((double)nums[i]/(double)num);\\n                cnt+=(val-1);\\n            }\\n            \\n            if(cnt>k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int n=nums.size();\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        \\n        int l=1,r=mx;\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(isPossible(nums,mid,maxOperations,n)){\\n                r=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums, int num, int k, int n){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>num){\\n                int val=ceil((double)nums[i]/(double)num);\\n                cnt+=(val-1);\\n            }\\n            \\n            if(cnt>k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int n=nums.size();\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        \\n        int l=1,r=mx;\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(isPossible(nums,mid,maxOperations,n)){\\n                r=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695898,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int c,int Max)\\n    {\\n        for(int a : A)\\n        {\\n            if(a > Max)\\n            {       \\n                c -= ( ceil((double)a / Max) - 1);\\n            }\\n            if(c < 0)\\n                return 0;\\n        }\\n        \\n        return 1;\\n    }\\n    int minimumSize(vector<int>&A, int c) {\\n        int l = 1;\\n        int r = *max_element(A.begin(),A.end());\\n        while(l < r)\\n        {\\n            int mid =  (l + r) / 2;\\n            if(check(A,c,mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int c,int Max)\\n    {\\n        for(int a : A)\\n        {\\n            if(a > Max)\\n            {       \\n                c -= ( ceil((double)a / Max) - 1);\\n            }\\n            if(c < 0)\\n                return 0;\\n        }\\n        \\n        return 1;\\n    }\\n    int minimumSize(vector<int>&A, int c) {\\n        int l = 1;\\n        int r = *max_element(A.begin(),A.end());\\n        while(l < r)\\n        {\\n            int mid =  (l + r) / 2;\\n            if(check(A,c,mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677588,
                "title": "c-binary-search-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &nums,int targetPenalty){\\n        int reqOps = 0;\\n        for(int ele : nums){\\n\\t\\t // if A[i] = 10 and targetPenalty = 4 then reqOps = 10/4 = 2 => [10] -> [4,6] -> [4,4,2]\\n          reqOps += ele / targetPenalty;\\n\\t\\t \\xA0/* if A[i] is divisible by targetPenalty eg : A[i] = 8 and targetPenalty = 4 . requied operaions = 8/4 = 2 but required operations are 1 i.e. [8] -> [4,4] so we need to decrement our required operations by 1. */\\n          if(ele % targetPenalty == 0)\\n              reqOps--;\\n        }\\n        return reqOps;\\n        \\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n\\t   // eg : [2,4,8,2] so penalty can be from 1 to 8\\n        int minPossiblePenalty = 1;\\n        int maxPossiblePenalty = *max_element(nums.begin(),nums.end());\\n        int minPenalty;\\n        while(minPossiblePenalty <= maxPossiblePenalty){\\n\\t\\t   // for above eg first targetPenalty = (1 + 8) /2 => 4 so we will find no of required operations to get targetPenalty of 4.\\n            int targetPenalty = (minPossiblePenalty + maxPossiblePenalty) / 2;\\n\\t\\t\\t/* find function will return 1 for target penalty 4 . Because in [2,4,8,2] only 8 will be divided to [4,4] and no need to divide rest all elements so no of operation for penalty 4 = 1 */\\n            int reqOp = find(nums,targetPenalty);\\n\\t\\t\\t/* for above example we got reqOps = 1 which is less than 4 , so to get penalty 4 reqOps is less so it is possible to minimize penalty further and current minimum penalty = 4 is saved in minPenalty varaible  */\\n            if(reqOp <= maxOperations)\\n            {\\n                minPenalty = targetPenalty;\\n                maxPossiblePenalty = targetPenalty - 1;\\n            }\\n\\t\\t\\t\\t/* if reqOps is greater than allowed operations then that means we have to increase our targetPenalty to get lesser Operations because penalty less than targetPenalty will only increase our required operations. */\\n            else\\n                minPossiblePenalty = targetPenalty + 1;\\n        }\\n        return minPenalty;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &nums,int targetPenalty){\\n        int reqOps = 0;\\n        for(int ele : nums){\\n\\t\\t // if A[i] = 10 and targetPenalty = 4 then reqOps = 10/4 = 2 => [10] -> [4,6] -> [4,4,2]\\n          reqOps += ele / targetPenalty;\\n\\t\\t \\xA0/* if A[i] is divisible by targetPenalty eg : A[i] = 8 and targetPenalty = 4 . requied operaions = 8/4 = 2 but required operations are 1 i.e. [8] -> [4,4] so we need to decrement our required operations by 1. */\\n          if(ele % targetPenalty == 0)\\n              reqOps--;\\n        }\\n        return reqOps;\\n        \\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n\\t   // eg : [2,4,8,2] so penalty can be from 1 to 8\\n        int minPossiblePenalty = 1;\\n        int maxPossiblePenalty = *max_element(nums.begin(),nums.end());\\n        int minPenalty;\\n        while(minPossiblePenalty <= maxPossiblePenalty){\\n\\t\\t   // for above eg first targetPenalty = (1 + 8) /2 => 4 so we will find no of required operations to get targetPenalty of 4.\\n            int targetPenalty = (minPossiblePenalty + maxPossiblePenalty) / 2;\\n\\t\\t\\t/* find function will return 1 for target penalty 4 . Because in [2,4,8,2] only 8 will be divided to [4,4] and no need to divide rest all elements so no of operation for penalty 4 = 1 */\\n            int reqOp = find(nums,targetPenalty);\\n\\t\\t\\t/* for above example we got reqOps = 1 which is less than 4 , so to get penalty 4 reqOps is less so it is possible to minimize penalty further and current minimum penalty = 4 is saved in minPenalty varaible  */\\n            if(reqOp <= maxOperations)\\n            {\\n                minPenalty = targetPenalty;\\n                maxPossiblePenalty = targetPenalty - 1;\\n            }\\n\\t\\t\\t\\t/* if reqOps is greater than allowed operations then that means we have to increase our targetPenalty to get lesser Operations because penalty less than targetPenalty will only increase our required operations. */\\n            else\\n                minPossiblePenalty = targetPenalty + 1;\\n        }\\n        return minPenalty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620326,
                "title": "c-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool countoccurences(vector<int>&nums,int op,int mid)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cnt=cnt+(nums[i]-1)/mid;\\n            if(cnt>op) //if the count of occurences of number is greater then the max no of operation so to minimise the number we should have to move right side since the value of mid will be large and it minimise the count of array element.\\n            {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n     \\n        \\n        //1.our search range is from 0 to max-element in array(not the index of nums array) so it will be sorted\\n        \\n        int low=1;\\n        int ans;ans=0;\\n       int high=*max_element(nums.begin(),nums.end());\\n       \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n           \\n            if(countoccurences(nums,maxOperations,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool countoccurences(vector<int>&nums,int op,int mid)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cnt=cnt+(nums[i]-1)/mid;\\n            if(cnt>op) //if the count of occurences of number is greater then the max no of operation so to minimise the number we should have to move right side since the value of mid will be large and it minimise the count of array element.\\n            {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n     \\n        \\n        //1.our search range is from 0 to max-element in array(not the index of nums array) so it will be sorted\\n        \\n        int low=1;\\n        int ans;ans=0;\\n       int high=*max_element(nums.begin(),nums.end());\\n       \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n           \\n            if(countoccurences(nums,maxOperations,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395190,
                "title": "python3-binary-search",
                "content": "```\\n#TIME COMPLEXITY - O(logn)\\n#SPACE COMPLEXITY - O(1)\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        low,high=1,max(nums)\\n        while low<high:\\n            mid=(low+high)>>1\\n            if sum([(i-1)//(mid) for i in nums])>maxOperations:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return low\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(logn)\\n#SPACE COMPLEXITY - O(1)\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        low,high=1,max(nums)\\n        while low<high:\\n            mid=(low+high)>>1\\n            if sum([(i-1)//(mid) for i in nums])>maxOperations:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return low\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317538,
                "title": "java-binary-search-greedy-t-c-o-nums-length-log-max-nums-s-c-o-1",
                "content": "\\n\\t// Binary Search + Greedy\\n\\t// O(nums.length*log(max(nums))) O(1)\\n\\tpublic int minimumSize(int[] nums, int maxOperations) {\\n\\n\\t\\tint len = nums.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] > max)\\n\\t\\t\\t\\tmax = nums[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nums.length) O(1)\\n\\tpublic boolean isPossible(int[] nums, int maxOperations, int penalty) {\\n\\n\\t\\tint len = nums.length, operations = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (nums[i] <= penalty)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint quot = nums[i] / penalty, rem = nums[i] % penalty;\\n\\t\\t\\tint cost = (rem == 0) ? quot - 1 : quot;\\n\\n\\t\\t\\toperations += cost;\\n\\t\\t\\tif (operations > maxOperations)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Binary Search + Greedy\\n\\t// O(nums.length*log(max(nums))) O(1)\\n\\tpublic int minimumSize(int[] nums, int maxOperations) {\\n\\n\\t\\tint len = nums.length, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] > max)\\n\\t\\t\\t\\tmax = nums[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(nums, maxOperations, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nums.length) O(1)\\n\\tpublic boolean isPossible(int[] nums, int maxOperations, int penalty) {\\n\\n\\t\\tint len = nums.length, operations = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (nums[i] <= penalty)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint quot = nums[i] / penalty, rem = nums[i] % penalty;\\n\\t\\t\\tint cost = (rem == 0) ? quot - 1 : quot;\\n\\n\\t\\t\\toperations += cost;\\n\\t\\t\\tif (operations > maxOperations)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1240730,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool find(vector<int>&nums,int mid,int val)\\n    {\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%mid==0)\\n            {\\n                sum=sum+nums[i]/mid-1;\\n            }\\n            else\\n            {\\n                sum=sum+nums[i]/mid;\\n            }\\n        }\\n        return sum<=val;\\n    }\\n    int minimumSize(vector<int>& nums, int mx) \\n    {    \\n        int l=1;\\n        int r=1e9;\\n        int ans=r;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(nums,mid,mx))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool find(vector<int>&nums,int mid,int val)\\n    {\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%mid==0)\\n            {\\n                sum=sum+nums[i]/mid-1;\\n            }\\n            else\\n            {\\n                sum=sum+nums[i]/mid;\\n            }\\n        }\\n        return sum<=val;\\n    }\\n    int minimumSize(vector<int>& nums, int mx) \\n    {    \\n        int l=1;\\n        int r=1e9;\\n        int ans=r;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(nums,mid,mx))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097680,
                "title": "java-binary-search",
                "content": "\\t// binary search\\n\\t\\tpublic int minimumSize(int[] nums, int maxOperations) {\\n\\n\\t\\t\\tint right = 0;\\n\\n\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tright = Math.max(right, num);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint left = 0;\\n\\n\\t\\t\\twhile (left < right - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint midSize = left + (right - left) / 2;\\n\\n\\t\\t\\t\\tif (canSplit(nums, maxOperations, midSize)) {\\n\\t\\t\\t\\t\\tright = midSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tleft = midSize + 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (left > 0 && canSplit(nums, maxOperations, left)) ? left : right;\\n\\n\\t\\t}\\n\\n\\t\\t// for each element in nums\\n\\t\\t// if nums[i] === a\\n\\t\\t// operations needed is (a - 1) / targetSize\\n\\t\\t// for example 7 -> 3 3 1 take 2 operations which is (a - 1) / 3 (targetSize = 3)\\n\\n\\t\\tprivate boolean canSplit(int[] nums, int maxOperations, int targetSize)\\n\\t\\t{\\n\\t\\t\\tint ops = 0;\\n\\n\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (num <= targetSize) continue;\\n\\n\\t\\t\\t\\tops += (num - 1) / targetSize;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ops <= maxOperations;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t// binary search\\n\\t\\tpublic int minimumSize(int[] nums, int maxOperations) {\\n\\n\\t\\t\\tint right = 0;\\n\\n\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tright = Math.max(right, num);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint left = 0;\\n\\n\\t\\t\\twhile (left < right - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint midSize = left + (right - left) / 2;\\n\\n\\t\\t\\t\\tif (canSplit(nums, maxOperations, midSize)) {\\n\\t\\t\\t\\t\\tright = midSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tleft = midSize + 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (left > 0 && canSplit(nums, maxOperations, left)) ? left : right;\\n\\n\\t\\t}\\n\\n\\t\\t// for each element in nums\\n\\t\\t// if nums[i] === a\\n\\t\\t// operations needed is (a - 1) / targetSize\\n\\t\\t// for example 7 -> 3 3 1 take 2 operations which is (a - 1) / 3 (targetSize = 3)\\n\\n\\t\\tprivate boolean canSplit(int[] nums, int maxOperations, int targetSize)\\n\\t\\t{\\n\\t\\t\\tint ops = 0;\\n\\n\\t\\t\\tfor (int num : nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (num <= targetSize) continue;\\n\\n\\t\\t\\t\\tops += (num - 1) / targetSize;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ops <= maxOperations;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1075011,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int start = 1, end = INT_MIN;\\n        \\n        for (const auto& num : nums) {\\n            end = max(end, num); \\n        }\\n        \\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (helper(nums, mid) <= maxOperations) end = mid;\\n            else start = mid;\\n        }\\n        \\n        if (helper(nums, start) <= maxOperations) return start;\\n        else return end;\\n    }\\n    \\n    int helper(vector<int>& nums, int target) {\\n        int operations = 0; \\n        \\n        for (const auto& num : nums) {\\n            if (target >= num) continue; \\n            \\n            operations += (num - 1) / target;\\n        }\\n        \\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int start = 1, end = INT_MIN;\\n        \\n        for (const auto& num : nums) {\\n            end = max(end, num); \\n        }\\n        \\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (helper(nums, mid) <= maxOperations) end = mid;\\n            else start = mid;\\n        }\\n        \\n        if (helper(nums, start) <= maxOperations) return start;\\n        else return end;\\n    }\\n    \\n    int helper(vector<int>& nums, int target) {\\n        int operations = 0; \\n        \\n        for (const auto& num : nums) {\\n            if (target >= num) continue; \\n            \\n            operations += (num - 1) / target;\\n        }\\n        \\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069092,
                "title": "1-liner-ruby",
                "content": "```\\ndef minimum_size(nums, max_operations)\\n  (1..nums.max).bsearch { |m| nums.sum { |b| (b - 1) / m } <= max_operations }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimum_size(nums, max_operations)\\n  (1..nums.max).bsearch { |m| nums.sum { |b| (b - 1) / m } <= max_operations }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1068776,
                "title": "o-n-c-48ms-beats-100",
                "content": "Here are two O(n) implementations. The first one uses linear-time median finding:\\n```\\n/***************************************************\\nAuthor: hqztrue\\nhttps://github.com/hqztrue/LeetCodeSolutions\\nComplexity: O(n)\\nIf you find this solution helpful, plz give a star:)\\n***************************************************/\\ntypedef long long ll;\\nconst int N=100005;\\nint c[N],d;\\nclass Solution {\\npublic:\\n\\tvoid reduce(int *a,int n,int r){\\n\\t\\tif (!r||r>n)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tnth_element(c,c+n-r,c+n); int v=c[n-r],n1=0,p;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint t=a[i]/(a[i]/d+1);\\n\\t\\t\\tif (t>v)a[n1++]=a[i];\\n\\t\\t\\telse if (t==v)p=a[i];\\n\\t\\t}\\n\\t\\tfor (int i=n1;i<r;++i)a[i]=p;\\n\\t}\\n\\tvoid find(int *a,int n,int r){\\n\\t\\tif (r==0)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tint mid=n/2,s=0,v;\\n\\t\\tnth_element(c,c+mid,c+n); v=c[mid];\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i]/(v+1)-a[i]/d;\\n\\t\\tif (s>=r){\\n\\t\\t\\tint n1=0;\\n\\t\\t\\tfor (int i=0;i<n;++i)if (a[i]/(a[i]/d+1)>v)a[n1++]=a[i];\\n\\t\\t\\tfind(a,n1,r);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (!v){d=v; return;}\\n\\t\\t\\ts=0; for (int i=0;i<n;++i)s+=a[i]/v-a[i]/d;\\n\\t\\t\\td=v; if (s>=r)return;\\n\\t\\t\\tr-=s; reduce(a,n,r);\\n\\t\\t\\tfind(a,min(n,r),r);\\n\\t\\t}\\n\\t}\\n\\tint minimumSize(vector<int>& a, int t) {\\n\\t\\tint n=a.size(); ll s=0; t+=n;\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i];\\n\\t\\tif (s<=t)return 1;\\n\\t\\td=t==n?*max_element(a.begin(),a.end()):(int)floor(1.*s/(t-n));\\n\\t\\tint s1=n; for (int i=0;i<n;++i)a[i]-=1,s1+=a[i]/d;\\n\\t\\tif (s1>t)return d+1;\\n\\t\\treduce(&a[0],n,t+1-s1);\\n\\t\\tfind(&a[0],min(n,t+1-s1),t+1-s1);\\n\\t\\treturn d+1;\\n\\t}\\n};\\n```\\n\\nThe second one uses random sampling to further improve the speed.\\n```\\ntypedef long long ll;\\nconst int N=100005,inf=1000000005;\\ninline int _rand(){static unsigned int x=1996090921;x+=(x<<4)+1;return x&=0x7fffffff;}\\nint c[N],d;\\nclass Solution {\\npublic:\\n\\tint *a,n,m; ll s;\\n\\tvoid reduce(int *a,int n,int r){\\n\\t\\tif (!r||r>n)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tnth_element(c,c+n-r,c+n); int v=c[n-r],n1=0,p;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint t=a[i]/(a[i]/d+1);\\n\\t\\t\\tif (t>v)a[n1++]=a[i];\\n\\t\\t\\telse if (t==v)p=a[i];\\n\\t\\t}\\n\\t\\tfor (int i=n1;i<r;++i)a[i]=p;\\n\\t}\\n\\tvoid find(int *a,int n,int r){\\n\\t\\tif (r==0)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tint mid=n/2,s=0,v;\\n\\t\\tnth_element(c,c+mid,c+n); v=c[mid];\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i]/(v+1)-a[i]/d;\\n\\t\\tif (s>=r){\\n\\t\\t\\tint n1=0;\\n\\t\\t\\tfor (int i=0;i<n;++i)if (a[i]/(a[i]/d+1)>v)a[n1++]=a[i];\\n\\t\\t\\tfind(a,n1,r);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (!v){d=v; return;}\\n\\t\\t\\ts=0; for (int i=0;i<n;++i)s+=a[i]/v-a[i]/d;\\n\\t\\t\\td=v; if (s>=r)return;\\n\\t\\t\\tr-=s; reduce(a,n,r);\\n\\t\\t\\tfind(a,min(n,r),r);\\n\\t\\t}\\n\\t}\\n\\tdouble f(int x){\\n\\t\\tdouble res=1.*s/x; ll s1=0;\\n\\t\\tfor (int i=0,j;i<m;++i)\\n\\t\\t\\tj=a[i]%x,s1+=x*(j>0)-j;  //a[_rand()%n]%x\\n\\t\\treturn res+1.*s1/x*n/m;\\n\\t}\\n\\tint minimumSize(vector<int>& A, int t) {\\n\\t\\tn=A.size(); a=&A[0]; m=min(n,(int)(pow(n*log2(N),2./3)*0.03+10)); s=0; t+=n;\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i];\\n\\t\\tif (s<=t)return 1;\\n\\t\\tfor (int i=0;i<m;++i)swap(a[i],a[i+_rand()%(n-i)]);  //random_shuffle(a,a+n);\\n\\t\\tint l=1,r=min(inf,(int)ceil(1.*s/(max(t-n,1)))),delta=m*log2(N)*0.15+100;\\n\\t\\twhile (l<r){\\n\\t\\t\\tint mid=(l+r)>>1;\\n\\t\\t\\tif (f(mid)+delta<=t)r=mid;\\n\\t\\t\\telse l=mid+1;\\n\\t\\t}\\n\\t\\tint s1=n; d=l; for (int i=0;i<n;++i)a[i]-=1,s1+=a[i]/d;\\n\\t\\tassert(s1<=t);\\n\\t\\tif (t-s1>delta*2){\\n\\t\\t\\ts1=n; d=l-1; for (int i=0;i<n;++i)s1+=a[i]/d;\\n\\t\\t\\tif (s1>t)return l;\\n\\t\\t}\\n\\t\\tassert(t-s1<=delta*2);\\n\\t\\tif (s1>t)return d+1;\\n\\t\\treduce(&a[0],n,t+1-s1);\\n\\t\\tfind(&a[0],min(n,t+1-s1),t+1-s1);\\n\\t\\treturn d+1;\\n\\t}\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bb0fcd10-3b21-43ec-a8fb-1a3da1633050_1613504584.8394372.png)\\n",
                "solutionTags": [],
                "code": "```\\n/***************************************************\\nAuthor: hqztrue\\nhttps://github.com/hqztrue/LeetCodeSolutions\\nComplexity: O(n)\\nIf you find this solution helpful, plz give a star:)\\n***************************************************/\\ntypedef long long ll;\\nconst int N=100005;\\nint c[N],d;\\nclass Solution {\\npublic:\\n\\tvoid reduce(int *a,int n,int r){\\n\\t\\tif (!r||r>n)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tnth_element(c,c+n-r,c+n); int v=c[n-r],n1=0,p;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint t=a[i]/(a[i]/d+1);\\n\\t\\t\\tif (t>v)a[n1++]=a[i];\\n\\t\\t\\telse if (t==v)p=a[i];\\n\\t\\t}\\n\\t\\tfor (int i=n1;i<r;++i)a[i]=p;\\n\\t}\\n\\tvoid find(int *a,int n,int r){\\n\\t\\tif (r==0)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tint mid=n/2,s=0,v;\\n\\t\\tnth_element(c,c+mid,c+n); v=c[mid];\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i]/(v+1)-a[i]/d;\\n\\t\\tif (s>=r){\\n\\t\\t\\tint n1=0;\\n\\t\\t\\tfor (int i=0;i<n;++i)if (a[i]/(a[i]/d+1)>v)a[n1++]=a[i];\\n\\t\\t\\tfind(a,n1,r);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (!v){d=v; return;}\\n\\t\\t\\ts=0; for (int i=0;i<n;++i)s+=a[i]/v-a[i]/d;\\n\\t\\t\\td=v; if (s>=r)return;\\n\\t\\t\\tr-=s; reduce(a,n,r);\\n\\t\\t\\tfind(a,min(n,r),r);\\n\\t\\t}\\n\\t}\\n\\tint minimumSize(vector<int>& a, int t) {\\n\\t\\tint n=a.size(); ll s=0; t+=n;\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i];\\n\\t\\tif (s<=t)return 1;\\n\\t\\td=t==n?*max_element(a.begin(),a.end()):(int)floor(1.*s/(t-n));\\n\\t\\tint s1=n; for (int i=0;i<n;++i)a[i]-=1,s1+=a[i]/d;\\n\\t\\tif (s1>t)return d+1;\\n\\t\\treduce(&a[0],n,t+1-s1);\\n\\t\\tfind(&a[0],min(n,t+1-s1),t+1-s1);\\n\\t\\treturn d+1;\\n\\t}\\n};\\n```\n```\\ntypedef long long ll;\\nconst int N=100005,inf=1000000005;\\ninline int _rand(){static unsigned int x=1996090921;x+=(x<<4)+1;return x&=0x7fffffff;}\\nint c[N],d;\\nclass Solution {\\npublic:\\n\\tint *a,n,m; ll s;\\n\\tvoid reduce(int *a,int n,int r){\\n\\t\\tif (!r||r>n)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tnth_element(c,c+n-r,c+n); int v=c[n-r],n1=0,p;\\n\\t\\tfor (int i=0;i<n;++i){\\n\\t\\t\\tint t=a[i]/(a[i]/d+1);\\n\\t\\t\\tif (t>v)a[n1++]=a[i];\\n\\t\\t\\telse if (t==v)p=a[i];\\n\\t\\t}\\n\\t\\tfor (int i=n1;i<r;++i)a[i]=p;\\n\\t}\\n\\tvoid find(int *a,int n,int r){\\n\\t\\tif (r==0)return;\\n\\t\\tfor (int i=0;i<n;++i)c[i]=a[i]/(a[i]/d+1);\\n\\t\\tint mid=n/2,s=0,v;\\n\\t\\tnth_element(c,c+mid,c+n); v=c[mid];\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i]/(v+1)-a[i]/d;\\n\\t\\tif (s>=r){\\n\\t\\t\\tint n1=0;\\n\\t\\t\\tfor (int i=0;i<n;++i)if (a[i]/(a[i]/d+1)>v)a[n1++]=a[i];\\n\\t\\t\\tfind(a,n1,r);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (!v){d=v; return;}\\n\\t\\t\\ts=0; for (int i=0;i<n;++i)s+=a[i]/v-a[i]/d;\\n\\t\\t\\td=v; if (s>=r)return;\\n\\t\\t\\tr-=s; reduce(a,n,r);\\n\\t\\t\\tfind(a,min(n,r),r);\\n\\t\\t}\\n\\t}\\n\\tdouble f(int x){\\n\\t\\tdouble res=1.*s/x; ll s1=0;\\n\\t\\tfor (int i=0,j;i<m;++i)\\n\\t\\t\\tj=a[i]%x,s1+=x*(j>0)-j;  //a[_rand()%n]%x\\n\\t\\treturn res+1.*s1/x*n/m;\\n\\t}\\n\\tint minimumSize(vector<int>& A, int t) {\\n\\t\\tn=A.size(); a=&A[0]; m=min(n,(int)(pow(n*log2(N),2./3)*0.03+10)); s=0; t+=n;\\n\\t\\tfor (int i=0;i<n;++i)s+=a[i];\\n\\t\\tif (s<=t)return 1;\\n\\t\\tfor (int i=0;i<m;++i)swap(a[i],a[i+_rand()%(n-i)]);  //random_shuffle(a,a+n);\\n\\t\\tint l=1,r=min(inf,(int)ceil(1.*s/(max(t-n,1)))),delta=m*log2(N)*0.15+100;\\n\\t\\twhile (l<r){\\n\\t\\t\\tint mid=(l+r)>>1;\\n\\t\\t\\tif (f(mid)+delta<=t)r=mid;\\n\\t\\t\\telse l=mid+1;\\n\\t\\t}\\n\\t\\tint s1=n; d=l; for (int i=0;i<n;++i)a[i]-=1,s1+=a[i]/d;\\n\\t\\tassert(s1<=t);\\n\\t\\tif (t-s1>delta*2){\\n\\t\\t\\ts1=n; d=l-1; for (int i=0;i<n;++i)s1+=a[i]/d;\\n\\t\\t\\tif (s1>t)return l;\\n\\t\\t}\\n\\t\\tassert(t-s1<=delta*2);\\n\\t\\tif (s1>t)return d+1;\\n\\t\\treduce(&a[0],n,t+1-s1);\\n\\t\\tfind(&a[0],min(n,t+1-s1),t+1-s1);\\n\\t\\treturn d+1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066493,
                "title": "python-binary-search",
                "content": "For a given `max_cost` we can find how many operations we need to obtain it. If it is less than `maxOperations`, this cost is do-able, otherwise we need to increase it. Mononotic, and can be solved via binary search.\\n\\n```python\\nclass Solution:\\n    def minimumSize(self, A, maxOperations):\\n        def possible(m):\\n            curOperations = 0\\n            for e in A:\\n                if e>m:\\n                    curOperations += (e-1)//m\\n                    if curOperations > maxOperations:\\n                        return False\\n            return True\\n        \\n        \\n        lo, hi = 1, 1<<30\\n        while lo<hi:\\n            m = lo + hi >> 1\\n            if possible(m):\\n                hi = m\\n            else:\\n                lo = m+1\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumSize(self, A, maxOperations):\\n        def possible(m):\\n            curOperations = 0\\n            for e in A:\\n                if e>m:\\n                    curOperations += (e-1)//m\\n                    if curOperations > maxOperations:\\n                        return False\\n            return True\\n        \\n        \\n        lo, hi = 1, 1<<30\\n        while lo<hi:\\n            m = lo + hi >> 1\\n            if possible(m):\\n                hi = m\\n            else:\\n                lo = m+1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066311,
                "title": "nice-problem-on-binary-search-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool fun(int maxOperations, vector<int>&nums,int maxvalue)\\n    {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] > maxvalue)\\n            {\\n                if(nums[i] % maxvalue == 0)\\n                {\\n                    count += nums[i] / maxvalue  - 1;\\n                }\\n                else \\n                {\\n                    count += nums[i] / maxvalue;\\n                }\\n            }\\n        }\\n        if(count <= maxOperations)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) \\n    {\\n        int l = 1 , r = INT_MAX;\\n        int ans;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if(fun(maxOperations, nums,mid) == true)\\n            {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// tc o(n * log(INT_MAX))\\n// sc o(1)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fun(int maxOperations, vector<int>&nums,int maxvalue)\\n    {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] > maxvalue)\\n            {\\n                if(nums[i] % maxvalue == 0)\\n                {\\n                    count += nums[i] / maxvalue  - 1;\\n                }\\n                else \\n                {\\n                    count += nums[i] / maxvalue;\\n                }\\n            }\\n        }\\n        if(count <= maxOperations)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) \\n    {\\n        int l = 1 , r = INT_MAX;\\n        int ans;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if(fun(maxOperations, nums,mid) == true)\\n            {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// tc o(n * log(INT_MAX))\\n// sc o(1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066075,
                "title": "2-line-python-solution-with-bisect-left",
                "content": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        ok = lambda x: sum([(num - 1) // x for num in nums]) <= maxOperations\\n        return bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda s, i: ok(i)})(), 1, 1, max(nums))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        ok = lambda x: sum([(num - 1) // x for num in nums]) <= maxOperations\\n        return bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda s, i: ok(i)})(), 1, 1, max(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065530,
                "title": "can-it-be-solved-with-priority-queue",
                "content": "I tried to solve this problem with priority queue, but stuck with the wrong answers in the middle (26/56 something like that).\\nI see that some people also tried to solve it using pq. Does anybone succeed with solving it using pq? I saw binary search solution, but I didn\\'t think at all applying BS :|",
                "solutionTags": [],
                "code": "I tried to solve this problem with priority queue, but stuck with the wrong answers in the middle (26/56 something like that).\\nI see that some people also tried to solve it using pq. Does anybone succeed with solving it using pq? I saw binary search solution, but I didn\\'t think at all applying BS :|",
                "codeTag": "Unknown"
            },
            {
                "id": 1065072,
                "title": "ruby-javascript-binary-search",
                "content": "Ruby\\n```\\ndef minimum_size(nums, max_operations)\\n  i = 1\\n  j = nums.max\\n  while i <= j\\n    penalty_count = 0\\n    penalty_mid = (j-i)/2 + i\\n\\n    nums.each { |n| penalty_count += (n-1)/penalty_mid }\\n\\n    if penalty_count <= max_operations\\n      j = penalty_mid - 1\\n    else\\n      i = penalty_mid + 1\\n    end\\n  end\\n  i\\nend\\n```\\n\\nJavascript\\n```\\nvar minimumSize = function(nums, maxOperations) {\\n  let i = 1\\n  let j = Math.max(...nums)\\n  \\n  while (i <= j) {\\n    let mid = Math.floor((j-i)/2 + i)\\n    let count = 0\\n    nums.forEach(n => count += Math.floor((n-1)/mid))\\n    \\n    if (count <= maxOperations) {\\n      j = mid - 1\\n    } else {\\n      i = mid + 1\\n    }\\n  }\\n  return i\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef minimum_size(nums, max_operations)\\n  i = 1\\n  j = nums.max\\n  while i <= j\\n    penalty_count = 0\\n    penalty_mid = (j-i)/2 + i\\n\\n    nums.each { |n| penalty_count += (n-1)/penalty_mid }\\n\\n    if penalty_count <= max_operations\\n      j = penalty_mid - 1\\n    else\\n      i = penalty_mid + 1\\n    end\\n  end\\n  i\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1064701,
                "title": "javascript-solution-binary-search",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} maxOperations\\n * @return {number}\\n */\\nvar minimumSize = function(nums, maxOperations) {\\n    \\n    function helper(target, nums){\\n        if(target===0){\\n            return maxOperations+1\\n        }\\n        let counter = 0;\\n        for(let num of nums){\\n            if(num>target){\\n                counter+=Math.floor((num-1)/target);\\n            }\\n        }\\n        return counter;\\n    }\\n    \\n    let length = nums.length;\\n    let sum = 0;\\n    let max = 0;\\n    for(let i =0;i<nums.length;i++){\\n        sum+=nums[i];\\n        if(nums[i]>max) max = nums[i];\\n    }\\n    let left = Math.floor(sum/(length+maxOperations));\\n    let right = max;\\n    \\n    while(left<right){\\n        let mid = Math.floor((left+right)/2);\\n        let c = helper(mid, nums);\\n        if(c<=maxOperations){\\n            right=mid;\\n        }\\n        else if(c>maxOperations){\\n            left = mid+1;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} maxOperations\\n * @return {number}\\n */\\nvar minimumSize = function(nums, maxOperations) {\\n    \\n    function helper(target, nums){\\n        if(target===0){\\n            return maxOperations+1\\n        }\\n        let counter = 0;\\n        for(let num of nums){\\n            if(num>target){\\n                counter+=Math.floor((num-1)/target);\\n            }\\n        }\\n        return counter;\\n    }\\n    \\n    let length = nums.length;\\n    let sum = 0;\\n    let max = 0;\\n    for(let i =0;i<nums.length;i++){\\n        sum+=nums[i];\\n        if(nums[i]>max) max = nums[i];\\n    }\\n    let left = Math.floor(sum/(length+maxOperations));\\n    let right = max;\\n    \\n    while(left<right){\\n        let mid = Math.floor((left+right)/2);\\n        let c = helper(mid, nums);\\n        if(c<=maxOperations){\\n            right=mid;\\n        }\\n        else if(c>maxOperations){\\n            left = mid+1;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1064652,
                "title": "python-can-someone-help-me-understand-why-this-wouldn-t-work",
                "content": "Can someone help me understand why this wouldn\\'t work? Basically find the current max Element after x operations and add one more operations to it.\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        if maxOperations == 0:\\n            return max(nums)\\n        mp = {}\\n        lst = []\\n        for num in nums:\\n            mp[num] = 1\\n            lst.append((num, num))\\n        \\n        while maxOperations > 0:\\n            temp = max(lst)\\n            mp[temp[1]]+=1\\n            lst.remove(temp)\\n            lst.append((ceil(temp[1]/mp[temp[1]]),temp[1]))\\n            maxOperations-=1\\n            \\n        return max(lst)[0]",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        if maxOperations == 0:\\n            return max(nums)\\n        mp = {}",
                "codeTag": "Java"
            },
            {
                "id": 1064576,
                "title": "java-binary-search",
                "content": "This is a binary search for the answer problem. The binary search is not hard, but how we verify it is more difficult. See my code below for how I verfy it. \\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1;\\n        int high = 1000000000;\\n        while (low < high){\\n            int mid = (low+high)/2;\\n            if (check(mid, nums, maxOperations)){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n    public static boolean check(int max, int[] nums, int op){\\n        int n = nums.length;\\n        int ans = 0;\\n        for (int i=0; i<n; i++){\\n            int count = -1;\\n            int curr = nums[i];\\n            count += curr/max;\\n            if (curr % max != 0){\\n                count++;\\n            }\\n            ans += count;\\n        }\\n        return ans <= op;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1;\\n        int high = 1000000000;\\n        while (low < high){\\n            int mid = (low+high)/2;\\n            if (check(mid, nums, maxOperations)){\\n                high = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1064516,
                "title": "java-binary-search",
                "content": "```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int en = 1;\\n        for(int i: nums){\\n            en = Math.max(en, i);\\n        }\\n        int st = 1;\\n        while(st < en){\\n            int mid = st + (en-st)/2;\\n            int sum = 0;\\n            for(int i:nums){\\n                sum += (i-1)/mid;        \\n            }\\n            if(sum > maxOperations){\\n                st = mid+1;\\n            }else{\\n                en = mid;\\n            }\\n        }\\n        return en;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int en = 1;\\n        for(int i: nums){\\n            en = Math.max(en, i);\\n        }\\n        int st = 1;\\n        while(st < en){\\n            int mid = st + (en-st)/2;\\n            int sum = 0;\\n            for(int i:nums){\\n                sum += (i-1)/mid;        \\n            }\\n            if(sum > maxOperations){\\n                st = mid+1;\\n            }else{\\n                en = mid;\\n            }\\n        }\\n        return en;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1064501,
                "title": "java-easy-o-nlogn-soln-using-binary-search",
                "content": "\\n```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int max=0,min=Integer.MAX_VALUE;    \\n        for(int val:nums){\\n            max=Math.max(max,val);  min=Math.min(min,val);\\n        }\\n        \\n        if(maxOperations==0){return max;}\\n        \\n        //bs\\n        int ans=0;\\n        int lo=1,hi=max;  //define Range\\n        // int ans=0;\\n        while(lo<=hi){\\n            \\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(bins(mid,maxOperations,nums)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean bins(int mid,int mo,int[] nums){\\n        int ct=0;\\n        for(int i=0;i<nums.length;i++){\\n            ct+=((Math.ceil((nums[i]*1.0)/mid))-1);\\n        }\\n        \\n        return ct<=mo;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\npublic int minimumSize(int[] nums, int maxOperations) {\\n        int max=0,min=Integer.MAX_VALUE;    \\n        for(int val:nums){\\n            max=Math.max(max,val);  min=Math.min(min,val);\\n        }\\n        \\n        if(maxOperations==0){return max;}\\n        \\n        //bs\\n        int ans=0;\\n        int lo=1,hi=max;  //define Range\\n        // int ans=0;\\n        while(lo<=hi){\\n            \\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(bins(mid,maxOperations,nums)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean bins(int mid,int mo,int[] nums){\\n        int ct=0;\\n        for(int i=0;i<nums.length;i++){\\n            ct+=((Math.ceil((nums[i]*1.0)/mid))-1);\\n        }\\n        \\n        return ct<=mo;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4059405,
                "title": "binary-search-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations)\\n    {\\n        int low=1;\\n        int high=1000000000;\\n        \\n        while(low<high)\\n        {\\n            int count=0;\\n            int mid=low+(high-low)/2;\\n            \\n            for(int i:nums)\\n            {\\n                count+=(i-1)/mid;\\n                \\n            }\\n            \\n            if(count<=maxOperations)\\n            {\\n                high=mid;\\n            }\\n            \\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations)\\n    {\\n        int low=1;\\n        int high=1000000000;\\n        \\n        while(low<high)\\n        {\\n            int count=0;\\n            int mid=low+(high-low)/2;\\n            \\n            for(int i:nums)\\n            {\\n                count+=(i-1)/mid;\\n                \\n            }\\n            \\n            if(count<=maxOperations)\\n            {\\n                high=mid;\\n            }\\n            \\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028614,
                "title": "cpp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int cal(vector<int> &nums,int x){\\n        int ct=0;\\n        for(auto it:nums){\\n            ct+=(it/x)+(it%x?1:0)-1;\\n        }\\n        return ct;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int lo =1, hi=*max_element(begin(nums),end(nums));\\n        \\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(cal(nums,mid)<=maxOperations) hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(vector<int> &nums,int x){\\n        int ct=0;\\n        for(auto it:nums){\\n            ct+=(it/x)+(it%x?1:0)-1;\\n        }\\n        return ct;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int lo =1, hi=*max_element(begin(nums),end(nums));\\n        \\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(cal(nums,mid)<=maxOperations) hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013117,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool poss ( vector<int>& nums, int o, int mid ) {\\n\\n        int op = 0;\\n\\n        for ( int i=0; i<nums.size(); i++ ) {\\n\\n            if ( nums[i]%mid == 0 ) {\\n                op += nums[i]/mid - 1;\\n            }\\n\\n            else {\\n                op += nums[i]/mid;\\n            }\\n        }\\n\\n        return op<=o;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int o) {\\n\\n        int ans = -1;\\n        \\n        int s = 1;\\n        int e = 0;\\n\\n        for ( auto i : nums ) {\\n            e = max(e,i);\\n        }\\n\\n        int mid = s + (e-s)/2;\\n\\n        while ( s<=e ) {\\n\\n            if ( poss(nums,o,mid) ) {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n\\n            else {\\n                s = mid+1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool poss ( vector<int>& nums, int o, int mid ) {\\n\\n        int op = 0;\\n\\n        for ( int i=0; i<nums.size(); i++ ) {\\n\\n            if ( nums[i]%mid == 0 ) {\\n                op += nums[i]/mid - 1;\\n            }\\n\\n            else {\\n                op += nums[i]/mid;\\n            }\\n        }\\n\\n        return op<=o;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int o) {\\n\\n        int ans = -1;\\n        \\n        int s = 1;\\n        int e = 0;\\n\\n        for ( auto i : nums ) {\\n            e = max(e,i);\\n        }\\n\\n        int mid = s + (e-s)/2;\\n\\n        while ( s<=e ) {\\n\\n            if ( poss(nums,o,mid) ) {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n\\n            else {\\n                s = mid+1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004588,
                "title": "c-python-binary-search-solution-with-explanation",
                "content": "We can use binary search to enumerate size of bag,\\nif number of additional bags > maxOperations, we can enlarge size of bag,\\nif number of additional bags <= maxOperations, we can shink size of bag.\\nand return min size of bag and number of additional bags <= maxOperations.\\nsearch left bound of size of bag.\\n\\ntc is O(nlogn), sc is O(1).\\n\\n### python\\n\\n```python\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        left = ceil(sum(nums) / (len(nums) + maxOperations))\\n        right = max(nums)\\n        def check(x):\\n            cnt = 0\\n            for y in nums:\\n                c = y // x if y % x else y // x - 1\\n                cnt += c\\n                if cnt > maxOperations: return False\\n            return True\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if check(mid): right = mid - 1\\n            else: left = mid + 1\\n        return left\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long left = ceil(accumulate(nums.begin(), nums.end(), 0.) / (nums.size() + maxOperations)), \\n        right = *max_element(nums.begin(), nums.end()), mid;\\n        auto check = [&] (long long x) {\\n            int cnt = 0;\\n            for (auto &y: nums) {\\n                long long c = y / x - (y % x == 0);\\n                cnt += c;\\n                if (cnt > maxOperations) return false;\\n            }\\n            return true;\\n        };\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (check(mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        left = ceil(sum(nums) / (len(nums) + maxOperations))\\n        right = max(nums)\\n        def check(x):\\n            cnt = 0\\n            for y in nums:\\n                c = y // x if y % x else y // x - 1\\n                cnt += c\\n                if cnt > maxOperations: return False\\n            return True\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if check(mid): right = mid - 1\\n            else: left = mid + 1\\n        return left\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        long long left = ceil(accumulate(nums.begin(), nums.end(), 0.) / (nums.size() + maxOperations)), \\n        right = *max_element(nums.begin(), nums.end()), mid;\\n        auto check = [&] (long long x) {\\n            int cnt = 0;\\n            for (auto &y: nums) {\\n                long long c = y / x - (y % x == 0);\\n                cnt += c;\\n                if (cnt > maxOperations) return false;\\n            }\\n            return true;\\n        };\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (check(mid)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991636,
                "title": "intuitive-c-binary-search-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int m,vector<int>&a, int k){\\n        int x=0;\\n        for(auto i:a){\\n            if(i%m==0)x+=(i/m-1);\\n            else x+=i/m;\\n        }\\n        return x<=k;\\n    }\\n\\n    int minimumSize(vector<int>& a, int k) {\\n        int n=a.size(),ans=0;\\n        int l=1,r=*max_element(a.begin(),a.end());\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(f(m,a,k)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int m,vector<int>&a, int k){\\n        int x=0;\\n        for(auto i:a){\\n            if(i%m==0)x+=(i/m-1);\\n            else x+=i/m;\\n        }\\n        return x<=k;\\n    }\\n\\n    int minimumSize(vector<int>& a, int k) {\\n        int n=a.size(),ans=0;\\n        int l=1,r=*max_element(a.begin(),a.end());\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(f(m,a,k)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978810,
                "title": "binary-search-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(vector<int>& nums,int maxOperations,int val){\\n        int a=0;\\n        for(int i=0;i<nums.size();i++){\\n          a +=(nums[i]-1)/val;\\n          if(a>maxOperations) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int start=1;\\n        int end =1e9;\\n        int ans=1e9;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(solve(nums,maxOperations,mid)){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<int>& nums,int maxOperations,int val){\\n        int a=0;\\n        for(int i=0;i<nums.size();i++){\\n          a +=(nums[i]-1)/val;\\n          if(a>maxOperations) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int start=1;\\n        int end =1e9;\\n        int ans=1e9;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(solve(nums,maxOperations,mid)){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963079,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    bool check(vector<int>& nums, int maxOperations, int mid) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxOperations -= ceil(nums[i] * 1.0 / mid) - 1;\\n        }\\n        return maxOperations >= 0;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low = 1, high = *max_element(nums.begin(), nums.end());\\n        int ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, maxOperations, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool check(vector<int>& nums, int maxOperations, int mid) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxOperations -= ceil(nums[i] * 1.0 / mid) - 1;\\n        }\\n        return maxOperations >= 0;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low = 1, high = *max_element(nums.begin(), nums.end());\\n        int ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, maxOperations, mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949927,
                "title": "java-beat-100-super-easy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOP) {\\n     int max=Integer.MIN_VALUE;\\n        \\n\\t    for(int x:nums) if(max<x) max=x;\\n\\t        \\n\\t\\tint penaltyStart=1;\\n\\t\\tint penaltyEnd=max-1; //minimum operations are 1 so {1,(max-1) } division can happen\\n\\n\\twhile(penaltyStart<=penaltyEnd) {\\n\\t\\t\\t  int mid=penaltyStart+(penaltyEnd-penaltyStart)/2;\\n\\t\\t\\t\\tint noOfOperation=0;\\n\\n\\t\\tfor(int elm:nums) {\\n\\t\\t\\t noOfOperation+=(elm-1)/mid; //used to calculate the ceil that number which is greater than the element\\n\\t\\t}\\n\\n\\t\\t\\tif(maxOP>=noOfOperation) penaltyEnd=mid-1;\\n\\t\\t\\telse penaltyStart=mid+1;\\n\\t\\t}\\n\\t\\treturn penaltyStart;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOP) {\\n     int max=Integer.MIN_VALUE;\\n        \\n\\t    for(int x:nums) if(max<x) max=x;\\n\\t        \\n\\t\\tint penaltyStart=1;\\n\\t\\tint penaltyEnd=max-1; //minimum operations are 1 so {1,(max-1) } division can happen\\n\\n\\twhile(penaltyStart<=penaltyEnd) {\\n\\t\\t\\t  int mid=penaltyStart+(penaltyEnd-penaltyStart)/2;\\n\\t\\t\\t\\tint noOfOperation=0;\\n\\n\\t\\tfor(int elm:nums) {\\n\\t\\t\\t noOfOperation+=(elm-1)/mid; //used to calculate the ceil that number which is greater than the element\\n\\t\\t}\\n\\n\\t\\t\\tif(maxOP>=noOfOperation) penaltyEnd=mid-1;\\n\\t\\t\\telse penaltyStart=mid+1;\\n\\t\\t}\\n\\t\\treturn penaltyStart;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945661,
                "title": "binary-search-c-monotonic-function-easy",
                "content": "\\t1-check function is important.\\n\\t---------lets start think in hindi ........\\n\\t2- think ( agar c hamara  maxOperation se bada aata hai to hame wo mid lena hi nahi it means we dont need to search on the left side , so we can use this ( l=mid+1);\\n\\t\\n\\t3- think like - if c hamare maxOperation se chota aata hai to means that there is still some soultion exist so we need to search on the right side .means h=mid-1;\\n\\tsimple------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid , vector<int>n , int t){\\n        int  c=0;\\n        for(int i=0 ;i<n.size();i++){\\n            if(n[i]>mid){\\n                if(n[i]%mid==0){\\n                    c+=(n[i]/mid)-1;\\n                }else{\\n                    c+=n[i]/mid;\\n                }\\n            }\\n        }\\n        if(c<=t)return 1;\\n        else return 0;\\n    }\\n    \\n    \\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n    int l=1 ;int ans=0,h=0;\\n       for(auto it:nums){\\n           h=max(h,it);\\n       }\\n        while(l<=h){\\n            int mid= l+(h-l)/2;\\n            if(check(mid , nums , maxOperations)==1){\\n                ans = mid ;\\n                h=mid-1;\\n                \\n            }else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid , vector<int>n , int t){\\n        int  c=0;\\n        for(int i=0 ;i<n.size();i++){\\n            if(n[i]>mid){\\n                if(n[i]%mid==0){\\n                    c+=(n[i]/mid)-1;\\n                }else{\\n                    c+=n[i]/mid;\\n                }\\n            }\\n        }\\n        if(c<=t)return 1;\\n        else return 0;\\n    }\\n    \\n    \\n    \\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n    int l=1 ;int ans=0,h=0;\\n       for(auto it:nums){\\n           h=max(h,it);\\n       }\\n        while(l<=h){\\n            int mid= l+(h-l)/2;\\n            if(check(mid , nums , maxOperations)==1){\\n                ans = mid ;\\n                h=mid-1;\\n                \\n            }else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921053,
                "title": "c-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n.log(n))$$\\n- Space complexity:\\n$$O(n.log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low =1, high = *max_element(nums.begin(),nums.end());\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            long long count =0;\\n            for(auto it : nums){\\n                count += it/mid;\\n                if(it%mid==0){\\n                    count--;\\n                }\\n            }\\n            if(count > maxOperations){\\n                low = mid+1;                \\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low =1, high = *max_element(nums.begin(),nums.end());\\n\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            long long count =0;\\n            for(auto it : nums){\\n                count += it/mid;\\n                if(it%mid==0){\\n                    count--;\\n                }\\n            }\\n            if(count > maxOperations){\\n                low = mid+1;                \\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899493,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(int penalty, vector<int> &nums, int maxOp)\\n    {\\n        int temp = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp += (nums[i]-1)/penalty;\\n        }\\n        return temp <=maxOp;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l = 1;\\n        int r = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            r = max(r, nums[i]);\\n        }\\n        while(l <= r)\\n        {\\n            int mid = (l+r) >> 1;\\n            if(!isValid(mid,   nums, maxOperations))\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(int penalty, vector<int> &nums, int maxOp)\\n    {\\n        int temp = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp += (nums[i]-1)/penalty;\\n        }\\n        return temp <=maxOp;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l = 1;\\n        int r = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            r = max(r, nums[i]);\\n        }\\n        while(l <= r)\\n        {\\n            int mid = (l+r) >> 1;\\n            if(!isValid(mid,   nums, maxOperations))\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893418,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (l, m-1) if sum(ceil(num / m)-1 for num in nums) <= maxOperations else (m+1, r)\\n        return l\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (l, m-1) if sum(ceil(num / m)-1 for num in nums) <= maxOperations else (m+1, r)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892894,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{k})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int penalty, int maxOperations) {\\n        for (int num : nums) maxOperations -= (num + penalty - 1) / penalty - 1;\\n        return maxOperations >= 0;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int lo = 1, hi = 0, mid, res;\\n        for (int num : nums) hi = max(hi, num);\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (isValid(nums, mid, maxOperations)) {\\n                res = mid;\\n                hi = mid - 1;\\n            } else lo = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& nums, int penalty, int maxOperations) {\\n        for (int num : nums) maxOperations -= (num + penalty - 1) / penalty - 1;\\n        return maxOperations >= 0;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int lo = 1, hi = 0, mid, res;\\n        for (int num : nums) hi = max(hi, num);\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (isValid(nums, mid, maxOperations)) {\\n                res = mid;\\n                hi = mid - 1;\\n            } else lo = mid + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887529,
                "title": "java-solution-easy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed simple binary search technique to find the Optimal answer.\\n\\n\\n# Complexity\\n- Time complexity: O(N * log(max(nums)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n      int low =1;\\n      int high = findMax(nums);\\n      while(low <= high){\\n          int mid = low + (high-low)/2;\\n\\n          if(isValid(nums,maxOperations,mid)){\\n              high = mid -1;\\n          }\\n          else {\\n              low =mid +1;\\n          }\\n      }  \\n      return low;\\n    }\\n\\n    public int findMax(int []nums){\\n        int max =0;\\n        for(int i:nums){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n    public boolean isValid(int []nums, int maxOperations,int mid){\\n        int count =0;\\n        for(int n: nums){\\n            if(n%mid ==0){\\n                count += n/mid -1;\\n            }\\n            else {\\n                count += n/mid;\\n            }\\n        }\\n        return count <=maxOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n      int low =1;\\n      int high = findMax(nums);\\n      while(low <= high){\\n          int mid = low + (high-low)/2;\\n\\n          if(isValid(nums,maxOperations,mid)){\\n              high = mid -1;\\n          }\\n          else {\\n              low =mid +1;\\n          }\\n      }  \\n      return low;\\n    }\\n\\n    public int findMax(int []nums){\\n        int max =0;\\n        for(int i:nums){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n    public boolean isValid(int []nums, int maxOperations,int mid){\\n        int count =0;\\n        for(int n: nums){\\n            if(n%mid ==0){\\n                count += n/mid -1;\\n            }\\n            else {\\n                count += n/mid;\\n            }\\n        }\\n        return count <=maxOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880650,
                "title": "simple-solution-for-beginners",
                "content": "# Intuition\\nA simple binary search question with a much elaborated checker function though the function calling increase the time prefer it becouse it simplifies the code to a very extent \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust a simple binary search on the penality of the result which is to be approched so that the answer will satify the given penality \\nOnce we found the correct peanality then the approch will be more delightful\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O( N log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checker(int penality,int maxOperations,vector<int>&nums)\\n    {\\n        // you dont nessesarily have to perform the maxOperations\\n        for(int i =0;i<nums.size();i++)\\n        {\\n                //cout<<nums[i]<<endl;\\n            if(nums[i]%penality==0)\\n            {\\n                maxOperations-=nums[i]/penality-1;\\n            }\\n            else \\n                maxOperations-=nums[i]/penality;\\n        }\\n        if(maxOperations>=0)return true;\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1,mid,high=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,maxOperations,nums))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else \\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int penality,int maxOperations,vector<int>&nums)\\n    {\\n        // you dont nessesarily have to perform the maxOperations\\n        for(int i =0;i<nums.size();i++)\\n        {\\n                //cout<<nums[i]<<endl;\\n            if(nums[i]%penality==0)\\n            {\\n                maxOperations-=nums[i]/penality-1;\\n            }\\n            else \\n                maxOperations-=nums[i]/penality;\\n        }\\n        if(maxOperations>=0)return true;\\n        return false;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1,mid,high=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,maxOperations,nums))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else \\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3859679,
                "title": "very-similar-to-koko-eating-banana",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int check(vector<int>nums,int mid)\\n    {\\n        int myop=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                int val=nums[i]/mid+(nums[i]%mid==0 ? +0: +1);\\n                myop+=val-1;\\n            }\\n        }\\n        return myop;\\n    }\\n    int minimumSize(vector<int>& nums, int maxo) {\\n        //minimize the max size of bag\\n        //assume penalty\\n        //max op nikaalo us penalyty pe\\n        //sawaal yhi h ki maxop kse niklega\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(check(nums,mid)<=maxo)\\n            {\\n                ans=min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int check(vector<int>nums,int mid)\\n    {\\n        int myop=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                int val=nums[i]/mid+(nums[i]%mid==0 ? +0: +1);\\n                myop+=val-1;\\n            }\\n        }\\n        return myop;\\n    }\\n    int minimumSize(vector<int>& nums, int maxo) {\\n        //minimize the max size of bag\\n        //assume penalty\\n        //max op nikaalo us penalyty pe\\n        //sawaal yhi h ki maxop kse niklega\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(check(nums,mid)<=maxo)\\n            {\\n                ans=min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848543,
                "title": "binary-search-67-ms",
                "content": "# Complexity\\n- Time complexity:\\nO (n * log(n)) + O(log(10 ^ 9 - 1) * maxOperations)\\n~= O(nlog(n)) + O(maxOperations)\\n\\nwhere n is size of the nums array\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumSize(int[] nums, int maxOperations) {\\n    Arrays.sort(nums);\\n\\n    int left = 1, right = nums[nums.length - 1];\\n    int minPenalty = right;\\n    while (left <= right) {\\n      int mid = left + (right - left) / 2;\\n      int cntOp = maxOperations;\\n      for (int i = 0; i < nums.length; i++) {\\n        int opc = nums[i] > mid ? (nums[i] / mid - (nums[i] % mid == 0 ? 1 : 0)) : 0;\\n        cntOp -= opc;\\n\\n        if (cntOp < 0) {\\n          break;\\n        }\\n      }\\n\\n      if (cntOp < 0) {\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      minPenalty = mid;\\n      right = mid - 1;\\n    }\\n\\n    return minPenalty;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumSize(int[] nums, int maxOperations) {\\n    Arrays.sort(nums);\\n\\n    int left = 1, right = nums[nums.length - 1];\\n    int minPenalty = right;\\n    while (left <= right) {\\n      int mid = left + (right - left) / 2;\\n      int cntOp = maxOperations;\\n      for (int i = 0; i < nums.length; i++) {\\n        int opc = nums[i] > mid ? (nums[i] / mid - (nums[i] % mid == 0 ? 1 : 0)) : 0;\\n        cntOp -= opc;\\n\\n        if (cntOp < 0) {\\n          break;\\n        }\\n      }\\n\\n      if (cntOp < 0) {\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      minPenalty = mid;\\n      right = mid - 1;\\n    }\\n\\n    return minPenalty;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829696,
                "title": "minimum-limit-of-balls-in-a-bag-binary-search-beats-100-tc-o-nlogn",
                "content": "# Intuition\\n\\n\\n# Approach\\nbinary search over solution\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean possible(int [] arr,int m, int mid){\\n\\t\\tint operation=0;\\n\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tif(arr[i]>mid){\\n\\t\\t\\t\\toperation+=(arr[i]-1)/mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(operation<=m){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    public int minimumSize(int[] arr, int m) {\\n        \\n        int lo=1;\\n\\t\\tint hi=0;\\n\\t\\tfor(int ele: arr){\\n\\t\\t\\thi=Math.max(hi, ele);\\n\\t\\t}\\n\\t\\tint minpenalty=1;\\n\\t\\twhile(lo<=hi){\\n\\t\\t\\tint mid=(hi+lo)/2;\\n\\t\\t\\tif(possible(arr,m,mid)){\\n\\t\\t\\t\\tminpenalty=mid;\\n\\t\\t\\t\\thi=mid-1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tlo=mid+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minpenalty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean possible(int [] arr,int m, int mid){\\n\\t\\tint operation=0;\\n\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tif(arr[i]>mid){\\n\\t\\t\\t\\toperation+=(arr[i]-1)/mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(operation<=m){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    public int minimumSize(int[] arr, int m) {\\n        \\n        int lo=1;\\n\\t\\tint hi=0;\\n\\t\\tfor(int ele: arr){\\n\\t\\t\\thi=Math.max(hi, ele);\\n\\t\\t}\\n\\t\\tint minpenalty=1;\\n\\t\\twhile(lo<=hi){\\n\\t\\t\\tint mid=(hi+lo)/2;\\n\\t\\t\\tif(possible(arr,m,mid)){\\n\\t\\t\\t\\tminpenalty=mid;\\n\\t\\t\\t\\thi=mid-1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tlo=mid+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minpenalty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822071,
                "title": "striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& nums, int maxOperations, int mid)\\n    {\\n        int total = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            total += (nums[i]-1)/mid;\\n        }\\n\\n        return total<=maxOperations;   \\n    }\\n\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int low = 1;\\n        int high = *max_element(nums.begin(), nums.end());\\n\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n\\n            if(f(nums, maxOperations, mid))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& nums, int maxOperations, int mid)\\n    {\\n        int total = 0;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            total += (nums[i]-1)/mid;\\n        }\\n\\n        return total<=maxOperations;   \\n    }\\n\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int low = 1;\\n        int high = *max_element(nums.begin(), nums.end());\\n\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n\\n            if(f(nums, maxOperations, mid))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821211,
                "title": "binary-search-t-o-nlog-max-nums-s-o-1",
                "content": "# Approach\\nBinary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlog(max(nums)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check(int max,int[] nums, int opCount){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                if(opCount==0)\\n                return false;\\n                int operRed=(nums[i]%max == 0? (nums[i]/max) -1:nums[i]/max );\\n                if(operRed>opCount)\\n                return false;\\n                opCount -= operRed;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        int left=1;\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        max= Math.max(max,nums[i]);\\n        int right= max;\\n        while(left<right){\\n\\n            int mid= (left+ right)/2;\\n            if(!check(mid, nums, maxOperations))\\n            {\\n                left=mid+1;\\n            }else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check(int max,int[] nums, int opCount){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                if(opCount==0)\\n                return false;\\n                int operRed=(nums[i]%max == 0? (nums[i]/max) -1:nums[i]/max );\\n                if(operRed>opCount)\\n                return false;\\n                opCount -= operRed;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        int left=1;\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        max= Math.max(max,nums[i]);\\n        int right= max;\\n        while(left<right){\\n\\n            int mid= (left+ right)/2;\\n            if(!check(mid, nums, maxOperations))\\n            {\\n                left=mid+1;\\n            }else\\n            {\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795498,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool f(int penalty,vector<int>& nums,int k){\\n        int cnt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>penalty){\\n                cnt+= (nums[i]-1)/(penalty);\\n            }\\n        }\\n        return cnt<=k;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left = 1; int right = *max_element(nums.begin(),nums.end());\\n        while(left<=right){\\n            int mid = left + (right - left)/2;\\n            if(f(mid,nums,maxOperations)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool f(int penalty,vector<int>& nums,int k){\\n        int cnt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>penalty){\\n                cnt+= (nums[i]-1)/(penalty);\\n            }\\n        }\\n        return cnt<=k;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left = 1; int right = *max_element(nums.begin(),nums.end());\\n        while(left<=right){\\n            int mid = left + (right - left)/2;\\n            if(f(mid,nums,maxOperations)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772855,
                "title": "easy-c-solution-using-binary-search",
                "content": "# Intuition\\nAt first we need to define our sample space which will be\\n[1,maximum element in the nums] and our answer will belong in this range (since it can\\'t be greater than the maximum element in the nums) and then we will proceed using binary search algo to check whether a particular middle element (found using mid=(end-start)/2 +start) can be the answer ,if yes store it and check in the left sample space otherwise check in the right sample space; \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(vector<int> &nums,int k,int mid){\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(nums[i]>mid){\\n\\n                int element=nums[i];\\n                int div=element/mid;\\n                if(element%mid==0){\\n                    div--;\\n                }\\n                k-=div;\\n                if(k<0) return false;\\n\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int start=1;\\n\\n        int end=-1;\\n        for(auto it:nums){\\n            end=max(end,it);\\n        }\\n        int mid=(end-start)/2 +start;\\n        int ans=-1;\\n        while(start<=end){\\n\\n            if(is_possible(nums,maxOperations,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n            mid=(end-start)/2 +start;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  9-> 4+5\\n//  \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(vector<int> &nums,int k,int mid){\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(nums[i]>mid){\\n\\n                int element=nums[i];\\n                int div=element/mid;\\n                if(element%mid==0){\\n                    div--;\\n                }\\n                k-=div;\\n                if(k<0) return false;\\n\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        \\n        int start=1;\\n\\n        int end=-1;\\n        for(auto it:nums){\\n            end=max(end,it);\\n        }\\n        int mid=(end-start)/2 +start;\\n        int ans=-1;\\n        while(start<=end){\\n\\n            if(is_possible(nums,maxOperations,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n            mid=(end-start)/2 +start;\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  9-> 4+5\\n//  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757094,
                "title": "why-binary-search-works-intuition",
                "content": "# Code\\n```\\n// Note: Doing binary search as we know ans lies in the range\\nclass Solution {\\n\\n    // TC: O(nlogk)\\n    // SC: O(1)\\n    // n = nums.length\\n    // k = max_of_nums\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int l = 1;\\n        int r = 0;\\n        for(int n:nums){\\n            if(n>r){\\n                r = n;\\n            }\\n        }\\n        int mid = 0;\\n        int ans = r;\\n\\n        // TC: O(log(max of arr))\\n        while(l<=r){\\n            mid = (l+r)/2 ; \\n            // TC: O(nums.length)\\n            if(isFeasible(nums,maxOperations,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isFeasible(int[] nums, int maxOperations,int currPenalty){\\n        int currOpr = 0;\\n        for(int n:nums){\\n            currOpr+=n/currPenalty;\\n            if(n%currPenalty==0){\\n                currOpr--;\\n            }\\n        }\\n        return currOpr<=maxOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// Note: Doing binary search as we know ans lies in the range\\nclass Solution {\\n\\n    // TC: O(nlogk)\\n    // SC: O(1)\\n    // n = nums.length\\n    // k = max_of_nums\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int l = 1;\\n        int r = 0;\\n        for(int n:nums){\\n            if(n>r){\\n                r = n;\\n            }\\n        }\\n        int mid = 0;\\n        int ans = r;\\n\\n        // TC: O(log(max of arr))\\n        while(l<=r){\\n            mid = (l+r)/2 ; \\n            // TC: O(nums.length)\\n            if(isFeasible(nums,maxOperations,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isFeasible(int[] nums, int maxOperations,int currPenalty){\\n        int currOpr = 0;\\n        for(int n:nums){\\n            currOpr+=n/currPenalty;\\n            if(n%currPenalty==0){\\n                currOpr--;\\n            }\\n        }\\n        return currOpr<=maxOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745085,
                "title": "binary-search-o-nlogn",
                "content": "# Intuition\\nfirst we take max penalty and as mentioned in question try to minimize it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& nums, int o,int mid){\\n    for(int i=0;i<nums.size();i++){\\n        o-=nums[i]/mid;\\n        if(nums[i]%mid==0)o++;\\n    }\\n    return o>=0;\\n}\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int s=1,e,ans=0;\\n        for(auto i:nums)e=max(i,e);\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(check(nums,maxOperations,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& nums, int o,int mid){\\n    for(int i=0;i<nums.size();i++){\\n        o-=nums[i]/mid;\\n        if(nums[i]%mid==0)o++;\\n    }\\n    return o>=0;\\n}\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int s=1,e,ans=0;\\n        for(auto i:nums)e=max(i,e);\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(check(nums,maxOperations,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722618,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] nums,int maxOperations,int mid){\\n        int count = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(mid <= nums[i]){\\n                if(nums[i]%mid == 0)\\n                    count += nums[i]/mid - 1;\\n                else\\n                    count += nums[i]/mid;\\n            }\\n        }\\n        return count <= maxOperations; \\n    }\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1;\\n        int high = nums[0];\\n        for(int i = 0;i < nums.length;i++)\\n            high = Math.max(high,nums[i]);\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(nums,maxOperations,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] nums,int maxOperations,int mid){\\n        int count = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(mid <= nums[i]){\\n                if(nums[i]%mid == 0)\\n                    count += nums[i]/mid - 1;\\n                else\\n                    count += nums[i]/mid;\\n            }\\n        }\\n        return count <= maxOperations; \\n    }\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int low = 1;\\n        int high = nums[0];\\n        for(int i = 0;i < nums.length;i++)\\n            high = Math.max(high,nums[i]);\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(isPossible(nums,maxOperations,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713259,
                "title": "self-explanatory-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&nums,int maxop,int maxlimit){\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>maxlimit){\\n                int req=nums[i]/mid;\\n                if(nums[i]%maxlimit==0)req--;\\n                maxop-=req;\\n            }\\n        }\\n        return maxop>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxop) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=1;\\n        int e=INT_MAX;\\n        int ans=0;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(nums,maxop,mid)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&nums,int maxop,int maxlimit){\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>maxlimit){\\n                int req=nums[i]/mid;\\n                if(nums[i]%maxlimit==0)req--;\\n                maxop-=req;\\n            }\\n        }\\n        return maxop>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxop) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int s=1;\\n        int e=INT_MAX;\\n        int ans=0;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(nums,maxop,mid)){\\n                e=mid-1;\\n                ans=mid;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703038,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$ O(nlogn) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool cando(int maxx,int maxops,vector<int>& nums){\\n        int n = nums.size();\\n        long long ops=0;\\n        for(int i=0;i<n;i++){\\n            ops+=(nums[i]/maxx);\\n            if(nums[i]%maxx==0) ops--;\\n        }\\n        return ops<=maxops;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left=1;\\n        int right=1000000000;\\n        int mid;\\n        int ans=1000000000;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(cando(mid,maxOperations,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool cando(int maxx,int maxops,vector<int>& nums){\\n        int n = nums.size();\\n        long long ops=0;\\n        for(int i=0;i<n;i++){\\n            ops+=(nums[i]/maxx);\\n            if(nums[i]%maxx==0) ops--;\\n        }\\n        return ops<=maxops;\\n    }\\n\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left=1;\\n        int right=1000000000;\\n        int mid;\\n        int ans=1000000000;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(cando(mid,maxOperations,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647715,
                "title": "java-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[] bags,int maxopt,int p){\\n\\t\\tint reqOpt=0;\\n\\t\\tfor(int bag:bags){\\n\\t\\t\\tif(bag%p==0){\\n\\t\\t\\t\\treqOpt+=bag/p-1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\treqOpt+=bag/p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn reqOpt<=maxopt;\\n\\t}\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int st=1;\\n        int end=0;\\n        for(int bag: nums){\\n            end=Math.max(end,bag);\\n        }\\n       int pans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(isPossible(nums,maxOperations,mid)==true){\\n                pans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return pans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[] bags,int maxopt,int p){\\n\\t\\tint reqOpt=0;\\n\\t\\tfor(int bag:bags){\\n\\t\\t\\tif(bag%p==0){\\n\\t\\t\\t\\treqOpt+=bag/p-1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\treqOpt+=bag/p;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn reqOpt<=maxopt;\\n\\t}\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int st=1;\\n        int end=0;\\n        for(int bag: nums){\\n            end=Math.max(end,bag);\\n        }\\n       int pans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(isPossible(nums,maxOperations,mid)==true){\\n                pans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return pans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646129,
                "title": "runtime-12ms-beats-96-well-commented-java-solution-tc-o-n-log-n-sc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:   O(N * Log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        // TC : O(N * Log N) && SC : O(1)\\n\\n        int high = 0;\\n\\n        // max number of ball would be the maximum balls in a certain bag\\n        for(int i : nums){\\n            high = Math.max(high,i);\\n        }\\n\\n        // lowest number of balls in a bag would be 1\\n        int low = 1;\\n        int ans = 0;\\n        while(low<=high){\\n\\n            int mid = high + (low-high)/2;\\n\\n            // checking is the mid can be maximum number of ball in a bag after the operations\\n            // if it is then the operations taken must be less than or equal to maxoperations\\n            if(isPossible(mid,maxOperations,nums)){\\n                ans = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    boolean isPossible(int mid, int maxOp, int[] nums){\\n\\n        int op = 0;\\n\\n        for(int val : nums){\\n\\n            op += (val-1)/mid;\\n\\n            if(op>maxOp) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n\\n        // TC : O(N * Log N) && SC : O(1)\\n\\n        int high = 0;\\n\\n        // max number of ball would be the maximum balls in a certain bag\\n        for(int i : nums){\\n            high = Math.max(high,i);\\n        }\\n\\n        // lowest number of balls in a bag would be 1\\n        int low = 1;\\n        int ans = 0;\\n        while(low<=high){\\n\\n            int mid = high + (low-high)/2;\\n\\n            // checking is the mid can be maximum number of ball in a bag after the operations\\n            // if it is then the operations taken must be less than or equal to maxoperations\\n            if(isPossible(mid,maxOperations,nums)){\\n                ans = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    boolean isPossible(int mid, int maxOp, int[] nums){\\n\\n        int op = 0;\\n\\n        for(int val : nums){\\n\\n            op += (val-1)/mid;\\n\\n            if(op>maxOp) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630718,
                "title": "binary-search-python3",
                "content": "# Intuition\\nWe binary serach the minimum value for the penalty. \\n# Approach\\nWe use a check function to determine if we can have maxBalls as the maximum number of balls after all the splits.\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        def check(maxBalls,maxOperations):\\n            nr = 0\\n            for balls in nums:\\n                if balls>maxBalls:\\n                    if balls % maxBalls == 0:\\n                        nr-=1\\n                    nr += balls//maxBalls  \\n\\n            return nr <= maxOperations\\n\\n\\n        right = max(nums)\\n        left = 1\\n        while left<=right:\\n            m = (left+right)//2\\n            if check(m, maxOperations):\\n                ans = m\\n                right = m-1\\n\\n            else:\\n                left = m+1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        def check(maxBalls,maxOperations):\\n            nr = 0\\n            for balls in nums:\\n                if balls>maxBalls:\\n                    if balls % maxBalls == 0:\\n                        nr-=1\\n                    nr += balls//maxBalls  \\n\\n            return nr <= maxOperations\\n\\n\\n        right = max(nums)\\n        left = 1\\n        while left<=right:\\n            m = (left+right)//2\\n            if check(m, maxOperations):\\n                ans = m\\n                right = m-1\\n\\n            else:\\n                left = m+1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598304,
                "title": "binary-search-explained-with-proper-variables",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOper) {\\n        int l = 1, r = *max_element(nums.begin(), nums.end());\\n        while(l <= r)\\n        {\\n            int maxBagSize = l + (r - l) / 2;\\n            int oper = 0;\\n            for(auto n: nums)\\n            {\\n                // no. of bags used to store maxBagSize no. of balls at max in each bag\\n                int bagsReq = ceil(double(n) / double(maxBagSize));\\n                \\n                // oper will be 1 less than the no. of bags req\\n                oper += bagsReq - 1;\\n            }\\n            \\n            if(oper > maxOper)\\n            {\\n                // current operations are more so increase the bag size to include more balls in each bag and decrease the no. of operations.\\n                l = maxBagSize + 1;\\n            }\\n            \\n            else \\n            {\\n                r = maxBagSize - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOper) {\\n        int l = 1, r = *max_element(nums.begin(), nums.end());\\n        while(l <= r)\\n        {\\n            int maxBagSize = l + (r - l) / 2;\\n            int oper = 0;\\n            for(auto n: nums)\\n            {\\n                // no. of bags used to store maxBagSize no. of balls at max in each bag\\n                int bagsReq = ceil(double(n) / double(maxBagSize));\\n                \\n                // oper will be 1 less than the no. of bags req\\n                oper += bagsReq - 1;\\n            }\\n            \\n            if(oper > maxOper)\\n            {\\n                // current operations are more so increase the bag size to include more balls in each bag and decrease the no. of operations.\\n                l = maxBagSize + 1;\\n            }\\n            \\n            else \\n            {\\n                r = maxBagSize - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597424,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First thought**:\\nInitially, I would consider calculating the average number of balls per bag, which would be the total number of balls divided by the number of bags. This average value can act as a reference point for distributing the balls.\\n\\nThen, I would analyze the bags that have more balls than the average and think about how to redistribute them to minimize the penalty. One option would be to split these bags into two smaller bags with an equal or close-to-equal number of balls. By doing so, we can decrease \\nthe maximum number of balls in any bag.\\n\\nHowever, simply dividing the bags evenly may not be the optimal solution, as we are limited by the maximum number of operations we can perform. So, I would also consider prioritizing the bags with the most balls and dividing them until we reach a point where the penalty is minimized or until we exhaust the maximum number of operations allowed.\\n\\nYou could solve this problem by completing this process:\\n\\n1. **Understanding the problem**: Read and understand the problem statement carefully. In this case, we are given an array of bags, each containing a certain number of balls. We can perform a specific operation, splitting a bag into two smaller bags, a limited number of times. The goal is to minimize the maximum number of balls in any bag after performing the operations.\\n\\n2. **Identify the key variables**: Determine the key variables and parameters involved in the problem. In this case, we have the `nums` array representing the bags of balls and the `maxOperations` parameter representing the maximum number of operations we can perform.\\n\\n3. **Defining the problem**: Define the problem in terms of inputs and outputs. In this case, the input is the `nums` array and `maxOperations`, and the output is the minimum possible penalty (i.e., the maximum number of balls in any bag after the operations).\\n\\n4. **Consider the possible approaches**: Based on the problem requirements, consider different approaches and algorithms that can help solve the problem. One possible approach is to use binary search to find the minimum possible penalty. Binary search is a common technique when dealing with optimization problems and searching for a specific value within a range.\\n\\n5. **Formulate the approach**: Define the steps and logic required to solve the problem using the chosen approach. In this case, we can start with a minimum penalty of 1 and a maximum penalty of the maximum value in the `nums` array. Then, we iteratively perform operations and update the minimum and maximum penalties until they converge on the final minimum possible penalty.\\n\\n6. **Implement the solution**: Translate the formulated approach into actual code. Write the necessary functions and algorithms to solve the problem. Break down the problem into smaller subproblems if needed and implement them one by one.\\n\\n7. **Test the solution**: Create test cases, including the example provided in the problem statement, to verify that the implemented solution is correct and produces the expected results. Test the solution with different inputs and edge cases to ensure its correctness and efficiency.\\n\\n8. **Optimize if necessary**: Analyze the solution\\'s efficiency and look for possible optimizations. If the solution is not efficient enough or there are alternative approaches, consider optimizing the code or exploring different algorithms to improve the performance.\\n\\nBy following these steps, you can approach and solve the given problem effectively and systematically.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. First, we need to determine the range of possible penalties. The maximum penalty cannot be less than the maximum number of balls in any bag, as we need to ensure that no bag exceeds this limit. On the other hand, the minimum penalty cannot be less than 1, as we cannot have bags with zero balls.\\n\\n2. We can use a binary search approach to find the minimum possible penalty within this range. We start with the minimum penalty set to 1 and the maximum penalty set to the maximum number of balls in any bag.\\n\\n3. In each iteration of the binary search, we calculate the midPenalty as the average of the current minimum and maximum penalties. We then simulate the operations with this midPenalty and count the total number of operations needed.\\n\\n4. To simulate the operations, we iterate over each bag in the `nums` array and calculate the number of operations required to split the bag into smaller bags with a maximum number of balls equal to the midPenalty. This can be done by dividing the number of balls in the bag by the midPenalty, rounding up to the nearest integer.\\n\\n5. We keep track of the total number of operations performed and compare it with the given `maxOperations`. If the total operations exceed `maxOperations`, it means the current midPenalty is too small, and we need to increase the minimum penalty. Otherwise, the current midPenalty is a valid solution, but we still need to search for a smaller penalty, so we update the maximum penalty.\\n\\n6. We repeat steps 3-5 until the minimum penalty is no longer less than the maximum penalty. At this point, we have found the minimum possible penalty that satisfies the condition of performing at most `maxOperations` operations.\\n\\n7. Finally, we return the minimum penalty as the output, which represents the maximum number of balls in any bag after performing the operations.\\n\\nBy using the binary search approach, we efficiently narrow down the search space for the minimum possible penalty and find the optimal solution in logarithmic time complexity.\\n\\n# Complexity\\n- Time complexity: $$O(n log m)$$, where n is the length of the nums array and m is the maximum number of balls in any bag.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nSince we are not using any additional data structures that scale with the input size.\\nWe only need a few integer variables to keep track of the minimum penalty, maximum penalty, mid-penalty, and the number of operations. These variables require a constant amount of space regardless of the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int minPenalty = 1;\\n    int maxPenalty = *std::max_element(nums.begin(), nums.end());\\n\\n    while (minPenalty < maxPenalty) {\\n        int midPenalty = minPenalty + (maxPenalty - minPenalty) / 2;\\n        int operations = 0;\\n\\n        for (int num : nums) {\\n            operations += (num - 1) / midPenalty;\\n            if (operations > maxOperations)\\n                break;\\n        }\\n\\n        if (operations > maxOperations)\\n            minPenalty = midPenalty + 1;\\n        else\\n            maxPenalty = midPenalty;\\n    }\\n\\n    return minPenalty;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int minPenalty = 1;\\n    int maxPenalty = *std::max_element(nums.begin(), nums.end());\\n\\n    while (minPenalty < maxPenalty) {\\n        int midPenalty = minPenalty + (maxPenalty - minPenalty) / 2;\\n        int operations = 0;\\n\\n        for (int num : nums) {\\n            operations += (num - 1) / midPenalty;\\n            if (operations > maxOperations)\\n                break;\\n        }\\n\\n        if (operations > maxOperations)\\n            minPenalty = midPenalty + 1;\\n        else\\n            maxPenalty = midPenalty;\\n    }\\n\\n    return minPenalty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577566,
                "title": "simple-solution-using-binary-search-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor binary search lower bound is s=1 and upper bound is e=INT_MAX, then we ll check if mid(m) satisfies the condition or not using check func. \\no is maxoperation. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(int m,vector<int>& nums,int o){\\n    for(int i=0;i<nums.size(); i++){\\n        o-=(nums[i]/m);\\n        if(nums[i]%m==0)o++;\\n    }return o>=0;\\n}\\n    int minimumSize(vector<int>& nums, int o) {\\n        int s=1, e=INT_MAX;\\n        int ans=0;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(check(m,nums,o)){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(int m,vector<int>& nums,int o){\\n    for(int i=0;i<nums.size(); i++){\\n        o-=(nums[i]/m);\\n        if(nums[i]%m==0)o++;\\n    }return o>=0;\\n}\\n    int minimumSize(vector<int>& nums, int o) {\\n        int s=1, e=INT_MAX;\\n        int ans=0;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(check(m,nums,o)){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555923,
                "title": "binary-search-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& ar, int max_op) {\\n    int n=ar.size();\\n    int s = 1, e=10000000000, mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        bool isValid = 1;\\n        int op = max_op;\\n        for (int x = 0; x < n; x++) {\\n            if (!Check(ar[x], mid ,op)) {\\n                isValid = 0; break;\\n            }\\n        }\\n        if (isValid)ans = mid, e = mid - 1;\\n        else s = mid+ 1;\\n    }\\n    return ans;\\n    }\\n\\n    bool Check(int num,int cost,int& max_op) {\\n    int cnt = num / cost;\\n    if (num % cost == 0)cnt--;\\n    \\n    if (cnt <= max_op) {\\n        max_op -= cnt; return 1;\\n    }\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& ar, int max_op) {\\n    int n=ar.size();\\n    int s = 1, e=10000000000, mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        bool isValid = 1;\\n        int op = max_op;\\n        for (int x = 0; x < n; x++) {\\n            if (!Check(ar[x], mid ,op)) {\\n                isValid = 0; break;\\n            }\\n        }\\n        if (isValid)ans = mid, e = mid - 1;\\n        else s = mid+ 1;\\n    }\\n    return ans;\\n    }\\n\\n    bool Check(int num,int cost,int& max_op) {\\n    int cnt = num / cost;\\n    if (num % cost == 0)cnt--;\\n    \\n    if (cnt <= max_op) {\\n        max_op -= cnt; return 1;\\n    }\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467561,
                "title": "ratio-number-of-balls-in-bags-for-lowest-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause our goal is to minimize the maximal bag size, we can actually see this as a reverse problem, or dual, where we focus on maximizing the size of the minimal bags we can target safely for our max number of operations. This lets us flip the problem on its head and solve it in a faster time by considering a ratio of each bag size to a selected bag size. We then binarily search for this maximal bag size that will give us the min operations, and do so to exhaustion to find the minimal form of it. This IS the minimal size we are looking for, and allows us to do so in a much more time efficient manner. For more on dual problems, check here : https://en.wikipedia.org/wiki/Duality_(optimization)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by first figuring out what the maximal size of a given number of balls in bag to target would be that is satisfactory. This is the value found when the sum of the value of the balls in bags integer divided by a current size selected for divisions is less than or equal to the total number of operations we can select. Here is why \\n- If the current size + 1 is greater than to the number of balls in a given bag, that bag contributes nothing towards the total ratio sum \\n- If the current size + 1 is equal to the number of balls in a bag, this is a size we will do an operation on, so it contributes + 1 \\n- If it is larger by a multiple, we determine that multiple as the number of splittings necessary to get it to the current size, and add appropriately. \\n\\nIf the number of operations is less than or equal to our current size, then the current size we focus our splitting on is valid! \\n\\nNow we turn to the binary search part of the operation. For this component, if we want to have a ball size upper bound of choice that is larger than our given range, we should focus on finding a value of number of balls that is far too great. We in this case can simply sum the entirety of nums, then split one more time than we currently can so that we did all of our splits that we could and one more on the nums. We then add 1 to avoid the zero case, so we at least always do one split. This turns out to also be the maximal case in the case that the sum of nums divided by one more than maximal operations plus 1 is zero, as we will add one to this and then avoid the binary search entirely! \\n\\nOn to the binary search. Due to the presence of test cases where the array is all 1s, we need to set low to 1 to account for these (otherwise, you\\'d be tempted to set it to 2 as I discovered!) \\n\\nRegardless, we follow our typical binary search, recording the mid value as halfway of low and high. Then, while low is less than high \\n- check if targeting ball bags of size mid is a valid total ratio number of operations. If it is, we move high down to mid, and record this as our optimal target. \\n- If not, we set low to mid plus 1, as this means we do need to select items larger than mid currently to get a valid answer. \\n\\nWhen done, return the central average of maximal balls in bags to target. \\n\\n\\n# Complexity\\n- Time complexity: O(N log N)\\n    - Our binary search takes time log N \\n        - within which we do a sum problem of time N \\n        - So total is N log N time \\n\\n- Space complexity: O(1) \\n    - We do not use any additional space in the process  \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        # valid number of operations \\n        def valid_total_ratio_number_of_operations(nums, current_size):\\n            # get sum of ratios of number of balls in a bag versus the current size \\n            # with an off by 1 penalty applied to consider the bags of size 1 and their ridculousness \\n            # for num in nums. This is the sum of the ratio number of operations per \\n            # location. We want to find that your total ratio number of operations \\n            # is less than or equal to the max # of operations to be valid \\n            return sum((num - 1) // current_size for num in nums) <= maxOperations\\n\\n        # highest is sum of nums reduced by max operations + 1 \\n        # plus 1. This is never going to be reached for any bag in nums as a total \\n        # and we will always be able to split this at least 1 + highest total // 1 more operation \\n        # this gives us a high value for the value of the balls in bags to focus our operation on \\n        high = sum(nums) // (maxOperations + 1) + 1\\n        # start low at 1 for the least amount of balls in bags to operate on. \\n        # if we have only ones, then we need low to be 1 just in case \\n        low = 1\\n        # track central average of maximal balls in bags \\n        central = high\\n\\n        # binary search for the largest average balls in bags we should operate on \\n        while low < high :\\n            # get mid value of maximal balls in bags \\n            mid = (low + high) // 2\\n            # if we have a total ratio number of operations less than or equal to max operations \\n            if valid_total_ratio_number_of_operations(nums, mid) :\\n                # move high and centralized down to find a spot where we have too many operations still \\n                central = mid\\n                high    = mid\\n            else:\\n                # otherwise we have too many max number of operations if we are operating on bags of this size \\n                low = mid + 1\\n\\n        # return central average of maximal balls in bags \\n        return central\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        # valid number of operations \\n        def valid_total_ratio_number_of_operations(nums, current_size):\\n            # get sum of ratios of number of balls in a bag versus the current size \\n            # with an off by 1 penalty applied to consider the bags of size 1 and their ridculousness \\n            # for num in nums. This is the sum of the ratio number of operations per \\n            # location. We want to find that your total ratio number of operations \\n            # is less than or equal to the max # of operations to be valid \\n            return sum((num - 1) // current_size for num in nums) <= maxOperations\\n\\n        # highest is sum of nums reduced by max operations + 1 \\n        # plus 1. This is never going to be reached for any bag in nums as a total \\n        # and we will always be able to split this at least 1 + highest total // 1 more operation \\n        # this gives us a high value for the value of the balls in bags to focus our operation on \\n        high = sum(nums) // (maxOperations + 1) + 1\\n        # start low at 1 for the least amount of balls in bags to operate on. \\n        # if we have only ones, then we need low to be 1 just in case \\n        low = 1\\n        # track central average of maximal balls in bags \\n        central = high\\n\\n        # binary search for the largest average balls in bags we should operate on \\n        while low < high :\\n            # get mid value of maximal balls in bags \\n            mid = (low + high) // 2\\n            # if we have a total ratio number of operations less than or equal to max operations \\n            if valid_total_ratio_number_of_operations(nums, mid) :\\n                # move high and centralized down to find a spot where we have too many operations still \\n                central = mid\\n                high    = mid\\n            else:\\n                # otherwise we have too many max number of operations if we are operating on bags of this size \\n                low = mid + 1\\n\\n        # return central average of maximal balls in bags \\n        return central\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454378,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool cheek(vector<int>&nums,int mid,int maxoperations){\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                if(nums[i]%mid == 0)count+=nums[i]/mid-1;\\n                else count+=nums[i]/mid;\\n            }\\n            if(count>maxoperations)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxoperations) {\\n        \\n        // minimize the maximum ... sp binary search\\n        int mini = *min_element(nums.begin(),nums.end());\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int low = 1;\\n        int high = maxi;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(cheek(nums,mid,maxoperations)){\\n                ans = mid;//mid is the current maxmimum number of balls in a bag\\n                high = mid-1;// now we have to minimize the maximum penalty\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool cheek(vector<int>&nums,int mid,int maxoperations){\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                if(nums[i]%mid == 0)count+=nums[i]/mid-1;\\n                else count+=nums[i]/mid;\\n            }\\n            if(count>maxoperations)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minimumSize(vector<int>& nums, int maxoperations) {\\n        \\n        // minimize the maximum ... sp binary search\\n        int mini = *min_element(nums.begin(),nums.end());\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int low = 1;\\n        int high = maxi;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(cheek(nums,mid,maxoperations)){\\n                ans = mid;//mid is the current maxmimum number of balls in a bag\\n                high = mid-1;// now we have to minimize the maximum penalty\\n            }\\n            else low = mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443055,
                "title": "easy-binary-search-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int start=1; //minimum element that can exist in array\\n        int end=Integer.MAX_VALUE; //maximum element that can exist in array\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n\\n            //checking for the maximum mid number that can exist in array after performing maxOperations\\n            if(check(mid,maxOperations,nums)){\\n                //if it exists then assign ans=mid and reduce search to end=mid-1\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n            // else increase start=mid+1\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    // [2,4,8,2]\\n    public boolean check(int mid,int maxOperations,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            //we reduce maxoperations after they are once performed \\n                maxOperations-=(nums[i]/mid);\\n                if(nums[i]%mid==0){\\n                    //here, we add 1 as it is reduced extra in above step\\n                    //when (8/2)=4, so 4 is subtracted from maxOperations\\n                    // but actually only 3 maxOperations have been performed 8->(4,4)->(2,2),(2,2)\\n                    //therefore we add 1\\n                    maxOperations++;\\n                }\\n        }\\n\\n    //if maxoperations>=0, it means valid operations have been performed, so return true else false\\n        return maxOperations>=0?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int start=1; //minimum element that can exist in array\\n        int end=Integer.MAX_VALUE; //maximum element that can exist in array\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n\\n            //checking for the maximum mid number that can exist in array after performing maxOperations\\n            if(check(mid,maxOperations,nums)){\\n                //if it exists then assign ans=mid and reduce search to end=mid-1\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n            // else increase start=mid+1\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    // [2,4,8,2]\\n    public boolean check(int mid,int maxOperations,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            //we reduce maxoperations after they are once performed \\n                maxOperations-=(nums[i]/mid);\\n                if(nums[i]%mid==0){\\n                    //here, we add 1 as it is reduced extra in above step\\n                    //when (8/2)=4, so 4 is subtracted from maxOperations\\n                    // but actually only 3 maxOperations have been performed 8->(4,4)->(2,2),(2,2)\\n                    //therefore we add 1\\n                    maxOperations++;\\n                }\\n        }\\n\\n    //if maxoperations>=0, it means valid operations have been performed, so return true else false\\n        return maxOperations>=0?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398452,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        lo, hi = 1, max(nums)\\n        \\n        def isPossible(n):\\n            \\n            numOp = 0\\n            i = 0\\n            while i < len(nums) and numOp <= maxOperations:\\n                numOp += (math.ceil(nums[i] / n) - 1)\\n                i += 1\\n            return numOp <= maxOperations\\n            \\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            if isPossible(mid):\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        \\n        lo, hi = 1, max(nums)\\n        \\n        def isPossible(n):\\n            \\n            numOp = 0\\n            i = 0\\n            while i < len(nums) and numOp <= maxOperations:\\n                numOp += (math.ceil(nums[i] / n) - 1)\\n                i += 1\\n            return numOp <= maxOperations\\n            \\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            if isPossible(mid):\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387138,
                "title": "java-easy-solution-aasheesh-111th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![UP vote ki bhik.jpeg](https://assets.leetcode.com/users/images/57d9faac-5a60-4087-9efb-82d276fd05f0_1680799314.4215221.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int start = 1;\\n        int end = 0;\\n        for(int can:nums) end = Math.max(end,can);\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            int sum = 0;\\n            for(int can:nums) sum += (can - 1)/mid ;\\n            if(sum <= maxOperations){\\n                end = mid;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n\\n        }\\n        return start;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int start = 1;\\n        int end = 0;\\n        for(int can:nums) end = Math.max(end,can);\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            int sum = 0;\\n            for(int can:nums) sum += (can - 1)/mid ;\\n            if(sum <= maxOperations){\\n                end = mid;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n\\n        }\\n        return start;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386374,
                "title": "binary-search-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int opera) {\\n        int l=1;\\n        int r=*max_element(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(possible(nums,mid,opera))\\n            {\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            l=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    bool possible(vector<int>& nums,int x,int y)\\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>=x)\\n            {\\n                if(nums[i]%x==0)\\n                c+=(nums[i]/x)-1;\\n                else\\n                c+=(nums[i]/x);\\n            }\\n        }\\n        if(c<=y)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int opera) {\\n        int l=1;\\n        int r=*max_element(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(possible(nums,mid,opera))\\n            {\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            l=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    bool possible(vector<int>& nums,int x,int y)\\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>=x)\\n            {\\n                if(nums[i]%x==0)\\n                c+=(nums[i]/x)-1;\\n                else\\n                c+=(nums[i]/x);\\n            }\\n        }\\n        if(c<=y)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381906,
                "title": "very-tricky-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int pen=high;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            int ops=0;\\n            for(auto i:nums){ ops+=(i-1)/mid;}\\n            if(ops<=maxOperations) {pen=mid;high=mid;}\\n            else low=mid+1;\\n        }\\n        return pen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int low=1;\\n        int high=*max_element(nums.begin(),nums.end());\\n        int pen=high;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            int ops=0;\\n            for(auto i:nums){ ops+=(i-1)/mid;}\\n            if(ops<=maxOperations) {pen=mid;high=mid;}\\n            else low=mid+1;\\n        }\\n        return pen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367331,
                "title": "c-binary-search",
                "content": "Check if there is a way to minimize by penlaty to X. Binary search on X.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &nums, int k, int mid)\\n    {\\n        long long cnt = 0; \\n        for(auto x : nums){\\n            if(x > mid){\\n                int q = x / mid;\\n                int m = x % mid; \\n                cnt = cnt + q;  \\n                if(m == 0) --cnt; \\n            }\\n        }\\n        if(cnt > k) return false; \\n        return true; \\n    }\\n    \\n    int minimumSize(vector<int>& nums, int k) {\\n        int low = 1 , high = 1e9; \\n        \\n        int ans = high; \\n        while(low <= high){\\n            int mid = (low + high) / 2 ;\\n            bool can = check(nums, k , mid); \\n            if(can){\\n                ans = mid; \\n                high = mid - 1; \\n            }\\n            else{\\n                low = mid + 1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &nums, int k, int mid)\\n    {\\n        long long cnt = 0; \\n        for(auto x : nums){\\n            if(x > mid){\\n                int q = x / mid;\\n                int m = x % mid; \\n                cnt = cnt + q;  \\n                if(m == 0) --cnt; \\n            }\\n        }\\n        if(cnt > k) return false; \\n        return true; \\n    }\\n    \\n    int minimumSize(vector<int>& nums, int k) {\\n        int low = 1 , high = 1e9; \\n        \\n        int ans = high; \\n        while(low <= high){\\n            int mid = (low + high) / 2 ;\\n            bool can = check(nums, k , mid); \\n            if(can){\\n                ans = mid; \\n                high = mid - 1; \\n            }\\n            else{\\n                low = mid + 1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339237,
                "title": "checking-the-min-value-using-binary-search-explanation",
                "content": "# **Explanation**\\nwe **assume** that mid be the **Maximum value of array** after applying the maxoperation .If we can make mid the max value of array  then we try to check whether we can make other smaller value maximum of array after applying the operation and finally return the last possible value.   \\n# Complexity\\n- Time complexity:nlog(10^9)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n       int left=1;int right=1000000000;int mid=0;int count=0;\\n       while(left<=right){\\n       mid=left+(right-left)/2;//assume that mid be the Maximum value of array\\n       count=0;\\n       for(int a:nums){count+=(a-1)/mid;}//counting the total operation need to make mid max value of array\\n       if(count>maxOperations){left=mid+1;}//Not able to make it in maxoperation\\n       else{right=mid-1;}//check whether we can make other smaller value maximum of array \\n       } \\n       return left;//the last possible value.   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n       int left=1;int right=1000000000;int mid=0;int count=0;\\n       while(left<=right){\\n       mid=left+(right-left)/2;//assume that mid be the Maximum value of array\\n       count=0;\\n       for(int a:nums){count+=(a-1)/mid;}//counting the total operation need to make mid max value of array\\n       if(count>maxOperations){left=mid+1;}//Not able to make it in maxoperation\\n       else{right=mid-1;}//check whether we can make other smaller value maximum of array \\n       } \\n       return left;//the last possible value.   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326149,
                "title": "c-binary-search-simplest-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mx) {\\n        int n=nums.size();\\n        int l=1,r=*max_element(nums.begin(),nums.end());\\n        // int op=0;\\n        int ans=r;//consider the minimum penalty as the maximum penalty initially \\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;\\n            int op=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]>mid)\\n                {\\n                    if(nums[i]%mid==0)\\n                    op+=(nums[i]/mid)-1;\\n                    else\\n                    op+=nums[i]/mid;\\n                }\\n            }\\n            if(op<=mx)\\n            {\\n               ans=mid;\\n               r=mid;// again checking for minimum penalty if none other exists returning ans\\n            }\\n            else\\n            {\\n                l=mid+1;//incrasing the penalty as it exceeds the operations to the specified penalty \\n            }\\n        }\\n        return ans;\\n    }\\n};// upvote if u like the solution :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int mx) {\\n        int n=nums.size();\\n        int l=1,r=*max_element(nums.begin(),nums.end());\\n        // int op=0;\\n        int ans=r;//consider the minimum penalty as the maximum penalty initially \\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;\\n            int op=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]>mid)\\n                {\\n                    if(nums[i]%mid==0)\\n                    op+=(nums[i]/mid)-1;\\n                    else\\n                    op+=nums[i]/mid;\\n                }\\n            }\\n            if(op<=mx)\\n            {\\n               ans=mid;\\n               r=mid;// again checking for minimum penalty if none other exists returning ans\\n            }\\n            else\\n            {\\n                l=mid+1;//incrasing the penalty as it exceeds the operations to the specified penalty \\n            }\\n        }\\n        return ans;\\n    }\\n};// upvote if u like the solution :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320870,
                "title": "easy-solution-using-binary-search-in-c",
                "content": "```\\n int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l=1,h=1e9;\\n        \\n        int ans=INT_MAX;\\n        while(l<=h){\\n            int mid= (h+l)/2;\\n            int cnt=0;\\n            for(auto i : nums){\\n                if(mid<=i){\\n                    if(i%mid==0) cnt+=(i/mid)-1;\\n                    else cnt+=(i/mid);\\n                }\\n            }\\n            \\n            \\n            if(cnt<=maxOperations) ans=min(ans,mid),h=mid-1;\\n            else l=mid+1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n** Please Upvote if found Useful**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l=1,h=1e9;\\n        \\n        int ans=INT_MAX;\\n        while(l<=h){\\n            int mid= (h+l)/2;\\n            int cnt=0;\\n            for(auto i : nums){\\n                if(mid<=i){\\n                    if(i%mid==0) cnt+=(i/mid)-1;\\n                    else cnt+=(i/mid);\\n                }\\n            }\\n            \\n            \\n            if(cnt<=maxOperations) ans=min(ans,mid),h=mid-1;\\n            else l=mid+1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312615,
                "title": "c-solution-using-generic-binary-search-framework",
                "content": "# Intuition\\nWe need to search in the search-space of maximum penalties that we can obtain rearranging the balls. We know that we have at most $maxOperations$ that we can try, and in every operation we cannot put zero elements in one basket, and we want to minimize our maximum value in the array. \\n# Approach\\nWe can try to binary search all the possible penalties and see at each trial we achieve at most $maxOperations$ (if we are done with less it is still good). In this case we need to make sure that we have at least one element when we split the single bag. That is why we will do ```(nums[i] - 1)/penalty```. \\n\\nAt the end we make sure that we do not cross our maximum number of operations maxOperations.\\n\\nThis kind of problems fits into a more generic framework of binary search on a function that defines our search space. The function needs to be monotonic, meaning that if a property is valid for an element $x$, then it is valid for all the elements greater then $x$ (or viceversa with decreasing functions).\\n\\nFor example, the general framework to find the minimum of a function\\n\\n```\\n    while(l < r)\\n    {\\n        const auto mid = l + (r - l)/2;\\n        if(f(parameters)) // Cuts our monotonic function in \\n                            //intervals of validity for a predicate\\n        {\\n            r = mid;\\n        }else\\n        {\\n            l = mid + 1;\\n        }\\n    }\\n\\n    return l;\\n```\\n\\nSuggest checking also to USACO guide: https://usaco.guide/silver/binary-search?lang=cpp\\n# Complexity\\n- Time complexity: $$O(nlog(max(arr)))$$\\n- Space complexity: $$O(1))$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    bool canWeAchieveInNumOp(const vector<int>& nums, int penalty, int maxOp)\\n    {\\n        int numOp = 0;\\n        for(const auto n : nums)\\n        {\\n            if(n > penalty)\\n            {\\n                numOp += (n - 1)/penalty;\\n            }\\n            if(numOp > maxOp)\\n            {\\n                return false;\\n            }\\n        }\\n        return numOp <= maxOp;\\n    }\\n\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l = 1;\\n        int r = numeric_limits<int>::min();\\n        for(auto c : nums)\\n        {\\n            r = max(c, r);\\n        }\\n\\n        while(l < r)\\n        {\\n            auto mid = l + (r - l)/2;\\n            if(canWeAchieveInNumOp(nums, mid, maxOperations))\\n            {\\n                r = mid;\\n            }else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```(nums[i] - 1)/penalty```\n```\\n    while(l < r)\\n    {\\n        const auto mid = l + (r - l)/2;\\n        if(f(parameters)) // Cuts our monotonic function in \\n                            //intervals of validity for a predicate\\n        {\\n            r = mid;\\n        }else\\n        {\\n            l = mid + 1;\\n        }\\n    }\\n\\n    return l;\\n```\n```\\nclass Solution {\\n\\n    bool canWeAchieveInNumOp(const vector<int>& nums, int penalty, int maxOp)\\n    {\\n        int numOp = 0;\\n        for(const auto n : nums)\\n        {\\n            if(n > penalty)\\n            {\\n                numOp += (n - 1)/penalty;\\n            }\\n            if(numOp > maxOp)\\n            {\\n                return false;\\n            }\\n        }\\n        return numOp <= maxOp;\\n    }\\n\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int l = 1;\\n        int r = numeric_limits<int>::min();\\n        for(auto c : nums)\\n        {\\n            r = max(c, r);\\n        }\\n\\n        while(l < r)\\n        {\\n            auto mid = l + (r - l)/2;\\n            if(canWeAchieveInNumOp(nums, mid, maxOperations))\\n            {\\n                r = mid;\\n            }else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303587,
                "title": "scala-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n\\n    def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\\n        var left = 1\\n        var right = nums.max\\n        \\n        while (left < right) {\\n            val mid = (left + right) / 2\\n            var ops = 0\\n            var i = 0\\n            while (i < nums.length && ops <= maxOperations) {\\n                ops += (nums(i) - 1) / mid\\n                i += 1\\n            }\\n            if (ops > maxOperations) left = mid + 1\\n            else right = mid\\n        }\\n        \\n        left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n\\n    def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\\n        var left = 1\\n        var right = nums.max\\n        \\n        while (left < right) {\\n            val mid = (left + right) / 2\\n            var ops = 0\\n            var i = 0\\n            while (i < nums.length && ops <= maxOperations) {\\n                ops += (nums(i) - 1) / mid\\n                i += 1\\n            }\\n            if (ops > maxOperations) left = mid + 1\\n            else right = mid\\n        }\\n        \\n        left\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3283227,
                "title": "java-binary-search-easy",
                "content": "\\n# Approach\\nBinary search on answers.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int s=1;\\n        int e=Integer.MIN_VALUE;\\n        for(int i:nums){\\n            e=Math.max(e,i);\\n        }\\n        int ans=e;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(givesAns(nums,maxOperations,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean givesAns(int[] nums,int maxOp,int mid){\\n        int ops=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=mid){\\n                if(nums[i]%mid==0){\\n                    ops+=nums[i]/mid-1;\\n                }else{\\n                    ops+=nums[i]/mid;\\n                }\\n            }\\n        }\\n        return ops<=maxOp;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumSize(int[] nums, int maxOperations) {\\n        int s=1;\\n        int e=Integer.MIN_VALUE;\\n        for(int i:nums){\\n            e=Math.max(e,i);\\n        }\\n        int ans=e;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(givesAns(nums,maxOperations,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean givesAns(int[] nums,int maxOp,int mid){\\n        int ops=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=mid){\\n                if(nums[i]%mid==0){\\n                    ops+=nums[i]/mid-1;\\n                }else{\\n                    ops+=nums[i]/mid;\\n                }\\n            }\\n        }\\n        return ops<=maxOp;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277245,
                "title": "easy-c-solution-using-binary-search-fast-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums,int mid,int operations)\\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            operations-=nums[i]/mid;\\n            if(nums[i]%mid==0)\\n                operations++; /* eg:- 8/2=4 but to divide 8 into 3 parts(2,2,2) requires only 3 operations not 4\\n                therefore we increament opeations by 1\\n                */\\n        }\\n        return operations>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int right=*max_element(nums.begin(),nums.end()); //Max Penalty\\n        int left=1; //Min Penalty\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else\\n                left=mid+1;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums,int mid,int operations)\\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            operations-=nums[i]/mid;\\n            if(nums[i]%mid==0)\\n                operations++; /* eg:- 8/2=4 but to divide 8 into 3 parts(2,2,2) requires only 3 operations not 4\\n                therefore we increament opeations by 1\\n                */\\n        }\\n        return operations>=0;\\n    }\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int right=*max_element(nums.begin(),nums.end()); //Max Penalty\\n        int left=1; //Min Penalty\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums,mid,maxOperations))\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else\\n                left=mid+1;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273686,
                "title": "c-easy-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left=1, right=*max_element(nums.begin(),nums.end());\\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            int cnt=0;\\n            for(int i=0;i<nums.size();i++){\\n                cnt+= (nums[i]-1)/mid;\\n            }\\n            if(cnt>maxOperations){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumSize(vector<int>& nums, int maxOperations) {\\n        int left=1, right=*max_element(nums.begin(),nums.end());\\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            int cnt=0;\\n            for(int i=0;i<nums.size();i++){\\n                cnt+= (nums[i]-1)/mid;\\n            }\\n            if(cnt>maxOperations){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271604,
                "title": "c-binary-search-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums,int maxV,int mO)\\n    {\\n        \\n        for(auto i:nums)\\n        {\\n            int ele = i;\\n            if(ele<=maxV)\\n            continue;\\n            else if(mO>0)\\n            {\\n                mO-=(ceil((double)i/maxV))-1;\\n                if(mO<0)\\n                return false;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n    int minimumSize(vector<int>& nums, int mO) {\\n        int l = 1;\\n        int r = *max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(solve(nums,mid,mO))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums,int maxV,int mO)\\n    {\\n        \\n        for(auto i:nums)\\n        {\\n            int ele = i;\\n            if(ele<=maxV)\\n            continue;\\n            else if(mO>0)\\n            {\\n                mO-=(ceil((double)i/maxV))-1;\\n                if(mO<0)\\n                return false;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n    int minimumSize(vector<int>& nums, int mO) {\\n        int l = 1;\\n        int r = *max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(solve(nums,mid,mO))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565088,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 1565790,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 1724828,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 1574953,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 2006432,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 1830353,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            },
            {
                "id": 1825184,
                "content": [
                    {
                        "username": "mark72",
                        "content": "As titles. I think the binary search solution is really clever and simple. But for me personally it is really hard to figure out binary search is needed here instead of \"calculating\" the answer. For those of you who came up with binary search solution, what makes you think this way? what\\'s the intuition?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Deathangel5677](/Deathangel5677) it actually helped me bro\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "For me personally if its a question that needs some form allocation type thing or I could deduce a search space it needs binary search. For example in this question here,what is the minimal number that things could be splittted to?That is 1 right and what is the max number that things could be split to with minimal operations(as given in constraints) that is max num in Array minus 1. So I have a space in which solution lies 1 to Max num minus 1. Now I just need to perform hit and trial. The main trick here was to figure out number of operations to reduce a one number to another. If a number was perfectly divisible it was it was quotient-1 number of operations and if it was not it was quotient number of operations. So if number of operations required to reduce all the numbers in array was greater than given operations I increase mid by doing start=mid+1,if its possible to reduce all numbers in the array to mid within given operations,I reduce mid to find the smallest number by doing end=mid-1. This is very similar to Allocate Minimum number of pages question or Aggresive Cows question. I know this reply is after 2 years,I just wanted to share my own insight to articulate my thoughts better."
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "I was solving this problem topic wise , so I already know that it is for binary search otherwise it would be difficult to identify that this is a Binary search problem, further more i have realised that when the problem is a optimisation problem and there is a linear or inverse relation between the input and that variable that we need to optimise we can use binary search."
                    },
                    {
                        "username": "PandaPro",
                        "content": "There is a heap tag in this question and I believe this can be solved using a priority queue but I am not able to come up with a solution yet."
                    },
                    {
                        "username": "i_am_not_me",
                        "content": "I dont think this can be solved with heap because we will need to know how to split the maximal element, if we don\\'t know how to split the maximal element, I think we can\\'t solve it with heap. But the question diverts our intiution towards heap."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "This question is solved using binary search"
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "hint: assume penalty and then calculate operations"
                    },
                    {
                        "username": "hqztrue",
                        "content": "Let t=maxOperations+nums.size()."
                    },
                    {
                        "username": "prashantst27203",
                        "content": "this problem can not be solved using heap beacuse we do not have  an idea of to divide the maximum in what manner , like of we have 7 as the maximum element , we do not have the control that whether to divide it as 3,4 or as 6,1 .\\n "
                    },
                    {
                        "username": "speedyy",
                        "content": "For ppl who thought the way of binary search way..\n\"Return the minimum possible penalty after performing the operations.\"\n\nMeans lets say nums = [2,4,8,2], maxOperations = 4\nassume left = 1, right = 4, mid = 2 : for mid 2 it takes 4 times which is == 4(maxOpearions). So now go left or right? \nQ ASKED MINIMIZE THE PENALTY, so we go left by right = mid   as 2 is a potential answer as well. Suppose by value 1 it also takes 4 times, so the answer will be 1 not 2 but they both takes same time to do the operation but Q ASKED  ``` MINIMIZE THE PENALTY ``` ..\n\nThis is what I think the explanation for \" If the opearion_time for the mid value == maxOperations \".. I only commented it because I faced this pb, it might help if anyone face the pb too. If I am wrong plz correct me without NEGATIVE UPVOTING ME:("
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Why isn\\'t this solvable using heap?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "only heap can\\'t lead to ans,, you can optimize using binary search and heap"
                    }
                ]
            }
        ]
    }
]